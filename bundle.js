"format global";
(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var getOwnPropertyDescriptor = true;
  try {
    Object.getOwnPropertyDescriptor({ a: 0 }, 'a');
  }
  catch(e) {
    getOwnPropertyDescriptor = false;
  }

  var defineProperty;
  (function () {
    try {
      if (!!Object.defineProperty({}, 'a', {}))
        defineProperty = Object.defineProperty;
    }
    catch (e) {
      defineProperty = function(obj, prop, opt) {
        try {
          obj[prop] = opt.value || opt.get.call(obj);
        }
        catch(e) {}
      }
    }
  })();

  function register(name, deps, declare) {
    if (arguments.length === 4)
      return registerDynamic.apply(this, arguments);
    doRegister(name, {
      declarative: true,
      deps: deps,
      declare: declare
    });
  }

  function registerDynamic(name, deps, executingRequire, execute) {
    doRegister(name, {
      declarative: false,
      deps: deps,
      executingRequire: executingRequire,
      execute: execute
    });
  }

  function doRegister(name, entry) {
    entry.name = name;

    // we never overwrite an existing define
    if (!(name in defined))
      defined[name] = entry;

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }


  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];

      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;

      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {

        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;

      if (typeof name == 'object') {
        for (var p in name)
          exports[p] = name[p];
      }
      else {
        exports[name] = value;
      }

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          for (var j = 0; j < importerModule.dependencies.length; ++j) {
            if (importerModule.dependencies[j] === module) {
              importerModule.setters[j](exports);
            }
          }
        }
      }

      module.locked = false;
      return value;
    });

    module.setters = declaration.setters;
    module.execute = declaration.execute;

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        depExports = depEntry.esModule;
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);

      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);

    if (output)
      module.exports = output;

    // create the esModule object, which allows ES6 named imports of dynamics
    exports = module.exports;
 
    if (exports && exports.__esModule) {
      entry.esModule = exports;
    }
    else {
      entry.esModule = {};
      
      // don't trigger getters/setters in environments that support them
      if (typeof exports == 'object' || typeof exports == 'function') {
        if (getOwnPropertyDescriptor) {
          var d;
          for (var p in exports)
            if (d = Object.getOwnPropertyDescriptor(exports, p))
              defineProperty(entry.esModule, p, d);
        }
        else {
          var hasOwnProperty = exports && exports.hasOwnProperty;
          for (var p in exports) {
            if (!hasOwnProperty || exports.hasOwnProperty(p))
              entry.esModule[p] = exports[p];
          }
         }
       }
      entry.esModule['default'] = exports;
      defineProperty(entry.esModule, '__useDefault', {
        value: true
      });
    }
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    // node core modules
    if (name.substr(0, 6) == '@node/')
      return require(name.substr(6));

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its 
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    // exported modules get __esModule defined for interop
    if (entry.declarative)
      defineProperty(entry.module.exports, '__esModule', { value: true });

    // return the defined module object
    return modules[name] = entry.declarative ? entry.module.exports : entry.esModule;
  };

  return function(mains, depNames, declare) {
    return function(formatDetect) {
      formatDetect(function(deps) {
        var System = {
          _nodeRequire: typeof require != 'undefined' && require.resolve && typeof process != 'undefined' && require,
          register: register,
          registerDynamic: registerDynamic,
          get: load, 
          set: function(name, module) {
            modules[name] = module; 
          },
          newModule: function(module) {
            return module;
          }
        };
        System.set('@empty', {});

        // register external dependencies
        for (var i = 0; i < depNames.length; i++) (function(depName, dep) {
          if (dep && dep.__esModule)
            System.register(depName, [], function(_export) {
              return {
                setters: [],
                execute: function() {
                  for (var p in dep)
                    if (p != '__esModule' && !(typeof p == 'object' && p + '' == 'Module'))
                      _export(p, dep[p]);
                }
              };
            });
          else
            System.registerDynamic(depName, [], false, function() {
              return dep;
            });
        })(depNames[i], arguments[i]);

        // register modules in this bundle
        declare(System);

        // load mains
        var firstLoad = load(mains[0]);
        if (mains.length > 1)
          for (var i = 1; i < mains.length; i++)
            load(mains[i]);

        if (firstLoad.__useDefault)
          return firstLoad['default'];
        else
          return firstLoad;
      });
    };
  };

})(typeof self != 'undefined' ? self : global)
/* (['mainModule'], ['external-dep'], function($__System) {
  System.register(...);
})
(function(factory) {
  if (typeof define && define.amd)
    define(['external-dep'], factory);
  // etc UMD / module pattern
})*/

(['1'], [], function($__System) {

(function(__global) {
  var loader = $__System;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  function readMemberExpression(p, value) {
    var pParts = p.split('.');
    while (pParts.length)
      value = value[pParts.shift()];
    return value;
  }

  // bare minimum ignores for IE8
  var ignoredGlobalProps = ['_g', 'sessionStorage', 'localStorage', 'clipboardData', 'frames', 'external', 'mozAnimationStartTime', 'webkitStorageInfo', 'webkitIndexedDB'];

  var globalSnapshot;

  function forEachGlobal(callback) {
    if (Object.keys)
      Object.keys(__global).forEach(callback);
    else
      for (var g in __global) {
        if (!hasOwnProperty.call(__global, g))
          continue;
        callback(g);
      }
  }

  function forEachGlobalValue(callback) {
    forEachGlobal(function(globalName) {
      if (indexOf.call(ignoredGlobalProps, globalName) != -1)
        return;
      try {
        var value = __global[globalName];
      }
      catch (e) {
        ignoredGlobalProps.push(globalName);
      }
      callback(globalName, value);
    });
  }

  loader.set('@@global-helpers', loader.newModule({
    prepareGlobal: function(moduleName, exportName, globals) {
      // disable module detection
      var curDefine = __global.define;
       
      __global.define = undefined;
      __global.exports = undefined;
      if (__global.module && __global.module.exports)
        __global.module = undefined;

      // set globals
      var oldGlobals;
      if (globals) {
        oldGlobals = {};
        for (var g in globals) {
          oldGlobals[g] = globals[g];
          __global[g] = globals[g];
        }
      }

      // store a complete copy of the global object in order to detect changes
      if (!exportName) {
        globalSnapshot = {};

        forEachGlobalValue(function(name, value) {
          globalSnapshot[name] = value;
        });
      }

      // return function to retrieve global
      return function() {
        var globalValue;

        if (exportName) {
          globalValue = readMemberExpression(exportName, __global);
        }
        else {
          var singleGlobal;
          var multipleExports;
          var exports = {};

          forEachGlobalValue(function(name, value) {
            if (globalSnapshot[name] === value)
              return;
            if (typeof value == 'undefined')
              return;
            exports[name] = value;

            if (typeof singleGlobal != 'undefined') {
              if (!multipleExports && singleGlobal !== value)
                multipleExports = true;
            }
            else {
              singleGlobal = value;
            }
          });
          globalValue = multipleExports ? exports : singleGlobal;
        }

        // revert globals
        if (oldGlobals) {
          for (var g in oldGlobals)
            __global[g] = oldGlobals[g];
        }
        __global.define = curDefine;

        return globalValue;
      };
    }
  }));

})(typeof self != 'undefined' ? self : global);

$__System.register("d3", [], function() { return { setters: [], execute: function() {} } });

$__System.register("d4", [], function() { return { setters: [], execute: function() {} } });

$__System.register("d5", [], function() { return { setters: [], execute: function() {} } });

$__System.register("d6", [], function() { return { setters: [], execute: function() {} } });

$__System.register("d7", [], function() { return { setters: [], execute: function() {} } });

$__System.register("d8", [], function() { return { setters: [], execute: function() {} } });

$__System.register("d9", [], function() { return { setters: [], execute: function() {} } });

$__System.registerDynamic("2", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3", ["2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("2");
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4", ["3"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? process : require("3");
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5", ["4"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("4");
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6", ["5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if ("production" !== process.env.NODE_ENV) {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error('Invariant Violation: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("6");
    var keyMirror = function(obj) {
      var ret = {};
      var key;
      ("production" !== process.env.NODE_ENV ? invariant(obj instanceof Object && !Array.isArray(obj), 'keyMirror(...): Argument must be an object.') : invariant(obj instanceof Object && !Array.isArray(obj)));
      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        ret[key] = key;
      }
      return ret;
    };
    module.exports = keyMirror;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8", ["7"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keyMirror = require("7");
  var PropagationPhases = keyMirror({
    bubbled: null,
    captured: null
  });
  var topLevelTypes = keyMirror({
    topBlur: null,
    topChange: null,
    topClick: null,
    topCompositionEnd: null,
    topCompositionStart: null,
    topCompositionUpdate: null,
    topContextMenu: null,
    topCopy: null,
    topCut: null,
    topDoubleClick: null,
    topDrag: null,
    topDragEnd: null,
    topDragEnter: null,
    topDragExit: null,
    topDragLeave: null,
    topDragOver: null,
    topDragStart: null,
    topDrop: null,
    topError: null,
    topFocus: null,
    topInput: null,
    topKeyDown: null,
    topKeyPress: null,
    topKeyUp: null,
    topLoad: null,
    topMouseDown: null,
    topMouseMove: null,
    topMouseOut: null,
    topMouseOver: null,
    topMouseUp: null,
    topPaste: null,
    topReset: null,
    topScroll: null,
    topSelectionChange: null,
    topSubmit: null,
    topTextInput: null,
    topTouchCancel: null,
    topTouchEnd: null,
    topTouchMove: null,
    topTouchStart: null,
    topWheel: null
  });
  var EventConstants = {
    topLevelTypes: topLevelTypes,
    PropagationPhases: PropagationPhases
  };
  module.exports = EventConstants;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9", ["8", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("8");
    var invariant = require("6");
    var injection = {
      Mount: null,
      injectMount: function(InjectedMount) {
        injection.Mount = InjectedMount;
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? invariant(InjectedMount && InjectedMount.getNode, 'EventPluginUtils.injection.injectMount(...): Injected Mount module ' + 'is missing getNode.') : invariant(InjectedMount && InjectedMount.getNode));
        }
      }
    };
    var topLevelTypes = EventConstants.topLevelTypes;
    function isEndish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
    }
    function isMoveish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
    }
    function isStartish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
    }
    var validateEventDispatches;
    if ("production" !== process.env.NODE_ENV) {
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var idsIsArr = Array.isArray(dispatchIDs);
        var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        ("production" !== process.env.NODE_ENV ? invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
      };
    }
    function forEachEventDispatch(event, cb) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          cb(event, dispatchListeners[i], dispatchIDs[i]);
        }
      } else if (dispatchListeners) {
        cb(event, dispatchListeners, dispatchIDs);
      }
    }
    function executeDispatch(event, listener, domID) {
      event.currentTarget = injection.Mount.getNode(domID);
      var returnValue = listener(event, domID);
      event.currentTarget = null;
      return returnValue;
    }
    function executeDispatchesInOrder(event, cb) {
      forEachEventDispatch(event, cb);
      event._dispatchListeners = null;
      event._dispatchIDs = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchIDs[i])) {
            return dispatchIDs[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchIDs)) {
          return dispatchIDs;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchIDs = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchID = event._dispatchIDs;
      ("production" !== process.env.NODE_ENV ? invariant(!Array.isArray(dispatchListener), 'executeDirectDispatch(...): Invalid `event`.') : invariant(!Array.isArray(dispatchListener)));
      var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
      event._dispatchListeners = null;
      event._dispatchIDs = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatch: executeDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      injection: injection,
      useTouchEvents: false
    };
    module.exports = EventPluginUtils;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("6");
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      ("production" !== process.env.NODE_ENV ? invariant(instance instanceof Klass, 'Trying to release an instance into a pool of a different type.') : invariant(instance instanceof Klass));
      if (instance.destructor) {
        instance.destructor();
      }
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fiveArgumentPooler: fiveArgumentPooler
    };
    module.exports = PooledClass;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function assign(target, sources) {
    if (target == null) {
      throw new TypeError('Object.assign target cannot be null or undefined');
    }
    var to = Object(target);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
      var nextSource = arguments[nextIndex];
      if (nextSource == null) {
        continue;
      }
      var from = Object(nextSource);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
    }
    return to;
  }
  module.exports = assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c", ["5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyObject = {};
    if ("production" !== process.env.NODE_ENV) {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  function emptyFunction() {}
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module.exports = emptyFunction;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e", ["d", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyFunction = require("d");
    var warning = emptyFunction;
    if ("production" !== process.env.NODE_ENV) {
      warning = function(condition, format) {
        for (var args = [],
            $__0 = 2,
            $__1 = arguments.length; $__0 < $__1; $__0++)
          args.push(arguments[$__0]);
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (format.length < 10 || /^[s\W]*$/.test(format)) {
          throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
        }
        if (format.indexOf('Failed Composite propType: ') === 0) {
          return;
        }
        if (!condition) {
          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          });
          console.warn(message);
          try {
            throw new Error(message);
          } catch (x) {}
        }
      };
    }
    module.exports = warning;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f", ["b", "c", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assign = require("b");
    var emptyObject = require("c");
    var warning = require("e");
    var didWarn = false;
    var ReactContext = {
      current: emptyObject,
      withContext: function(newContext, scopedCallback) {
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(didWarn, 'withContext is deprecated and will be removed in a future version. ' + 'Use a wrapper component with getChildContext instead.') : null);
          didWarn = true;
        }
        var result;
        var previousContext = ReactContext.current;
        ReactContext.current = assign({}, previousContext, newContext);
        try {
          result = scopedCallback();
        } finally {
          ReactContext.current = previousContext;
        }
        return result;
      }
    };
    module.exports = ReactContext;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactCurrentOwner = {current: null};
  module.exports = ReactCurrentOwner;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11", ["f", "10", "b", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactContext = require("f");
    var ReactCurrentOwner = require("10");
    var assign = require("b");
    var warning = require("e");
    var RESERVED_PROPS = {
      key: true,
      ref: true
    };
    function defineWarningProperty(object, key) {
      Object.defineProperty(object, key, {
        configurable: false,
        enumerable: true,
        get: function() {
          if (!this._store) {
            return null;
          }
          return this._store[key];
        },
        set: function(value) {
          ("production" !== process.env.NODE_ENV ? warning(false, 'Don\'t set the %s property of the React element. Instead, ' + 'specify the correct value when initially creating the element.', key) : null);
          this._store[key] = value;
        }
      });
    }
    var useMutationMembrane = false;
    function defineMutationMembrane(prototype) {
      try {
        var pseudoFrozenProperties = {props: true};
        for (var key in pseudoFrozenProperties) {
          defineWarningProperty(prototype, key);
        }
        useMutationMembrane = true;
      } catch (x) {}
    }
    var ReactElement = function(type, key, ref, owner, context, props) {
      this.type = type;
      this.key = key;
      this.ref = ref;
      this._owner = owner;
      this._context = context;
      if ("production" !== process.env.NODE_ENV) {
        this._store = {
          props: props,
          originalProps: assign({}, props)
        };
        try {
          Object.defineProperty(this._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true
          });
        } catch (x) {}
        this._store.validated = false;
        if (useMutationMembrane) {
          Object.freeze(this);
          return;
        }
      }
      this.props = props;
    };
    ReactElement.prototype = {_isReactElement: true};
    if ("production" !== process.env.NODE_ENV) {
      defineMutationMembrane(ReactElement.prototype);
    }
    ReactElement.createElement = function(type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      if (config != null) {
        ref = config.ref === undefined ? null : config.ref;
        key = config.key === undefined ? null : '' + config.key;
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (typeof props[propName] === 'undefined') {
            props[propName] = defaultProps[propName];
          }
        }
      }
      return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props);
    };
    ReactElement.createFactory = function(type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
      var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);
      if ("production" !== process.env.NODE_ENV) {
        newElement._store.validated = oldElement._store.validated;
      }
      return newElement;
    };
    ReactElement.cloneElement = function(element, config, children) {
      var propName;
      var props = assign({}, element.props);
      var key = element.key;
      var ref = element.ref;
      var owner = element._owner;
      if (config != null) {
        if (config.ref !== undefined) {
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (config.key !== undefined) {
          key = '' + config.key;
        }
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      return new ReactElement(element.type, key, ref, owner, element._context, props);
    };
    ReactElement.isValidElement = function(object) {
      var isElement = !!(object && object._isReactElement);
      return isElement;
    };
    module.exports = ReactElement;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12", ["11", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("11");
    var warning = require("e");
    if ("production" !== process.env.NODE_ENV) {
      var fragmentKey = '_reactFragment';
      var didWarnKey = '_reactDidWarn';
      var canWarnForReactFragment = false;
      try {
        var dummy = function() {
          return 1;
        };
        Object.defineProperty({}, fragmentKey, {
          enumerable: false,
          value: true
        });
        Object.defineProperty({}, 'key', {
          enumerable: true,
          get: dummy
        });
        canWarnForReactFragment = true;
      } catch (x) {}
      var proxyPropertyAccessWithWarning = function(obj, key) {
        Object.defineProperty(obj, key, {
          enumerable: true,
          get: function() {
            ("production" !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an opaque type. Accessing any of its ' + 'properties is deprecated. Pass it to one of the React.Children ' + 'helpers.') : null);
            this[didWarnKey] = true;
            return this[fragmentKey][key];
          },
          set: function(value) {
            ("production" !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an immutable opaque type. Mutating its ' + 'properties is deprecated.') : null);
            this[didWarnKey] = true;
            this[fragmentKey][key] = value;
          }
        });
      };
      var issuedWarnings = {};
      var didWarnForFragment = function(fragment) {
        var fragmentCacheKey = '';
        for (var key in fragment) {
          fragmentCacheKey += key + ':' + (typeof fragment[key]) + ',';
        }
        var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];
        issuedWarnings[fragmentCacheKey] = true;
        return alreadyWarnedOnce;
      };
    }
    var ReactFragment = {
      create: function(object) {
        if ("production" !== process.env.NODE_ENV) {
          if (typeof object !== 'object' || !object || Array.isArray(object)) {
            ("production" !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment only accepts a single object.', object) : null);
            return object;
          }
          if (ReactElement.isValidElement(object)) {
            ("production" !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : null);
            return object;
          }
          if (canWarnForReactFragment) {
            var proxy = {};
            Object.defineProperty(proxy, fragmentKey, {
              enumerable: false,
              value: object
            });
            Object.defineProperty(proxy, didWarnKey, {
              writable: true,
              enumerable: false,
              value: false
            });
            for (var key in object) {
              proxyPropertyAccessWithWarning(proxy, key);
            }
            Object.preventExtensions(proxy);
            return proxy;
          }
        }
        return object;
      },
      extract: function(fragment) {
        if ("production" !== process.env.NODE_ENV) {
          if (canWarnForReactFragment) {
            if (!fragment[fragmentKey]) {
              ("production" !== process.env.NODE_ENV ? warning(didWarnForFragment(fragment), 'Any use of a keyed object should be wrapped in ' + 'React.addons.createFragment(object) before being passed as a ' + 'child.') : null);
              return fragment;
            }
            return fragment[fragmentKey];
          }
        }
        return fragment;
      },
      extractIfFragment: function(fragment) {
        if ("production" !== process.env.NODE_ENV) {
          if (canWarnForReactFragment) {
            if (fragment[fragmentKey]) {
              return fragment[fragmentKey];
            }
            for (var key in fragment) {
              if (fragment.hasOwnProperty(key) && ReactElement.isValidElement(fragment[key])) {
                return ReactFragment.extract(fragment);
              }
            }
          }
        }
        return fragment;
      }
    };
    module.exports = ReactFragment;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactRootIndexInjection = {injectCreateReactRootIndex: function(_createReactRootIndex) {
      ReactRootIndex.createReactRootIndex = _createReactRootIndex;
    }};
  var ReactRootIndex = {
    createReactRootIndex: null,
    injection: ReactRootIndexInjection
  };
  module.exports = ReactRootIndex;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14", ["13", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactRootIndex = require("13");
    var invariant = require("6");
    var SEPARATOR = '.';
    var SEPARATOR_LENGTH = SEPARATOR.length;
    var MAX_TREE_DEPTH = 100;
    function getReactRootIDString(index) {
      return SEPARATOR + index.toString(36);
    }
    function isBoundary(id, index) {
      return id.charAt(index) === SEPARATOR || index === id.length;
    }
    function isValidID(id) {
      return id === '' || (id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR);
    }
    function isAncestorIDOf(ancestorID, descendantID) {
      return (descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length));
    }
    function getParentID(id) {
      return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
    }
    function getNextDescendantID(ancestorID, destinationID) {
      ("production" !== process.env.NODE_ENV ? invariant(isValidID(ancestorID) && isValidID(destinationID), 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(isValidID(ancestorID) && isValidID(destinationID)));
      ("production" !== process.env.NODE_ENV ? invariant(isAncestorIDOf(ancestorID, destinationID), 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(isAncestorIDOf(ancestorID, destinationID)));
      if (ancestorID === destinationID) {
        return ancestorID;
      }
      var start = ancestorID.length + SEPARATOR_LENGTH;
      var i;
      for (i = start; i < destinationID.length; i++) {
        if (isBoundary(destinationID, i)) {
          break;
        }
      }
      return destinationID.substr(0, i);
    }
    function getFirstCommonAncestorID(oneID, twoID) {
      var minLength = Math.min(oneID.length, twoID.length);
      if (minLength === 0) {
        return '';
      }
      var lastCommonMarkerIndex = 0;
      for (var i = 0; i <= minLength; i++) {
        if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
          lastCommonMarkerIndex = i;
        } else if (oneID.charAt(i) !== twoID.charAt(i)) {
          break;
        }
      }
      var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
      ("production" !== process.env.NODE_ENV ? invariant(isValidID(longestCommonID), 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(isValidID(longestCommonID)));
      return longestCommonID;
    }
    function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
      start = start || '';
      stop = stop || '';
      ("production" !== process.env.NODE_ENV ? invariant(start !== stop, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(start !== stop));
      var traverseUp = isAncestorIDOf(stop, start);
      ("production" !== process.env.NODE_ENV ? invariant(traverseUp || isAncestorIDOf(start, stop), 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(traverseUp || isAncestorIDOf(start, stop)));
      var depth = 0;
      var traverse = traverseUp ? getParentID : getNextDescendantID;
      for (var id = start; ; id = traverse(id, stop)) {
        var ret;
        if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
          ret = cb(id, traverseUp, arg);
        }
        if (ret === false || id === stop) {
          break;
        }
        ("production" !== process.env.NODE_ENV ? invariant(depth++ < MAX_TREE_DEPTH, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop) : invariant(depth++ < MAX_TREE_DEPTH));
      }
    }
    var ReactInstanceHandles = {
      createReactRootID: function() {
        return getReactRootIDString(ReactRootIndex.createReactRootIndex());
      },
      createReactID: function(rootID, name) {
        return rootID + name;
      },
      getReactRootIDFromNodeID: function(id) {
        if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
          var index = id.indexOf(SEPARATOR, 1);
          return index > -1 ? id.substr(0, index) : id;
        }
        return null;
      },
      traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
        var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
        if (ancestorID !== leaveID) {
          traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
        }
        if (ancestorID !== enterID) {
          traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
        }
      },
      traverseTwoPhase: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath('', targetID, cb, arg, true, false);
          traverseParentPath(targetID, '', cb, arg, false, true);
        }
      },
      traverseAncestors: function(targetID, cb, arg) {
        traverseParentPath('', targetID, cb, arg, true, false);
      },
      _getFirstCommonAncestorID: getFirstCommonAncestorID,
      _getNextDescendantID: getNextDescendantID,
      isAncestorIDOf: isAncestorIDOf,
      SEPARATOR: SEPARATOR
    };
    module.exports = ReactInstanceHandles;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]));
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }
  module.exports = getIteratorFn;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16", ["11", "12", "14", "15", "6", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("11");
    var ReactFragment = require("12");
    var ReactInstanceHandles = require("14");
    var getIteratorFn = require("15");
    var invariant = require("6");
    var warning = require("e");
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var SUBSEPARATOR = ':';
    var userProvidedKeyEscaperLookup = {
      '=': '=0',
      '.': '=1',
      ':': '=2'
    };
    var userProvidedKeyEscapeRegex = /[=.:]/g;
    var didWarnAboutMaps = false;
    function userProvidedKeyEscaper(match) {
      return userProvidedKeyEscaperLookup[match];
    }
    function getComponentKey(component, index) {
      if (component && component.key != null) {
        return wrapUserProvidedKey(component.key);
      }
      return index.toString(36);
    }
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
    }
    function wrapUserProvidedKey(key) {
      return '$' + escapeUserProvidedKey(key);
    }
    function traverseAllChildrenImpl(children, nameSoFar, indexSoFar, callback, traverseContext) {
      var type = typeof children;
      if (type === 'undefined' || type === 'boolean') {
        children = null;
      }
      if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
        callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, indexSoFar);
        return 1;
      }
      var child,
          nextName,
          nextIndex;
      var subtreeCount = 0;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = ((nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i));
          nextIndex = indexSoFar + subtreeCount;
          subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = ((nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, ii++));
              nextIndex = indexSoFar + subtreeCount;
              subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
            }
          } else {
            if ("production" !== process.env.NODE_ENV) {
              ("production" !== process.env.NODE_ENV ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : null);
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName = ((nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0));
                nextIndex = indexSoFar + subtreeCount;
                subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
              }
            }
          }
        } else if (type === 'object') {
          ("production" !== process.env.NODE_ENV ? invariant(children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(children.nodeType !== 1));
          var fragment = ReactFragment.extract(children);
          for (var key in fragment) {
            if (fragment.hasOwnProperty(key)) {
              child = fragment[key];
              nextName = ((nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(child, 0));
              nextIndex = indexSoFar + subtreeCount;
              subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
            }
          }
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17", ["a", "12", "16", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var PooledClass = require("a");
    var ReactFragment = require("12");
    var traverseAllChildren = require("16");
    var warning = require("e");
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var threeArgumentPooler = PooledClass.threeArgumentPooler;
    function ForEachBookKeeping(forEachFunction, forEachContext) {
      this.forEachFunction = forEachFunction;
      this.forEachContext = forEachContext;
    }
    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(traverseContext, child, name, i) {
      var forEachBookKeeping = traverseContext;
      forEachBookKeeping.forEachFunction.call(forEachBookKeeping.forEachContext, child, i);
    }
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      ForEachBookKeeping.release(traverseContext);
    }
    function MapBookKeeping(mapResult, mapFunction, mapContext) {
      this.mapResult = mapResult;
      this.mapFunction = mapFunction;
      this.mapContext = mapContext;
    }
    PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
    function mapSingleChildIntoContext(traverseContext, child, name, i) {
      var mapBookKeeping = traverseContext;
      var mapResult = mapBookKeeping.mapResult;
      var keyUnique = !mapResult.hasOwnProperty(name);
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(keyUnique, 'ReactChildren.map(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : null);
      }
      if (keyUnique) {
        var mappedChild = mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
        mapResult[name] = mappedChild;
      }
    }
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var mapResult = {};
      var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      MapBookKeeping.release(traverseContext);
      return ReactFragment.create(mapResult);
    }
    function forEachSingleChildDummy(traverseContext, child, name, i) {
      return null;
    }
    function countChildren(children, context) {
      return traverseAllChildren(children, forEachSingleChildDummy, null);
    }
    var ReactChildren = {
      forEach: forEachChildren,
      map: mapChildren,
      count: countChildren
    };
    module.exports = ReactChildren;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18", ["5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactLifeCycle = {
      currentlyMountingInstance: null,
      currentlyUnmountingInstance: null
    };
    module.exports = ReactLifeCycle;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactInstanceMap = {
    remove: function(key) {
      key._reactInternalInstance = undefined;
    },
    get: function(key) {
      return key._reactInternalInstance;
    },
    has: function(key) {
      return key._reactInternalInstance !== undefined;
    },
    set: function(key, value) {
      key._reactInternalInstance = value;
    }
  };
  module.exports = ReactInstanceMap;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a", ["a", "b", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var PooledClass = require("a");
    var assign = require("b");
    var invariant = require("6");
    function CallbackQueue() {
      this._callbacks = null;
      this._contexts = null;
    }
    assign(CallbackQueue.prototype, {
      enqueue: function(callback, context) {
        this._callbacks = this._callbacks || [];
        this._contexts = this._contexts || [];
        this._callbacks.push(callback);
        this._contexts.push(context);
      },
      notifyAll: function() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        if (callbacks) {
          ("production" !== process.env.NODE_ENV ? invariant(callbacks.length === contexts.length, 'Mismatched list of contexts in callback queue') : invariant(callbacks.length === contexts.length));
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0,
              l = callbacks.length; i < l; i++) {
            callbacks[i].call(contexts[i]);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      },
      reset: function() {
        this._callbacks = null;
        this._contexts = null;
      },
      destructor: function() {
        this.reset();
      }
    });
    PooledClass.addPoolingTo(CallbackQueue);
    module.exports = CallbackQueue;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b", ["5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPerf = {
      enableMeasure: false,
      storedMeasure: _noMeasure,
      measureMethods: function(object, objectName, methodNames) {
        if ("production" !== process.env.NODE_ENV) {
          for (var key in methodNames) {
            if (!methodNames.hasOwnProperty(key)) {
              continue;
            }
            object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
          }
        }
      },
      measure: function(objName, fnName, func) {
        if ("production" !== process.env.NODE_ENV) {
          var measuredFunc = null;
          var wrapper = function() {
            if (ReactPerf.enableMeasure) {
              if (!measuredFunc) {
                measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
              }
              return measuredFunc.apply(this, arguments);
            }
            return func.apply(this, arguments);
          };
          wrapper.displayName = objName + '_' + fnName;
          return wrapper;
        }
        return func;
      },
      injection: {injectMeasure: function(measure) {
          ReactPerf.storedMeasure = measure;
        }}
    };
    function _noMeasure(objName, fnName, func) {
      return func;
    }
    module.exports = ReactPerf;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("6");
    var ReactOwner = {
      isValidOwner: function(object) {
        return !!((object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function'));
      },
      addComponentAsRefTo: function(component, ref, owner) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), 'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to add a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(ReactOwner.isValidOwner(owner)));
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function(component, ref, owner) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to remove a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(ReactOwner.isValidOwner(owner)));
        if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
          owner.detachRef(ref);
        }
      }
    };
    module.exports = ReactOwner;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d", ["1c", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactOwner = require("1c");
    var ReactRef = {};
    function attachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(component.getPublicInstance());
      } else {
        ReactOwner.addComponentAsRefTo(component, ref, owner);
      }
    }
    function detachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(null);
      } else {
        ReactOwner.removeComponentAsRefFrom(component, ref, owner);
      }
    }
    ReactRef.attachRefs = function(instance, element) {
      var ref = element.ref;
      if (ref != null) {
        attachRef(ref, instance, element._owner);
      }
    };
    ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
      return (nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref);
    };
    ReactRef.detachRefs = function(instance, element) {
      var ref = element.ref;
      if (ref != null) {
        detachRef(ref, instance, element._owner);
      }
    };
    module.exports = ReactRef;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e", ["7"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keyMirror = require("7");
  var ReactPropTypeLocations = keyMirror({
    prop: null,
    context: null,
    childContext: null
  });
  module.exports = ReactPropTypeLocations;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f", ["5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPropTypeLocationNames = {};
    if ("production" !== process.env.NODE_ENV) {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20", ["b", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assign = require("b");
    var invariant = require("6");
    var autoGenerateWrapperClass = null;
    var genericComponentClass = null;
    var tagToComponentClass = {};
    var textComponentClass = null;
    var ReactNativeComponentInjection = {
      injectGenericComponentClass: function(componentClass) {
        genericComponentClass = componentClass;
      },
      injectTextComponentClass: function(componentClass) {
        textComponentClass = componentClass;
      },
      injectComponentClasses: function(componentClasses) {
        assign(tagToComponentClass, componentClasses);
      },
      injectAutoWrapper: function(wrapperFactory) {
        autoGenerateWrapperClass = wrapperFactory;
      }
    };
    function getComponentClassForElement(element) {
      if (typeof element.type === 'function') {
        return element.type;
      }
      var tag = element.type;
      var componentClass = tagToComponentClass[tag];
      if (componentClass == null) {
        tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
      }
      return componentClass;
    }
    function createInternalComponent(element) {
      ("production" !== process.env.NODE_ENV ? invariant(genericComponentClass, 'There is no registered component for the tag %s', element.type) : invariant(genericComponentClass));
      return new genericComponentClass(element.type, element.props);
    }
    function createInstanceForText(text) {
      return new textComponentClass(text);
    }
    function isTextComponent(component) {
      return component instanceof textComponentClass;
    }
    var ReactNativeComponent = {
      getComponentClassForElement: getComponentClassForElement,
      createInternalComponent: createInternalComponent,
      createInstanceForText: createInstanceForText,
      isTextComponent: isTextComponent,
      injection: ReactNativeComponentInjection
    };
    module.exports = ReactNativeComponent;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21", ["11", "12", "1e", "1f", "10", "20", "15", "6", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("11");
    var ReactFragment = require("12");
    var ReactPropTypeLocations = require("1e");
    var ReactPropTypeLocationNames = require("1f");
    var ReactCurrentOwner = require("10");
    var ReactNativeComponent = require("20");
    var getIteratorFn = require("15");
    var invariant = require("6");
    var warning = require("e");
    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = ReactCurrentOwner.current.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var ownerHasKeyUseWarning = {};
    var loggedTypeFailures = {};
    var NUMERIC_PROPERTY_REGEX = /^\d+$/;
    function getName(instance) {
      var publicInstance = instance && instance.getPublicInstance();
      if (!publicInstance) {
        return undefined;
      }
      var constructor = publicInstance.constructor;
      if (!constructor) {
        return undefined;
      }
      return constructor.displayName || constructor.name || undefined;
    }
    function getCurrentOwnerDisplayName() {
      var current = ReactCurrentOwner.current;
      return (current && getName(current) || undefined);
    }
    function validateExplicitKey(element, parentType) {
      if (element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;
      warnAndMonitorForKeyUse('Each child in an array or iterator should have a unique "key" prop.', element, parentType);
    }
    function validatePropertyKey(name, element, parentType) {
      if (!NUMERIC_PROPERTY_REGEX.test(name)) {
        return;
      }
      warnAndMonitorForKeyUse('Child objects should have non-numeric keys so ordering is preserved.', element, parentType);
    }
    function warnAndMonitorForKeyUse(message, element, parentType) {
      var ownerName = getCurrentOwnerDisplayName();
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
      var useName = ownerName || parentName;
      var memoizer = ownerHasKeyUseWarning[message] || ((ownerHasKeyUseWarning[message] = {}));
      if (memoizer.hasOwnProperty(useName)) {
        return;
      }
      memoizer[useName] = true;
      var parentOrOwnerAddendum = ownerName ? (" Check the render method of " + ownerName + ".") : parentName ? (" Check the React.render call using <" + parentName + ">.") : '';
      var childOwnerAddendum = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        var childOwnerName = getName(element._owner);
        childOwnerAddendum = (" It was passed a child from " + childOwnerName + ".");
      }
      ("production" !== process.env.NODE_ENV ? warning(false, message + '%s%s See https://fb.me/react-warning-keys for more information.', parentOrOwnerAddendum, childOwnerAddendum) : null);
    }
    function validateChildKeys(node, parentType) {
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (ReactElement.isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (ReactElement.isValidElement(node)) {
        node._store.validated = true;
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (iteratorFn) {
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (ReactElement.isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        } else if (typeof node === 'object') {
          var fragment = ReactFragment.extractIfFragment(node);
          for (var key in fragment) {
            if (fragment.hasOwnProperty(key)) {
              validatePropertyKey(key, fragment[key], parentType);
            }
          }
        }
      }
    }
    function checkPropTypes(componentName, propTypes, props, location) {
      for (var propName in propTypes) {
        if (propTypes.hasOwnProperty(propName)) {
          var error;
          try {
            ("production" !== process.env.NODE_ENV ? invariant(typeof propTypes[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(typeof propTypes[propName] === 'function'));
            error = propTypes[propName](props, propName, componentName, location);
          } catch (ex) {
            error = ex;
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var addendum = getDeclarationErrorAddendum(this);
            ("production" !== process.env.NODE_ENV ? warning(false, 'Failed propType: %s%s', error.message, addendum) : null);
          }
        }
      }
    }
    var warnedPropsMutations = {};
    function warnForPropsMutation(propName, element) {
      var type = element.type;
      var elementName = typeof type === 'string' ? type : type.displayName;
      var ownerName = element._owner ? element._owner.getPublicInstance().constructor.displayName : null;
      var warningKey = propName + '|' + elementName + '|' + ownerName;
      if (warnedPropsMutations.hasOwnProperty(warningKey)) {
        return;
      }
      warnedPropsMutations[warningKey] = true;
      var elementInfo = '';
      if (elementName) {
        elementInfo = ' <' + elementName + ' />';
      }
      var ownerInfo = '';
      if (ownerName) {
        ownerInfo = ' The element was created by ' + ownerName + '.';
      }
      ("production" !== process.env.NODE_ENV ? warning(false, 'Don\'t set .props.%s of the React component%s. Instead, specify the ' + 'correct value when initially creating the element or use ' + 'React.cloneElement to make a new element with updated props.%s', propName, elementInfo, ownerInfo) : null);
    }
    function is(a, b) {
      if (a !== a) {
        return b !== b;
      }
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      }
      return a === b;
    }
    function checkAndWarnForMutatedProps(element) {
      if (!element._store) {
        return;
      }
      var originalProps = element._store.originalProps;
      var props = element.props;
      for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
          if (!originalProps.hasOwnProperty(propName) || !is(originalProps[propName], props[propName])) {
            warnForPropsMutation(propName, element);
            originalProps[propName] = props[propName];
          }
        }
      }
    }
    function validatePropTypes(element) {
      if (element.type == null) {
        return;
      }
      var componentClass = ReactNativeComponent.getComponentClassForElement(element);
      var name = componentClass.displayName || componentClass.name;
      if (componentClass.propTypes) {
        checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        ("production" !== process.env.NODE_ENV ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : null);
      }
    }
    var ReactElementValidator = {
      checkAndWarnForMutatedProps: checkAndWarnForMutatedProps,
      createElement: function(type, props, children) {
        ("production" !== process.env.NODE_ENV ? warning(type != null, 'React.createElement: type should not be null or undefined. It should ' + 'be a string (for DOM elements) or a ReactClass (for composite ' + 'components).') : null);
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
        validatePropTypes(element);
        return element;
      },
      createFactory: function(type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        if ("production" !== process.env.NODE_ENV) {
          try {
            Object.defineProperty(validatedFactory, 'type', {
              enumerable: false,
              get: function() {
                ("production" !== process.env.NODE_ENV ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : null);
                Object.defineProperty(this, 'type', {value: type});
                return type;
              }
            });
          } catch (x) {}
        }
        return validatedFactory;
      },
      cloneElement: function(element, props, children) {
        var newElement = ReactElement.cloneElement.apply(this, arguments);
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
    };
    module.exports = ReactElementValidator;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22", ["1d", "21", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactRef = require("1d");
    var ReactElementValidator = require("21");
    function attachRefs() {
      ReactRef.attachRefs(this, this._currentElement);
    }
    var ReactReconciler = {
      mountComponent: function(internalInstance, rootID, transaction, context) {
        var markup = internalInstance.mountComponent(rootID, transaction, context);
        if ("production" !== process.env.NODE_ENV) {
          ReactElementValidator.checkAndWarnForMutatedProps(internalInstance._currentElement);
        }
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
        return markup;
      },
      unmountComponent: function(internalInstance) {
        ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
        internalInstance.unmountComponent();
      },
      receiveComponent: function(internalInstance, nextElement, transaction, context) {
        var prevElement = internalInstance._currentElement;
        if (nextElement === prevElement && nextElement._owner != null) {
          return;
        }
        if ("production" !== process.env.NODE_ENV) {
          ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
        }
        var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
        if (refsChanged) {
          ReactRef.detachRefs(internalInstance, prevElement);
        }
        internalInstance.receiveComponent(nextElement, transaction, context);
        if (refsChanged) {
          transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
        }
      },
      performUpdateIfNecessary: function(internalInstance, transaction) {
        internalInstance.performUpdateIfNecessary(transaction);
      }
    };
    module.exports = ReactReconciler;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("6");
    var Mixin = {
      reinitializeTransaction: function() {
        this.transactionWrappers = this.getTransactionWrappers();
        if (!this.wrapperInitData) {
          this.wrapperInitData = [];
        } else {
          this.wrapperInitData.length = 0;
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function() {
        return !!this._isInTransaction;
      },
      perform: function(method, scope, a, b, c, d, e, f) {
        ("production" !== process.env.NODE_ENV ? invariant(!this.isInTransaction(), 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(!this.isInTransaction()));
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function(startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function(startIndex) {
        ("production" !== process.env.NODE_ENV ? invariant(this.isInTransaction(), 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(this.isInTransaction()));
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
              wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    var Transaction = {
      Mixin: Mixin,
      OBSERVED_ERROR: {}
    };
    module.exports = Transaction;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24", ["1a", "a", "10", "1b", "22", "23", "b", "6", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CallbackQueue = require("1a");
    var PooledClass = require("a");
    var ReactCurrentOwner = require("10");
    var ReactPerf = require("1b");
    var ReactReconciler = require("22");
    var Transaction = require("23");
    var assign = require("b");
    var invariant = require("6");
    var warning = require("e");
    var dirtyComponents = [];
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      ("production" !== process.env.NODE_ENV ? invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));
    }
    var NESTED_UPDATES = {
      initialize: function() {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function() {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function() {
        this.callbackQueue.reset();
      },
      close: function() {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();
    }
    assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function() {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null;
      },
      perform: function(method, scope, a) {
        return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b, c, d) {
      ensureInjected();
      batchingStrategy.batchedUpdates(callback, a, b, c, d);
    }
    function mountOrderComparator(c1, c2) {
      return c1._mountOrder - c2._mountOrder;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      ("production" !== process.env.NODE_ENV ? invariant(len === dirtyComponents.length, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(len === dirtyComponents.length));
      dirtyComponents.sort(mountOrderComparator);
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        var callbacks = component._pendingCallbacks;
        component._pendingCallbacks = null;
        ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
        if (callbacks) {
          for (var j = 0; j < callbacks.length; j++) {
            transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
          }
        }
      }
    }
    var flushBatchedUpdates = function() {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    };
    flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
    function enqueueUpdate(component) {
      ensureInjected();
      ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'enqueueUpdate(): Render methods should be a pure function of props ' + 'and state; triggering nested component updates from render is not ' + 'allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component);
        return;
      }
      dirtyComponents.push(component);
    }
    function asap(callback, context) {
      ("production" !== process.env.NODE_ENV ? invariant(batchingStrategy.isBatchingUpdates, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(batchingStrategy.isBatchingUpdates));
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function(ReconcileTransaction) {
        ("production" !== process.env.NODE_ENV ? invariant(ReconcileTransaction, 'ReactUpdates: must provide a reconcile transaction class') : invariant(ReconcileTransaction));
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function(_batchingStrategy) {
        ("production" !== process.env.NODE_ENV ? invariant(_batchingStrategy, 'ReactUpdates: must provide a batching strategy') : invariant(_batchingStrategy));
        ("production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.batchedUpdates === 'function', 'ReactUpdates: must provide a batchedUpdates() function') : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));
        ("production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean', 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25", ["18", "10", "11", "19", "24", "b", "6", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactLifeCycle = require("18");
    var ReactCurrentOwner = require("10");
    var ReactElement = require("11");
    var ReactInstanceMap = require("19");
    var ReactUpdates = require("24");
    var assign = require("b");
    var invariant = require("6");
    var warning = require("e");
    function enqueueUpdate(internalInstance) {
      if (internalInstance !== ReactLifeCycle.currentlyMountingInstance) {
        ReactUpdates.enqueueUpdate(internalInstance);
      }
    }
    function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : invariant(ReactCurrentOwner.current == null));
      var internalInstance = ReactInstanceMap.get(publicInstance);
      if (!internalInstance) {
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted ' + 'component. This is a no-op.', callerName, callerName) : null);
        }
        return null;
      }
      if (internalInstance === ReactLifeCycle.currentlyUnmountingInstance) {
        return null;
      }
      return internalInstance;
    }
    var ReactUpdateQueue = {
      enqueueCallback: function(publicInstance, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(typeof callback === 'function', 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(typeof callback === 'function'));
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
        if (!internalInstance || internalInstance === ReactLifeCycle.currentlyMountingInstance) {
          return null;
        }
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueCallbackInternal: function(internalInstance, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(typeof callback === 'function', 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(typeof callback === 'function'));
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueForceUpdate: function(publicInstance) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingForceUpdate = true;
        enqueueUpdate(internalInstance);
      },
      enqueueReplaceState: function(publicInstance, completeState) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingStateQueue = [completeState];
        internalInstance._pendingReplaceState = true;
        enqueueUpdate(internalInstance);
      },
      enqueueSetState: function(publicInstance, partialState) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
        if (!internalInstance) {
          return;
        }
        var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
        queue.push(partialState);
        enqueueUpdate(internalInstance);
      },
      enqueueSetProps: function(publicInstance, partialProps) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
        if (!internalInstance) {
          return;
        }
        ("production" !== process.env.NODE_ENV ? invariant(internalInstance._isTopLevel, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(internalInstance._isTopLevel));
        var element = internalInstance._pendingElement || internalInstance._currentElement;
        var props = assign({}, element.props, partialProps);
        internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);
        enqueueUpdate(internalInstance);
      },
      enqueueReplaceProps: function(publicInstance, props) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
        if (!internalInstance) {
          return;
        }
        ("production" !== process.env.NODE_ENV ? invariant(internalInstance._isTopLevel, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(internalInstance._isTopLevel));
        var element = internalInstance._pendingElement || internalInstance._currentElement;
        internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);
        enqueueUpdate(internalInstance);
      },
      enqueueElementInternal: function(internalInstance, newElement) {
        internalInstance._pendingElement = newElement;
        enqueueUpdate(internalInstance);
      }
    };
    module.exports = ReactUpdateQueue;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26", ["25", "6", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactUpdateQueue = require("25");
    var invariant = require("6");
    var warning = require("e");
    function ReactComponent(props, context) {
      this.props = props;
      this.context = context;
    }
    ReactComponent.prototype.setState = function(partialState, callback) {
      ("production" !== process.env.NODE_ENV ? invariant(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null));
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : null);
      }
      ReactUpdateQueue.enqueueSetState(this, partialState);
      if (callback) {
        ReactUpdateQueue.enqueueCallback(this, callback);
      }
    };
    ReactComponent.prototype.forceUpdate = function(callback) {
      ReactUpdateQueue.enqueueForceUpdate(this);
      if (callback) {
        ReactUpdateQueue.enqueueCallback(this, callback);
      }
    };
    if ("production" !== process.env.NODE_ENV) {
      var deprecatedAPIs = {
        getDOMNode: ['getDOMNode', 'Use React.findDOMNode(component) instead.'],
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceProps: ['replaceProps', 'Instead, call React.render again at the top level.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
        setProps: ['setProps', 'Instead, call React.render again at the top level.']
      };
      var defineDeprecationWarning = function(methodName, info) {
        try {
          Object.defineProperty(ReactComponent.prototype, methodName, {get: function() {
              ("production" !== process.env.NODE_ENV ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : null);
              return undefined;
            }});
        } catch (x) {}
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }
    module.exports = ReactComponent;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactErrorUtils = {guard: function(func, name) {
      return func;
    }};
  module.exports = ReactErrorUtils;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("28", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keyOf = function(oneKeyObj) {
    var key;
    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }
      return key;
    }
    return null;
  };
  module.exports = keyOf;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("29", ["26", "10", "11", "27", "19", "18", "1e", "1f", "25", "b", "6", "7", "28", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponent = require("26");
    var ReactCurrentOwner = require("10");
    var ReactElement = require("11");
    var ReactErrorUtils = require("27");
    var ReactInstanceMap = require("19");
    var ReactLifeCycle = require("18");
    var ReactPropTypeLocations = require("1e");
    var ReactPropTypeLocationNames = require("1f");
    var ReactUpdateQueue = require("25");
    var assign = require("b");
    var invariant = require("6");
    var keyMirror = require("7");
    var keyOf = require("28");
    var warning = require("e");
    var MIXINS_KEY = keyOf({mixins: null});
    var SpecPolicy = keyMirror({
      DEFINE_ONCE: null,
      DEFINE_MANY: null,
      OVERRIDE_BASE: null,
      DEFINE_MANY_MERGED: null
    });
    var injectedMixins = [];
    var ReactClassInterface = {
      mixins: SpecPolicy.DEFINE_MANY,
      statics: SpecPolicy.DEFINE_MANY,
      propTypes: SpecPolicy.DEFINE_MANY,
      contextTypes: SpecPolicy.DEFINE_MANY,
      childContextTypes: SpecPolicy.DEFINE_MANY,
      getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
      getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
      getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
      render: SpecPolicy.DEFINE_ONCE,
      componentWillMount: SpecPolicy.DEFINE_MANY,
      componentDidMount: SpecPolicy.DEFINE_MANY,
      componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
      shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
      componentWillUpdate: SpecPolicy.DEFINE_MANY,
      componentDidUpdate: SpecPolicy.DEFINE_MANY,
      componentWillUnmount: SpecPolicy.DEFINE_MANY,
      updateComponent: SpecPolicy.OVERRIDE_BASE
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function(Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function(Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(Constructor, childContextTypes) {
        if ("production" !== process.env.NODE_ENV) {
          validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
        }
        Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
      },
      contextTypes: function(Constructor, contextTypes) {
        if ("production" !== process.env.NODE_ENV) {
          validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
        }
        Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
      },
      getDefaultProps: function(Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function(Constructor, propTypes) {
        if ("production" !== process.env.NODE_ENV) {
          validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
        }
        Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
      },
      statics: function(Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      }
    };
    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          ("production" !== process.env.NODE_ENV ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : null);
        }
      }
    }
    function validateMethodOverride(proto, name) {
      var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
      if (ReactClassMixin.hasOwnProperty(name)) {
        ("production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.OVERRIDE_BASE, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));
      }
      if (proto.hasOwnProperty(name)) {
        ("production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED));
      }
    }
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        return;
      }
      ("production" !== process.env.NODE_ENV ? invariant(typeof spec !== 'function', 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(typeof spec !== 'function'));
      ("production" !== process.env.NODE_ENV ? invariant(!ReactElement.isValidElement(spec), 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(!ReactElement.isValidElement(spec)));
      var proto = Constructor.prototype;
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }
      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }
        if (name === MIXINS_KEY) {
          continue;
        }
        var property = spec[name];
        validateMethodOverride(proto, name);
        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          var isAlreadyDefined = proto.hasOwnProperty(name);
          var markedDontBind = property && property.__reactDontBind;
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && !markedDontBind;
          if (shouldAutoBind) {
            if (!proto.__reactAutoBindMap) {
              proto.__reactAutoBindMap = {};
            }
            proto.__reactAutoBindMap[name] = property;
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactClassInterface[name];
              ("production" !== process.env.NODE_ENV ? invariant(isReactClassMethod && ((specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(isReactClassMethod && ((specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY))));
              if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
              if ("production" !== process.env.NODE_ENV) {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }
    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return;
      }
      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }
        var isReserved = name in RESERVED_SPEC_KEYS;
        ("production" !== process.env.NODE_ENV ? invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(!isReserved));
        var isInherited = name in Constructor;
        ("production" !== process.env.NODE_ENV ? invariant(!isInherited, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(!isInherited));
        Constructor[name] = property;
      }
    }
    function mergeIntoWithNoDuplicateKeys(one, two) {
      ("production" !== process.env.NODE_ENV ? invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(one && two && typeof one === 'object' && typeof two === 'object'));
      for (var key in two) {
        if (two.hasOwnProperty(key)) {
          ("production" !== process.env.NODE_ENV ? invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(one[key] === undefined));
          one[key] = two[key];
        }
      }
      return one;
    }
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        var c = {};
        mergeIntoWithNoDuplicateKeys(c, a);
        mergeIntoWithNoDuplicateKeys(c, b);
        return c;
      };
    }
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }
    function bindAutoBindMethod(component, method) {
      var boundMethod = method.bind(component);
      if ("production" !== process.env.NODE_ENV) {
        boundMethod.__reactBoundContext = component;
        boundMethod.__reactBoundMethod = method;
        boundMethod.__reactBoundArguments = null;
        var componentName = component.constructor.displayName;
        var _bind = boundMethod.bind;
        boundMethod.bind = function(newThis) {
          for (var args = [],
              $__0 = 1,
              $__1 = arguments.length; $__0 < $__1; $__0++)
            args.push(arguments[$__0]);
          if (newThis !== component && newThis !== null) {
            ("production" !== process.env.NODE_ENV ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : null);
          } else if (!args.length) {
            ("production" !== process.env.NODE_ENV ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : null);
            return boundMethod;
          }
          var reboundMethod = _bind.apply(boundMethod, arguments);
          reboundMethod.__reactBoundContext = component;
          reboundMethod.__reactBoundMethod = method;
          reboundMethod.__reactBoundArguments = args;
          return reboundMethod;
        };
      }
      return boundMethod;
    }
    function bindAutoBindMethods(component) {
      for (var autoBindKey in component.__reactAutoBindMap) {
        if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
          var method = component.__reactAutoBindMap[autoBindKey];
          component[autoBindKey] = bindAutoBindMethod(component, ReactErrorUtils.guard(method, component.constructor.displayName + '.' + autoBindKey));
        }
      }
    }
    var typeDeprecationDescriptor = {
      enumerable: false,
      get: function() {
        var displayName = this.displayName || this.name || 'Component';
        ("production" !== process.env.NODE_ENV ? warning(false, '%s.type is deprecated. Use %s directly to access the class.', displayName, displayName) : null);
        Object.defineProperty(this, 'type', {value: this});
        return this;
      }
    };
    var ReactClassMixin = {
      replaceState: function(newState, callback) {
        ReactUpdateQueue.enqueueReplaceState(this, newState);
        if (callback) {
          ReactUpdateQueue.enqueueCallback(this, callback);
        }
      },
      isMounted: function() {
        if ("production" !== process.env.NODE_ENV) {
          var owner = ReactCurrentOwner.current;
          if (owner !== null) {
            ("production" !== process.env.NODE_ENV ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : null);
            owner._warnedAboutRefsInRender = true;
          }
        }
        var internalInstance = ReactInstanceMap.get(this);
        return (internalInstance && internalInstance !== ReactLifeCycle.currentlyMountingInstance);
      },
      setProps: function(partialProps, callback) {
        ReactUpdateQueue.enqueueSetProps(this, partialProps);
        if (callback) {
          ReactUpdateQueue.enqueueCallback(this, callback);
        }
      },
      replaceProps: function(newProps, callback) {
        ReactUpdateQueue.enqueueReplaceProps(this, newProps);
        if (callback) {
          ReactUpdateQueue.enqueueCallback(this, callback);
        }
      }
    };
    var ReactClassComponent = function() {};
    assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
    var ReactClass = {
      createClass: function(spec) {
        var Constructor = function(props, context) {
          if ("production" !== process.env.NODE_ENV) {
            ("production" !== process.env.NODE_ENV ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : null);
          }
          if (this.__reactAutoBindMap) {
            bindAutoBindMethods(this);
          }
          this.props = props;
          this.context = context;
          this.state = null;
          var initialState = this.getInitialState ? this.getInitialState() : null;
          if ("production" !== process.env.NODE_ENV) {
            if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
              initialState = null;
            }
          }
          ("production" !== process.env.NODE_ENV ? invariant(typeof initialState === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(typeof initialState === 'object' && !Array.isArray(initialState)));
          this.state = initialState;
        };
        Constructor.prototype = new ReactClassComponent();
        Constructor.prototype.constructor = Constructor;
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, spec);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        if ("production" !== process.env.NODE_ENV) {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps.isReactClassApproved = {};
          }
          if (Constructor.prototype.getInitialState) {
            Constructor.prototype.getInitialState.isReactClassApproved = {};
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.') : invariant(Constructor.prototype.render));
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : null);
        }
        for (var methodName in ReactClassInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        Constructor.type = Constructor;
        if ("production" !== process.env.NODE_ENV) {
          try {
            Object.defineProperty(Constructor, 'type', typeDeprecationDescriptor);
          } catch (x) {}
        }
        return Constructor;
      },
      injection: {injectMixin: function(mixin) {
          injectedMixins.push(mixin);
        }}
    };
    module.exports = ReactClass;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2a", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function mapObject(object, callback, context) {
    if (!object) {
      return null;
    }
    var result = {};
    for (var name in object) {
      if (hasOwnProperty.call(object, name)) {
        result[name] = callback.call(context, object[name], name, object);
      }
    }
    return result;
  }
  module.exports = mapObject;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2b", ["11", "21", "2a", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("11");
    var ReactElementValidator = require("21");
    var mapObject = require("2a");
    function createDOMFactory(tag) {
      if ("production" !== process.env.NODE_ENV) {
        return ReactElementValidator.createFactory(tag);
      }
      return ReactElement.createFactory(tag);
    }
    var ReactDOM = mapObject({
      a: 'a',
      abbr: 'abbr',
      address: 'address',
      area: 'area',
      article: 'article',
      aside: 'aside',
      audio: 'audio',
      b: 'b',
      base: 'base',
      bdi: 'bdi',
      bdo: 'bdo',
      big: 'big',
      blockquote: 'blockquote',
      body: 'body',
      br: 'br',
      button: 'button',
      canvas: 'canvas',
      caption: 'caption',
      cite: 'cite',
      code: 'code',
      col: 'col',
      colgroup: 'colgroup',
      data: 'data',
      datalist: 'datalist',
      dd: 'dd',
      del: 'del',
      details: 'details',
      dfn: 'dfn',
      dialog: 'dialog',
      div: 'div',
      dl: 'dl',
      dt: 'dt',
      em: 'em',
      embed: 'embed',
      fieldset: 'fieldset',
      figcaption: 'figcaption',
      figure: 'figure',
      footer: 'footer',
      form: 'form',
      h1: 'h1',
      h2: 'h2',
      h3: 'h3',
      h4: 'h4',
      h5: 'h5',
      h6: 'h6',
      head: 'head',
      header: 'header',
      hr: 'hr',
      html: 'html',
      i: 'i',
      iframe: 'iframe',
      img: 'img',
      input: 'input',
      ins: 'ins',
      kbd: 'kbd',
      keygen: 'keygen',
      label: 'label',
      legend: 'legend',
      li: 'li',
      link: 'link',
      main: 'main',
      map: 'map',
      mark: 'mark',
      menu: 'menu',
      menuitem: 'menuitem',
      meta: 'meta',
      meter: 'meter',
      nav: 'nav',
      noscript: 'noscript',
      object: 'object',
      ol: 'ol',
      optgroup: 'optgroup',
      option: 'option',
      output: 'output',
      p: 'p',
      param: 'param',
      picture: 'picture',
      pre: 'pre',
      progress: 'progress',
      q: 'q',
      rp: 'rp',
      rt: 'rt',
      ruby: 'ruby',
      s: 's',
      samp: 'samp',
      script: 'script',
      section: 'section',
      select: 'select',
      small: 'small',
      source: 'source',
      span: 'span',
      strong: 'strong',
      style: 'style',
      sub: 'sub',
      summary: 'summary',
      sup: 'sup',
      table: 'table',
      tbody: 'tbody',
      td: 'td',
      textarea: 'textarea',
      tfoot: 'tfoot',
      th: 'th',
      thead: 'thead',
      time: 'time',
      title: 'title',
      tr: 'tr',
      track: 'track',
      u: 'u',
      ul: 'ul',
      'var': 'var',
      video: 'video',
      wbr: 'wbr',
      circle: 'circle',
      clipPath: 'clipPath',
      defs: 'defs',
      ellipse: 'ellipse',
      g: 'g',
      line: 'line',
      linearGradient: 'linearGradient',
      mask: 'mask',
      path: 'path',
      pattern: 'pattern',
      polygon: 'polygon',
      polyline: 'polyline',
      radialGradient: 'radialGradient',
      rect: 'rect',
      stop: 'stop',
      svg: 'svg',
      text: 'text',
      tspan: 'tspan'
    }, createDOMFactory);
    module.exports = ReactDOM;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2c", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("6");
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_ATTRIBUTE: 0x1,
      MUST_USE_PROPERTY: 0x2,
      HAS_SIDE_EFFECTS: 0x4,
      HAS_BOOLEAN_VALUE: 0x8,
      HAS_NUMERIC_VALUE: 0x10,
      HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
      injectDOMPropertyConfig: function(domPropertyConfig) {
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
        }
        for (var propName in Properties) {
          ("production" !== process.env.NODE_ENV ? invariant(!DOMProperty.isStandardName.hasOwnProperty(propName), 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));
          DOMProperty.isStandardName[propName] = true;
          var lowerCased = propName.toLowerCase();
          DOMProperty.getPossibleStandardName[lowerCased] = propName;
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            DOMProperty.getPossibleStandardName[attributeName] = propName;
            DOMProperty.getAttributeName[propName] = attributeName;
          } else {
            DOMProperty.getAttributeName[propName] = lowerCased;
          }
          DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName;
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
          } else {
            DOMProperty.getMutationMethod[propName] = null;
          }
          var propConfig = Properties[propName];
          DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
          DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
          DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
          DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
          DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
          DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
          DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);
          ("production" !== process.env.NODE_ENV ? invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName], 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]));
          ("production" !== process.env.NODE_ENV ? invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName], 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]));
          ("production" !== process.env.NODE_ENV ? invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));
        }
      }
    };
    var defaultValueCache = {};
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: 'data-reactid',
      isStandardName: {},
      getPossibleStandardName: {},
      getAttributeName: {},
      getPropertyName: {},
      getMutationMethod: {},
      mustUseAttribute: {},
      mustUseProperty: {},
      hasSideEffects: {},
      hasBooleanValue: {},
      hasNumericValue: {},
      hasPositiveNumericValue: {},
      hasOverloadedBooleanValue: {},
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function(attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      getDefaultValueForProperty: function(nodeName, prop) {
        var nodeDefaults = defaultValueCache[nodeName];
        var testElement;
        if (!nodeDefaults) {
          defaultValueCache[nodeName] = nodeDefaults = {};
        }
        if (!(prop in nodeDefaults)) {
          testElement = document.createElement(nodeName);
          nodeDefaults[prop] = testElement[prop];
        }
        return nodeDefaults[prop];
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2d", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ESCAPE_LOOKUP = {
    '&': '&amp;',
    '>': '&gt;',
    '<': '&lt;',
    '"': '&quot;',
    '\'': '&#x27;'
  };
  var ESCAPE_REGEX = /[&><"']/g;
  function escaper(match) {
    return ESCAPE_LOOKUP[match];
  }
  function escapeTextContentForBrowser(text) {
    return ('' + text).replace(ESCAPE_REGEX, escaper);
  }
  module.exports = escapeTextContentForBrowser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2e", ["2d"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var escapeTextContentForBrowser = require("2d");
  function quoteAttributeValueForBrowser(value) {
    return '"' + escapeTextContentForBrowser(value) + '"';
  }
  module.exports = quoteAttributeValueForBrowser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2f", ["2c", "2e", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMProperty = require("2c");
    var quoteAttributeValueForBrowser = require("2e");
    var warning = require("e");
    function shouldIgnoreValue(name, value) {
      return value == null || (DOMProperty.hasBooleanValue[name] && !value) || (DOMProperty.hasNumericValue[name] && isNaN(value)) || (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) || (DOMProperty.hasOverloadedBooleanValue[name] && value === false);
    }
    if ("production" !== process.env.NODE_ENV) {
      var reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true
      };
      var warnedProperties = {};
      var warnUnknownProperty = function(name) {
        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
          return;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = (DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null);
        ("production" !== process.env.NODE_ENV ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : null);
      };
    }
    var DOMPropertyOperations = {
      createMarkupForID: function(id) {
        return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
      },
      createMarkupForProperty: function(name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          if (shouldIgnoreValue(name, value)) {
            return '';
          }
          var attributeName = DOMProperty.getAttributeName[name];
          if (DOMProperty.hasBooleanValue[name] || (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {
            return attributeName;
          }
          return attributeName + '=' + quoteAttributeValueForBrowser(value);
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return '';
          }
          return name + '=' + quoteAttributeValueForBrowser(value);
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
        return null;
      },
      setValueForProperty: function(node, name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(name, value)) {
            this.deleteValueForProperty(node, name);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.setAttribute(DOMProperty.getAttributeName[name], '' + value);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            if (!DOMProperty.hasSideEffects[name] || ('' + node[propName]) !== ('' + value)) {
              node[propName] = value;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            node.removeAttribute(name);
          } else {
            node.setAttribute(name, '' + value);
          }
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
      },
      deleteValueForProperty: function(node, name) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.removeAttribute(DOMProperty.getAttributeName[name]);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
            if (!DOMProperty.hasSideEffects[name] || ('' + node[propName]) !== defaultValue) {
              node[propName] = defaultValue;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
      }
    };
    module.exports = DOMPropertyOperations;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("30", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var isUnitlessNumber = {
    boxFlex: true,
    boxFlexGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    strokeDashoffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundImage: true,
      backgroundPosition: true,
      backgroundRepeat: true,
      backgroundColor: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };
  module.exports = CSSProperty;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("31", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var canUseDOM = !!((typeof window !== 'undefined' && window.document && window.document.createElement));
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("32", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _hyphenPattern = /-(.)/g;
  function camelize(string) {
    return string.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module.exports = camelize;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("33", ["32"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var camelize = require("32");
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("34", ["30"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var CSSProperty = require("30");
  var isUnitlessNumber = CSSProperty.isUnitlessNumber;
  function dangerousStyleValue(name, value) {
    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return '' + value;
    }
    if (typeof value === 'string') {
      value = value.trim();
    }
    return value + 'px';
  }
  module.exports = dangerousStyleValue;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("35", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }
  module.exports = hyphenate;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("36", ["35"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var hyphenate = require("35");
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("37", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function memoizeStringOnly(callback) {
    var cache = {};
    return function(string) {
      if (!cache.hasOwnProperty(string)) {
        cache[string] = callback.call(this, string);
      }
      return cache[string];
    };
  }
  module.exports = memoizeStringOnly;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("38", ["30", "31", "33", "34", "36", "37", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CSSProperty = require("30");
    var ExecutionEnvironment = require("31");
    var camelizeStyleName = require("33");
    var dangerousStyleValue = require("34");
    var hyphenateStyleName = require("36");
    var memoizeStringOnly = require("37");
    var warning = require("e");
    var processStyleName = memoizeStringOnly(function(styleName) {
      return hyphenateStyleName(styleName);
    });
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = 'styleFloat';
      }
    }
    if ("production" !== process.env.NODE_ENV) {
      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
      var badStyleValueWithSemicolonPattern = /;\s*$/;
      var warnedStyleNames = {};
      var warnedStyleValues = {};
      var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        ("production" !== process.env.NODE_ENV ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : null);
      };
      var warnBadVendoredStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        ("production" !== process.env.NODE_ENV ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : null);
      };
      var warnStyleValueWithSemicolon = function(name, value) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
          return;
        }
        warnedStyleValues[value] = true;
        ("production" !== process.env.NODE_ENV ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : null);
      };
      var warnValidStyle = function(name, value) {
        if (name.indexOf('-') > -1) {
          warnHyphenatedStyleName(name);
        } else if (badVendoredStyleNamePattern.test(name)) {
          warnBadVendoredStyleName(name);
        } else if (badStyleValueWithSemicolonPattern.test(value)) {
          warnStyleValueWithSemicolon(name, value);
        }
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function(styles) {
        var serialized = '';
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var styleValue = styles[styleName];
          if ("production" !== process.env.NODE_ENV) {
            warnValidStyle(styleName, styleValue);
          }
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ':';
            serialized += dangerousStyleValue(styleName, styleValue) + ';';
          }
        }
        return serialized || null;
      },
      setValueForStyles: function(node, styles) {
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if ("production" !== process.env.NODE_ENV) {
            warnValidStyle(styleName, styles[styleName]);
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName]);
          if (styleName === 'float') {
            styleName = styleFloatAccessor;
          }
          if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = '';
              }
            } else {
              style[styleName] = '';
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("39", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var invariant = require("6");
    function toArray(obj) {
      var length = obj.length;
      ("production" !== process.env.NODE_ENV ? invariant(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function'), 'toArray: Array-like object expected') : invariant(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')));
      ("production" !== process.env.NODE_ENV ? invariant(typeof length === 'number', 'toArray: Object needs a length property') : invariant(typeof length === 'number'));
      ("production" !== process.env.NODE_ENV ? invariant(length === 0 || (length - 1) in obj, 'toArray: Object should have keys for indices') : invariant(length === 0 || (length - 1) in obj));
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    module.exports = toArray;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3a", ["39"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toArray = require("39");
  function hasArrayNature(obj) {
    return (!!obj && (typeof obj == 'object' || typeof obj == 'function') && ('length' in obj) && !('setInterval' in obj) && (typeof obj.nodeType != 'number') && (((Array.isArray(obj) || ('callee' in obj) || 'item' in obj))));
  }
  function createArrayFromMixed(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }
  module.exports = createArrayFromMixed;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3b", ["31", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ExecutionEnvironment = require("31");
    var invariant = require("6");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {
      'circle': true,
      'clipPath': true,
      'defs': true,
      'ellipse': true,
      'g': true,
      'line': true,
      'linearGradient': true,
      'path': true,
      'polygon': true,
      'polyline': true,
      'radialGradient': true,
      'rect': true,
      'stop': true,
      'text': true
    };
    var selectWrap = [1, '<select multiple="true">', '</select>'];
    var tableWrap = [1, '<table>', '</table>'];
    var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    var svgWrap = [1, '<svg>', '</svg>'];
    var markupWrap = {
      '*': [1, '?<div>', '</div>'],
      'area': [1, '<map>', '</map>'],
      'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      'legend': [1, '<fieldset>', '</fieldset>'],
      'param': [1, '<object>', '</object>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'optgroup': selectWrap,
      'option': selectWrap,
      'caption': tableWrap,
      'colgroup': tableWrap,
      'tbody': tableWrap,
      'tfoot': tableWrap,
      'thead': tableWrap,
      'td': trWrap,
      'th': trWrap,
      'circle': svgWrap,
      'clipPath': svgWrap,
      'defs': svgWrap,
      'ellipse': svgWrap,
      'g': svgWrap,
      'line': svgWrap,
      'linearGradient': svgWrap,
      'path': svgWrap,
      'polygon': svgWrap,
      'polyline': svgWrap,
      'radialGradient': svgWrap,
      'rect': svgWrap,
      'stop': svgWrap,
      'text': svgWrap
    };
    function getMarkupWrap(nodeName) {
      ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = '*';
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === '*') {
          dummyNode.innerHTML = '<link />';
        } else {
          dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3c", ["31", "3a", "3b", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ExecutionEnvironment = require("31");
    var createArrayFromMixed = require("3a");
    var getMarkupWrap = require("3b");
    var invariant = require("6");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName('script');
      if (scripts.length) {
        ("production" !== process.env.NODE_ENV ? invariant(handleScript, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(handleScript));
        createArrayFromMixed(scripts).forEach(handleScript);
      }
      var nodes = createArrayFromMixed(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3d", ["31", "3c", "d", "3b", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = require("31");
    var createNodesFromMarkup = require("3c");
    var emptyFunction = require("d");
    var getMarkupWrap = require("3b");
    var invariant = require("6");
    var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
    var RESULT_INDEX_ATTR = 'data-danger-index';
    function getNodeName(markup) {
      return markup.substring(1, markup.indexOf(' '));
    }
    var Danger = {
      dangerouslyRenderMarkup: function(markupList) {
        ("production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(ExecutionEnvironment.canUseDOM));
        var nodeName;
        var markupByNodeName = {};
        for (var i = 0; i < markupList.length; i++) {
          ("production" !== process.env.NODE_ENV ? invariant(markupList[i], 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(markupList[i]));
          nodeName = getNodeName(markupList[i]);
          nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
          markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
          markupByNodeName[nodeName][i] = markupList[i];
        }
        var resultList = [];
        var resultListAssignmentCount = 0;
        for (nodeName in markupByNodeName) {
          if (!markupByNodeName.hasOwnProperty(nodeName)) {
            continue;
          }
          var markupListByNodeName = markupByNodeName[nodeName];
          var resultIndex;
          for (resultIndex in markupListByNodeName) {
            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
              var markup = markupListByNodeName[resultIndex];
              markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
            }
          }
          var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction);
          for (var j = 0; j < renderNodes.length; ++j) {
            var renderNode = renderNodes[j];
            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
              resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
              renderNode.removeAttribute(RESULT_INDEX_ATTR);
              ("production" !== process.env.NODE_ENV ? invariant(!resultList.hasOwnProperty(resultIndex), 'Danger: Assigning to an already-occupied result index.') : invariant(!resultList.hasOwnProperty(resultIndex)));
              resultList[resultIndex] = renderNode;
              resultListAssignmentCount += 1;
            } else if ("production" !== process.env.NODE_ENV) {
              console.error('Danger: Discarding unexpected node:', renderNode);
            }
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(resultListAssignmentCount === resultList.length, 'Danger: Did not assign to every index of resultList.') : invariant(resultListAssignmentCount === resultList.length));
        ("production" !== process.env.NODE_ENV ? invariant(resultList.length === markupList.length, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(resultList.length === markupList.length));
        return resultList;
      },
      dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
        ("production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(ExecutionEnvironment.canUseDOM));
        ("production" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));
        ("production" !== process.env.NODE_ENV ? invariant(oldChild.tagName.toLowerCase() !== 'html', 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See React.renderToString().') : invariant(oldChild.tagName.toLowerCase() !== 'html'));
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild);
      }
    };
    module.exports = Danger;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3e", ["7"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keyMirror = require("7");
  var ReactMultiChildUpdateTypes = keyMirror({
    INSERT_MARKUP: null,
    MOVE_EXISTING: null,
    REMOVE_NODE: null,
    TEXT_CONTENT: null
  });
  module.exports = ReactMultiChildUpdateTypes;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3f", ["31", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = require("31");
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var setInnerHTML = function(node, html) {
      node.innerHTML = html;
    };
    if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
      setInnerHTML = function(node, html) {
        MSApp.execUnsafeLocalFunction(function() {
          node.innerHTML = html;
        });
      };
    }
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement('div');
      testElement.innerHTML = ' ';
      if (testElement.innerHTML === '') {
        setInnerHTML = function(node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = '\uFEFF' + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
    }
    module.exports = setInnerHTML;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("40", ["31", "2d", "3f"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("31");
  var escapeTextContentForBrowser = require("2d");
  var setInnerHTML = require("3f");
  var setTextContent = function(node, text) {
    node.textContent = text;
  };
  if (ExecutionEnvironment.canUseDOM) {
    if (!('textContent' in document.documentElement)) {
      setTextContent = function(node, text) {
        setInnerHTML(node, escapeTextContentForBrowser(text));
      };
    }
  }
  module.exports = setTextContent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("41", ["3d", "3e", "40", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var Danger = require("3d");
    var ReactMultiChildUpdateTypes = require("3e");
    var setTextContent = require("40");
    var invariant = require("6");
    function insertChildAt(parentNode, childNode, index) {
      parentNode.insertBefore(childNode, parentNode.childNodes[index] || null);
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
      updateTextContent: setTextContent,
      processUpdates: function(updates, markupList) {
        var update;
        var initialChildren = null;
        var updatedChildren = null;
        for (var i = 0; i < updates.length; i++) {
          update = updates[i];
          if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
            var updatedIndex = update.fromIndex;
            var updatedChild = update.parentNode.childNodes[updatedIndex];
            var parentID = update.parentID;
            ("production" !== process.env.NODE_ENV ? invariant(updatedChild, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(updatedChild));
            initialChildren = initialChildren || {};
            initialChildren[parentID] = initialChildren[parentID] || [];
            initialChildren[parentID][updatedIndex] = updatedChild;
            updatedChildren = updatedChildren || [];
            updatedChildren.push(updatedChild);
          }
        }
        var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
        if (updatedChildren) {
          for (var j = 0; j < updatedChildren.length; j++) {
            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
          }
        }
        for (var k = 0; k < updates.length; k++) {
          update = updates[k];
          switch (update.type) {
            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
              insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
              insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
              setTextContent(update.parentNode, update.textContent);
              break;
            case ReactMultiChildUpdateTypes.REMOVE_NODE:
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("42", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("6");
    var EventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!EventPluginOrder) {
        return;
      }
      for (var pluginName in namesToPlugins) {
        var PluginModule = namesToPlugins[pluginName];
        var pluginIndex = EventPluginOrder.indexOf(pluginName);
        ("production" !== process.env.NODE_ENV ? invariant(pluginIndex > -1, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(pluginIndex > -1));
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        ("production" !== process.env.NODE_ENV ? invariant(PluginModule.extractEvents, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(PluginModule.extractEvents));
        EventPluginRegistry.plugins[pluginIndex] = PluginModule;
        var publishedEvents = PluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          ("production" !== process.env.NODE_ENV ? invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName), 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName)));
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
      ("production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName), 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, PluginModule, eventName) {
      ("production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.registrationNameModules[registrationName], 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
      EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      injectEventPluginOrder: function(InjectedEventPluginOrder) {
        ("production" !== process.env.NODE_ENV ? invariant(!EventPluginOrder, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(!EventPluginOrder));
        EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function(injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var PluginModule = injectedNamesToPlugins[pluginName];
          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
            ("production" !== process.env.NODE_ENV ? invariant(!namesToPlugins[pluginName], 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(!namesToPlugins[pluginName]));
            namesToPlugins[pluginName] = PluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function(event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        for (var phase in dispatchConfig.phasedRegistrationNames) {
          if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
          if (PluginModule) {
            return PluginModule;
          }
        }
        return null;
      },
      _resetEventPlugins: function() {
        EventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("43", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("6");
    function accumulateInto(current, next) {
      ("production" !== process.env.NODE_ENV ? invariant(next != null, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(next != null));
      if (current == null) {
        return next;
      }
      var currentIsArray = Array.isArray(current);
      var nextIsArray = Array.isArray(next);
      if (currentIsArray && nextIsArray) {
        current.push.apply(current, next);
        return current;
      }
      if (currentIsArray) {
        current.push(next);
        return current;
      }
      if (nextIsArray) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("44", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var forEachAccumulated = function(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  };
  module.exports = forEachAccumulated;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("45", ["42", "9", "43", "44", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventPluginRegistry = require("42");
    var EventPluginUtils = require("9");
    var accumulateInto = require("43");
    var forEachAccumulated = require("44");
    var invariant = require("6");
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function(event) {
      if (event) {
        var executeDispatch = EventPluginUtils.executeDispatch;
        var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
        if (PluginModule && PluginModule.executeDispatch) {
          executeDispatch = PluginModule.executeDispatch;
        }
        EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var InstanceHandle = null;
    function validateInstanceHandle() {
      var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
      ("production" !== process.env.NODE_ENV ? invariant(valid, 'InstanceHandle not injected before use!') : invariant(valid));
    }
    var EventPluginHub = {
      injection: {
        injectMount: EventPluginUtils.injection.injectMount,
        injectInstanceHandle: function(InjectedInstanceHandle) {
          InstanceHandle = InjectedInstanceHandle;
          if ("production" !== process.env.NODE_ENV) {
            validateInstanceHandle();
          }
        },
        getInstanceHandle: function() {
          if ("production" !== process.env.NODE_ENV) {
            validateInstanceHandle();
          }
          return InstanceHandle;
        },
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
      registrationNameModules: EventPluginRegistry.registrationNameModules,
      putListener: function(id, registrationName, listener) {
        ("production" !== process.env.NODE_ENV ? invariant(!listener || typeof listener === 'function', 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(!listener || typeof listener === 'function'));
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[id] = listener;
      },
      getListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        return bankForRegistrationName && bankForRegistrationName[id];
      },
      deleteListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          delete bankForRegistrationName[id];
        }
      },
      deleteAllListeners: function(id) {
        for (var registrationName in listenerBank) {
          delete listenerBank[registrationName][id];
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0,
            l = plugins.length; i < l; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function(events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function() {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
        ("production" !== process.env.NODE_ENV ? invariant(!eventQueue, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(!eventQueue));
      },
      __purge: function() {
        listenerBank = {};
      },
      __getListenerBank: function() {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("46", ["45"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventPluginHub = require("45");
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue();
  }
  var ReactEventEmitterMixin = {handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
      runEventQueueInBatch(events);
    }};
  module.exports = ReactEventEmitterMixin;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("47", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ViewportMetrics = {
    currentScrollLeft: 0,
    currentScrollTop: 0,
    refreshScrollValues: function(scrollPosition) {
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }
  };
  module.exports = ViewportMetrics;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("48", ["31"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("31");
  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }
    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;
    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }
    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }
    return isSupported;
  }
  module.exports = isEventSupported;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("49", ["8", "45", "42", "46", "47", "b", "48", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("8");
    var EventPluginHub = require("45");
    var EventPluginRegistry = require("42");
    var ReactEventEmitterMixin = require("46");
    var ViewportMetrics = require("47");
    var assign = require("b");
    var isEventSupported = require("48");
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topBlur: 'blur',
      topChange: 'change',
      topClick: 'click',
      topCompositionEnd: 'compositionend',
      topCompositionStart: 'compositionstart',
      topCompositionUpdate: 'compositionupdate',
      topContextMenu: 'contextmenu',
      topCopy: 'copy',
      topCut: 'cut',
      topDoubleClick: 'dblclick',
      topDrag: 'drag',
      topDragEnd: 'dragend',
      topDragEnter: 'dragenter',
      topDragExit: 'dragexit',
      topDragLeave: 'dragleave',
      topDragOver: 'dragover',
      topDragStart: 'dragstart',
      topDrop: 'drop',
      topFocus: 'focus',
      topInput: 'input',
      topKeyDown: 'keydown',
      topKeyPress: 'keypress',
      topKeyUp: 'keyup',
      topMouseDown: 'mousedown',
      topMouseMove: 'mousemove',
      topMouseOut: 'mouseout',
      topMouseOver: 'mouseover',
      topMouseUp: 'mouseup',
      topPaste: 'paste',
      topScroll: 'scroll',
      topSelectionChange: 'selectionchange',
      topTextInput: 'textInput',
      topTouchCancel: 'touchcancel',
      topTouchEnd: 'touchend',
      topTouchMove: 'touchmove',
      topTouchStart: 'touchstart',
      topWheel: 'wheel'
    };
    var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: {injectReactEventListener: function(ReactEventListener) {
          ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        }},
      setEnabled: function(enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function() {
        return !!((ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled()));
      },
      listenTo: function(registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        var topLevelTypes = EventConstants.topLevelTypes;
        for (var i = 0,
            l = dependencies.length; i < l; i++) {
          var dependency = dependencies[i];
          if (!((isListening.hasOwnProperty(dependency) && isListening[dependency]))) {
            if (dependency === topLevelTypes.topWheel) {
              if (isEventSupported('wheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
              } else if (isEventSupported('mousewheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
              }
            } else if (dependency === topLevelTypes.topScroll) {
              if (isEventSupported('scroll', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
              }
            } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
              if (isEventSupported('focus', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
              } else if (isEventSupported('focusin')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
              }
              isListening[topLevelTypes.topBlur] = true;
              isListening[topLevelTypes.topFocus] = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
      },
      ensureScrollValueMonitoring: function() {
        if (!isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
          isMonitoringScrollValue = true;
        }
      },
      eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
      registrationNameModules: EventPluginHub.registrationNameModules,
      putListener: EventPluginHub.putListener,
      getListener: EventPluginHub.getListener,
      deleteListener: EventPluginHub.deleteListener,
      deleteAllListeners: EventPluginHub.deleteAllListeners
    });
    module.exports = ReactBrowserEventEmitter;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4a", ["11", "19", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("11");
    var ReactInstanceMap = require("19");
    var invariant = require("6");
    var component;
    var nullComponentIDsRegistry = {};
    var ReactEmptyComponentInjection = {injectEmptyComponent: function(emptyComponent) {
        component = ReactElement.createFactory(emptyComponent);
      }};
    var ReactEmptyComponentType = function() {};
    ReactEmptyComponentType.prototype.componentDidMount = function() {
      var internalInstance = ReactInstanceMap.get(this);
      if (!internalInstance) {
        return;
      }
      registerNullComponentID(internalInstance._rootNodeID);
    };
    ReactEmptyComponentType.prototype.componentWillUnmount = function() {
      var internalInstance = ReactInstanceMap.get(this);
      if (!internalInstance) {
        return;
      }
      deregisterNullComponentID(internalInstance._rootNodeID);
    };
    ReactEmptyComponentType.prototype.render = function() {
      ("production" !== process.env.NODE_ENV ? invariant(component, 'Trying to return null from a render, but no null placeholder component ' + 'was injected.') : invariant(component));
      return component();
    };
    var emptyElement = ReactElement.createElement(ReactEmptyComponentType);
    function registerNullComponentID(id) {
      nullComponentIDsRegistry[id] = true;
    }
    function deregisterNullComponentID(id) {
      delete nullComponentIDsRegistry[id];
    }
    function isNullComponentID(id) {
      return !!nullComponentIDsRegistry[id];
    }
    var ReactEmptyComponent = {
      emptyElement: emptyElement,
      injection: ReactEmptyComponentInjection,
      isNullComponentID: isNullComponentID
    };
    module.exports = ReactEmptyComponent;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4b", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var MOD = 65521;
  function adler32(data) {
    var a = 1;
    var b = 0;
    for (var i = 0; i < data.length; i++) {
      a = (a + data.charCodeAt(i)) % MOD;
      b = (b + a) % MOD;
    }
    return a | (b << 16);
  }
  module.exports = adler32;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4c", ["4b"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var adler32 = require("4b");
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function(markup) {
      var checksum = adler32(markup);
      return markup.replace('>', ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">');
    },
    canReuseMarkup: function(markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4d", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function isNode(object) {
    return !!(object && (((typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'))));
  }
  module.exports = isNode;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4e", ["4d"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isNode = require("4d");
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4f", ["4e"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isTextNode = require("4e");
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
  module.exports = containsNode;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("50", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOC_NODE_TYPE = 9;
  function getReactRootElementInContainer(container) {
    if (!container) {
      return null;
    }
    if (container.nodeType === DOC_NODE_TYPE) {
      return container.documentElement;
    } else {
      return container.firstChild;
    }
  }
  module.exports = getReactRootElementInContainer;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("51", ["6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("6");
    var injected = false;
    var ReactComponentEnvironment = {
      unmountIDFromEnvironment: null,
      replaceNodeWithMarkupByID: null,
      processChildrenUpdates: null,
      injection: {injectEnvironment: function(environment) {
          ("production" !== process.env.NODE_ENV ? invariant(!injected, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(!injected));
          ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
          ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
          ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
          injected = true;
        }}
    };
    module.exports = ReactComponentEnvironment;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("52", ["e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var warning = require("e");
    function shouldUpdateReactComponent(prevElement, nextElement) {
      if (prevElement != null && nextElement != null) {
        var prevType = typeof prevElement;
        var nextType = typeof nextElement;
        if (prevType === 'string' || prevType === 'number') {
          return (nextType === 'string' || nextType === 'number');
        } else {
          if (nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key) {
            var ownersMatch = prevElement._owner === nextElement._owner;
            var prevName = null;
            var nextName = null;
            var nextDisplayName = null;
            if ("production" !== process.env.NODE_ENV) {
              if (!ownersMatch) {
                if (prevElement._owner != null && prevElement._owner.getPublicInstance() != null && prevElement._owner.getPublicInstance().constructor != null) {
                  prevName = prevElement._owner.getPublicInstance().constructor.displayName;
                }
                if (nextElement._owner != null && nextElement._owner.getPublicInstance() != null && nextElement._owner.getPublicInstance().constructor != null) {
                  nextName = nextElement._owner.getPublicInstance().constructor.displayName;
                }
                if (nextElement.type != null && nextElement.type.displayName != null) {
                  nextDisplayName = nextElement.type.displayName;
                }
                if (nextElement.type != null && typeof nextElement.type === 'string') {
                  nextDisplayName = nextElement.type;
                }
                if (typeof nextElement.type !== 'string' || nextElement.type === 'input' || nextElement.type === 'textarea') {
                  if ((prevElement._owner != null && prevElement._owner._isOwnerNecessary === false) || (nextElement._owner != null && nextElement._owner._isOwnerNecessary === false)) {
                    if (prevElement._owner != null) {
                      prevElement._owner._isOwnerNecessary = true;
                    }
                    if (nextElement._owner != null) {
                      nextElement._owner._isOwnerNecessary = true;
                    }
                    ("production" !== process.env.NODE_ENV ? warning(false, '<%s /> is being rendered by both %s and %s using the same ' + 'key (%s) in the same place. Currently, this means that ' + 'they don\'t preserve state. This behavior should be very ' + 'rare so we\'re considering deprecating it. Please contact ' + 'the React team and explain your use case so that we can ' + 'take that into consideration.', nextDisplayName || 'Unknown Component', prevName || '[Unknown]', nextName || '[Unknown]', prevElement.key) : null);
                  }
                }
              }
            }
            return ownersMatch;
          }
        }
      }
      return false;
    }
    module.exports = shouldUpdateReactComponent;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("53", ["51", "f", "10", "11", "21", "19", "18", "20", "1b", "1e", "1f", "22", "24", "b", "c", "6", "52", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponentEnvironment = require("51");
    var ReactContext = require("f");
    var ReactCurrentOwner = require("10");
    var ReactElement = require("11");
    var ReactElementValidator = require("21");
    var ReactInstanceMap = require("19");
    var ReactLifeCycle = require("18");
    var ReactNativeComponent = require("20");
    var ReactPerf = require("1b");
    var ReactPropTypeLocations = require("1e");
    var ReactPropTypeLocationNames = require("1f");
    var ReactReconciler = require("22");
    var ReactUpdates = require("24");
    var assign = require("b");
    var emptyObject = require("c");
    var invariant = require("6");
    var shouldUpdateReactComponent = require("52");
    var warning = require("e");
    function getDeclarationErrorAddendum(component) {
      var owner = component._currentElement._owner || null;
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var nextMountID = 1;
    var ReactCompositeComponentMixin = {
      construct: function(element) {
        this._currentElement = element;
        this._rootNodeID = null;
        this._instance = null;
        this._pendingElement = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._renderedComponent = null;
        this._context = null;
        this._mountOrder = 0;
        this._isTopLevel = false;
        this._pendingCallbacks = null;
      },
      mountComponent: function(rootID, transaction, context) {
        this._context = context;
        this._mountOrder = nextMountID++;
        this._rootNodeID = rootID;
        var publicProps = this._processProps(this._currentElement.props);
        var publicContext = this._processContext(this._currentElement._context);
        var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
        var inst = new Component(publicProps, publicContext);
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(inst.render != null, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render` in your ' + 'component or you may have accidentally tried to render an element ' + 'whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : null);
        }
        inst.props = publicProps;
        inst.context = publicContext;
        inst.refs = emptyObject;
        this._instance = inst;
        ReactInstanceMap.set(inst, this);
        if ("production" !== process.env.NODE_ENV) {
          this._warnIfContextsDiffer(this._currentElement._context, context);
        }
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : null);
          ("production" !== process.env.NODE_ENV ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : null);
          ("production" !== process.env.NODE_ENV ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : null);
          ("production" !== process.env.NODE_ENV ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : null);
          ("production" !== process.env.NODE_ENV ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', (this.getName() || 'A component')) : null);
        }
        var initialState = inst.state;
        if (initialState === undefined) {
          inst.state = initialState = null;
        }
        ("production" !== process.env.NODE_ENV ? invariant(typeof initialState === 'object' && !Array.isArray(initialState), '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(typeof initialState === 'object' && !Array.isArray(initialState)));
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        var childContext;
        var renderedElement;
        var previouslyMounting = ReactLifeCycle.currentlyMountingInstance;
        ReactLifeCycle.currentlyMountingInstance = this;
        try {
          if (inst.componentWillMount) {
            inst.componentWillMount();
            if (this._pendingStateQueue) {
              inst.state = this._processPendingState(inst.props, inst.context);
            }
          }
          childContext = this._getValidatedChildContext(context);
          renderedElement = this._renderValidatedComponent(childContext);
        } finally {
          ReactLifeCycle.currentlyMountingInstance = previouslyMounting;
        }
        this._renderedComponent = this._instantiateReactComponent(renderedElement, this._currentElement.type);
        var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._mergeChildContext(context, childContext));
        if (inst.componentDidMount) {
          transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
        }
        return markup;
      },
      unmountComponent: function() {
        var inst = this._instance;
        if (inst.componentWillUnmount) {
          var previouslyUnmounting = ReactLifeCycle.currentlyUnmountingInstance;
          ReactLifeCycle.currentlyUnmountingInstance = this;
          try {
            inst.componentWillUnmount();
          } finally {
            ReactLifeCycle.currentlyUnmountingInstance = previouslyUnmounting;
          }
        }
        ReactReconciler.unmountComponent(this._renderedComponent);
        this._renderedComponent = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._pendingCallbacks = null;
        this._pendingElement = null;
        this._context = null;
        this._rootNodeID = null;
        ReactInstanceMap.remove(inst);
      },
      _setPropsInternal: function(partialProps, callback) {
        var element = this._pendingElement || this._currentElement;
        this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));
        ReactUpdates.enqueueUpdate(this, callback);
      },
      _maskContext: function(context) {
        var maskedContext = null;
        if (typeof this._currentElement.type === 'string') {
          return emptyObject;
        }
        var contextTypes = this._currentElement.type.contextTypes;
        if (!contextTypes) {
          return emptyObject;
        }
        maskedContext = {};
        for (var contextName in contextTypes) {
          maskedContext[contextName] = context[contextName];
        }
        return maskedContext;
      },
      _processContext: function(context) {
        var maskedContext = this._maskContext(context);
        if ("production" !== process.env.NODE_ENV) {
          var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
          if (Component.contextTypes) {
            this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
          }
        }
        return maskedContext;
      },
      _getValidatedChildContext: function(currentContext) {
        var inst = this._instance;
        var childContext = inst.getChildContext && inst.getChildContext();
        if (childContext) {
          ("production" !== process.env.NODE_ENV ? invariant(typeof inst.constructor.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(typeof inst.constructor.childContextTypes === 'object'));
          if ("production" !== process.env.NODE_ENV) {
            this._checkPropTypes(inst.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);
          }
          for (var name in childContext) {
            ("production" !== process.env.NODE_ENV ? invariant(name in inst.constructor.childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(name in inst.constructor.childContextTypes));
          }
          return childContext;
        }
        return null;
      },
      _mergeChildContext: function(currentContext, childContext) {
        if (childContext) {
          return assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _processProps: function(newProps) {
        if ("production" !== process.env.NODE_ENV) {
          var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
          if (Component.propTypes) {
            this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
          }
        }
        return newProps;
      },
      _checkPropTypes: function(propTypes, props, location) {
        var componentName = this.getName();
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error;
            try {
              ("production" !== process.env.NODE_ENV ? invariant(typeof propTypes[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(typeof propTypes[propName] === 'function'));
              error = propTypes[propName](props, propName, componentName, location);
            } catch (ex) {
              error = ex;
            }
            if (error instanceof Error) {
              var addendum = getDeclarationErrorAddendum(this);
              if (location === ReactPropTypeLocations.prop) {
                ("production" !== process.env.NODE_ENV ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : null);
              } else {
                ("production" !== process.env.NODE_ENV ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : null);
              }
            }
          }
        }
      },
      receiveComponent: function(nextElement, transaction, nextContext) {
        var prevElement = this._currentElement;
        var prevContext = this._context;
        this._pendingElement = null;
        this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
      },
      performUpdateIfNecessary: function(transaction) {
        if (this._pendingElement != null) {
          ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
        }
        if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
          if ("production" !== process.env.NODE_ENV) {
            ReactElementValidator.checkAndWarnForMutatedProps(this._currentElement);
          }
          this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
        }
      },
      _warnIfContextsDiffer: function(ownerBasedContext, parentBasedContext) {
        ownerBasedContext = this._maskContext(ownerBasedContext);
        parentBasedContext = this._maskContext(parentBasedContext);
        var parentKeys = Object.keys(parentBasedContext).sort();
        var displayName = this.getName() || 'ReactCompositeComponent';
        for (var i = 0; i < parentKeys.length; i++) {
          var key = parentKeys[i];
          ("production" !== process.env.NODE_ENV ? warning(ownerBasedContext[key] === parentBasedContext[key], 'owner-based and parent-based contexts differ ' + '(values: `%s` vs `%s`) for key (%s) while mounting %s ' + '(see: http://fb.me/react-context-by-parent)', ownerBasedContext[key], parentBasedContext[key], key, displayName) : null);
        }
      },
      updateComponent: function(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
        var inst = this._instance;
        var nextContext = inst.context;
        var nextProps = inst.props;
        if (prevParentElement !== nextParentElement) {
          nextContext = this._processContext(nextParentElement._context);
          nextProps = this._processProps(nextParentElement.props);
          if ("production" !== process.env.NODE_ENV) {
            if (nextUnmaskedContext != null) {
              this._warnIfContextsDiffer(nextParentElement._context, nextUnmaskedContext);
            }
          }
          if (inst.componentWillReceiveProps) {
            inst.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        var nextState = this._processPendingState(nextProps, nextContext);
        var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : null);
        }
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
        } else {
          this._currentElement = nextParentElement;
          this._context = nextUnmaskedContext;
          inst.props = nextProps;
          inst.state = nextState;
          inst.context = nextContext;
        }
      },
      _processPendingState: function(props, context) {
        var inst = this._instance;
        var queue = this._pendingStateQueue;
        var replace = this._pendingReplaceState;
        this._pendingReplaceState = false;
        this._pendingStateQueue = null;
        if (!queue) {
          return inst.state;
        }
        if (replace && queue.length === 1) {
          return queue[0];
        }
        var nextState = assign({}, replace ? queue[0] : inst.state);
        for (var i = replace ? 1 : 0; i < queue.length; i++) {
          var partial = queue[i];
          assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
        }
        return nextState;
      },
      _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
        var inst = this._instance;
        var prevProps = inst.props;
        var prevState = inst.state;
        var prevContext = inst.context;
        if (inst.componentWillUpdate) {
          inst.componentWillUpdate(nextProps, nextState, nextContext);
        }
        this._currentElement = nextElement;
        this._context = unmaskedContext;
        inst.props = nextProps;
        inst.state = nextState;
        inst.context = nextContext;
        this._updateRenderedComponent(transaction, unmaskedContext);
        if (inst.componentDidUpdate) {
          transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
        }
      },
      _updateRenderedComponent: function(transaction, context) {
        var prevComponentInstance = this._renderedComponent;
        var prevRenderedElement = prevComponentInstance._currentElement;
        var childContext = this._getValidatedChildContext();
        var nextRenderedElement = this._renderValidatedComponent(childContext);
        if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
          ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._mergeChildContext(context, childContext));
        } else {
          var thisID = this._rootNodeID;
          var prevComponentID = prevComponentInstance._rootNodeID;
          ReactReconciler.unmountComponent(prevComponentInstance);
          this._renderedComponent = this._instantiateReactComponent(nextRenderedElement, this._currentElement.type);
          var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._mergeChildContext(context, childContext));
          this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
        }
      },
      _replaceNodeWithMarkupByID: function(prevComponentID, nextMarkup) {
        ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
      },
      _renderValidatedComponentWithoutOwnerOrContext: function() {
        var inst = this._instance;
        var renderedComponent = inst.render();
        if ("production" !== process.env.NODE_ENV) {
          if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
            renderedComponent = null;
          }
        }
        return renderedComponent;
      },
      _renderValidatedComponent: function(childContext) {
        var renderedComponent;
        var previousContext = ReactContext.current;
        ReactContext.current = this._mergeChildContext(this._currentElement._context, childContext);
        ReactCurrentOwner.current = this;
        try {
          renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
        } finally {
          ReactContext.current = previousContext;
          ReactCurrentOwner.current = null;
        }
        ("production" !== process.env.NODE_ENV ? invariant(renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent), '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)));
        return renderedComponent;
      },
      attachRef: function(ref, component) {
        var inst = this.getPublicInstance();
        var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;
        refs[ref] = component.getPublicInstance();
      },
      detachRef: function(ref) {
        var refs = this.getPublicInstance().refs;
        delete refs[ref];
      },
      getName: function() {
        var type = this._currentElement.type;
        var constructor = this._instance && this._instance.constructor;
        return (type.displayName || (constructor && constructor.displayName) || type.name || (constructor && constructor.name) || null);
      },
      getPublicInstance: function() {
        return this._instance;
      },
      _instantiateReactComponent: null
    };
    ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
      mountComponent: 'mountComponent',
      updateComponent: 'updateComponent',
      _renderValidatedComponent: '_renderValidatedComponent'
    });
    var ReactCompositeComponent = {Mixin: ReactCompositeComponentMixin};
    module.exports = ReactCompositeComponent;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("54", ["53", "4a", "20", "b", "6", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCompositeComponent = require("53");
    var ReactEmptyComponent = require("4a");
    var ReactNativeComponent = require("20");
    var assign = require("b");
    var invariant = require("6");
    var warning = require("e");
    var ReactCompositeComponentWrapper = function() {};
    assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {_instantiateReactComponent: instantiateReactComponent});
    function isInternalComponentType(type) {
      return (typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function');
    }
    function instantiateReactComponent(node, parentCompositeType) {
      var instance;
      if (node === null || node === false) {
        node = ReactEmptyComponent.emptyElement;
      }
      if (typeof node === 'object') {
        var element = node;
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(element && (typeof element.type === 'function' || typeof element.type === 'string'), 'Only functions or strings can be mounted as React components.') : null);
        }
        if (parentCompositeType === element.type && typeof element.type === 'string') {
          instance = ReactNativeComponent.createInternalComponent(element);
        } else if (isInternalComponentType(element.type)) {
          instance = new element.type(element);
        } else {
          instance = new ReactCompositeComponentWrapper();
        }
      } else if (typeof node === 'string' || typeof node === 'number') {
        instance = ReactNativeComponent.createInstanceForText(node);
      } else {
        ("production" !== process.env.NODE_ENV ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false));
      }
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : null);
      }
      instance.construct(node);
      instance._mountIndex = 0;
      instance._mountImage = null;
      if ("production" !== process.env.NODE_ENV) {
        instance._isOwnerNecessary = false;
        instance._warnedAboutRefsInRender = false;
      }
      if ("production" !== process.env.NODE_ENV) {
        if (Object.preventExtensions) {
          Object.preventExtensions(instance);
        }
      }
      return instance;
    }
    module.exports = instantiateReactComponent;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("55", ["2c", "49", "10", "11", "21", "4a", "14", "19", "4c", "1b", "22", "25", "24", "c", "4f", "50", "54", "6", "3f", "52", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMProperty = require("2c");
    var ReactBrowserEventEmitter = require("49");
    var ReactCurrentOwner = require("10");
    var ReactElement = require("11");
    var ReactElementValidator = require("21");
    var ReactEmptyComponent = require("4a");
    var ReactInstanceHandles = require("14");
    var ReactInstanceMap = require("19");
    var ReactMarkupChecksum = require("4c");
    var ReactPerf = require("1b");
    var ReactReconciler = require("22");
    var ReactUpdateQueue = require("25");
    var ReactUpdates = require("24");
    var emptyObject = require("c");
    var containsNode = require("4f");
    var getReactRootElementInContainer = require("50");
    var instantiateReactComponent = require("54");
    var invariant = require("6");
    var setInnerHTML = require("3f");
    var shouldUpdateReactComponent = require("52");
    var warning = require("e");
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var nodeCache = {};
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var instancesByReactRootID = {};
    var containersByReactRootID = {};
    if ("production" !== process.env.NODE_ENV) {
      var rootElementsByReactRootID = {};
    }
    var findComponentRootReusableArray = [];
    function firstDifferenceIndex(string1, string2) {
      var minLen = Math.min(string1.length, string2.length);
      for (var i = 0; i < minLen; i++) {
        if (string1.charAt(i) !== string2.charAt(i)) {
          return i;
        }
      }
      return string1.length === string2.length ? -1 : minLen;
    }
    function getReactRootID(container) {
      var rootElement = getReactRootElementInContainer(container);
      return rootElement && ReactMount.getID(rootElement);
    }
    function getID(node) {
      var id = internalGetID(node);
      if (id) {
        if (nodeCache.hasOwnProperty(id)) {
          var cached = nodeCache[id];
          if (cached !== node) {
            ("production" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(!isValid(cached, id)));
            nodeCache[id] = node;
          }
        } else {
          nodeCache[id] = node;
        }
      }
      return id;
    }
    function internalGetID(node) {
      return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function setID(node, id) {
      var oldID = internalGetID(node);
      if (oldID !== id) {
        delete nodeCache[oldID];
      }
      node.setAttribute(ATTR_NAME, id);
      nodeCache[id] = node;
    }
    function getNode(id) {
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function getNodeFromInstance(instance) {
      var id = ReactInstanceMap.get(instance)._rootNodeID;
      if (ReactEmptyComponent.isNullComponentID(id)) {
        return null;
      }
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function isValid(node, id) {
      if (node) {
        ("production" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(internalGetID(node) === id));
        var container = ReactMount.findReactContainerForID(id);
        if (container && containsNode(container, node)) {
          return true;
        }
      }
      return false;
    }
    function purgeID(id) {
      delete nodeCache[id];
    }
    var deepestNodeSoFar = null;
    function findDeepestCachedAncestorImpl(ancestorID) {
      var ancestor = nodeCache[ancestorID];
      if (ancestor && isValid(ancestor, ancestorID)) {
        deepestNodeSoFar = ancestor;
      } else {
        return false;
      }
    }
    function findDeepestCachedAncestor(targetID) {
      deepestNodeSoFar = null;
      ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
      var foundNode = deepestNodeSoFar;
      deepestNodeSoFar = null;
      return foundNode;
    }
    function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup) {
      var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, emptyObject);
      componentInstance._isTopLevel = true;
      ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);
    }
    function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
      transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup);
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    }
    var ReactMount = {
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function(container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function(prevComponent, nextElement, container, callback) {
        if ("production" !== process.env.NODE_ENV) {
          ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
        }
        ReactMount.scrollMonitor(container, function() {
          ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
          if (callback) {
            ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
          }
        });
        if ("production" !== process.env.NODE_ENV) {
          rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
        }
        return prevComponent;
      },
      _registerComponent: function(nextComponent, container) {
        ("production" !== process.env.NODE_ENV ? invariant(container && ((container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)), '_registerComponent(...): Target container is not a DOM element.') : invariant(container && ((container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE))));
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var reactRootID = ReactMount.registerContainer(container);
        instancesByReactRootID[reactRootID] = nextComponent;
        return reactRootID;
      },
      _renderNewRootComponent: function(nextElement, container, shouldReuseMarkup) {
        ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
        var componentInstance = instantiateReactComponent(nextElement, null);
        var reactRootID = ReactMount._registerComponent(componentInstance, container);
        ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup);
        if ("production" !== process.env.NODE_ENV) {
          rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
        }
        return componentInstance;
      },
      render: function(nextElement, container, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), 'React.render(): Invalid component element.%s', (typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '')) : invariant(ReactElement.isValidElement(nextElement)));
        var prevComponent = instancesByReactRootID[getReactRootID(container)];
        if (prevComponent) {
          var prevElement = prevComponent._currentElement;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback).getPublicInstance();
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
        if ("production" !== process.env.NODE_ENV) {
          if (!containerHasReactMarkup || reactRootElement.nextSibling) {
            var rootElementSibling = reactRootElement;
            while (rootElementSibling) {
              if (ReactMount.isRenderedByReact(rootElementSibling)) {
                ("production" !== process.env.NODE_ENV ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : null);
                break;
              }
              rootElementSibling = rootElementSibling.nextSibling;
            }
          }
        }
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
        var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup).getPublicInstance();
        if (callback) {
          callback.call(component);
        }
        return component;
      },
      constructAndRenderComponent: function(constructor, props, container) {
        var element = ReactElement.createElement(constructor, props);
        return ReactMount.render(element, container);
      },
      constructAndRenderComponentByID: function(constructor, props, id) {
        var domNode = document.getElementById(id);
        ("production" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of "%s" but it is not present on the page.', id) : invariant(domNode));
        return ReactMount.constructAndRenderComponent(constructor, props, domNode);
      },
      registerContainer: function(container) {
        var reactRootID = getReactRootID(container);
        if (reactRootID) {
          reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
        }
        if (!reactRootID) {
          reactRootID = ReactInstanceHandles.createReactRootID();
        }
        containersByReactRootID[reactRootID] = container;
        return reactRootID;
      },
      unmountComponentAtNode: function(container) {
        ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function of ' + 'props and state; triggering nested component updates from render is ' + 'not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
        ("production" !== process.env.NODE_ENV ? invariant(container && ((container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)), 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(container && ((container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE))));
        var reactRootID = getReactRootID(container);
        var component = instancesByReactRootID[reactRootID];
        if (!component) {
          return false;
        }
        ReactMount.unmountComponentFromNode(component, container);
        delete instancesByReactRootID[reactRootID];
        delete containersByReactRootID[reactRootID];
        if ("production" !== process.env.NODE_ENV) {
          delete rootElementsByReactRootID[reactRootID];
        }
        return true;
      },
      unmountComponentFromNode: function(instance, container) {
        ReactReconciler.unmountComponent(instance);
        if (container.nodeType === DOC_NODE_TYPE) {
          container = container.documentElement;
        }
        while (container.lastChild) {
          container.removeChild(container.lastChild);
        }
      },
      findReactContainerForID: function(id) {
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
        var container = containersByReactRootID[reactRootID];
        if ("production" !== process.env.NODE_ENV) {
          var rootElement = rootElementsByReactRootID[reactRootID];
          if (rootElement && rootElement.parentNode !== container) {
            ("production" !== process.env.NODE_ENV ? invariant(internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : invariant(internalGetID(rootElement) === reactRootID));
            var containerChild = container.firstChild;
            if (containerChild && reactRootID === internalGetID(containerChild)) {
              rootElementsByReactRootID[reactRootID] = containerChild;
            } else {
              ("production" !== process.env.NODE_ENV ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode) : null);
            }
          }
        }
        return container;
      },
      findReactNodeByID: function(id) {
        var reactRoot = ReactMount.findReactContainerForID(id);
        return ReactMount.findComponentRoot(reactRoot, id);
      },
      isRenderedByReact: function(node) {
        if (node.nodeType !== 1) {
          return false;
        }
        var id = ReactMount.getID(node);
        return id ? id.charAt(0) === SEPARATOR : false;
      },
      getFirstReactDOM: function(node) {
        var current = node;
        while (current && current.parentNode !== current) {
          if (ReactMount.isRenderedByReact(current)) {
            return current;
          }
          current = current.parentNode;
        }
        return null;
      },
      findComponentRoot: function(ancestorNode, targetID) {
        var firstChildren = findComponentRootReusableArray;
        var childIndex = 0;
        var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
        firstChildren[0] = deepestAncestor.firstChild;
        firstChildren.length = 1;
        while (childIndex < firstChildren.length) {
          var child = firstChildren[childIndex++];
          var targetChild;
          while (child) {
            var childID = ReactMount.getID(child);
            if (childID) {
              if (targetID === childID) {
                targetChild = child;
              } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                firstChildren.length = childIndex = 0;
                firstChildren.push(child.firstChild);
              }
            } else {
              firstChildren.push(child.firstChild);
            }
            child = child.nextSibling;
          }
          if (targetChild) {
            firstChildren.length = 0;
            return targetChild;
          }
        }
        firstChildren.length = 0;
        ("production" !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false));
      },
      _mountImageIntoNode: function(markup, container, shouldReuseMarkup) {
        ("production" !== process.env.NODE_ENV ? invariant(container && ((container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)), 'mountComponentIntoNode(...): Target container is not valid.') : invariant(container && ((container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE))));
        if (shouldReuseMarkup) {
          var rootElement = getReactRootElementInContainer(container);
          if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
            return;
          } else {
            var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            var rootMarkup = rootElement.outerHTML;
            rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
            var diffIndex = firstDifferenceIndex(markup, rootMarkup);
            var difference = ' (client) ' + markup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
            ("production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(container.nodeType !== DOC_NODE_TYPE));
            if ("production" !== process.env.NODE_ENV) {
              ("production" !== process.env.NODE_ENV ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : null);
            }
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See React.renderToString() for server rendering.') : invariant(container.nodeType !== DOC_NODE_TYPE));
        setInnerHTML(container, markup);
      },
      getReactRootID: getReactRootID,
      getID: getID,
      setID: setID,
      getNode: getNode,
      getNodeFromInstance: getNodeFromInstance,
      purgeID: purgeID
    };
    ReactPerf.measureMethods(ReactMount, 'ReactMount', {
      _renderNewRootComponent: '_renderNewRootComponent',
      _mountImageIntoNode: '_mountImageIntoNode'
    });
    module.exports = ReactMount;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("56", ["38", "41", "2f", "55", "1b", "6", "3f", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CSSPropertyOperations = require("38");
    var DOMChildrenOperations = require("41");
    var DOMPropertyOperations = require("2f");
    var ReactMount = require("55");
    var ReactPerf = require("1b");
    var invariant = require("6");
    var setInnerHTML = require("3f");
    var INVALID_PROPERTY_ERRORS = {
      dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
      style: '`style` must be set using `updateStylesByID()`.'
    };
    var ReactDOMIDOperations = {
      updatePropertyByID: function(id, name, value) {
        var node = ReactMount.getNode(id);
        ("production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(node, name, value);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, name);
        }
      },
      deletePropertyByID: function(id, name, value) {
        var node = ReactMount.getNode(id);
        ("production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
        DOMPropertyOperations.deleteValueForProperty(node, name, value);
      },
      updateStylesByID: function(id, styles) {
        var node = ReactMount.getNode(id);
        CSSPropertyOperations.setValueForStyles(node, styles);
      },
      updateInnerHTMLByID: function(id, html) {
        var node = ReactMount.getNode(id);
        setInnerHTML(node, html);
      },
      updateTextContentByID: function(id, content) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.updateTextContent(node, content);
      },
      dangerouslyReplaceNodeWithMarkupByID: function(id, markup) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
      },
      dangerouslyProcessChildrenUpdates: function(updates, markup) {
        for (var i = 0; i < updates.length; i++) {
          updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
        }
        DOMChildrenOperations.processUpdates(updates, markup);
      }
    };
    ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
      updatePropertyByID: 'updatePropertyByID',
      deletePropertyByID: 'deletePropertyByID',
      updateStylesByID: 'updateStylesByID',
      updateInnerHTMLByID: 'updateInnerHTMLByID',
      updateTextContentByID: 'updateTextContentByID',
      dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
      dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
    });
    module.exports = ReactDOMIDOperations;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("57", ["56", "55", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactDOMIDOperations = require("56");
    var ReactMount = require("55");
    var ReactComponentBrowserEnvironment = {
      processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
      replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
      unmountIDFromEnvironment: function(rootNodeID) {
        ReactMount.purgeID(rootNodeID);
      }
    };
    module.exports = ReactComponentBrowserEnvironment;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("58", ["16", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var traverseAllChildren = require("16");
    var warning = require("e");
    function flattenSingleChildIntoContext(traverseContext, child, name) {
      var result = traverseContext;
      var keyUnique = !result.hasOwnProperty(name);
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : null);
      }
      if (keyUnique && child != null) {
        result[name] = child;
      }
    }
    function flattenChildren(children) {
      if (children == null) {
        return children;
      }
      var result = {};
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
      return result;
    }
    module.exports = flattenChildren;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("59", ["22", "58", "54", "52"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactReconciler = require("22");
  var flattenChildren = require("58");
  var instantiateReactComponent = require("54");
  var shouldUpdateReactComponent = require("52");
  var ReactChildReconciler = {
    instantiateChildren: function(nestedChildNodes, transaction, context) {
      var children = flattenChildren(nestedChildNodes);
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var childInstance = instantiateReactComponent(child, null);
          children[name] = childInstance;
        }
      }
      return children;
    },
    updateChildren: function(prevChildren, nextNestedChildNodes, transaction, context) {
      var nextChildren = flattenChildren(nextNestedChildNodes);
      if (!nextChildren && !prevChildren) {
        return null;
      }
      var name;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var prevElement = prevChild && prevChild._currentElement;
        var nextElement = nextChildren[name];
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
          ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
          nextChildren[name] = prevChild;
        } else {
          if (prevChild) {
            ReactReconciler.unmountComponent(prevChild, name);
          }
          var nextChildInstance = instantiateReactComponent(nextElement, null);
          nextChildren[name] = nextChildInstance;
        }
      }
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          ReactReconciler.unmountComponent(prevChildren[name]);
        }
      }
      return nextChildren;
    },
    unmountChildren: function(renderedChildren) {
      for (var name in renderedChildren) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild);
      }
    }
  };
  module.exports = ReactChildReconciler;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5a", ["51", "3e", "22", "59", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponentEnvironment = require("51");
    var ReactMultiChildUpdateTypes = require("3e");
    var ReactReconciler = require("22");
    var ReactChildReconciler = require("59");
    var updateDepth = 0;
    var updateQueue = [];
    var markupQueue = [];
    function enqueueMarkup(parentID, markup, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
        markupIndex: markupQueue.push(markup) - 1,
        textContent: null,
        fromIndex: null,
        toIndex: toIndex
      });
    }
    function enqueueMove(parentID, fromIndex, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
        markupIndex: null,
        textContent: null,
        fromIndex: fromIndex,
        toIndex: toIndex
      });
    }
    function enqueueRemove(parentID, fromIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.REMOVE_NODE,
        markupIndex: null,
        textContent: null,
        fromIndex: fromIndex,
        toIndex: null
      });
    }
    function enqueueTextContent(parentID, textContent) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
        markupIndex: null,
        textContent: textContent,
        fromIndex: null,
        toIndex: null
      });
    }
    function processQueue() {
      if (updateQueue.length) {
        ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
        clearQueue();
      }
    }
    function clearQueue() {
      updateQueue.length = 0;
      markupQueue.length = 0;
    }
    var ReactMultiChild = {Mixin: {
        mountChildren: function(nestedChildren, transaction, context) {
          var children = ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
          this._renderedChildren = children;
          var mountImages = [];
          var index = 0;
          for (var name in children) {
            if (children.hasOwnProperty(name)) {
              var child = children[name];
              var rootID = this._rootNodeID + name;
              var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
              child._mountIndex = index;
              mountImages.push(mountImage);
              index++;
            }
          }
          return mountImages;
        },
        updateTextContent: function(nextContent) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            ReactChildReconciler.unmountChildren(prevChildren);
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChildByName(prevChildren[name], name);
              }
            }
            this.setTextContent(nextContent);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              if (errorThrown) {
                clearQueue();
              } else {
                processQueue();
              }
            }
          }
        },
        updateChildren: function(nextNestedChildren, transaction, context) {
          updateDepth++;
          var errorThrown = true;
          try {
            this._updateChildren(nextNestedChildren, transaction, context);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              if (errorThrown) {
                clearQueue();
              } else {
                processQueue();
              }
            }
          }
        },
        _updateChildren: function(nextNestedChildren, transaction, context) {
          var prevChildren = this._renderedChildren;
          var nextChildren = ReactChildReconciler.updateChildren(prevChildren, nextNestedChildren, transaction, context);
          this._renderedChildren = nextChildren;
          if (!nextChildren && !prevChildren) {
            return;
          }
          var name;
          var lastIndex = 0;
          var nextIndex = 0;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var nextChild = nextChildren[name];
            if (prevChild === nextChild) {
              this.moveChild(prevChild, nextIndex, lastIndex);
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                this._unmountChildByName(prevChild, name);
              }
              this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
            }
            nextIndex++;
          }
          for (name in prevChildren) {
            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
              this._unmountChildByName(prevChildren[name], name);
            }
          }
        },
        unmountChildren: function() {
          var renderedChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(renderedChildren);
          this._renderedChildren = null;
        },
        moveChild: function(child, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
          }
        },
        createChild: function(child, mountImage) {
          enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
        },
        removeChild: function(child) {
          enqueueRemove(this._rootNodeID, child._mountIndex);
        },
        setTextContent: function(textContent) {
          enqueueTextContent(this._rootNodeID, textContent);
        },
        _mountChildByNameAtIndex: function(child, name, index, transaction, context) {
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index;
          this.createChild(child, mountImage);
        },
        _unmountChildByName: function(child, name) {
          this.removeChild(child);
          child._mountIndex = null;
        }
      }};
    module.exports = ReactMultiChild;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5b", ["38", "2c", "2f", "49", "57", "55", "5a", "1b", "b", "2d", "6", "48", "28", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CSSPropertyOperations = require("38");
    var DOMProperty = require("2c");
    var DOMPropertyOperations = require("2f");
    var ReactBrowserEventEmitter = require("49");
    var ReactComponentBrowserEnvironment = require("57");
    var ReactMount = require("55");
    var ReactMultiChild = require("5a");
    var ReactPerf = require("1b");
    var assign = require("b");
    var escapeTextContentForBrowser = require("2d");
    var invariant = require("6");
    var isEventSupported = require("48");
    var keyOf = require("28");
    var warning = require("e");
    var deleteListener = ReactBrowserEventEmitter.deleteListener;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
    var CONTENT_TYPES = {
      'string': true,
      'number': true
    };
    var STYLE = keyOf({style: null});
    var ELEMENT_NODE_TYPE = 1;
    var BackendIDOperations = null;
    function assertValidProps(props) {
      if (!props) {
        return;
      }
      if (props.dangerouslySetInnerHTML != null) {
        ("production" !== process.env.NODE_ENV ? invariant(props.children == null, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(props.children == null));
        ("production" !== process.env.NODE_ENV ? invariant(typeof props.dangerouslySetInnerHTML === 'object' && '__html' in props.dangerouslySetInnerHTML, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(typeof props.dangerouslySetInnerHTML === 'object' && '__html' in props.dangerouslySetInnerHTML));
      }
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : null);
        ("production" !== process.env.NODE_ENV ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : null);
      }
      ("production" !== process.env.NODE_ENV ? invariant(props.style == null || typeof props.style === 'object', 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.') : invariant(props.style == null || typeof props.style === 'object'));
    }
    function putListener(id, registrationName, listener, transaction) {
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : null);
      }
      var container = ReactMount.findReactContainerForID(id);
      if (container) {
        var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
        listenTo(registrationName, doc);
      }
      transaction.getPutListenerQueue().enqueuePutListener(id, registrationName, listener);
    }
    var omittedCloseTags = {
      'area': true,
      'base': true,
      'br': true,
      'col': true,
      'embed': true,
      'hr': true,
      'img': true,
      'input': true,
      'keygen': true,
      'link': true,
      'meta': true,
      'param': true,
      'source': true,
      'track': true,
      'wbr': true
    };
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = {}.hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        ("production" !== process.env.NODE_ENV ? invariant(VALID_TAG_REGEX.test(tag), 'Invalid tag: %s', tag) : invariant(VALID_TAG_REGEX.test(tag)));
        validatedTagCache[tag] = true;
      }
    }
    function ReactDOMComponent(tag) {
      validateDangerousTag(tag);
      this._tag = tag;
      this._renderedChildren = null;
      this._previousStyleCopy = null;
      this._rootNodeID = null;
    }
    ReactDOMComponent.displayName = 'ReactDOMComponent';
    ReactDOMComponent.Mixin = {
      construct: function(element) {
        this._currentElement = element;
      },
      mountComponent: function(rootID, transaction, context) {
        this._rootNodeID = rootID;
        assertValidProps(this._currentElement.props);
        var closeTag = omittedCloseTags[this._tag] ? '' : '</' + this._tag + '>';
        return (this._createOpenTagMarkupAndPutListeners(transaction) + this._createContentMarkup(transaction, context) + closeTag);
      },
      _createOpenTagMarkupAndPutListeners: function(transaction) {
        var props = this._currentElement.props;
        var ret = '<' + this._tag;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            putListener(this._rootNodeID, propKey, propValue, transaction);
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                propValue = this._previousStyleCopy = assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
            }
            var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            if (markup) {
              ret += ' ' + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret + '>';
        }
        var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
        return ret + ' ' + markupForID + '>';
      },
      _createContentMarkup: function(transaction, context) {
        var prefix = '';
        if (this._tag === 'listing' || this._tag === 'pre' || this._tag === 'textarea') {
          prefix = '\n';
        }
        var props = this._currentElement.props;
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            return prefix + innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            return prefix + escapeTextContentForBrowser(contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction, context);
            return prefix + mountImages.join('');
          }
        }
        return prefix;
      },
      receiveComponent: function(nextElement, transaction, context) {
        var prevElement = this._currentElement;
        this._currentElement = nextElement;
        this.updateComponent(transaction, prevElement, nextElement, context);
      },
      updateComponent: function(transaction, prevElement, nextElement, context) {
        assertValidProps(this._currentElement.props);
        this._updateDOMProperties(prevElement.props, transaction);
        this._updateDOMChildren(prevElement.props, transaction, context);
      },
      _updateDOMProperties: function(lastProps, transaction) {
        var nextProps = this._currentElement.props;
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = this._previousStyleCopy;
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
            this._previousStyleCopy = null;
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            deleteListener(this._rootNodeID, propKey);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              nextProp = this._previousStyleCopy = assign({}, nextProp);
            } else {
              this._previousStyleCopy = null;
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = '';
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            putListener(this._rootNodeID, propKey, nextProp, transaction);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp);
          }
        }
        if (styleUpdates) {
          BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates);
        }
      },
      _updateDOMChildren: function(lastProps, transaction, context) {
        var nextProps = this._currentElement.props;
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction, context);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent('');
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent('' + nextContent);
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml);
          }
        } else if (nextChildren != null) {
          this.updateChildren(nextChildren, transaction, context);
        }
      },
      unmountComponent: function() {
        this.unmountChildren();
        ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
        ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
        this._rootNodeID = null;
      }
    };
    ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
      mountComponent: 'mountComponent',
      updateComponent: 'updateComponent'
    });
    assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
    ReactDOMComponent.injection = {injectIDOperations: function(IDOperations) {
        ReactDOMComponent.BackendIDOperations = BackendIDOperations = IDOperations;
      }};
    module.exports = ReactDOMComponent;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5c", ["2f", "57", "5b", "b", "2d"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMPropertyOperations = require("2f");
  var ReactComponentBrowserEnvironment = require("57");
  var ReactDOMComponent = require("5b");
  var assign = require("b");
  var escapeTextContentForBrowser = require("2d");
  var ReactDOMTextComponent = function(props) {};
  assign(ReactDOMTextComponent.prototype, {
    construct: function(text) {
      this._currentElement = text;
      this._stringText = '' + text;
      this._rootNodeID = null;
      this._mountIndex = 0;
    },
    mountComponent: function(rootID, transaction, context) {
      this._rootNodeID = rootID;
      var escapedText = escapeTextContentForBrowser(this._stringText);
      if (transaction.renderToStaticMarkup) {
        return escapedText;
      }
      return ('<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>');
    },
    receiveComponent: function(nextText, transaction) {
      if (nextText !== this._currentElement) {
        this._currentElement = nextText;
        var nextStringText = '' + nextText;
        if (nextStringText !== this._stringText) {
          this._stringText = nextStringText;
          ReactDOMComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextStringText);
        }
      }
    },
    unmountComponent: function() {
      ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    }
  });
  module.exports = ReactDOMTextComponent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5d", ["8", "45", "43", "44", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("8");
    var EventPluginHub = require("45");
    var accumulateInto = require("43");
    var forEachAccumulated = require("44");
    var PropagationPhases = EventConstants.PropagationPhases;
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(id, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(id, registrationName);
    }
    function accumulateDirectionalDispatches(domID, upwards, event) {
      if ("production" !== process.env.NODE_ENV) {
        if (!domID) {
          throw new Error('Dispatching id must not be null');
        }
      }
      var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
      var listener = listenerAtPhase(domID, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateDispatches(id, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(id, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event.dispatchMarker, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
      EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5e", ["31"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("31");
  var contentKey = null;
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }
  module.exports = getTextContentAccessor;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5f", ["a", "b", "5e"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var PooledClass = require("a");
  var assign = require("b");
  var getTextContentAccessor = require("5e");
  function FallbackCompositionState(root) {
    this._root = root;
    this._startText = this.getText();
    this._fallbackText = null;
  }
  assign(FallbackCompositionState.prototype, {
    getText: function() {
      if ('value' in this._root) {
        return this._root.value;
      }
      return this._root[getTextContentAccessor()];
    },
    getData: function() {
      if (this._fallbackText) {
        return this._fallbackText;
      }
      var start;
      var startValue = this._startText;
      var startLength = startValue.length;
      var end;
      var endValue = this.getText();
      var endLength = endValue.length;
      for (start = 0; start < startLength; start++) {
        if (startValue[start] !== endValue[start]) {
          break;
        }
      }
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd; end++) {
        if (startValue[startLength - end] !== endValue[endLength - end]) {
          break;
        }
      }
      var sliceTail = end > 1 ? 1 - end : undefined;
      this._fallbackText = endValue.slice(start, sliceTail);
      return this._fallbackText;
    }
  });
  PooledClass.addPoolingTo(FallbackCompositionState);
  module.exports = FallbackCompositionState;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("60", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;
    return target.nodeType === 3 ? target.parentNode : target;
  }
  module.exports = getEventTarget;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("61", ["a", "b", "d", "60"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var PooledClass = require("a");
  var assign = require("b");
  var emptyFunction = require("d");
  var getEventTarget = require("60");
  var EventInterface = {
    type: null,
    target: getEventTarget,
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };
  function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    this.dispatchConfig = dispatchConfig;
    this.dispatchMarker = dispatchMarker;
    this.nativeEvent = nativeEvent;
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      var normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    } else {
      this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  }
  assign(SyntheticEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      if (event.preventDefault) {
        event.preventDefault();
      } else {
        event.returnValue = false;
      }
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      if (event.stopPropagation) {
        event.stopPropagation();
      } else {
        event.cancelBubble = true;
      }
      this.isPropagationStopped = emptyFunction.thatReturnsTrue;
    },
    persist: function() {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },
    isPersistent: emptyFunction.thatReturnsFalse,
    destructor: function() {
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        this[propName] = null;
      }
      this.dispatchConfig = null;
      this.dispatchMarker = null;
      this.nativeEvent = null;
    }
  });
  SyntheticEvent.Interface = EventInterface;
  SyntheticEvent.augmentClass = function(Class, Interface) {
    var Super = this;
    var prototype = Object.create(Super.prototype);
    assign(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = assign({}, Super.Interface, Interface);
    Class.augmentClass = Super.augmentClass;
    PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
  };
  PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);
  module.exports = SyntheticEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("62", ["61"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticEvent = require("61");
  var CompositionEventInterface = {data: null};
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("63", ["61"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticEvent = require("61");
  var InputEventInterface = {data: null};
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("64", ["8", "5d", "31", "5f", "62", "63", "28"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("8");
  var EventPropagators = require("5d");
  var ExecutionEnvironment = require("31");
  var FallbackCompositionState = require("5f");
  var SyntheticCompositionEvent = require("62");
  var SyntheticInputEvent = require("63");
  var keyOf = require("28");
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var canUseCompositionEvent = (ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window);
  var documentMode = null;
  if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
    documentMode = document.documentMode;
  }
  var canUseTextInputEvent = (ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto());
  var useFallbackCompositionData = (ExecutionEnvironment.canUseDOM && ((!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11)));
  function isPresto() {
    var opera = window.opera;
    return (typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12);
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {
    beforeInput: {
      phasedRegistrationNames: {
        bubbled: keyOf({onBeforeInput: null}),
        captured: keyOf({onBeforeInputCapture: null})
      },
      dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
    },
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionEnd: null}),
        captured: keyOf({onCompositionEndCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionStart: null}),
        captured: keyOf({onCompositionStartCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionUpdate: null}),
        captured: keyOf({onCompositionUpdateCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    }
  };
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return ((nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey));
  }
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionStart:
        return eventTypes.compositionStart;
      case topLevelTypes.topCompositionEnd:
        return eventTypes.compositionEnd;
      case topLevelTypes.topCompositionUpdate:
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackCompositionStart(topLevelType, nativeEvent) {
    return (topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE);
  }
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topKeyUp:
        return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);
      case topLevelTypes.topKeyDown:
        return (nativeEvent.keyCode !== START_KEYCODE);
      case topLevelTypes.topKeyPress:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topBlur:
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    var detail = nativeEvent.detail;
    if (typeof detail === 'object' && 'data' in detail) {
      return detail.data;
    }
    return null;
  }
  var currentComposition = null;
  function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    var eventType;
    var fallbackData;
    if (canUseCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }
    if (!eventType) {
      return null;
    }
    if (useFallbackCompositionData) {
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          fallbackData = currentComposition.getData();
        }
      }
    }
    var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);
    if (fallbackData) {
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionEnd:
        return getDataFromCustomEvent(nativeEvent);
      case topLevelTypes.topKeyPress:
        var which = nativeEvent.which;
        if (which !== SPACEBAR_CODE) {
          return null;
        }
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case topLevelTypes.topTextInput:
        var chars = nativeEvent.data;
        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
          return null;
        }
        return chars;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    if (currentComposition) {
      if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        var chars = currentComposition.getData();
        FallbackCompositionState.release(currentComposition);
        currentComposition = null;
        return chars;
      }
      return null;
    }
    switch (topLevelType) {
      case topLevelTypes.topPaste:
        return null;
      case topLevelTypes.topKeyPress:
        if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
          return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case topLevelTypes.topCompositionEnd:
        return useFallbackCompositionData ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    var chars;
    if (canUseTextInputEvent) {
      chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
    } else {
      chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
    }
    if (!chars) {
      return null;
    }
    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);
    event.data = chars;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent)];
    }
  };
  module.exports = BeforeInputEventPlugin;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("65", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };
  function isTextInputElement(elem) {
    return elem && ((elem.nodeName === 'INPUT' && supportedInputTypes[elem.type] || elem.nodeName === 'TEXTAREA'));
  }
  module.exports = isTextInputElement;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("66", ["8", "45", "5d", "31", "24", "61", "48", "65", "28", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("8");
    var EventPluginHub = require("45");
    var EventPropagators = require("5d");
    var ExecutionEnvironment = require("31");
    var ReactUpdates = require("24");
    var SyntheticEvent = require("61");
    var isEventSupported = require("48");
    var isTextInputElement = require("65");
    var keyOf = require("28");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {change: {
        phasedRegistrationNames: {
          bubbled: keyOf({onChange: null}),
          captured: keyOf({onChangeCapture: null})
        },
        dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
      }};
    var activeElement = null;
    var activeElementID = null;
    var activeElementValue = null;
    var activeElementValueProp = null;
    function shouldUseChangeEvent(elem) {
      return (elem.nodeName === 'SELECT' || (elem.nodeName === 'INPUT' && elem.type === 'file'));
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported('change') && ((!('documentMode' in document) || document.documentMode > 8));
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
      EventPropagators.accumulateTwoPhaseDispatches(event);
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    }
    function startWatchingForChangeEventIE8(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent('onchange', manualDispatchChangeEvent);
      activeElement = null;
      activeElementID = null;
    }
    function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topChange) {
        return topLevelTargetID;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported('input') && ((!('documentMode' in document) || document.documentMode > 9));
    }
    var newValueProp = {
      get: function() {
        return activeElementValueProp.get.call(this);
      },
      set: function(val) {
        activeElementValue = '' + val;
        activeElementValueProp.set.call(this, val);
      }
    };
    function startWatchingForValueChange(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElementValue = target.value;
      activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
      Object.defineProperty(activeElement, 'value', newValueProp);
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return;
      }
      delete activeElement.value;
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
      activeElement = null;
      activeElementID = null;
      activeElementValue = null;
      activeElementValueProp = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== 'value') {
        return;
      }
      var value = nativeEvent.srcElement.value;
      if (value === activeElementValue) {
        return;
      }
      activeElementValue = value;
      manualDispatchChangeEvent(nativeEvent);
    }
    function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topInput) {
        return topLevelTargetID;
      }
    }
    function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForValueChange();
        startWatchingForValueChange(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForValueChange();
      }
    }
    function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
        if (activeElement && activeElement.value !== activeElementValue) {
          activeElementValue = activeElement.value;
          return activeElementID;
        }
      }
    }
    function shouldUseClickEvent(elem) {
      return (elem.nodeName === 'INPUT' && (elem.type === 'checkbox' || elem.type === 'radio'));
    }
    function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topClick) {
        return topLevelTargetID;
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var getTargetIDFunc,
            handleEventFunc;
        if (shouldUseChangeEvent(topLevelTarget)) {
          if (doesChangeEventBubble) {
            getTargetIDFunc = getTargetIDForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(topLevelTarget)) {
          if (isInputEventSupported) {
            getTargetIDFunc = getTargetIDForInputEvent;
          } else {
            getTargetIDFunc = getTargetIDForInputEventIE;
            handleEventFunc = handleEventsForInputEventIE;
          }
        } else if (shouldUseClickEvent(topLevelTarget)) {
          getTargetIDFunc = getTargetIDForClickEvent;
        }
        if (getTargetIDFunc) {
          var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
          if (targetID) {
            var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("67", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var nextReactRootIndex = 0;
  var ClientReactRootIndex = {createReactRootIndex: function() {
      return nextReactRootIndex++;
    }};
  module.exports = ClientReactRootIndex;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("68", ["28"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keyOf = require("28");
  var DefaultEventPluginOrder = [keyOf({ResponderEventPlugin: null}), keyOf({SimpleEventPlugin: null}), keyOf({TapEventPlugin: null}), keyOf({EnterLeaveEventPlugin: null}), keyOf({ChangeEventPlugin: null}), keyOf({SelectEventPlugin: null}), keyOf({BeforeInputEventPlugin: null}), keyOf({AnalyticsEventPlugin: null}), keyOf({MobileSafariClickEventPlugin: null})];
  module.exports = DefaultEventPluginOrder;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("69", ["61", "60"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticEvent = require("61");
  var getEventTarget = require("60");
  var UIEventInterface = {
    view: function(event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target != null && target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function(event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6a", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }
  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }
  module.exports = getEventModifierState;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6b", ["69", "47", "6a"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticUIEvent = require("69");
  var ViewportMetrics = require("47");
  var getEventModifierState = require("6a");
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function(event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function(event) {
      return event.relatedTarget || (((event.fromElement === event.srcElement ? event.toElement : event.fromElement)));
    },
    pageX: function(event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function(event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6c", ["8", "5d", "6b", "55", "28"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("8");
  var EventPropagators = require("5d");
  var SyntheticMouseEvent = require("6b");
  var ReactMount = require("55");
  var keyOf = require("28");
  var topLevelTypes = EventConstants.topLevelTypes;
  var getFirstReactDOM = ReactMount.getFirstReactDOM;
  var eventTypes = {
    mouseEnter: {
      registrationName: keyOf({onMouseEnter: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    },
    mouseLeave: {
      registrationName: keyOf({onMouseLeave: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    }
  };
  var extractedEvents = [null, null];
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
        return null;
      }
      var win;
      if (topLevelTarget.window === topLevelTarget) {
        win = topLevelTarget;
      } else {
        var doc = topLevelTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from,
          to;
      if (topLevelType === topLevelTypes.topMouseOut) {
        from = topLevelTarget;
        to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
      } else {
        from = win;
        to = topLevelTarget;
      }
      if (from === to) {
        return null;
      }
      var fromID = from ? ReactMount.getID(from) : '';
      var toID = to ? ReactMount.getID(to) : '';
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
      leave.type = 'mouseleave';
      leave.target = from;
      leave.relatedTarget = to;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
      enter.type = 'mouseenter';
      enter.target = to;
      enter.relatedTarget = from;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
      extractedEvents[0] = leave;
      extractedEvents[1] = enter;
      return extractedEvents;
    }
  };
  module.exports = EnterLeaveEventPlugin;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6d", ["2c", "31"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMProperty = require("2c");
  var ExecutionEnvironment = require("31");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var hasSVG;
  if (ExecutionEnvironment.canUseDOM) {
    var implementation = document.implementation;
    hasSVG = (implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1'));
  }
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
    Properties: {
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoPlay: HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      dateTime: MUST_USE_ATTRIBUTE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      headers: null,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      high: null,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      low: null,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      autoCapitalize: null,
      autoCorrect: null,
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      itemID: MUST_USE_ATTRIBUTE,
      itemRef: MUST_USE_ATTRIBUTE,
      property: null,
      unselectable: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {
      autoCapitalize: 'autocapitalize',
      autoComplete: 'autocomplete',
      autoCorrect: 'autocorrect',
      autoFocus: 'autofocus',
      autoPlay: 'autoplay',
      encType: 'encoding',
      hrefLang: 'hreflang',
      radioGroup: 'radiogroup',
      spellCheck: 'spellcheck',
      srcDoc: 'srcdoc',
      srcSet: 'srcset'
    }
  };
  module.exports = HTMLDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6e", ["8", "d"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("8");
  var emptyFunction = require("d");
  var topLevelTypes = EventConstants.topLevelTypes;
  var MobileSafariClickEventPlugin = {
    eventTypes: null,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      if (topLevelType === topLevelTypes.topTouchStart) {
        var target = nativeEvent.target;
        if (target && !target.onclick) {
          target.onclick = emptyFunction;
        }
      }
    }
  };
  module.exports = MobileSafariClickEventPlugin;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6f", ["10", "19", "55", "6", "4d", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = require("10");
    var ReactInstanceMap = require("19");
    var ReactMount = require("55");
    var invariant = require("6");
    var isNode = require("4d");
    var warning = require("e");
    function findDOMNode(componentOrElement) {
      if ("production" !== process.env.NODE_ENV) {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          ("production" !== process.env.NODE_ENV ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : null);
          owner._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrElement == null) {
        return null;
      }
      if (isNode(componentOrElement)) {
        return componentOrElement;
      }
      if (ReactInstanceMap.has(componentOrElement)) {
        return ReactMount.getNodeFromInstance(componentOrElement);
      }
      ("production" !== process.env.NODE_ENV ? invariant(componentOrElement.render == null || typeof componentOrElement.render !== 'function', 'Component (with keys: %s) contains `render` method ' + 'but is not mounted in the DOM', Object.keys(componentOrElement)) : invariant(componentOrElement.render == null || typeof componentOrElement.render !== 'function'));
      ("production" !== process.env.NODE_ENV ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false));
    }
    module.exports = findDOMNode;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("70", ["6f"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var findDOMNode = require("6f");
  var ReactBrowserComponentMixin = {getDOMNode: function() {
      return findDOMNode(this);
    }};
  module.exports = ReactBrowserComponentMixin;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("71", ["24", "23", "b", "d"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactUpdates = require("24");
  var Transaction = require("23");
  var assign = require("b");
  var emptyFunction = require("d");
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function() {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    }});
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback, a, b, c, d) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        callback(a, b, c, d);
      } else {
        transaction.perform(callback, null, a, b, c, d);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("72", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function focusNode(node) {
    try {
      node.focus();
    } catch (e) {}
  }
  module.exports = focusNode;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("73", ["72"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var focusNode = require("72");
  var AutoFocusMixin = {componentDidMount: function() {
      if (this.props.autoFocus) {
        focusNode(this.getDOMNode());
      }
    }};
  module.exports = AutoFocusMixin;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("74", ["73", "70", "29", "11", "7"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var AutoFocusMixin = require("73");
  var ReactBrowserComponentMixin = require("70");
  var ReactClass = require("29");
  var ReactElement = require("11");
  var keyMirror = require("7");
  var button = ReactElement.createFactory('button');
  var mouseListenerNames = keyMirror({
    onClick: true,
    onDoubleClick: true,
    onMouseDown: true,
    onMouseMove: true,
    onMouseUp: true,
    onClickCapture: true,
    onDoubleClickCapture: true,
    onMouseDownCapture: true,
    onMouseMoveCapture: true,
    onMouseUpCapture: true
  });
  var ReactDOMButton = ReactClass.createClass({
    displayName: 'ReactDOMButton',
    tagName: 'BUTTON',
    mixins: [AutoFocusMixin, ReactBrowserComponentMixin],
    render: function() {
      var props = {};
      for (var key in this.props) {
        if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
          props[key] = this.props[key];
        }
      }
      return button(props, this.props.children);
    }
  });
  module.exports = ReactDOMButton;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("75", ["49", "43", "44", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactBrowserEventEmitter = require("49");
    var accumulateInto = require("43");
    var forEachAccumulated = require("44");
    var invariant = require("6");
    function remove(event) {
      event.remove();
    }
    var LocalEventTrapMixin = {
      trapBubbledEvent: function(topLevelType, handlerBaseName) {
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));
        var node = this.getDOMNode();
        ("production" !== process.env.NODE_ENV ? invariant(node, 'LocalEventTrapMixin.trapBubbledEvent(...): Requires node to be rendered.') : invariant(node));
        var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, node);
        this._localEventListeners = accumulateInto(this._localEventListeners, listener);
      },
      componentWillUnmount: function() {
        if (this._localEventListeners) {
          forEachAccumulated(this._localEventListeners, remove);
        }
      }
    };
    module.exports = LocalEventTrapMixin;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("76", ["8", "75", "70", "29", "11"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("8");
  var LocalEventTrapMixin = require("75");
  var ReactBrowserComponentMixin = require("70");
  var ReactClass = require("29");
  var ReactElement = require("11");
  var form = ReactElement.createFactory('form');
  var ReactDOMForm = ReactClass.createClass({
    displayName: 'ReactDOMForm',
    tagName: 'FORM',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return form(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
      this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
    }
  });
  module.exports = ReactDOMForm;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("77", ["8", "75", "70", "29", "11"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("8");
  var LocalEventTrapMixin = require("75");
  var ReactBrowserComponentMixin = require("70");
  var ReactClass = require("29");
  var ReactElement = require("11");
  var img = ReactElement.createFactory('img');
  var ReactDOMImg = ReactClass.createClass({
    displayName: 'ReactDOMImg',
    tagName: 'IMG',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return img(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
      this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
    }
  });
  module.exports = ReactDOMImg;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("78", ["8", "75", "70", "29", "11"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("8");
  var LocalEventTrapMixin = require("75");
  var ReactBrowserComponentMixin = require("70");
  var ReactClass = require("29");
  var ReactElement = require("11");
  var iframe = ReactElement.createFactory('iframe');
  var ReactDOMIframe = ReactClass.createClass({
    displayName: 'ReactDOMIframe',
    tagName: 'IFRAME',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return iframe(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
    }
  });
  module.exports = ReactDOMIframe;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("79", ["11", "12", "1f", "d"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactElement = require("11");
  var ReactFragment = require("12");
  var ReactPropTypeLocationNames = require("1f");
  var emptyFunction = require("d");
  var ANONYMOUS = '<<anonymous>>';
  var elementTypeChecker = createElementTypeChecker();
  var nodeTypeChecker = createNodeChecker();
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: elementTypeChecker,
    instanceOf: createInstanceTypeChecker,
    node: nodeTypeChecker,
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };
  function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location) {
      componentName = componentName || ANONYMOUS;
      if (props[propName] == null) {
        var locationName = ReactPropTypeLocationNames[location];
        if (isRequired) {
          return new Error(("Required " + locationName + " `" + propName + "` was not specified in ") + ("`" + componentName + "`."));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location);
      }
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        var locationName = ReactPropTypeLocationNames[location];
        var preciseType = getPreciseType(propValue);
        return new Error(("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") + ("supplied to `" + componentName + "`, expected `" + expectedType + "`."));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturns(null));
  }
  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new Error(("Invalid " + locationName + " `" + propName + "` of type ") + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeChecker() {
    function validate(props, propName, componentName, location) {
      if (!ReactElement.isValidElement(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected a ReactElement."));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location) {
      if (!(props[propName] instanceof expectedClass)) {
        var locationName = ReactPropTypeLocationNames[location];
        var expectedClassName = expectedClass.name || ANONYMOUS;
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected instance of `" + expectedClassName + "`."));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createEnumTypeChecker(expectedValues) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (propValue === expectedValues[i]) {
          return null;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      var valuesString = JSON.stringify(expectedValues);
      return new Error(("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
    }
    return createChainableTypeChecker(validate);
  }
  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` of type ") + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createUnionTypeChecker(arrayOfTypeCheckers) {
    function validate(props, propName, componentName, location) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location) == null) {
          return null;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`."));
    }
    return createChainableTypeChecker(validate);
  }
  function createNodeChecker() {
    function validate(props, propName, componentName, location) {
      if (!isNode(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected a ReactNode."));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") + ("supplied to `" + componentName + "`, expected `object`."));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || ReactElement.isValidElement(propValue)) {
          return true;
        }
        propValue = ReactFragment.extractIfFragment(propValue);
        for (var k in propValue) {
          if (!isNode(propValue[k])) {
            return false;
          }
        }
        return true;
      default:
        return false;
    }
  }
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      return 'object';
    }
    return propType;
  }
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }
  module.exports = ReactPropTypes;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7a", ["79", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPropTypes = require("79");
    var invariant = require("6");
    var hasReadOnlyValue = {
      'button': true,
      'checkbox': true,
      'image': true,
      'hidden': true,
      'radio': true,
      'reset': true,
      'submit': true
    };
    function _assertSingleLink(input) {
      ("production" !== process.env.NODE_ENV ? invariant(input.props.checkedLink == null || input.props.valueLink == null, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(input.props.checkedLink == null || input.props.valueLink == null));
    }
    function _assertValueLink(input) {
      _assertSingleLink(input);
      ("production" !== process.env.NODE_ENV ? invariant(input.props.value == null && input.props.onChange == null, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(input.props.value == null && input.props.onChange == null));
    }
    function _assertCheckedLink(input) {
      _assertSingleLink(input);
      ("production" !== process.env.NODE_ENV ? invariant(input.props.checked == null && input.props.onChange == null, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(input.props.checked == null && input.props.onChange == null));
    }
    function _handleLinkedValueChange(e) {
      this.props.valueLink.requestChange(e.target.value);
    }
    function _handleLinkedCheckChange(e) {
      this.props.checkedLink.requestChange(e.target.checked);
    }
    var LinkedValueUtils = {
      Mixin: {propTypes: {
          value: function(props, propName, componentName) {
            if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
              return null;
            }
            return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
          },
          checked: function(props, propName, componentName) {
            if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
              return null;
            }
            return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
          },
          onChange: ReactPropTypes.func
        }},
      getValue: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return input.props.valueLink.value;
        }
        return input.props.value;
      },
      getChecked: function(input) {
        if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return input.props.checkedLink.value;
        }
        return input.props.checked;
      },
      getOnChange: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return _handleLinkedValueChange;
        } else if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return _handleLinkedCheckChange;
        }
        return input.props.onChange;
      }
    };
    module.exports = LinkedValueUtils;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7b", ["73", "2f", "7a", "70", "29", "11", "55", "24", "b", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var AutoFocusMixin = require("73");
    var DOMPropertyOperations = require("2f");
    var LinkedValueUtils = require("7a");
    var ReactBrowserComponentMixin = require("70");
    var ReactClass = require("29");
    var ReactElement = require("11");
    var ReactMount = require("55");
    var ReactUpdates = require("24");
    var assign = require("b");
    var invariant = require("6");
    var input = ReactElement.createFactory('input');
    var instancesByReactID = {};
    function forceUpdateIfMounted() {
      if (this.isMounted()) {
        this.forceUpdate();
      }
    }
    var ReactDOMInput = ReactClass.createClass({
      displayName: 'ReactDOMInput',
      tagName: 'INPUT',
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        return {
          initialChecked: this.props.defaultChecked || false,
          initialValue: defaultValue != null ? defaultValue : null
        };
      },
      render: function() {
        var props = assign({}, this.props);
        props.defaultChecked = null;
        props.defaultValue = null;
        var value = LinkedValueUtils.getValue(this);
        props.value = value != null ? value : this.state.initialValue;
        var checked = LinkedValueUtils.getChecked(this);
        props.checked = checked != null ? checked : this.state.initialChecked;
        props.onChange = this._handleChange;
        return input(props, this.props.children);
      },
      componentDidMount: function() {
        var id = ReactMount.getID(this.getDOMNode());
        instancesByReactID[id] = this;
      },
      componentWillUnmount: function() {
        var rootNode = this.getDOMNode();
        var id = ReactMount.getID(rootNode);
        delete instancesByReactID[id];
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var rootNode = this.getDOMNode();
        if (this.props.checked != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, 'checked', this.props.checked || false);
        }
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          returnValue = onChange.call(this, event);
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        var name = this.props.name;
        if (this.props.type === 'radio' && name != null) {
          var rootNode = this.getDOMNode();
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
          for (var i = 0,
              groupLen = group.length; i < groupLen; i++) {
            var otherNode = group[i];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherID = ReactMount.getID(otherNode);
            ("production" !== process.env.NODE_ENV ? invariant(otherID, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(otherID));
            var otherInstance = instancesByReactID[otherID];
            ("production" !== process.env.NODE_ENV ? invariant(otherInstance, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(otherInstance));
            ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
          }
        }
        return returnValue;
      }
    });
    module.exports = ReactDOMInput;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7c", ["70", "29", "11", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactBrowserComponentMixin = require("70");
    var ReactClass = require("29");
    var ReactElement = require("11");
    var warning = require("e");
    var option = ReactElement.createFactory('option');
    var ReactDOMOption = ReactClass.createClass({
      displayName: 'ReactDOMOption',
      tagName: 'OPTION',
      mixins: [ReactBrowserComponentMixin],
      componentWillMount: function() {
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(this.props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : null);
        }
      },
      render: function() {
        return option(this.props, this.props.children);
      }
    });
    module.exports = ReactDOMOption;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7d", ["73", "7a", "70", "29", "11", "24", "b"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var AutoFocusMixin = require("73");
  var LinkedValueUtils = require("7a");
  var ReactBrowserComponentMixin = require("70");
  var ReactClass = require("29");
  var ReactElement = require("11");
  var ReactUpdates = require("24");
  var assign = require("b");
  var select = ReactElement.createFactory('select');
  function updateOptionsIfPendingUpdateAndMounted() {
    if (this._pendingUpdate) {
      this._pendingUpdate = false;
      var value = LinkedValueUtils.getValue(this);
      if (value != null && this.isMounted()) {
        updateOptions(this, value);
      }
    }
  }
  function selectValueType(props, propName, componentName) {
    if (props[propName] == null) {
      return null;
    }
    if (props.multiple) {
      if (!Array.isArray(props[propName])) {
        return new Error(("The `" + propName + "` prop supplied to <select> must be an array if ") + ("`multiple` is true."));
      }
    } else {
      if (Array.isArray(props[propName])) {
        return new Error(("The `" + propName + "` prop supplied to <select> must be a scalar ") + ("value if `multiple` is false."));
      }
    }
  }
  function updateOptions(component, propValue) {
    var selectedValue,
        i,
        l;
    var options = component.getDOMNode().options;
    if (component.props.multiple) {
      selectedValue = {};
      for (i = 0, l = propValue.length; i < l; i++) {
        selectedValue['' + propValue[i]] = true;
      }
      for (i = 0, l = options.length; i < l; i++) {
        var selected = selectedValue.hasOwnProperty(options[i].value);
        if (options[i].selected !== selected) {
          options[i].selected = selected;
        }
      }
    } else {
      selectedValue = '' + propValue;
      for (i = 0, l = options.length; i < l; i++) {
        if (options[i].value === selectedValue) {
          options[i].selected = true;
          return;
        }
      }
      if (options.length) {
        options[0].selected = true;
      }
    }
  }
  var ReactDOMSelect = ReactClass.createClass({
    displayName: 'ReactDOMSelect',
    tagName: 'SELECT',
    mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
    propTypes: {
      defaultValue: selectValueType,
      value: selectValueType
    },
    render: function() {
      var props = assign({}, this.props);
      props.onChange = this._handleChange;
      props.value = null;
      return select(props, this.props.children);
    },
    componentWillMount: function() {
      this._pendingUpdate = false;
    },
    componentDidMount: function() {
      var value = LinkedValueUtils.getValue(this);
      if (value != null) {
        updateOptions(this, value);
      } else if (this.props.defaultValue != null) {
        updateOptions(this, this.props.defaultValue);
      }
    },
    componentDidUpdate: function(prevProps) {
      var value = LinkedValueUtils.getValue(this);
      if (value != null) {
        this._pendingUpdate = false;
        updateOptions(this, value);
      } else if (!prevProps.multiple !== !this.props.multiple) {
        if (this.props.defaultValue != null) {
          updateOptions(this, this.props.defaultValue);
        } else {
          updateOptions(this, this.props.multiple ? [] : '');
        }
      }
    },
    _handleChange: function(event) {
      var returnValue;
      var onChange = LinkedValueUtils.getOnChange(this);
      if (onChange) {
        returnValue = onChange.call(this, event);
      }
      this._pendingUpdate = true;
      ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
      return returnValue;
    }
  });
  module.exports = ReactDOMSelect;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7e", ["73", "2f", "7a", "70", "29", "11", "24", "b", "6", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var AutoFocusMixin = require("73");
    var DOMPropertyOperations = require("2f");
    var LinkedValueUtils = require("7a");
    var ReactBrowserComponentMixin = require("70");
    var ReactClass = require("29");
    var ReactElement = require("11");
    var ReactUpdates = require("24");
    var assign = require("b");
    var invariant = require("6");
    var warning = require("e");
    var textarea = ReactElement.createFactory('textarea');
    function forceUpdateIfMounted() {
      if (this.isMounted()) {
        this.forceUpdate();
      }
    }
    var ReactDOMTextarea = ReactClass.createClass({
      displayName: 'ReactDOMTextarea',
      tagName: 'TEXTAREA',
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        var children = this.props.children;
        if (children != null) {
          if ("production" !== process.env.NODE_ENV) {
            ("production" !== process.env.NODE_ENV ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : null);
          }
          ("production" !== process.env.NODE_ENV ? invariant(defaultValue == null, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(defaultValue == null));
          if (Array.isArray(children)) {
            ("production" !== process.env.NODE_ENV ? invariant(children.length <= 1, '<textarea> can only have at most one child.') : invariant(children.length <= 1));
            children = children[0];
          }
          defaultValue = '' + children;
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        var value = LinkedValueUtils.getValue(this);
        return {initialValue: '' + (value != null ? value : defaultValue)};
      },
      render: function() {
        var props = assign({}, this.props);
        ("production" !== process.env.NODE_ENV ? invariant(props.dangerouslySetInnerHTML == null, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(props.dangerouslySetInnerHTML == null));
        props.defaultValue = null;
        props.value = null;
        props.onChange = this._handleChange;
        return textarea(props, this.state.initialValue);
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          var rootNode = this.getDOMNode();
          DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          returnValue = onChange.call(this, event);
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        return returnValue;
      }
    });
    module.exports = ReactDOMTextarea;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7f", ["d", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var emptyFunction = require("d");
    var EventListener = {
      listen: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return {remove: function() {
              target.removeEventListener(eventType, callback, false);
            }};
        } else if (target.attachEvent) {
          target.attachEvent('on' + eventType, callback);
          return {remove: function() {
              target.detachEvent('on' + eventType, callback);
            }};
        }
      },
      capture: function(target, eventType, callback) {
        if (!target.addEventListener) {
          if ("production" !== process.env.NODE_ENV) {
            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
          }
          return {remove: emptyFunction};
        } else {
          target.addEventListener(eventType, callback, true);
          return {remove: function() {
              target.removeEventListener(eventType, callback, true);
            }};
        }
      },
      registerDefault: function() {}
    };
    module.exports = EventListener;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("80", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }
  module.exports = getUnboundedScrollPosition;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("81", ["7f", "31", "a", "14", "55", "24", "b", "60", "80", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventListener = require("7f");
    var ExecutionEnvironment = require("31");
    var PooledClass = require("a");
    var ReactInstanceHandles = require("14");
    var ReactMount = require("55");
    var ReactUpdates = require("24");
    var assign = require("b");
    var getEventTarget = require("60");
    var getUnboundedScrollPosition = require("80");
    function findParent(node) {
      var nodeID = ReactMount.getID(node);
      var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
      var container = ReactMount.findReactContainerForID(rootID);
      var parent = ReactMount.getFirstReactDOM(container);
      return parent;
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    assign(TopLevelCallbackBookKeeping.prototype, {destructor: function() {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      }});
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
      var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
      var ancestor = topLevelTarget;
      while (ancestor) {
        bookKeeping.ancestors.push(ancestor);
        ancestor = findParent(ancestor);
      }
      for (var i = 0,
          l = bookKeeping.ancestors.length; i < l; i++) {
        topLevelTarget = bookKeeping.ancestors[i];
        var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent);
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function(handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function(enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function() {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return null;
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return null;
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      monitorScrollValue: function(refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, 'scroll', callback);
      },
      dispatchEvent: function(topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("82", ["2c", "45", "51", "29", "4a", "49", "20", "5b", "1b", "13", "24"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMProperty = require("2c");
  var EventPluginHub = require("45");
  var ReactComponentEnvironment = require("51");
  var ReactClass = require("29");
  var ReactEmptyComponent = require("4a");
  var ReactBrowserEventEmitter = require("49");
  var ReactNativeComponent = require("20");
  var ReactDOMComponent = require("5b");
  var ReactPerf = require("1b");
  var ReactRootIndex = require("13");
  var ReactUpdates = require("24");
  var ReactInjection = {
    Component: ReactComponentEnvironment.injection,
    Class: ReactClass.injection,
    DOMComponent: ReactDOMComponent.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    NativeComponent: ReactNativeComponent.injection,
    Perf: ReactPerf.injection,
    RootIndex: ReactRootIndex.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("83", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;
    while (node) {
      if (node.nodeType === 3) {
        nodeEnd = nodeStart + node.textContent.length;
        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }
        nodeStart = nodeEnd;
      }
      node = getLeafNode(getSiblingNode(node));
    }
  }
  module.exports = getNodeForCharacterOffset;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("84", ["31", "83", "5e"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("31");
  var getNodeForCharacterOffset = require("83");
  var getTextContentAccessor = require("5e");
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start,
        end;
    if (typeof offsets.end === 'undefined') {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = (ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window));
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("85", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function getActiveElement() {
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }
  module.exports = getActiveElement;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("86", ["84", "4f", "72", "85"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactDOMSelection = require("84");
  var containsNode = require("4f");
  var focusNode = require("72");
  var getActiveElement = require("85");
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function(elem) {
      return elem && (((elem.nodeName === 'INPUT' && elem.type === 'text') || elem.nodeName === 'TEXTAREA' || elem.contentEditable === 'true'));
    },
    getSelectionInformation: function() {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function(priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function(input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && input.nodeName === 'INPUT') {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function(input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (typeof end === 'undefined') {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && input.nodeName === 'INPUT') {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("87", ["a", "49", "b"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var PooledClass = require("a");
  var ReactBrowserEventEmitter = require("49");
  var assign = require("b");
  function ReactPutListenerQueue() {
    this.listenersToPut = [];
  }
  assign(ReactPutListenerQueue.prototype, {
    enqueuePutListener: function(rootNodeID, propKey, propValue) {
      this.listenersToPut.push({
        rootNodeID: rootNodeID,
        propKey: propKey,
        propValue: propValue
      });
    },
    putListeners: function() {
      for (var i = 0; i < this.listenersToPut.length; i++) {
        var listenerToPut = this.listenersToPut[i];
        ReactBrowserEventEmitter.putListener(listenerToPut.rootNodeID, listenerToPut.propKey, listenerToPut.propValue);
      }
    },
    reset: function() {
      this.listenersToPut.length = 0;
    },
    destructor: function() {
      this.reset();
    }
  });
  PooledClass.addPoolingTo(ReactPutListenerQueue);
  module.exports = ReactPutListenerQueue;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("88", ["1a", "a", "49", "86", "87", "23", "b"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var CallbackQueue = require("1a");
  var PooledClass = require("a");
  var ReactBrowserEventEmitter = require("49");
  var ReactInputSelection = require("86");
  var ReactPutListenerQueue = require("87");
  var Transaction = require("23");
  var assign = require("b");
  var SELECTION_RESTORATION = {
    initialize: ReactInputSelection.getSelectionInformation,
    close: ReactInputSelection.restoreSelection
  };
  var EVENT_SUPPRESSION = {
    initialize: function() {
      var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
      ReactBrowserEventEmitter.setEnabled(false);
      return currentlyEnabled;
    },
    close: function(previouslyEnabled) {
      ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
    }
  };
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: function() {
      this.reactMountReady.notifyAll();
    }
  };
  var PUT_LISTENER_QUEUEING = {
    initialize: function() {
      this.putListenerQueue.reset();
    },
    close: function() {
      this.putListenerQueue.putListeners();
    }
  };
  var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
  function ReactReconcileTransaction() {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = false;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.putListenerQueue = ReactPutListenerQueue.getPooled();
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getPutListenerQueue: function() {
      return this.putListenerQueue;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
      ReactPutListenerQueue.release(this.putListenerQueue);
      this.putListenerQueue = null;
    }
  };
  assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactReconcileTransaction);
  module.exports = ReactReconcileTransaction;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("89", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    var key;
    for (key in objA) {
      if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
        return false;
      }
    }
    for (key in objB) {
      if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }
  module.exports = shallowEqual;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8a", ["8", "5d", "86", "61", "85", "65", "28", "89"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("8");
  var EventPropagators = require("5d");
  var ReactInputSelection = require("86");
  var SyntheticEvent = require("61");
  var getActiveElement = require("85");
  var isTextInputElement = require("65");
  var keyOf = require("28");
  var shallowEqual = require("89");
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {select: {
      phasedRegistrationNames: {
        bubbled: keyOf({onSelect: null}),
        captured: keyOf({onSelectCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
    }};
  var activeElement = null;
  var activeElementID = null;
  var lastSelection = null;
  var mouseDown = false;
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent) {
    if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
      return null;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      switch (topLevelType) {
        case topLevelTypes.topFocus:
          if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
            activeElement = topLevelTarget;
            activeElementID = topLevelTargetID;
            lastSelection = null;
          }
          break;
        case topLevelTypes.topBlur:
          activeElement = null;
          activeElementID = null;
          lastSelection = null;
          break;
        case topLevelTypes.topMouseDown:
          mouseDown = true;
          break;
        case topLevelTypes.topContextMenu:
        case topLevelTypes.topMouseUp:
          mouseDown = false;
          return constructSelectEvent(nativeEvent);
        case topLevelTypes.topSelectionChange:
        case topLevelTypes.topKeyDown:
        case topLevelTypes.topKeyUp:
          return constructSelectEvent(nativeEvent);
      }
    }
  };
  module.exports = SelectEventPlugin;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8b", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
  var ServerReactRootIndex = {createReactRootIndex: function() {
      return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
    }};
  module.exports = ServerReactRootIndex;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8c", ["61"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticEvent = require("61");
  var ClipboardEventInterface = {clipboardData: function(event) {
      return ('clipboardData' in event ? event.clipboardData : window.clipboardData);
    }};
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8d", ["69"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticUIEvent = require("69");
  var FocusEventInterface = {relatedTarget: null};
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8e", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;
    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      charCode = keyCode;
    }
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }
    return 0;
  }
  module.exports = getEventCharCode;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8f", ["8e"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var getEventCharCode = require("8e");
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("90", ["69", "8e", "8f", "6a"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticUIEvent = require("69");
  var getEventCharCode = require("8e");
  var getEventKey = require("8f");
  var getEventModifierState = require("6a");
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function(event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("91", ["6b"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticMouseEvent = require("6b");
  var DragEventInterface = {dataTransfer: null};
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("92", ["69", "6a"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticUIEvent = require("69");
  var getEventModifierState = require("6a");
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("93", ["6b"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticMouseEvent = require("6b");
  var WheelEventInterface = {
    deltaX: function(event) {
      return ('deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0);
    },
    deltaY: function(event) {
      return ('deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0);
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("94", ["8", "9", "5d", "8c", "61", "8d", "90", "6b", "91", "92", "69", "93", "8e", "6", "28", "e", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("8");
    var EventPluginUtils = require("9");
    var EventPropagators = require("5d");
    var SyntheticClipboardEvent = require("8c");
    var SyntheticEvent = require("61");
    var SyntheticFocusEvent = require("8d");
    var SyntheticKeyboardEvent = require("90");
    var SyntheticMouseEvent = require("6b");
    var SyntheticDragEvent = require("91");
    var SyntheticTouchEvent = require("92");
    var SyntheticUIEvent = require("69");
    var SyntheticWheelEvent = require("93");
    var getEventCharCode = require("8e");
    var invariant = require("6");
    var keyOf = require("28");
    var warning = require("e");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      blur: {phasedRegistrationNames: {
          bubbled: keyOf({onBlur: true}),
          captured: keyOf({onBlurCapture: true})
        }},
      click: {phasedRegistrationNames: {
          bubbled: keyOf({onClick: true}),
          captured: keyOf({onClickCapture: true})
        }},
      contextMenu: {phasedRegistrationNames: {
          bubbled: keyOf({onContextMenu: true}),
          captured: keyOf({onContextMenuCapture: true})
        }},
      copy: {phasedRegistrationNames: {
          bubbled: keyOf({onCopy: true}),
          captured: keyOf({onCopyCapture: true})
        }},
      cut: {phasedRegistrationNames: {
          bubbled: keyOf({onCut: true}),
          captured: keyOf({onCutCapture: true})
        }},
      doubleClick: {phasedRegistrationNames: {
          bubbled: keyOf({onDoubleClick: true}),
          captured: keyOf({onDoubleClickCapture: true})
        }},
      drag: {phasedRegistrationNames: {
          bubbled: keyOf({onDrag: true}),
          captured: keyOf({onDragCapture: true})
        }},
      dragEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnd: true}),
          captured: keyOf({onDragEndCapture: true})
        }},
      dragEnter: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnter: true}),
          captured: keyOf({onDragEnterCapture: true})
        }},
      dragExit: {phasedRegistrationNames: {
          bubbled: keyOf({onDragExit: true}),
          captured: keyOf({onDragExitCapture: true})
        }},
      dragLeave: {phasedRegistrationNames: {
          bubbled: keyOf({onDragLeave: true}),
          captured: keyOf({onDragLeaveCapture: true})
        }},
      dragOver: {phasedRegistrationNames: {
          bubbled: keyOf({onDragOver: true}),
          captured: keyOf({onDragOverCapture: true})
        }},
      dragStart: {phasedRegistrationNames: {
          bubbled: keyOf({onDragStart: true}),
          captured: keyOf({onDragStartCapture: true})
        }},
      drop: {phasedRegistrationNames: {
          bubbled: keyOf({onDrop: true}),
          captured: keyOf({onDropCapture: true})
        }},
      focus: {phasedRegistrationNames: {
          bubbled: keyOf({onFocus: true}),
          captured: keyOf({onFocusCapture: true})
        }},
      input: {phasedRegistrationNames: {
          bubbled: keyOf({onInput: true}),
          captured: keyOf({onInputCapture: true})
        }},
      keyDown: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyDown: true}),
          captured: keyOf({onKeyDownCapture: true})
        }},
      keyPress: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyPress: true}),
          captured: keyOf({onKeyPressCapture: true})
        }},
      keyUp: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyUp: true}),
          captured: keyOf({onKeyUpCapture: true})
        }},
      load: {phasedRegistrationNames: {
          bubbled: keyOf({onLoad: true}),
          captured: keyOf({onLoadCapture: true})
        }},
      error: {phasedRegistrationNames: {
          bubbled: keyOf({onError: true}),
          captured: keyOf({onErrorCapture: true})
        }},
      mouseDown: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseDown: true}),
          captured: keyOf({onMouseDownCapture: true})
        }},
      mouseMove: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseMove: true}),
          captured: keyOf({onMouseMoveCapture: true})
        }},
      mouseOut: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOut: true}),
          captured: keyOf({onMouseOutCapture: true})
        }},
      mouseOver: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOver: true}),
          captured: keyOf({onMouseOverCapture: true})
        }},
      mouseUp: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseUp: true}),
          captured: keyOf({onMouseUpCapture: true})
        }},
      paste: {phasedRegistrationNames: {
          bubbled: keyOf({onPaste: true}),
          captured: keyOf({onPasteCapture: true})
        }},
      reset: {phasedRegistrationNames: {
          bubbled: keyOf({onReset: true}),
          captured: keyOf({onResetCapture: true})
        }},
      scroll: {phasedRegistrationNames: {
          bubbled: keyOf({onScroll: true}),
          captured: keyOf({onScrollCapture: true})
        }},
      submit: {phasedRegistrationNames: {
          bubbled: keyOf({onSubmit: true}),
          captured: keyOf({onSubmitCapture: true})
        }},
      touchCancel: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchCancel: true}),
          captured: keyOf({onTouchCancelCapture: true})
        }},
      touchEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchEnd: true}),
          captured: keyOf({onTouchEndCapture: true})
        }},
      touchMove: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchMove: true}),
          captured: keyOf({onTouchMoveCapture: true})
        }},
      touchStart: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchStart: true}),
          captured: keyOf({onTouchStartCapture: true})
        }},
      wheel: {phasedRegistrationNames: {
          bubbled: keyOf({onWheel: true}),
          captured: keyOf({onWheelCapture: true})
        }}
    };
    var topLevelEventsToDispatchConfig = {
      topBlur: eventTypes.blur,
      topClick: eventTypes.click,
      topContextMenu: eventTypes.contextMenu,
      topCopy: eventTypes.copy,
      topCut: eventTypes.cut,
      topDoubleClick: eventTypes.doubleClick,
      topDrag: eventTypes.drag,
      topDragEnd: eventTypes.dragEnd,
      topDragEnter: eventTypes.dragEnter,
      topDragExit: eventTypes.dragExit,
      topDragLeave: eventTypes.dragLeave,
      topDragOver: eventTypes.dragOver,
      topDragStart: eventTypes.dragStart,
      topDrop: eventTypes.drop,
      topError: eventTypes.error,
      topFocus: eventTypes.focus,
      topInput: eventTypes.input,
      topKeyDown: eventTypes.keyDown,
      topKeyPress: eventTypes.keyPress,
      topKeyUp: eventTypes.keyUp,
      topLoad: eventTypes.load,
      topMouseDown: eventTypes.mouseDown,
      topMouseMove: eventTypes.mouseMove,
      topMouseOut: eventTypes.mouseOut,
      topMouseOver: eventTypes.mouseOver,
      topMouseUp: eventTypes.mouseUp,
      topPaste: eventTypes.paste,
      topReset: eventTypes.reset,
      topScroll: eventTypes.scroll,
      topSubmit: eventTypes.submit,
      topTouchCancel: eventTypes.touchCancel,
      topTouchEnd: eventTypes.touchEnd,
      topTouchMove: eventTypes.touchMove,
      topTouchStart: eventTypes.touchStart,
      topWheel: eventTypes.wheel
    };
    for (var type in topLevelEventsToDispatchConfig) {
      topLevelEventsToDispatchConfig[type].dependencies = [type];
    }
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      executeDispatch: function(event, listener, domID) {
        var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
        ("production" !== process.env.NODE_ENV ? warning(typeof returnValue !== 'boolean', 'Returning `false` from an event handler is deprecated and will be ' + 'ignored in a future release. Instead, manually call ' + 'e.stopPropagation() or e.preventDefault(), as appropriate.') : null);
        if (returnValue === false) {
          event.stopPropagation();
          event.preventDefault();
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case topLevelTypes.topInput:
          case topLevelTypes.topLoad:
          case topLevelTypes.topError:
          case topLevelTypes.topReset:
          case topLevelTypes.topSubmit:
            EventConstructor = SyntheticEvent;
            break;
          case topLevelTypes.topKeyPress:
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case topLevelTypes.topKeyDown:
          case topLevelTypes.topKeyUp:
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case topLevelTypes.topBlur:
          case topLevelTypes.topFocus:
            EventConstructor = SyntheticFocusEvent;
            break;
          case topLevelTypes.topClick:
            if (nativeEvent.button === 2) {
              return null;
            }
          case topLevelTypes.topContextMenu:
          case topLevelTypes.topDoubleClick:
          case topLevelTypes.topMouseDown:
          case topLevelTypes.topMouseMove:
          case topLevelTypes.topMouseOut:
          case topLevelTypes.topMouseOver:
          case topLevelTypes.topMouseUp:
            EventConstructor = SyntheticMouseEvent;
            break;
          case topLevelTypes.topDrag:
          case topLevelTypes.topDragEnd:
          case topLevelTypes.topDragEnter:
          case topLevelTypes.topDragExit:
          case topLevelTypes.topDragLeave:
          case topLevelTypes.topDragOver:
          case topLevelTypes.topDragStart:
          case topLevelTypes.topDrop:
            EventConstructor = SyntheticDragEvent;
            break;
          case topLevelTypes.topTouchCancel:
          case topLevelTypes.topTouchEnd:
          case topLevelTypes.topTouchMove:
          case topLevelTypes.topTouchStart:
            EventConstructor = SyntheticTouchEvent;
            break;
          case topLevelTypes.topScroll:
            EventConstructor = SyntheticUIEvent;
            break;
          case topLevelTypes.topWheel:
            EventConstructor = SyntheticWheelEvent;
            break;
          case topLevelTypes.topCopy:
          case topLevelTypes.topCut:
          case topLevelTypes.topPaste:
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        ("production" !== process.env.NODE_ENV ? invariant(EventConstructor, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(EventConstructor));
        var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    };
    module.exports = SimpleEventPlugin;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("95", ["2c"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMProperty = require("2c");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var SVGDOMPropertyConfig = {
    Properties: {
      clipPath: MUST_USE_ATTRIBUTE,
      cx: MUST_USE_ATTRIBUTE,
      cy: MUST_USE_ATTRIBUTE,
      d: MUST_USE_ATTRIBUTE,
      dx: MUST_USE_ATTRIBUTE,
      dy: MUST_USE_ATTRIBUTE,
      fill: MUST_USE_ATTRIBUTE,
      fillOpacity: MUST_USE_ATTRIBUTE,
      fontFamily: MUST_USE_ATTRIBUTE,
      fontSize: MUST_USE_ATTRIBUTE,
      fx: MUST_USE_ATTRIBUTE,
      fy: MUST_USE_ATTRIBUTE,
      gradientTransform: MUST_USE_ATTRIBUTE,
      gradientUnits: MUST_USE_ATTRIBUTE,
      markerEnd: MUST_USE_ATTRIBUTE,
      markerMid: MUST_USE_ATTRIBUTE,
      markerStart: MUST_USE_ATTRIBUTE,
      offset: MUST_USE_ATTRIBUTE,
      opacity: MUST_USE_ATTRIBUTE,
      patternContentUnits: MUST_USE_ATTRIBUTE,
      patternUnits: MUST_USE_ATTRIBUTE,
      points: MUST_USE_ATTRIBUTE,
      preserveAspectRatio: MUST_USE_ATTRIBUTE,
      r: MUST_USE_ATTRIBUTE,
      rx: MUST_USE_ATTRIBUTE,
      ry: MUST_USE_ATTRIBUTE,
      spreadMethod: MUST_USE_ATTRIBUTE,
      stopColor: MUST_USE_ATTRIBUTE,
      stopOpacity: MUST_USE_ATTRIBUTE,
      stroke: MUST_USE_ATTRIBUTE,
      strokeDasharray: MUST_USE_ATTRIBUTE,
      strokeLinecap: MUST_USE_ATTRIBUTE,
      strokeOpacity: MUST_USE_ATTRIBUTE,
      strokeWidth: MUST_USE_ATTRIBUTE,
      textAnchor: MUST_USE_ATTRIBUTE,
      transform: MUST_USE_ATTRIBUTE,
      version: MUST_USE_ATTRIBUTE,
      viewBox: MUST_USE_ATTRIBUTE,
      x1: MUST_USE_ATTRIBUTE,
      x2: MUST_USE_ATTRIBUTE,
      x: MUST_USE_ATTRIBUTE,
      y1: MUST_USE_ATTRIBUTE,
      y2: MUST_USE_ATTRIBUTE,
      y: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNames: {
      clipPath: 'clip-path',
      fillOpacity: 'fill-opacity',
      fontFamily: 'font-family',
      fontSize: 'font-size',
      gradientTransform: 'gradientTransform',
      gradientUnits: 'gradientUnits',
      markerEnd: 'marker-end',
      markerMid: 'marker-mid',
      markerStart: 'marker-start',
      patternContentUnits: 'patternContentUnits',
      patternUnits: 'patternUnits',
      preserveAspectRatio: 'preserveAspectRatio',
      spreadMethod: 'spreadMethod',
      stopColor: 'stop-color',
      stopOpacity: 'stop-opacity',
      strokeDasharray: 'stroke-dasharray',
      strokeLinecap: 'stroke-linecap',
      strokeOpacity: 'stroke-opacity',
      strokeWidth: 'stroke-width',
      textAnchor: 'text-anchor',
      viewBox: 'viewBox'
    }
  };
  module.exports = SVGDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("96", ["29", "11", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactClass = require("29");
    var ReactElement = require("11");
    var invariant = require("6");
    function createFullPageComponent(tag) {
      var elementFactory = ReactElement.createFactory(tag);
      var FullPageComponent = ReactClass.createClass({
        tagName: tag.toUpperCase(),
        displayName: 'ReactFullPageComponent' + tag,
        componentWillUnmount: function() {
          ("production" !== process.env.NODE_ENV ? invariant(false, '%s tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, <head>, ' + 'and <body>) reliably and efficiently. To fix this, have a single ' + 'top-level component that never unmounts render these elements.', this.constructor.displayName) : invariant(false));
        },
        render: function() {
          return elementFactory(this.props);
        }
      });
      return FullPageComponent;
    }
    module.exports = createFullPageComponent;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("97", ["b"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assign = require("b");
  var DONT_CARE_THRESHOLD = 1.2;
  var DOM_OPERATION_TYPES = {
    '_mountImageIntoNode': 'set innerHTML',
    INSERT_MARKUP: 'set innerHTML',
    MOVE_EXISTING: 'move',
    REMOVE_NODE: 'remove',
    TEXT_CONTENT: 'set textContent',
    'updatePropertyByID': 'update attribute',
    'deletePropertyByID': 'delete attribute',
    'updateStylesByID': 'update styles',
    'updateInnerHTMLByID': 'set innerHTML',
    'dangerouslyReplaceNodeWithMarkupByID': 'replace'
  };
  function getTotalTime(measurements) {
    var totalTime = 0;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      totalTime += measurement.totalTime;
    }
    return totalTime;
  }
  function getDOMSummary(measurements) {
    var items = [];
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var id;
      for (id in measurement.writes) {
        measurement.writes[id].forEach(function(write) {
          items.push({
            id: id,
            type: DOM_OPERATION_TYPES[write.type] || write.type,
            args: write.args
          });
        });
      }
    }
    return items;
  }
  function getExclusiveSummary(measurements) {
    var candidates = {};
    var displayName;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      for (var id in allIDs) {
        displayName = measurement.displayNames[id].current;
        candidates[displayName] = candidates[displayName] || {
          componentName: displayName,
          inclusive: 0,
          exclusive: 0,
          render: 0,
          count: 0
        };
        if (measurement.render[id]) {
          candidates[displayName].render += measurement.render[id];
        }
        if (measurement.exclusive[id]) {
          candidates[displayName].exclusive += measurement.exclusive[id];
        }
        if (measurement.inclusive[id]) {
          candidates[displayName].inclusive += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[displayName].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (displayName in candidates) {
      if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[displayName]);
      }
    }
    arr.sort(function(a, b) {
      return b.exclusive - a.exclusive;
    });
    return arr;
  }
  function getInclusiveSummary(measurements, onlyClean) {
    var candidates = {};
    var inclusiveKey;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      var cleanComponents;
      if (onlyClean) {
        cleanComponents = getUnchangedComponents(measurement);
      }
      for (var id in allIDs) {
        if (onlyClean && !cleanComponents[id]) {
          continue;
        }
        var displayName = measurement.displayNames[id];
        inclusiveKey = displayName.owner + ' > ' + displayName.current;
        candidates[inclusiveKey] = candidates[inclusiveKey] || {
          componentName: inclusiveKey,
          time: 0,
          count: 0
        };
        if (measurement.inclusive[id]) {
          candidates[inclusiveKey].time += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[inclusiveKey].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (inclusiveKey in candidates) {
      if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[inclusiveKey]);
      }
    }
    arr.sort(function(a, b) {
      return b.time - a.time;
    });
    return arr;
  }
  function getUnchangedComponents(measurement) {
    var cleanComponents = {};
    var dirtyLeafIDs = Object.keys(measurement.writes);
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    for (var id in allIDs) {
      var isDirty = false;
      for (var i = 0; i < dirtyLeafIDs.length; i++) {
        if (dirtyLeafIDs[i].indexOf(id) === 0) {
          isDirty = true;
          break;
        }
      }
      if (!isDirty && measurement.counts[id] > 0) {
        cleanComponents[id] = true;
      }
    }
    return cleanComponents;
  }
  var ReactDefaultPerfAnalysis = {
    getExclusiveSummary: getExclusiveSummary,
    getInclusiveSummary: getInclusiveSummary,
    getDOMSummary: getDOMSummary,
    getTotalTime: getTotalTime
  };
  module.exports = ReactDefaultPerfAnalysis;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("98", ["31"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("31");
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("99", ["98"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var performance = require("98");
  if (!performance || !performance.now) {
    performance = Date;
  }
  var performanceNow = performance.now.bind(performance);
  module.exports = performanceNow;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9a", ["2c", "97", "55", "1b", "99"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMProperty = require("2c");
  var ReactDefaultPerfAnalysis = require("97");
  var ReactMount = require("55");
  var ReactPerf = require("1b");
  var performanceNow = require("99");
  function roundFloat(val) {
    return Math.floor(val * 100) / 100;
  }
  function addValue(obj, key, val) {
    obj[key] = (obj[key] || 0) + val;
  }
  var ReactDefaultPerf = {
    _allMeasurements: [],
    _mountStack: [0],
    _injected: false,
    start: function() {
      if (!ReactDefaultPerf._injected) {
        ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
      }
      ReactDefaultPerf._allMeasurements.length = 0;
      ReactPerf.enableMeasure = true;
    },
    stop: function() {
      ReactPerf.enableMeasure = false;
    },
    getLastMeasurements: function() {
      return ReactDefaultPerf._allMeasurements;
    },
    printExclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Component class name': item.componentName,
          'Total inclusive time (ms)': roundFloat(item.inclusive),
          'Exclusive mount time (ms)': roundFloat(item.exclusive),
          'Exclusive render time (ms)': roundFloat(item.render),
          'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
          'Render time per instance (ms)': roundFloat(item.render / item.count),
          'Instances': item.count
        };
      }));
    },
    printInclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Inclusive time (ms)': roundFloat(item.time),
          'Instances': item.count
        };
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    getMeasurementsSummaryMap: function(measurements) {
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
      return summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Wasted time (ms)': item.time,
          'Instances': item.count
        };
      });
    },
    printWasted: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    printDOM: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
      console.table(summary.map(function(item) {
        var result = {};
        result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
        result['type'] = item.type;
        result['args'] = JSON.stringify(item.args);
        return result;
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    _recordWrite: function(id, fnName, totalTime, args) {
      var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
      writes[id] = writes[id] || [];
      writes[id].push({
        type: fnName,
        time: totalTime,
        args: args
      });
    },
    measure: function(moduleName, fnName, func) {
      return function() {
        for (var args = [],
            $__0 = 0,
            $__1 = arguments.length; $__0 < $__1; $__0++)
          args.push(arguments[$__0]);
        var totalTime;
        var rv;
        var start;
        if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
          ReactDefaultPerf._allMeasurements.push({
            exclusive: {},
            inclusive: {},
            render: {},
            counts: {},
            writes: {},
            displayNames: {},
            totalTime: 0
          });
          start = performanceNow();
          rv = func.apply(this, args);
          ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
          return rv;
        } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactDOMIDOperations') {
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (fnName === '_mountImageIntoNode') {
            var mountID = ReactMount.getID(args[1]);
            ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
          } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
            args[0].forEach(function(update) {
              var writeArgs = {};
              if (update.fromIndex !== null) {
                writeArgs.fromIndex = update.fromIndex;
              }
              if (update.toIndex !== null) {
                writeArgs.toIndex = update.toIndex;
              }
              if (update.textContent !== null) {
                writeArgs.textContent = update.textContent;
              }
              if (update.markupIndex !== null) {
                writeArgs.markup = args[1][update.markupIndex];
              }
              ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
            });
          } else {
            ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
          }
          return rv;
        } else if (moduleName === 'ReactCompositeComponent' && (((fnName === 'mountComponent' || fnName === 'updateComponent' || fnName === '_renderValidatedComponent')))) {
          if (typeof this._currentElement.type === 'string') {
            return func.apply(this, args);
          }
          var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
          var isRender = fnName === '_renderValidatedComponent';
          var isMount = fnName === 'mountComponent';
          var mountStack = ReactDefaultPerf._mountStack;
          var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
          if (isRender) {
            addValue(entry.counts, rootNodeID, 1);
          } else if (isMount) {
            mountStack.push(0);
          }
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (isRender) {
            addValue(entry.render, rootNodeID, totalTime);
          } else if (isMount) {
            var subMountTime = mountStack.pop();
            mountStack[mountStack.length - 1] += totalTime;
            addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
            addValue(entry.inclusive, rootNodeID, totalTime);
          } else {
            addValue(entry.inclusive, rootNodeID, totalTime);
          }
          entry.displayNames[rootNodeID] = {
            current: this.getName(),
            owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
          };
          return rv;
        } else {
          return func.apply(this, args);
        }
      };
    }
  };
  module.exports = ReactDefaultPerf;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9b", ["64", "66", "67", "68", "6c", "31", "6d", "6e", "70", "29", "57", "71", "5b", "74", "76", "77", "56", "78", "7b", "7c", "7d", "7e", "5c", "11", "81", "82", "14", "55", "88", "8a", "8b", "94", "95", "96", "9a", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var BeforeInputEventPlugin = require("64");
    var ChangeEventPlugin = require("66");
    var ClientReactRootIndex = require("67");
    var DefaultEventPluginOrder = require("68");
    var EnterLeaveEventPlugin = require("6c");
    var ExecutionEnvironment = require("31");
    var HTMLDOMPropertyConfig = require("6d");
    var MobileSafariClickEventPlugin = require("6e");
    var ReactBrowserComponentMixin = require("70");
    var ReactClass = require("29");
    var ReactComponentBrowserEnvironment = require("57");
    var ReactDefaultBatchingStrategy = require("71");
    var ReactDOMComponent = require("5b");
    var ReactDOMButton = require("74");
    var ReactDOMForm = require("76");
    var ReactDOMImg = require("77");
    var ReactDOMIDOperations = require("56");
    var ReactDOMIframe = require("78");
    var ReactDOMInput = require("7b");
    var ReactDOMOption = require("7c");
    var ReactDOMSelect = require("7d");
    var ReactDOMTextarea = require("7e");
    var ReactDOMTextComponent = require("5c");
    var ReactElement = require("11");
    var ReactEventListener = require("81");
    var ReactInjection = require("82");
    var ReactInstanceHandles = require("14");
    var ReactMount = require("55");
    var ReactReconcileTransaction = require("88");
    var SelectEventPlugin = require("8a");
    var ServerReactRootIndex = require("8b");
    var SimpleEventPlugin = require("94");
    var SVGDOMPropertyConfig = require("95");
    var createFullPageComponent = require("96");
    function autoGenerateWrapperClass(type) {
      return ReactClass.createClass({
        tagName: type.toUpperCase(),
        render: function() {
          return new ReactElement(type, null, null, null, null, this.props);
        }
      });
    }
    function inject() {
      ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
      ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
      ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
      ReactInjection.EventPluginHub.injectMount(ReactMount);
      ReactInjection.EventPluginHub.injectEventPluginsByName({
        SimpleEventPlugin: SimpleEventPlugin,
        EnterLeaveEventPlugin: EnterLeaveEventPlugin,
        ChangeEventPlugin: ChangeEventPlugin,
        MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
        SelectEventPlugin: SelectEventPlugin,
        BeforeInputEventPlugin: BeforeInputEventPlugin
      });
      ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
      ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
      ReactInjection.NativeComponent.injectAutoWrapper(autoGenerateWrapperClass);
      ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
      ReactInjection.NativeComponent.injectComponentClasses({
        'button': ReactDOMButton,
        'form': ReactDOMForm,
        'iframe': ReactDOMIframe,
        'img': ReactDOMImg,
        'input': ReactDOMInput,
        'option': ReactDOMOption,
        'select': ReactDOMSelect,
        'textarea': ReactDOMTextarea,
        'html': createFullPageComponent('html'),
        'head': createFullPageComponent('head'),
        'body': createFullPageComponent('body')
      });
      ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
      ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
      ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
      ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
      ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
      ReactInjection.DOMComponent.injectIDOperations(ReactDOMIDOperations);
      if ("production" !== process.env.NODE_ENV) {
        var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';
        if ((/[?&]react_perf\b/).test(url)) {
          var ReactDefaultPerf = require("9a");
          ReactDefaultPerf.start();
        }
      }
    }
    module.exports = {inject: inject};
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9c", ["a", "1a", "87", "23", "b", "d"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var PooledClass = require("a");
  var CallbackQueue = require("1a");
  var ReactPutListenerQueue = require("87");
  var Transaction = require("23");
  var assign = require("b");
  var emptyFunction = require("d");
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: emptyFunction
  };
  var PUT_LISTENER_QUEUEING = {
    initialize: function() {
      this.putListenerQueue.reset();
    },
    close: emptyFunction
  };
  var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, ON_DOM_READY_QUEUEING];
  function ReactServerRenderingTransaction(renderToStaticMarkup) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = renderToStaticMarkup;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.putListenerQueue = ReactPutListenerQueue.getPooled();
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getPutListenerQueue: function() {
      return this.putListenerQueue;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
      ReactPutListenerQueue.release(this.putListenerQueue);
      this.putListenerQueue = null;
    }
  };
  assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactServerRenderingTransaction);
  module.exports = ReactServerRenderingTransaction;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9d", ["11", "14", "4c", "9c", "c", "54", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("11");
    var ReactInstanceHandles = require("14");
    var ReactMarkupChecksum = require("4c");
    var ReactServerRenderingTransaction = require("9c");
    var emptyObject = require("c");
    var instantiateReactComponent = require("54");
    var invariant = require("6");
    function renderToString(element) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), 'renderToString(): You must pass a valid ReactElement.') : invariant(ReactElement.isValidElement(element)));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(false);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          var markup = componentInstance.mountComponent(id, transaction, emptyObject);
          return ReactMarkupChecksum.addChecksumToMarkup(markup);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    function renderToStaticMarkup(element) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(ReactElement.isValidElement(element)));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(true);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          return componentInstance.mountComponent(id, transaction, emptyObject);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    module.exports = {
      renderToString: renderToString,
      renderToStaticMarkup: renderToStaticMarkup
    };
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9e", ["11", "6", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("11");
    var invariant = require("6");
    function onlyChild(children) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(children), 'onlyChild must be passed a children with exactly one child.') : invariant(ReactElement.isValidElement(children)));
      return children;
    }
    module.exports = onlyChild;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9f", ["9", "17", "26", "29", "f", "10", "11", "21", "2b", "5c", "9b", "14", "55", "1b", "79", "22", "9d", "b", "6f", "9e", "31", "5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventPluginUtils = require("9");
    var ReactChildren = require("17");
    var ReactComponent = require("26");
    var ReactClass = require("29");
    var ReactContext = require("f");
    var ReactCurrentOwner = require("10");
    var ReactElement = require("11");
    var ReactElementValidator = require("21");
    var ReactDOM = require("2b");
    var ReactDOMTextComponent = require("5c");
    var ReactDefaultInjection = require("9b");
    var ReactInstanceHandles = require("14");
    var ReactMount = require("55");
    var ReactPerf = require("1b");
    var ReactPropTypes = require("79");
    var ReactReconciler = require("22");
    var ReactServerRendering = require("9d");
    var assign = require("b");
    var findDOMNode = require("6f");
    var onlyChild = require("9e");
    ReactDefaultInjection.inject();
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    var cloneElement = ReactElement.cloneElement;
    if ("production" !== process.env.NODE_ENV) {
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
      cloneElement = ReactElementValidator.cloneElement;
    }
    var render = ReactPerf.measure('React', 'render', ReactMount.render);
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        only: onlyChild
      },
      Component: ReactComponent,
      DOM: ReactDOM,
      PropTypes: ReactPropTypes,
      initializeTouchEvents: function(shouldUseTouch) {
        EventPluginUtils.useTouchEvents = shouldUseTouch;
      },
      createClass: ReactClass.createClass,
      createElement: createElement,
      cloneElement: cloneElement,
      createFactory: createFactory,
      createMixin: function(mixin) {
        return mixin;
      },
      constructAndRenderComponent: ReactMount.constructAndRenderComponent,
      constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
      findDOMNode: findDOMNode,
      render: render,
      renderToString: ReactServerRendering.renderToString,
      renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      isValidElement: ReactElement.isValidElement,
      withContext: ReactContext.withContext,
      __spread: assign
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        CurrentOwner: ReactCurrentOwner,
        InstanceHandles: ReactInstanceHandles,
        Mount: ReactMount,
        Reconciler: ReactReconciler,
        TextComponent: ReactDOMTextComponent
      });
    }
    if ("production" !== process.env.NODE_ENV) {
      var ExecutionEnvironment = require("31");
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (navigator.userAgent.indexOf('Chrome') > -1) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
            console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
          }
        }
        var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
            break;
          }
        }
      }
    }
    React.version = '0.13.3';
    module.exports = React;
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a0", ["9f"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("9f");
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a1", ["a0"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("a0");
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a2", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a3", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a4", ["a3"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = require("a3");
  module.exports = 0 in Object('z') ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a5", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a6", ["a4", "a5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = require("a4"),
      defined = require("a5");
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a7", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var UNDEFINED = 'undefined';
  var global = module.exports = typeof window != UNDEFINED && window.Math == Math ? window : typeof self != UNDEFINED && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a8", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.0'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a9", ["a7", "a8"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = require("a7"),
      core = require("a8"),
      PROTOTYPE = 'prototype';
  var ctx = function(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var $def = function(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] : (global[name] || {})[PROTOTYPE],
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      if (isGlobal && typeof target[key] != 'function')
        exp = source[key];
      else if (type & $def.B && own)
        exp = ctx(out, global);
      else if (type & $def.W && target[key] == out)
        !function(C) {
          exp = function(param) {
            return this instanceof C ? new C(param) : C(param);
          };
          exp[PROTOTYPE] = C[PROTOTYPE];
        }(out);
      else
        exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
      exports[key] = exp;
      if (isProto)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("aa", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ab", ["a9", "a8", "aa"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(KEY, exec) {
    var $def = require("a9"),
        fn = (require("a8").Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $def($def.S + $def.F * require("aa")(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ac", ["a6", "ab"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = require("a6");
  require("ab")('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ad", ["a2", "ac"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("a2");
  require("ac");
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ae", ["ad"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("ad"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("af", ["ae"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$getOwnPropertyDescriptor = require("ae")["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b0", ["a2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("a2");
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b1", ["b0"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("b0"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b2", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b3", ["b2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("b2");
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b4", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b5", ["b4"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = require("b4");
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b6", ["a2", "b2", "b3", "b5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = require("a2").getDesc,
      isObject = require("b2"),
      anObject = require("b3");
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = require("b5")(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b7", ["a9", "b6"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("a9");
  $def($def.S, 'Object', {setPrototypeOf: require("b6").set});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b8", ["b7", "a8"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("b7");
  module.exports = require("a8").Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b9", ["b8"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("b8"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ba", ["b1", "b9"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$create = require("b1")["default"];
  var _Object$setPrototypeOf = require("b9")["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bb", ["a2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("a2");
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bc", ["bb"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("bb"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bd", ["bc"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$defineProperty = require("bc")["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("be", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bf", ["a5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = require("a5");
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c0", ["a2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("a2");
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c1", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c2", ["bf", "a4", "c0", "c1", "aa"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = require("bf"),
      IObject = require("a4"),
      enumKeys = require("c0"),
      has = require("c1");
  module.exports = require("aa")(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        l = arguments.length,
        i = 1;
    while (l > i) {
      var S = IObject(arguments[i++]),
          keys = enumKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (has(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c3", ["a9", "c2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("a9");
  $def($def.S + $def.F, 'Object', {assign: require("c2")});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c4", ["c3", "a8"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("c3");
  module.exports = require("a8").Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c5", ["c4"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("c4"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c6", ["c5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$assign = require("c5")["default"];
  exports["default"] = _Object$assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c7", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function() {
    'use strict';
    function classNames() {
      var classes = '';
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if ('string' === argType || 'number' === argType) {
          classes += ' ' + arg;
        } else if (Array.isArray(arg)) {
          classes += ' ' + classNames.apply(null, arg);
        } else if ('object' === argType) {
          for (var key in arg) {
            if (arg.hasOwnProperty(key) && arg[key]) {
              classes += ' ' + key;
            }
          }
        }
      }
      return classes.substr(1);
    }
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = classNames;
    } else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
      define(function() {
        return classNames;
      });
    } else {
      window.classNames = classNames;
    }
  }());
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c8", ["c7"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("c7");
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c9", ["5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = mod();
      else if (typeof define == "function" && define.amd)
        return define([], mod);
      else
        this.CodeMirror = mod();
    })(function() {
      "use strict";
      var gecko = /gecko\/\d/i.test(navigator.userAgent);
      var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
      var ie = ie_upto10 || ie_11up;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
      var webkit = /WebKit\//.test(navigator.userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
      var chrome = /Chrome\//.test(navigator.userAgent);
      var presto = /Opera\//.test(navigator.userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
      var phantom = /PhantomJS/.test(navigator.userAgent);
      var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
      var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
      var mac = ios || /Mac/.test(navigator.platform);
      var windows = /win/i.test(navigator.platform);
      var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
      if (presto_version)
        presto_version = Number(presto_version[1]);
      if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
      }
      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || (ie && ie_version >= 9);
      var sawReadOnlySpans = false,
          sawCollapsedSpans = false;
      function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror))
          return new CodeMirror(place, options);
        this.options = options = options ? copyObj(options) : {};
        copyObj(defaults, options, false);
        setGuttersForLineNumbers(options);
        var doc = options.value;
        if (typeof doc == "string")
          doc = new Doc(doc, options.mode, null, options.lineSeparator);
        this.doc = doc;
        var input = new CodeMirror.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input);
        display.wrapper.CodeMirror = this;
        updateGutters(this);
        themeChanged(this);
        if (options.lineWrapping)
          this.display.wrapper.className += " CodeMirror-wrap";
        if (options.autofocus && !mobile)
          display.input.focus();
        initScrollbars(this);
        this.state = {
          keyMaps: [],
          overlays: [],
          modeGen: 0,
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          pasteIncoming: false,
          cutIncoming: false,
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(),
          keySeq: null,
          specialChars: null
        };
        var cm = this;
        if (ie && ie_version < 11)
          setTimeout(function() {
            cm.display.input.reset(true);
          }, 20);
        registerEventHandlers(this);
        ensureGlobalHandlers();
        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc);
        if ((options.autofocus && !mobile) || cm.hasFocus())
          setTimeout(bind(onFocus, this), 20);
        else
          onBlur(this);
        for (var opt in optionHandlers)
          if (optionHandlers.hasOwnProperty(opt))
            optionHandlers[opt](this, options[opt], Init);
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit)
          options.finishInit(this);
        for (var i = 0; i < initHooks.length; ++i)
          initHooks[i](this);
        endOperation(this);
        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
          display.lineDiv.style.textRendering = "auto";
      }
      function Display(place, doc, input) {
        var d = this;
        this.input = input;
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true");
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true");
        d.lineDiv = elt("div", null, "CodeMirror-code");
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors");
        d.measure = elt("div", null, "CodeMirror-measure");
        d.lineMeasure = elt("div", null, "CodeMirror-measure");
        d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
        d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        d.sizerWidth = null;
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
        if (ie && ie_version < 8) {
          d.gutters.style.zIndex = -1;
          d.scroller.style.paddingRight = 0;
        }
        if (!webkit && !(gecko && mobile))
          d.scroller.draggable = true;
        if (place) {
          if (place.appendChild)
            place.appendChild(d.wrapper);
          else
            place(d.wrapper);
        }
        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first;
        d.view = [];
        d.renderedView = null;
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
        d.activeTouch = null;
        input.init(d);
      }
      function loadMode(cm) {
        cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }
      function resetModeState(cm) {
        cm.doc.iter(function(line) {
          if (line.stateAfter)
            line.stateAfter = null;
          if (line.styles)
            line.styles = null;
        });
        cm.doc.frontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp)
          regChange(cm);
      }
      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function() {
          updateScrollbars(cm);
        }, 100);
      }
      function estimateHeight(cm) {
        var th = textHeight(cm.display),
            wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
          if (lineIsHidden(cm.doc, line))
            return 0;
          var widgetsHeight = 0;
          if (line.widgets)
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].height)
                widgetsHeight += line.widgets[i].height;
            }
          if (wrapping)
            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
          else
            return widgetsHeight + th;
        };
      }
      function estimateLineHeights(cm) {
        var doc = cm.doc,
            est = estimateHeight(cm);
        doc.iter(function(line) {
          var estHeight = est(line);
          if (estHeight != line.height)
            updateLineHeight(line, estHeight);
        });
      }
      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }
      function guttersChanged(cm) {
        updateGutters(cm);
        regChange(cm);
        setTimeout(function() {
          alignHorizontally(cm);
        }, 20);
      }
      function updateGutters(cm) {
        var gutters = cm.display.gutters,
            specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
          var gutterClass = specs[i];
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
          if (gutterClass == "CodeMirror-linenumbers") {
            cm.display.lineGutter = gElt;
            gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = i ? "" : "none";
        updateGutterSpace(cm);
      }
      function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + "px";
      }
      function lineLength(line) {
        if (line.height == 0)
          return 0;
        var len = line.text.length,
            merged,
            cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found = merged.find(0, true);
          len -= cur.text.length - found.from.ch;
          cur = found.to.line;
          len += cur.text.length - found.to.ch;
        }
        return len;
      }
      function findMaxLine(cm) {
        var d = cm.display,
            doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function(line) {
          var len = lineLength(line);
          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      }
      function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        if (found == -1 && options.lineNumbers) {
          options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
        } else if (found > -1 && !options.lineNumbers) {
          options.gutters = options.gutters.slice(0);
          options.gutters.splice(found, 1);
        }
      }
      function measureForScrollbars(cm) {
        var d = cm.display,
            gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d.scroller.clientHeight,
          viewHeight: d.wrapper.clientHeight,
          scrollWidth: d.scroller.scrollWidth,
          clientWidth: d.scroller.clientWidth,
          viewWidth: d.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d.barHeight,
          nativeBarWidth: d.nativeBarWidth,
          gutterWidth: gutterW
        };
      }
      function NativeScrollbars(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        place(vert);
        place(horiz);
        on(vert, "scroll", function() {
          if (vert.clientHeight)
            scroll(vert.scrollTop, "vertical");
        });
        on(horiz, "scroll", function() {
          if (horiz.clientWidth)
            scroll(horiz.scrollLeft, "horizontal");
        });
        this.checkedOverlay = false;
        if (ie && ie_version < 8)
          this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
      }
      NativeScrollbars.prototype = copyObj({
        update: function(measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1;
          var needsV = measure.scrollHeight > measure.clientHeight + 1;
          var sWidth = measure.nativeBarWidth;
          if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
          } else {
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
          }
          if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
          } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
          }
          if (!this.checkedOverlay && measure.clientHeight > 0) {
            if (sWidth == 0)
              this.overlayHack();
            this.checkedOverlay = true;
          }
          return {
            right: needsV ? sWidth : 0,
            bottom: needsH ? sWidth : 0
          };
        },
        setScrollLeft: function(pos) {
          if (this.horiz.scrollLeft != pos)
            this.horiz.scrollLeft = pos;
        },
        setScrollTop: function(pos) {
          if (this.vert.scrollTop != pos)
            this.vert.scrollTop = pos;
        },
        overlayHack: function() {
          var w = mac && !mac_geMountainLion ? "12px" : "18px";
          this.horiz.style.minHeight = this.vert.style.minWidth = w;
          var self = this;
          var barMouseDown = function(e) {
            if (e_target(e) != self.vert && e_target(e) != self.horiz)
              operation(self.cm, onMouseDown)(e);
          };
          on(this.vert, "mousedown", barMouseDown);
          on(this.horiz, "mousedown", barMouseDown);
        },
        clear: function() {
          var parent = this.horiz.parentNode;
          parent.removeChild(this.horiz);
          parent.removeChild(this.vert);
        }
      }, NativeScrollbars.prototype);
      function NullScrollbars() {}
      NullScrollbars.prototype = copyObj({
        update: function() {
          return {
            bottom: 0,
            right: 0
          };
        },
        setScrollLeft: function() {},
        setScrollTop: function() {},
        clear: function() {}
      }, NullScrollbars.prototype);
      CodeMirror.scrollbarModel = {
        "native": NativeScrollbars,
        "null": NullScrollbars
      };
      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();
          if (cm.display.scrollbars.addClass)
            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
        cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
          on(node, "mousedown", function() {
            if (cm.state.focused)
              setTimeout(function() {
                cm.display.input.focus();
              }, 0);
          });
          node.setAttribute("cm-not-content", "true");
        }, function(pos, axis) {
          if (axis == "horizontal")
            setScrollLeft(cm, pos);
          else
            setScrollTop(cm, pos);
        }, cm);
        if (cm.display.scrollbars.addClass)
          addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
      function updateScrollbars(cm, measure) {
        if (!measure)
          measure = measureForScrollbars(cm);
        var startWidth = cm.display.barWidth,
            startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
            updateHeightsInViewport(cm);
          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth;
          startHeight = cm.display.barHeight;
        }
      }
      function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        if (sizes.right && sizes.bottom) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = sizes.bottom + "px";
          d.scrollbarFiller.style.width = sizes.right + "px";
        } else
          d.scrollbarFiller.style.display = "";
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = sizes.bottom + "px";
          d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else
          d.gutterFiller.style.display = "";
      }
      function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from = lineAtHeight(doc, top),
            to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line,
              ensureTo = viewport.ensure.to.line;
          if (ensureFrom < from) {
            from = ensureFrom;
            to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
            from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }
        return {
          from: from,
          to: Math.max(to, from + 1)
        };
      }
      function alignHorizontally(cm) {
        var display = cm.display,
            view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
          return;
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth,
            left = comp + "px";
        for (var i = 0; i < view.length; i++)
          if (!view[i].hidden) {
            if (cm.options.fixedGutter && view[i].gutter)
              view[i].gutter.style.left = left;
            var align = view[i].alignable;
            if (align)
              for (var j = 0; j < align.length; j++)
                align[j].style.left = left;
          }
        if (cm.options.fixedGutter)
          display.gutters.style.left = (comp + gutterW) + "px";
      }
      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers)
          return false;
        var doc = cm.doc,
            last = lineNumberFor(cm.options, doc.first + doc.size - 1),
            display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth,
              padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm);
          return true;
        }
        return false;
      }
      function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
      }
      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
      }
      function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      }
      DisplayUpdate.prototype.signal = function(emitter, type) {
        if (hasHandler(emitter, type))
          this.events.push(arguments);
      };
      DisplayUpdate.prototype.finish = function() {
        for (var i = 0; i < this.events.length; i++)
          signal.apply(null, this.events[i]);
      };
      function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }
      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display,
            doc = cm.doc;
        if (update.editorIsHidden) {
          resetView(cm);
          return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0)
          return false;
        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        }
        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20)
          from = Math.max(doc.first, display.viewFrom);
        if (display.viewTo > to && display.viewTo - to < 20)
          to = Math.min(end, display.viewTo);
        if (sawCollapsedSpans) {
          from = visualLineNo(cm.doc, from);
          to = visualLineEndNo(cm.doc, to);
        }
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
          return false;
        var focused = activeElt();
        if (toUpdate > 4)
          display.lineDiv.style.display = "none";
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4)
          display.lineDiv.style.display = "";
        display.renderedView = display.view;
        if (focused && activeElt() != focused && focused.offsetHeight)
          focused.focus();
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;
        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
      }
      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;
        for (var first = true; ; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            if (viewport && viewport.top != null)
              viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
            update.visible = visibleLines(cm.display, cm.doc, viewport);
            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
              break;
          }
          if (!updateDisplayIfNeeded(cm, update))
            break;
          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          setDocumentHeight(cm, barMeasure);
          updateScrollbars(cm, barMeasure);
        }
        update.signal(cm, "update", cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom;
          cm.display.reportedViewTo = cm.display.viewTo;
        }
      }
      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          setDocumentHeight(cm, barMeasure);
          updateScrollbars(cm, barMeasure);
          update.finish();
        }
      }
      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        var total = measure.docHeight + cm.display.barHeight;
        cm.display.heightForcer.style.top = total + "px";
        cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + "px";
      }
      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for (var i = 0; i < display.view.length; i++) {
          var cur = display.view[i],
              height;
          if (cur.hidden)
            continue;
          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = cur.node.getBoundingClientRect();
            height = box.bottom - box.top;
          }
          var diff = cur.line.height - height;
          if (height < 2)
            height = textHeight(display);
          if (diff > .001 || diff < -.001) {
            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);
            if (cur.rest)
              for (var j = 0; j < cur.rest.length; j++)
                updateWidgetHeight(cur.rest[j]);
          }
        }
      }
      function updateWidgetHeight(line) {
        if (line.widgets)
          for (var i = 0; i < line.widgets.length; ++i)
            line.widgets[i].height = line.widgets[i].node.offsetHeight;
      }
      function getDimensions(cm) {
        var d = cm.display,
            left = {},
            width = {};
        var gutterLeft = d.gutters.clientLeft;
        for (var n = d.gutters.firstChild,
            i = 0; n; n = n.nextSibling, ++i) {
          left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
          width[cm.options.gutters[i]] = n.clientWidth;
        }
        return {
          fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth
        };
      }
      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display,
            lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv,
            cur = container.firstChild;
        function rm(node) {
          var next = node.nextSibling;
          if (webkit && mac && cm.display.currentWheelTarget == node)
            node.style.display = "none";
          else
            node.parentNode.removeChild(node);
          return next;
        }
        var view = display.view,
            lineN = display.viewFrom;
        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (lineView.hidden) {} else if (!lineView.node || lineView.node.parentNode != container) {
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else {
            while (cur != lineView.node)
              cur = rm(cur);
            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1)
                updateNumber = false;
              updateLineForChanges(cm, lineView, lineN, dims);
            }
            if (updateNumber) {
              removeChildren(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }
            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }
        while (cur)
          cur = rm(cur);
      }
      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
          var type = lineView.changes[j];
          if (type == "text")
            updateLineText(cm, lineView);
          else if (type == "gutter")
            updateLineGutter(cm, lineView, lineN, dims);
          else if (type == "class")
            updateLineClasses(lineView);
          else if (type == "widget")
            updateLineWidgets(cm, lineView, dims);
        }
        lineView.changes = null;
      }
      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");
          if (lineView.text.parentNode)
            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
          lineView.node.appendChild(lineView.text);
          if (ie && ie_version < 8)
            lineView.node.style.zIndex = 2;
        }
        return lineView.node;
      }
      function updateLineBackground(lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls)
          cls += " CodeMirror-linebackground";
        if (lineView.background) {
          if (cls)
            lineView.background.className = cls;
          else {
            lineView.background.parentNode.removeChild(lineView.background);
            lineView.background = null;
          }
        } else if (cls) {
          var wrap = ensureLineWrapped(lineView);
          lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
        }
      }
      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built;
        }
        return buildLineContent(cm, lineView);
      }
      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node)
          lineView.node = built.pre;
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }
      function updateLineClasses(lineView) {
        updateLineBackground(lineView);
        if (lineView.line.wrapClass)
          ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        else if (lineView.node != lineView.text)
          lineView.node.className = "";
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }
      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
          var wrap = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
          wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
          var wrap = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
          cm.display.input.setUneditable(gutterWrap);
          wrap.insertBefore(gutterWrap, lineView.text);
          if (lineView.line.gutterClass)
            gutterWrap.className += " " + lineView.line.gutterClass;
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
            lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
          if (markers)
            for (var k = 0; k < cm.options.gutters.length; ++k) {
              var id = cm.options.gutters[k],
                  found = markers.hasOwnProperty(id) && markers[id];
              if (found)
                gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
            }
        }
      }
      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable)
          lineView.alignable = null;
        for (var node = lineView.node.firstChild,
            next; node; node = next) {
          var next = node.nextSibling;
          if (node.className == "CodeMirror-linewidget")
            lineView.node.removeChild(node);
        }
        insertLineWidgets(cm, lineView, dims);
      }
      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass)
          lineView.bgClass = built.bgClass;
        if (built.textClass)
          lineView.textClass = built.textClass;
        updateLineClasses(lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
      }
      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest)
          for (var i = 0; i < lineView.rest.length; i++)
            insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
      }
      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets)
          return;
        var wrap = ensureLineWrapped(lineView);
        for (var i = 0,
            ws = line.widgets; i < ws.length; ++i) {
          var widget = ws[i],
              node = elt("div", [widget.node], "CodeMirror-linewidget");
          if (!widget.handleMouseEvents)
            node.setAttribute("cm-ignore-events", "true");
          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);
          if (allowAbove && widget.above)
            wrap.insertBefore(node, lineView.gutter || lineView.text);
          else
            wrap.appendChild(node);
          signalLater(widget, "redraw");
        }
      }
      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
          (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll)
            node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }
      var Pos = CodeMirror.Pos = function(line, ch) {
        if (!(this instanceof Pos))
          return new Pos(line, ch);
        this.line = line;
        this.ch = ch;
      };
      var cmp = CodeMirror.cmpPos = function(a, b) {
        return a.line - b.line || a.ch - b.ch;
      };
      function copyPos(x) {
        return Pos(x.line, x.ch);
      }
      function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
      }
      function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
      }
      function ensureFocus(cm) {
        if (!cm.state.focused) {
          cm.display.input.focus();
          onFocus(cm);
        }
      }
      function isReadOnly(cm) {
        return cm.options.readOnly || cm.doc.cantEdit;
      }
      var lastCopied = null;
      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;
        if (!sel)
          sel = doc.sel;
        var paste = cm.state.pasteIncoming || origin == "paste";
        var textLines = doc.splitLines(inserted),
            multiPaste = null;
        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.length == 0) {
              multiPaste = [];
              for (var i = 0; i < lastCopied.length; i++)
                multiPaste.push(doc.splitLines(lastCopied[i]));
            }
          } else if (textLines.length == sel.ranges.length) {
            multiPaste = map(textLines, function(l) {
              return [l];
            });
          }
        }
        for (var i = sel.ranges.length - 1; i >= 0; i--) {
          var range = sel.ranges[i];
          var from = range.from(),
              to = range.to();
          if (range.empty()) {
            if (deleted && deleted > 0)
              from = Pos(from.line, from.ch - deleted);
            else if (cm.state.overwrite && !paste)
              to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          }
          var updateInput = cm.curOp.updateInput;
          var changeEvent = {
            from: from,
            to: to,
            text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
            origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
          };
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }
        if (inserted && !paste)
          triggerElectric(cm, inserted);
        ensureCursorVisible(cm);
        cm.curOp.updateInput = updateInput;
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = false;
      }
      function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
        if (pasted) {
          e.preventDefault();
          if (!isReadOnly(cm) && !cm.options.disableInput)
            runInOp(cm, function() {
              applyTextInput(cm, pasted, 0, null, "paste");
            });
          return true;
        }
      }
      function triggerElectric(cm, inserted) {
        if (!cm.options.electricChars || !cm.options.smartIndent)
          return;
        var sel = cm.doc.sel;
        for (var i = sel.ranges.length - 1; i >= 0; i--) {
          var range = sel.ranges[i];
          if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line))
            continue;
          var mode = cm.getModeAt(range.head);
          var indented = false;
          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++)
              if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indented = indentLine(cm, range.head.line, "smart");
                break;
              }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
              indented = indentLine(cm, range.head.line, "smart");
          }
          if (indented)
            signalLater(cm, "electricInput", cm, range.head.line);
        }
      }
      function copyableRanges(cm) {
        var text = [],
            ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {
            anchor: Pos(line, 0),
            head: Pos(line + 1, 0)
          };
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return {
          text: text,
          ranges: ranges
        };
      }
      function disableBrowserMagic(field) {
        field.setAttribute("autocorrect", "off");
        field.setAttribute("autocapitalize", "off");
        field.setAttribute("spellcheck", "false");
      }
      function TextareaInput(cm) {
        this.cm = cm;
        this.prevInput = "";
        this.pollingFast = false;
        this.polling = new Delayed();
        this.inaccurateSelection = false;
        this.hasSelection = false;
        this.composing = null;
      }
      ;
      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        if (webkit)
          te.style.width = "1000px";
        else
          te.setAttribute("wrap", "off");
        if (ios)
          te.style.border = "1px solid black";
        disableBrowserMagic(te);
        return div;
      }
      TextareaInput.prototype = copyObj({
        init: function(display) {
          var input = this,
              cm = this.cm;
          var div = this.wrapper = hiddenTextarea();
          var te = this.textarea = div.firstChild;
          display.wrapper.insertBefore(div, display.wrapper.firstChild);
          if (ios)
            te.style.width = "0px";
          on(te, "input", function() {
            if (ie && ie_version >= 9 && input.hasSelection)
              input.hasSelection = null;
            input.poll();
          });
          on(te, "paste", function(e) {
            if (handlePaste(e, cm))
              return true;
            cm.state.pasteIncoming = true;
            input.fastPoll();
          });
          function prepareCopyCut(e) {
            if (cm.somethingSelected()) {
              lastCopied = cm.getSelections();
              if (input.inaccurateSelection) {
                input.prevInput = "";
                input.inaccurateSelection = false;
                te.value = lastCopied.join("\n");
                selectInput(te);
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              lastCopied = ranges.text;
              if (e.type == "cut") {
                cm.setSelections(ranges.ranges, null, sel_dontScroll);
              } else {
                input.prevInput = "";
                te.value = ranges.text.join("\n");
                selectInput(te);
              }
            }
            if (e.type == "cut")
              cm.state.cutIncoming = true;
          }
          on(te, "cut", prepareCopyCut);
          on(te, "copy", prepareCopyCut);
          on(display.scroller, "paste", function(e) {
            if (eventInWidget(display, e))
              return;
            cm.state.pasteIncoming = true;
            input.focus();
          });
          on(display.lineSpace, "selectstart", function(e) {
            if (!eventInWidget(display, e))
              e_preventDefault(e);
          });
          on(te, "compositionstart", function() {
            var start = cm.getCursor("from");
            if (input.composing)
              input.composing.range.clear();
            input.composing = {
              start: start,
              range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
            };
          });
          on(te, "compositionend", function() {
            if (input.composing) {
              input.poll();
              input.composing.range.clear();
              input.composing = null;
            }
          });
        },
        prepareSelection: function() {
          var cm = this.cm,
              display = cm.display,
              doc = cm.doc;
          var result = prepareSelection(cm);
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(),
                lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
          }
          return result;
        },
        showSelection: function(drawn) {
          var cm = this.cm,
              display = cm.display;
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
          removeChildrenAndAdd(display.selectionDiv, drawn.selection);
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
          }
        },
        reset: function(typing) {
          if (this.contextMenuPending)
            return;
          var minimal,
              selected,
              cm = this.cm,
              doc = cm.doc;
          if (cm.somethingSelected()) {
            this.prevInput = "";
            var range = doc.sel.primary();
            minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
            var content = minimal ? "-" : selected || cm.getSelection();
            this.textarea.value = content;
            if (cm.state.focused)
              selectInput(this.textarea);
            if (ie && ie_version >= 9)
              this.hasSelection = content;
          } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie && ie_version >= 9)
              this.hasSelection = null;
          }
          this.inaccurateSelection = minimal;
        },
        getField: function() {
          return this.textarea;
        },
        supportsTouch: function() {
          return false;
        },
        focus: function() {
          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
            try {
              this.textarea.focus();
            } catch (e) {}
          }
        },
        blur: function() {
          this.textarea.blur();
        },
        resetPosition: function() {
          this.wrapper.style.top = this.wrapper.style.left = 0;
        },
        receivedFocus: function() {
          this.slowPoll();
        },
        slowPoll: function() {
          var input = this;
          if (input.pollingFast)
            return;
          input.polling.set(this.cm.options.pollInterval, function() {
            input.poll();
            if (input.cm.state.focused)
              input.slowPoll();
          });
        },
        fastPoll: function() {
          var missed = false,
              input = this;
          input.pollingFast = true;
          function p() {
            var changed = input.poll();
            if (!changed && !missed) {
              missed = true;
              input.polling.set(60, p);
            } else {
              input.pollingFast = false;
              input.slowPoll();
            }
          }
          input.polling.set(20, p);
        },
        poll: function() {
          var cm = this.cm,
              input = this.textarea,
              prevInput = this.prevInput;
          if (this.contextMenuPending || !cm.state.focused || (hasSelection(input) && !prevInput && !this.composing) || isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
            return false;
          var text = input.value;
          if (text == prevInput && !cm.somethingSelected())
            return false;
          if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
          }
          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 0x200b && !prevInput)
              prevInput = "\u200b";
            if (first == 0x21da) {
              this.reset();
              return this.cm.execCommand("undo");
            }
          }
          var same = 0,
              l = Math.min(prevInput.length, text.length);
          while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
            ++same;
          var self = this;
          runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, self.composing ? "*compose" : null);
            if (text.length > 1000 || text.indexOf("\n") > -1)
              input.value = self.prevInput = "";
            else
              self.prevInput = text;
            if (self.composing) {
              self.composing.range.clear();
              self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"), {className: "CodeMirror-composing"});
            }
          });
          return true;
        },
        ensurePolled: function() {
          if (this.pollingFast && this.poll())
            this.pollingFast = false;
        },
        onKeyPress: function() {
          if (ie && ie_version >= 9)
            this.hasSelection = null;
          this.fastPoll();
        },
        onContextMenu: function(e) {
          var input = this,
              cm = input.cm,
              display = cm.display,
              te = input.textarea;
          var pos = posFromMouse(cm, e),
              scrollPos = display.scroller.scrollTop;
          if (!pos || presto)
            return;
          var reset = cm.options.resetSelectionOnContextMenu;
          if (reset && cm.doc.sel.contains(pos) == -1)
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
          var oldCSS = te.style.cssText;
          input.wrapper.style.position = "absolute";
          te.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) + "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
          if (webkit)
            var oldScrollY = window.scrollY;
          display.input.focus();
          if (webkit)
            window.scrollTo(null, oldScrollY);
          display.input.reset();
          if (!cm.somethingSelected())
            te.value = input.prevInput = " ";
          input.contextMenuPending = true;
          display.selForContextMenu = cm.doc.sel;
          clearTimeout(display.detectingSelectAll);
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected();
              var extval = "\u200b" + (selected ? te.value : "");
              te.value = "\u21da";
              te.value = extval;
              input.prevInput = selected ? "" : "\u200b";
              te.selectionStart = 1;
              te.selectionEnd = extval.length;
              display.selForContextMenu = cm.doc.sel;
            }
          }
          function rehide() {
            input.contextMenuPending = false;
            input.wrapper.style.position = "relative";
            te.style.cssText = oldCSS;
            if (ie && ie_version < 9)
              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            if (te.selectionStart != null) {
              if (!ie || (ie && ie_version < 9))
                prepareSelectAllHack();
              var i = 0,
                  poll = function() {
                    if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b")
                      operation(cm, commands.selectAll)(cm);
                    else if (i++ < 10)
                      display.detectingSelectAll = setTimeout(poll, 500);
                    else
                      display.input.reset();
                  };
              display.detectingSelectAll = setTimeout(poll, 200);
            }
          }
          if (ie && ie_version >= 9)
            prepareSelectAllHack();
          if (captureRightClick) {
            e_stop(e);
            var mouseup = function() {
              off(window, "mouseup", mouseup);
              setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
          } else {
            setTimeout(rehide, 50);
          }
        },
        readOnlyChanged: function(val) {
          if (!val)
            this.reset();
        },
        setUneditable: nothing,
        needsContentAttribute: false
      }, TextareaInput.prototype);
      function ContentEditableInput(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.gracePeriod = false;
      }
      ContentEditableInput.prototype = copyObj({
        init: function(display) {
          var input = this,
              cm = input.cm;
          var div = input.div = display.lineDiv;
          disableBrowserMagic(div);
          on(div, "paste", function(e) {
            handlePaste(e, cm);
          });
          on(div, "compositionstart", function(e) {
            var data = e.data;
            input.composing = {
              sel: cm.doc.sel,
              data: data,
              startData: data
            };
            if (!data)
              return;
            var prim = cm.doc.sel.primary();
            var line = cm.getLine(prim.head.line);
            var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
            if (found > -1 && found <= prim.head.ch)
              input.composing.sel = simpleSelection(Pos(prim.head.line, found), Pos(prim.head.line, found + data.length));
          });
          on(div, "compositionupdate", function(e) {
            input.composing.data = e.data;
          });
          on(div, "compositionend", function(e) {
            var ours = input.composing;
            if (!ours)
              return;
            if (e.data != ours.startData && !/\u200b/.test(e.data))
              ours.data = e.data;
            setTimeout(function() {
              if (!ours.handled)
                input.applyComposition(ours);
              if (input.composing == ours)
                input.composing = null;
            }, 50);
          });
          on(div, "touchstart", function() {
            input.forceCompositionEnd();
          });
          on(div, "input", function() {
            if (input.composing)
              return;
            if (isReadOnly(cm) || !input.pollContent())
              runInOp(input.cm, function() {
                regChange(cm);
              });
          });
          function onCopyCut(e) {
            if (cm.somethingSelected()) {
              lastCopied = cm.getSelections();
              if (e.type == "cut")
                cm.replaceSelection("", null, "cut");
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              lastCopied = ranges.text;
              if (e.type == "cut") {
                cm.operation(function() {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                  cm.replaceSelection("", null, "cut");
                });
              }
            }
            if (e.clipboardData && !ios) {
              e.preventDefault();
              e.clipboardData.clearData();
              e.clipboardData.setData("text/plain", lastCopied.join("\n"));
            } else {
              var kludge = hiddenTextarea(),
                  te = kludge.firstChild;
              cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
              te.value = lastCopied.join("\n");
              var hadFocus = document.activeElement;
              selectInput(te);
              setTimeout(function() {
                cm.display.lineSpace.removeChild(kludge);
                hadFocus.focus();
              }, 50);
            }
          }
          on(div, "copy", onCopyCut);
          on(div, "cut", onCopyCut);
        },
        prepareSelection: function() {
          var result = prepareSelection(this.cm, false);
          result.focus = this.cm.state.focused;
          return result;
        },
        showSelection: function(info) {
          if (!info || !this.cm.display.view.length)
            return;
          if (info.focus)
            this.showPrimarySelection();
          this.showMultipleSelections(info);
        },
        showPrimarySelection: function() {
          var sel = window.getSelection(),
              prim = this.cm.doc.sel.primary();
          var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
          var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), prim.from()) == 0 && cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
            return;
          var start = posToDOM(this.cm, prim.from());
          var end = posToDOM(this.cm, prim.to());
          if (!start && !end)
            return;
          var view = this.cm.display.view;
          var old = sel.rangeCount && sel.getRangeAt(0);
          if (!start) {
            start = {
              node: view[0].measure.map[2],
              offset: 0
            };
          } else if (!end) {
            var measure = view[view.length - 1].measure;
            var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end = {
              node: map[map.length - 1],
              offset: map[map.length - 2] - map[map.length - 3]
            };
          }
          try {
            var rng = range(start.node, start.offset, end.offset, end.node);
          } catch (e) {}
          if (rng) {
            sel.removeAllRanges();
            sel.addRange(rng);
            if (old && sel.anchorNode == null)
              sel.addRange(old);
            else if (gecko)
              this.startGracePeriod();
          }
          this.rememberSelection();
        },
        startGracePeriod: function() {
          var input = this;
          clearTimeout(this.gracePeriod);
          this.gracePeriod = setTimeout(function() {
            input.gracePeriod = false;
            if (input.selectionChanged())
              input.cm.operation(function() {
                input.cm.curOp.selectionChanged = true;
              });
          }, 20);
        },
        showMultipleSelections: function(info) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        },
        rememberSelection: function() {
          var sel = window.getSelection();
          this.lastAnchorNode = sel.anchorNode;
          this.lastAnchorOffset = sel.anchorOffset;
          this.lastFocusNode = sel.focusNode;
          this.lastFocusOffset = sel.focusOffset;
        },
        selectionInEditor: function() {
          var sel = window.getSelection();
          if (!sel.rangeCount)
            return false;
          var node = sel.getRangeAt(0).commonAncestorContainer;
          return contains(this.div, node);
        },
        focus: function() {
          if (this.cm.options.readOnly != "nocursor")
            this.div.focus();
        },
        blur: function() {
          this.div.blur();
        },
        getField: function() {
          return this.div;
        },
        supportsTouch: function() {
          return true;
        },
        receivedFocus: function() {
          var input = this;
          if (this.selectionInEditor())
            this.pollSelection();
          else
            runInOp(this.cm, function() {
              input.cm.curOp.selectionChanged = true;
            });
          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection();
              input.polling.set(input.cm.options.pollInterval, poll);
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll);
        },
        selectionChanged: function() {
          var sel = window.getSelection();
          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        },
        pollSelection: function() {
          if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
            var sel = window.getSelection(),
                cm = this.cm;
            this.rememberSelection();
            var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
            var head = domToPos(cm, sel.focusNode, sel.focusOffset);
            if (anchor && head)
              runInOp(cm, function() {
                setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
                if (anchor.bad || head.bad)
                  cm.curOp.selectionChanged = true;
              });
          }
        },
        pollContent: function() {
          var cm = this.cm,
              display = cm.display,
              sel = cm.doc.sel.primary();
          var from = sel.from(),
              to = sel.to();
          if (from.line < display.viewFrom || to.line > display.viewTo - 1)
            return false;
          var fromIndex;
          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            var fromLine = lineNo(display.view[0].line);
            var fromNode = display.view[0].node;
          } else {
            var fromLine = lineNo(display.view[fromIndex].line);
            var fromNode = display.view[fromIndex - 1].node.nextSibling;
          }
          var toIndex = findViewIndex(cm, to.line);
          if (toIndex == display.view.length - 1) {
            var toLine = display.viewTo - 1;
            var toNode = display.lineDiv.lastChild;
          } else {
            var toLine = lineNo(display.view[toIndex + 1].line) - 1;
            var toNode = display.view[toIndex + 1].node.previousSibling;
          }
          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
          var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop();
              oldText.pop();
              toLine--;
            } else if (newText[0] == oldText[0]) {
              newText.shift();
              oldText.shift();
              fromLine++;
            } else
              break;
          }
          var cutFront = 0,
              cutEnd = 0;
          var newTop = newText[0],
              oldTop = oldText[0],
              maxCutFront = Math.min(newTop.length, oldTop.length);
          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
            ++cutFront;
          var newBot = lst(newText),
              oldBot = lst(oldText);
          var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
            ++cutEnd;
          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
          newText[0] = newText[0].slice(cutFront);
          var chFrom = Pos(fromLine, cutFront);
          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
          }
        },
        ensurePolled: function() {
          this.forceCompositionEnd();
        },
        reset: function() {
          this.forceCompositionEnd();
        },
        forceCompositionEnd: function() {
          if (!this.composing || this.composing.handled)
            return;
          this.applyComposition(this.composing);
          this.composing.handled = true;
          this.div.blur();
          this.div.focus();
        },
        applyComposition: function(composing) {
          if (isReadOnly(this.cm))
            operation(this.cm, regChange)(this.cm);
          else if (composing.data && composing.data != composing.startData)
            operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
        },
        setUneditable: function(node) {
          node.contentEditable = "false";
        },
        onKeyPress: function(e) {
          e.preventDefault();
          if (!isReadOnly(this.cm))
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        },
        readOnlyChanged: function(val) {
          this.div.contentEditable = String(val != "nocursor");
        },
        onContextMenu: nothing,
        resetPosition: nothing,
        needsContentAttribute: true
      }, ContentEditableInput.prototype);
      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden)
          return null;
        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line),
            side = "left";
        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
      }
      function badPos(pos, bad) {
        if (bad)
          pos.bad = true;
        return pos;
      }
      function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];
          if (!lineNode)
            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
          node = null;
          offset = 0;
        } else {
          for (lineNode = node; ; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv)
              return null;
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv)
              break;
          }
        }
        for (var i = 0; i < cm.display.view.length; i++) {
          var lineView = cm.display.view[i];
          if (lineView.node == lineNode)
            return locateNodeInLineView(lineView, node, offset);
        }
      }
      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild,
            bad = false;
        if (!node || !contains(wrapper, node))
          return badPos(Pos(lineNo(lineView.line), 0), true);
        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;
          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
          }
        }
        var textNode = node.nodeType == 3 ? node : null,
            topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;
          if (offset)
            offset = textNode.nodeValue.length;
        }
        while (topNode.parentNode != wrapper)
          topNode = topNode.parentNode;
        var measure = lineView.measure,
            maps = measure.maps;
        function find(textNode, topNode, offset) {
          for (var i = -1; i < (maps ? maps.length : 0); i++) {
            var map = i < 0 ? measure.map : maps[i];
            for (var j = 0; j < map.length; j += 3) {
              var curNode = map[j + 2];
              if (curNode == textNode || curNode == topNode) {
                var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                var ch = map[j] + offset;
                if (offset < 0 || curNode != textNode)
                  ch = map[j + (offset ? 1 : 0)];
                return Pos(line, ch);
              }
            }
          }
        }
        var found = find(textNode, topNode, offset);
        if (found)
          return badPos(found, bad);
        for (var after = topNode.nextSibling,
            dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find(after, after.firstChild, 0);
          if (found)
            return badPos(Pos(found.line, found.ch - dist), bad);
          else
            dist += after.textContent.length;
        }
        for (var before = topNode.previousSibling,
            dist = offset; before; before = before.previousSibling) {
          found = find(before, before.firstChild, -1);
          if (found)
            return badPos(Pos(found.line, found.ch + dist), bad);
          else
            dist += after.textContent.length;
        }
      }
      function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = "",
            closing = false,
            lineSep = cm.doc.lineSeparator();
        function recognizeMarker(id) {
          return function(marker) {
            return marker.id == id;
          };
        }
        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");
            if (cmText != null) {
              if (cmText == "")
                cmText = node.textContent.replace(/\u200b/g, "");
              text += cmText;
              return;
            }
            var markerID = node.getAttribute("cm-marker"),
                range;
            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
              if (found.length && (range = found[0].find()))
                text += getBetween(cm.doc, range.from, range.to).join(lineSep);
              return;
            }
            if (node.getAttribute("contenteditable") == "false")
              return;
            for (var i = 0; i < node.childNodes.length; i++)
              walk(node.childNodes[i]);
            if (/^(pre|div|p)$/i.test(node.nodeName))
              closing = true;
          } else if (node.nodeType == 3) {
            var val = node.nodeValue;
            if (!val)
              return;
            if (closing) {
              text += lineSep;
              closing = false;
            }
            text += val;
          }
        }
        for (; ; ) {
          walk(from);
          if (from == to)
            break;
          from = from.nextSibling;
        }
        return text;
      }
      CodeMirror.inputStyles = {
        "textarea": TextareaInput,
        "contenteditable": ContentEditableInput
      };
      function Selection(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      }
      Selection.prototype = {
        primary: function() {
          return this.ranges[this.primIndex];
        },
        equals: function(other) {
          if (other == this)
            return true;
          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
            return false;
          for (var i = 0; i < this.ranges.length; i++) {
            var here = this.ranges[i],
                there = other.ranges[i];
            if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0)
              return false;
          }
          return true;
        },
        deepCopy: function() {
          for (var out = [],
              i = 0; i < this.ranges.length; i++)
            out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
          return new Selection(out, this.primIndex);
        },
        somethingSelected: function() {
          for (var i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].empty())
              return true;
          return false;
        },
        contains: function(pos, end) {
          if (!end)
            end = pos;
          for (var i = 0; i < this.ranges.length; i++) {
            var range = this.ranges[i];
            if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
              return i;
          }
          return -1;
        }
      };
      function Range(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      }
      Range.prototype = {
        from: function() {
          return minPos(this.anchor, this.head);
        },
        to: function() {
          return maxPos(this.anchor, this.head);
        },
        empty: function() {
          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        }
      };
      function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function(a, b) {
          return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
          var cur = ranges[i],
              prev = ranges[i - 1];
          if (cmp(prev.to(), cur.from()) >= 0) {
            var from = minPos(prev.from(), cur.from()),
                to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
            if (i <= primIndex)
              --primIndex;
            ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
          }
        }
        return new Selection(ranges, primIndex);
      }
      function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
      }
      function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
      }
      function clipPos(doc, pos) {
        if (pos.line < doc.first)
          return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        if (pos.line > last)
          return Pos(last, getLine(doc, last).text.length);
        return clipToLen(pos, getLine(doc, pos.line).text.length);
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen)
          return Pos(pos.line, linelen);
        else if (ch < 0)
          return Pos(pos.line, 0);
        else
          return pos;
      }
      function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
      }
      function clipPosArray(doc, array) {
        for (var out = [],
            i = 0; i < array.length; i++)
          out[i] = clipPos(doc, array[i]);
        return out;
      }
      function extendRange(doc, range, head, other) {
        if (doc.cm && doc.cm.display.shift || doc.extend) {
          var anchor = range.anchor;
          if (other) {
            var posBefore = cmp(head, anchor) < 0;
            if (posBefore != (cmp(other, anchor) < 0)) {
              anchor = head;
              head = other;
            } else if (posBefore != (cmp(head, other) < 0)) {
              head = other;
            }
          }
          return new Range(anchor, head);
        } else {
          return new Range(other || head, head);
        }
      }
      function extendSelection(doc, head, other, options) {
        setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
      }
      function extendSelections(doc, heads, options) {
        for (var out = [],
            i = 0; i < doc.sel.ranges.length; i++)
          out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
        var newSel = normalizeSelection(out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
      }
      function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
      }
      function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
      }
      function filterSelectionChange(doc, sel) {
        var obj = {
          ranges: sel.ranges,
          update: function(ranges) {
            this.ranges = [];
            for (var i = 0; i < ranges.length; i++)
              this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
          }
        };
        signal(doc, "beforeSelectionChange", doc, obj);
        if (doc.cm)
          signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        if (obj.ranges != sel.ranges)
          return normalizeSelection(obj.ranges, obj.ranges.length - 1);
        else
          return sel;
      }
      function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done,
            last = lst(done);
        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc, sel, options);
        } else {
          setSelection(doc, sel, options);
        }
      }
      function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
      }
      function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
          sel = filterSelectionChange(doc, sel);
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
        if (!(options && options.scroll === false) && doc.cm)
          ensureCursorVisible(doc.cm);
      }
      function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel))
          return;
        doc.sel = sel;
        if (doc.cm) {
          doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc.cm);
        }
        signalLater(doc, "cursorActivity", doc);
      }
      function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
      }
      function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;
        for (var i = 0; i < sel.ranges.length; i++) {
          var range = sel.ranges[i];
          var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
          var newHead = skipAtomic(doc, range.head, bias, mayClear);
          if (out || newAnchor != range.anchor || newHead != range.head) {
            if (!out)
              out = sel.ranges.slice(0, i);
            out[i] = new Range(newAnchor, newHead);
          }
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel;
      }
      function skipAtomic(doc, pos, bias, mayClear) {
        var flipped = false,
            curPos = pos;
        var dir = bias || 1;
        doc.cantEdit = false;
        search: for (; ; ) {
          var line = getLine(doc, curPos.line);
          if (line.markedSpans) {
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var sp = line.markedSpans[i],
                  m = sp.marker;
              if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                if (mayClear) {
                  signal(m, "beforeCursorEnter");
                  if (m.explicitlyCleared) {
                    if (!line.markedSpans)
                      break;
                    else {
                      --i;
                      continue;
                    }
                  }
                }
                if (!m.atomic)
                  continue;
                var newPos = m.find(dir < 0 ? -1 : 1);
                if (cmp(newPos, curPos) == 0) {
                  newPos.ch += dir;
                  if (newPos.ch < 0) {
                    if (newPos.line > doc.first)
                      newPos = clipPos(doc, Pos(newPos.line - 1));
                    else
                      newPos = null;
                  } else if (newPos.ch > line.text.length) {
                    if (newPos.line < doc.first + doc.size - 1)
                      newPos = Pos(newPos.line + 1, 0);
                    else
                      newPos = null;
                  }
                  if (!newPos) {
                    if (flipped) {
                      if (!mayClear)
                        return skipAtomic(doc, pos, bias, true);
                      doc.cantEdit = true;
                      return Pos(doc.first, 0);
                    }
                    flipped = true;
                    newPos = pos;
                    dir = -dir;
                  }
                }
                curPos = newPos;
                continue search;
              }
            }
          }
          return curPos;
        }
      }
      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }
      function prepareSelection(cm, primary) {
        var doc = cm.doc,
            result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          if (primary === false && i == doc.sel.primIndex)
            continue;
          var range = doc.sel.ranges[i];
          var collapsed = range.empty();
          if (collapsed || cm.options.showCursorWhenSelecting)
            drawSelectionCursor(cm, range.head, curFragment);
          if (!collapsed)
            drawSelectionRange(cm, range, selFragment);
        }
        return result;
      }
      function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        if (pos.other) {
          var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
        }
      }
      function drawSelectionRange(cm, range, output) {
        var display = cm.display,
            doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display),
            leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        function add(left, top, width, bottom) {
          if (top < 0)
            top = 0;
          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px; height: " + (bottom - top) + "px"));
        }
        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start,
              end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }
          iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
            var leftPos = coords(from, "left"),
                rightPos,
                left,
                right;
            if (from == to) {
              rightPos = leftPos;
              left = right = leftPos.left;
            } else {
              rightPos = coords(to - 1, "right");
              if (dir == "rtl") {
                var tmp = leftPos;
                leftPos = rightPos;
                rightPos = tmp;
              }
              left = leftPos.left;
              right = rightPos.right;
            }
            if (fromArg == null && from == 0)
              left = leftSide;
            if (rightPos.top - leftPos.top > 3) {
              add(left, leftPos.top, null, leftPos.bottom);
              left = leftSide;
              if (leftPos.bottom < rightPos.top)
                add(left, leftPos.bottom, null, rightPos.top);
            }
            if (toArg == null && to == lineLen)
              right = rightSide;
            if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
              start = leftPos;
            if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
              end = rightPos;
            if (left < leftSide + 1)
              left = leftSide;
            add(left, rightPos.top, right - left, rightPos.bottom);
          });
          return {
            start: start,
            end: end
          };
        }
        var sFrom = range.from(),
            sTo = range.to();
        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine(doc, sFrom.line),
              toLine = getLine(doc, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top)
            add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
        output.appendChild(fragment);
      }
      function restartBlink(cm) {
        if (!cm.state.focused)
          return;
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0)
          display.blinker = setInterval(function() {
            display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
          }, cm.options.cursorBlinkRate);
        else if (cm.options.cursorBlinkRate < 0)
          display.cursorDiv.style.visibility = "hidden";
      }
      function startWorker(cm, time) {
        if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
          cm.state.highlight.set(time, bind(highlightWorker, cm));
      }
      function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first)
          doc.frontier = doc.first;
        if (doc.frontier >= cm.display.viewTo)
          return;
        var end = +new Date + cm.options.workTime;
        var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
        var changedLines = [];
        doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
          if (doc.frontier >= cm.display.viewFrom) {
            var oldStyles = line.styles,
                tooLong = line.text.length > cm.options.maxHighlightLength;
            var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
            line.styles = highlighted.styles;
            var oldCls = line.styleClasses,
                newCls = highlighted.classes;
            if (newCls)
              line.styleClasses = newCls;
            else if (oldCls)
              line.styleClasses = null;
            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
            for (var i = 0; !ischange && i < oldStyles.length; ++i)
              ischange = oldStyles[i] != line.styles[i];
            if (ischange)
              changedLines.push(doc.frontier);
            line.stateAfter = tooLong ? state : copyState(doc.mode, state);
          } else {
            if (line.text.length <= cm.options.maxHighlightLength)
              processLine(cm, line.text, state);
            line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
          }
          ++doc.frontier;
          if (+new Date > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        if (changedLines.length)
          runInOp(cm, function() {
            for (var i = 0; i < changedLines.length; i++)
              regLineChange(cm, changedLines[i], "text");
          });
      }
      function findStartLine(cm, n, precise) {
        var minindent,
            minline,
            doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (var search = n; search > lim; --search) {
          if (search <= doc.first)
            return doc.first;
          var line = getLine(doc, search - 1);
          if (line.stateAfter && (!precise || search <= doc.frontier))
            return search;
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline;
      }
      function getStateBefore(cm, n, precise) {
        var doc = cm.doc,
            display = cm.display;
        if (!doc.mode.startState)
          return true;
        var pos = findStartLine(cm, n, precise),
            state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        if (!state)
          state = startState(doc.mode);
        else
          state = copyState(doc.mode, state);
        doc.iter(pos, n, function(line) {
          processLine(cm, line.text, state);
          var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
          line.stateAfter = save ? copyState(doc.mode, state) : null;
          ++pos;
        });
        if (precise)
          doc.frontier = pos;
        return state;
      }
      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }
      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }
      function paddingH(display) {
        if (display.cachedPaddingH)
          return display.cachedPaddingH;
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {
          left: parseInt(style.paddingLeft),
          right: parseInt(style.paddingRight)
        };
        if (!isNaN(data.left) && !isNaN(data.right))
          display.cachedPaddingH = data;
        return data;
      }
      function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
      }
      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
      }
      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
      }
      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];
          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();
            for (var i = 0; i < rects.length - 1; i++) {
              var cur = rects[i],
                  next = rects[i + 1];
              if (Math.abs(cur.bottom - next.bottom) > 2)
                heights.push((cur.bottom + next.top) / 2 - rect.top);
            }
          }
          heights.push(rect.bottom - rect.top);
        }
      }
      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line)
          return {
            map: lineView.measure.map,
            cache: lineView.measure.cache
          };
        for (var i = 0; i < lineView.rest.length; i++)
          if (lineView.rest[i] == line)
            return {
              map: lineView.measure.maps[i],
              cache: lineView.measure.caches[i]
            };
        for (var i = 0; i < lineView.rest.length; i++)
          if (lineNo(lineView.rest[i]) > lineN)
            return {
              map: lineView.measure.maps[i],
              cache: lineView.measure.caches[i],
              before: true
            };
      }
      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
      }
      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
      }
      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
          return cm.display.view[findViewIndex(cm, lineN)];
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
          return ext;
      }
      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }
        if (!view)
          view = updateExternalMeasurement(cm, line);
        var info = mapFromLineView(view, line, lineN);
        return {
          line: line,
          view: view,
          rect: null,
          map: info.map,
          cache: info.cache,
          before: info.before,
          hasHeights: false
        };
      }
      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before)
          ch = -1;
        var key = ch + (bias || ""),
            found;
        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect)
            prepared.rect = prepared.view.text.getBoundingClientRect();
          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }
          found = measureCharInner(cm, prepared, ch, bias);
          if (!found.bogus)
            prepared.cache[key] = found;
        }
        return {
          left: found.left,
          right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom
        };
      }
      var nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      function nodeAndOffsetInLineMap(map, ch, bias) {
        var node,
            start,
            end,
            collapse;
        for (var i = 0; i < map.length; i += 3) {
          var mStart = map[i],
              mEnd = map[i + 1];
          if (ch < mStart) {
            start = 0;
            end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start = ch - mStart;
            end = start + 1;
          } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
            end = mEnd - mStart;
            start = end - 1;
            if (ch >= mEnd)
              collapse = "right";
          }
          if (start != null) {
            node = map[i + 2];
            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
              collapse = bias;
            if (bias == "left" && start == 0)
              while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                node = map[(i -= 3) + 2];
                collapse = "left";
              }
            if (bias == "right" && start == mEnd - mStart)
              while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                node = map[(i += 3) + 2];
                collapse = "right";
              }
            break;
          }
        }
        return {
          node: node,
          start: start,
          end: end,
          collapse: collapse,
          coverStart: mStart,
          coverEnd: mEnd
        };
      }
      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node,
            start = place.start,
            end = place.end,
            collapse = place.collapse;
        var rect;
        if (node.nodeType == 3) {
          for (var i = 0; i < 4; i++) {
            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start)))
              --start;
            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end)))
              ++end;
            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
              rect = node.parentNode.getBoundingClientRect();
            } else if (ie && cm.options.lineWrapping) {
              var rects = range(node, start, end).getClientRects();
              if (rects.length)
                rect = rects[bias == "right" ? rects.length - 1 : 0];
              else
                rect = nullRect;
            } else {
              rect = range(node, start, end).getBoundingClientRect() || nullRect;
            }
            if (rect.left || rect.right || start == 0)
              break;
            end = start;
            start = start - 1;
            collapse = "right";
          }
          if (ie && ie_version < 11)
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
        } else {
          if (start > 0)
            collapse = bias = "right";
          var rects;
          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = node.getBoundingClientRect();
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];
          if (rSpan)
            rect = {
              left: rSpan.left,
              right: rSpan.left + charWidth(cm.display),
              top: rSpan.top,
              bottom: rSpan.bottom
            };
          else
            rect = nullRect;
        }
        var rtop = rect.top - prepared.rect.top,
            rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        for (var i = 0; i < heights.length - 1; i++)
          if (mid < heights[i])
            break;
        var top = i ? heights[i - 1] : 0,
            bot = heights[i];
        var result = {
          left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
          right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
          top: top,
          bottom: bot
        };
        if (!rect.left && !rect.right)
          result.bogus = true;
        if (!cm.options.singleCursorHeightPerLine) {
          result.rtop = rtop;
          result.rbottom = rbot;
        }
        return result;
      }
      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
          return rect;
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: rect.left * scaleX,
          right: rect.right * scaleX,
          top: rect.top * scaleY,
          bottom: rect.bottom * scaleY
        };
      }
      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;
          if (lineView.rest)
            for (var i = 0; i < lineView.rest.length; i++)
              lineView.measure.caches[i] = {};
        }
      }
      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++)
          clearLineMeasurementCacheFor(cm.display.view[i]);
      }
      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping)
          cm.display.maxLineChanged = true;
        cm.display.lineNumChars = null;
      }
      function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      }
      function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
      }
      function intoCoordSystem(cm, lineObj, rect, context) {
        if (lineObj.widgets)
          for (var i = 0; i < lineObj.widgets.length; ++i)
            if (lineObj.widgets[i].above) {
              var size = widgetHeight(lineObj.widgets[i]);
              rect.top += size;
              rect.bottom += size;
            }
        if (context == "line")
          return rect;
        if (!context)
          context = "local";
        var yOff = heightAtLine(lineObj);
        if (context == "local")
          yOff += paddingTop(cm.display);
        else
          yOff -= cm.display.viewOffset;
        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff;
          rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
      }
      function fromCoordSystem(cm, coords, context) {
        if (context == "div")
          return coords;
        var left = coords.left,
            top = coords.top;
        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
          left: left - lineSpaceBox.left,
          top: top - lineSpaceBox.top
        };
      }
      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj)
          lineObj = getLine(cm.doc, pos.line);
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
      }
      function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure)
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function get(ch, right) {
          var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
          if (right)
            m.left = m.right;
          else
            m.right = m.left;
          return intoCoordSystem(cm, lineObj, m, context);
        }
        function getBidi(ch, partPos) {
          var part = order[partPos],
              right = part.level % 2;
          if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
            part = order[--partPos];
            ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
            right = true;
          } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
            part = order[++partPos];
            ch = bidiLeft(part) - part.level % 2;
            right = false;
          }
          if (right && ch == part.to && ch > part.from)
            return get(ch - 1);
          return get(ch, right);
        }
        var order = getOrder(lineObj),
            ch = pos.ch;
        if (!order)
          return get(ch);
        var partPos = getBidiPartAt(order, ch);
        var val = getBidi(ch, partPos);
        if (bidiOther != null)
          val.other = getBidi(ch, bidiOther);
        return val;
      }
      function estimateCoords(cm, pos) {
        var left = 0,
            pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping)
          left = charWidth(cm.display) * pos.ch;
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {
          left: left,
          right: left,
          top: top,
          bottom: top + lineObj.height
        };
      }
      function PosWithInfo(line, ch, outside, xRel) {
        var pos = Pos(line, ch);
        pos.xRel = xRel;
        if (outside)
          pos.outside = true;
        return pos;
      }
      function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0)
          return PosWithInfo(doc.first, 0, true, -1);
        var lineN = lineAtHeight(doc, y),
            last = doc.first + doc.size - 1;
        if (lineN > last)
          return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
        if (x < 0)
          x = 0;
        var lineObj = getLine(doc, lineN);
        for (; ; ) {
          var found = coordsCharInner(cm, lineObj, lineN, x, y);
          var merged = collapsedSpanAtEnd(lineObj);
          var mergedPos = merged && merged.find(0, true);
          if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
            lineN = lineNo(lineObj = mergedPos.to.line);
          else
            return found;
        }
      }
      function coordsCharInner(cm, lineObj, lineNo, x, y) {
        var innerOff = y - heightAtLine(lineObj);
        var wrongLine = false,
            adjust = 2 * cm.display.wrapper.clientWidth;
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function getX(ch) {
          var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
          wrongLine = true;
          if (innerOff > sp.bottom)
            return sp.left - adjust;
          else if (innerOff < sp.top)
            return sp.left + adjust;
          else
            wrongLine = false;
          return sp.left;
        }
        var bidi = getOrder(lineObj),
            dist = lineObj.text.length;
        var from = lineLeft(lineObj),
            to = lineRight(lineObj);
        var fromX = getX(from),
            fromOutside = wrongLine,
            toX = getX(to),
            toOutside = wrongLine;
        if (x > toX)
          return PosWithInfo(lineNo, to, toOutside, 1);
        for (; ; ) {
          if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
            var ch = x < fromX || x - fromX <= toX - x ? from : to;
            var xDiff = x - (ch == from ? fromX : toX);
            while (isExtendingChar(lineObj.text.charAt(ch)))
              ++ch;
            var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
            return pos;
          }
          var step = Math.ceil(dist / 2),
              middle = from + step;
          if (bidi) {
            middle = from;
            for (var i = 0; i < step; ++i)
              middle = moveVisually(lineObj, middle, 1);
          }
          var middleX = getX(middle);
          if (middleX > x) {
            to = middle;
            toX = middleX;
            if (toOutside = wrongLine)
              toX += 1000;
            dist = step;
          } else {
            from = middle;
            fromX = middleX;
            fromOutside = wrongLine;
            dist -= step;
          }
        }
      }
      var measureText;
      function textHeight(display) {
        if (display.cachedTextHeight != null)
          return display.cachedTextHeight;
        if (measureText == null) {
          measureText = elt("pre");
          for (var i = 0; i < 49; ++i) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3)
          display.cachedTextHeight = height;
        removeChildren(display.measure);
        return height || 1;
      }
      function charWidth(display) {
        if (display.cachedCharWidth != null)
          return display.cachedCharWidth;
        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(),
            width = (rect.right - rect.left) / 10;
        if (width > 2)
          display.cachedCharWidth = width;
        return width || 10;
      }
      var operationGroup = null;
      var nextOpId = 0;
      function startOperation(cm) {
        cm.curOp = {
          cm: cm,
          viewChanged: false,
          startHeight: cm.doc.height,
          forceUpdate: false,
          updateInput: null,
          typing: false,
          changeObjs: null,
          cursorActivityHandlers: null,
          cursorActivityCalled: 0,
          selectionChanged: false,
          updateMaxLine: false,
          scrollLeft: null,
          scrollTop: null,
          scrollToPos: null,
          focus: false,
          id: ++nextOpId
        };
        if (operationGroup) {
          operationGroup.ops.push(cm.curOp);
        } else {
          cm.curOp.ownsGroup = operationGroup = {
            ops: [cm.curOp],
            delayedCallbacks: []
          };
        }
      }
      function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks,
            i = 0;
        do {
          for (; i < callbacks.length; i++)
            callbacks[i].call(null);
          for (var j = 0; j < group.ops.length; j++) {
            var op = group.ops[j];
            if (op.cursorActivityHandlers)
              while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        } while (i < callbacks.length);
      }
      function endOperation(cm) {
        var op = cm.curOp,
            group = op.ownsGroup;
        if (!group)
          return;
        try {
          fireCallbacksForOps(group);
        } finally {
          operationGroup = null;
          for (var i = 0; i < group.ops.length; i++)
            group.ops[i].cm.curOp = null;
          endOperations(group);
        }
      }
      function endOperations(group) {
        var ops = group.ops;
        for (var i = 0; i < ops.length; i++)
          endOperation_R1(ops[i]);
        for (var i = 0; i < ops.length; i++)
          endOperation_W1(ops[i]);
        for (var i = 0; i < ops.length; i++)
          endOperation_R2(ops[i]);
        for (var i = 0; i < ops.length; i++)
          endOperation_W2(ops[i]);
        for (var i = 0; i < ops.length; i++)
          endOperation_finish(ops[i]);
      }
      function endOperation_R1(op) {
        var cm = op.cm,
            display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine)
          findMaxLine(cm);
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
          top: op.scrollTop,
          ensure: op.scrollToPos
        }, op.forceUpdate);
      }
      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }
      function endOperation_R2(op) {
        var cm = op.cm,
            display = cm.display;
        if (op.updatedDisplay)
          updateHeightsInViewport(cm);
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged)
          op.preparedSelection = display.input.prepareSelection();
      }
      function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
          if (op.maxScrollLeft < cm.doc.scrollLeft)
            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
          cm.display.maxLineChanged = false;
        }
        if (op.preparedSelection)
          cm.display.input.showSelection(op.preparedSelection);
        if (op.updatedDisplay)
          setDocumentHeight(cm, op.barMeasure);
        if (op.updatedDisplay || op.startHeight != cm.doc.height)
          updateScrollbars(cm, op.barMeasure);
        if (op.selectionChanged)
          restartBlink(cm);
        if (cm.state.focused && op.updateInput)
          cm.display.input.reset(op.typing);
        if (op.focus && op.focus == activeElt())
          ensureFocus(op.cm);
      }
      function endOperation_finish(op) {
        var cm = op.cm,
            display = cm.display,
            doc = cm.doc;
        if (op.updatedDisplay)
          postUpdateDisplay(cm, op.update);
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
          display.wheelStartX = display.wheelStartY = null;
        if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
          doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
          display.scrollbars.setScrollTop(doc.scrollTop);
          display.scroller.scrollTop = doc.scrollTop;
        }
        if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
          doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));
          display.scrollbars.setScrollLeft(doc.scrollLeft);
          display.scroller.scrollLeft = doc.scrollLeft;
          alignHorizontally(cm);
        }
        if (op.scrollToPos) {
          var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
          if (op.scrollToPos.isCursor && cm.state.focused)
            maybeScrollWindow(cm, coords);
        }
        var hidden = op.maybeHiddenMarkers,
            unhidden = op.maybeUnhiddenMarkers;
        if (hidden)
          for (var i = 0; i < hidden.length; ++i)
            if (!hidden[i].lines.length)
              signal(hidden[i], "hide");
        if (unhidden)
          for (var i = 0; i < unhidden.length; ++i)
            if (unhidden[i].lines.length)
              signal(unhidden[i], "unhide");
        if (display.wrapper.offsetHeight)
          doc.scrollTop = cm.display.scroller.scrollTop;
        if (op.changeObjs)
          signal(cm, "changes", cm, op.changeObjs);
        if (op.update)
          op.update.finish();
      }
      function runInOp(cm, f) {
        if (cm.curOp)
          return f();
        startOperation(cm);
        try {
          return f();
        } finally {
          endOperation(cm);
        }
      }
      function operation(cm, f) {
        return function() {
          if (cm.curOp)
            return f.apply(cm, arguments);
          startOperation(cm);
          try {
            return f.apply(cm, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function methodOp(f) {
        return function() {
          if (this.curOp)
            return f.apply(this, arguments);
          startOperation(this);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(this);
          }
        };
      }
      function docMethodOp(f) {
        return function() {
          var cm = this.cm;
          if (!cm || cm.curOp)
            return f.apply(this, arguments);
          startOperation(cm);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function LineView(doc, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
      }
      function buildViewArray(cm, from, to) {
        var array = [],
            nextPos;
        for (var pos = from; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array.push(view);
        }
        return array;
      }
      function regChange(cm, from, to, lendiff) {
        if (from == null)
          from = cm.doc.first;
        if (to == null)
          to = cm.doc.first + cm.doc.size;
        if (!lendiff)
          lendiff = 0;
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from))
          display.updateLineNumbers = from;
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
          if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
            resetView(cm);
        } else if (to <= display.viewFrom) {
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
          resetView(cm);
        } else if (from <= display.viewFrom) {
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) {
          var cut = viewCuttingPoint(cm, from, from, -1);
          if (cut) {
            display.view = display.view.slice(0, cut.index);
            display.viewTo = cut.lineN;
          } else {
            resetView(cm);
          }
        } else {
          var cutTop = viewCuttingPoint(cm, from, from, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }
        var ext = display.externalMeasured;
        if (ext) {
          if (to < ext.lineN)
            ext.lineN += lendiff;
          else if (from < ext.lineN + ext.size)
            display.externalMeasured = null;
        }
      }
      function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display,
            ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
          display.externalMeasured = null;
        if (line < display.viewFrom || line >= display.viewTo)
          return;
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null)
          return;
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type) == -1)
          arr.push(type);
      }
      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }
      function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo)
          return null;
        n -= cm.display.viewFrom;
        if (n < 0)
          return null;
        var view = cm.display.view;
        for (var i = 0; i < view.length; i++) {
          n -= view[i].size;
          if (n < 0)
            return i;
        }
      }
      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN),
            diff,
            view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
          return {
            index: index,
            lineN: newN
          };
        for (var i = 0,
            n = cm.display.viewFrom; i < index; i++)
          n += view[i].size;
        if (n != oldN) {
          if (dir > 0) {
            if (index == view.length - 1)
              return null;
            diff = (n + view[index].size) - oldN;
            index++;
          } else {
            diff = n - oldN;
          }
          oldN += diff;
          newN += diff;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
          if (index == (dir < 0 ? 0 : view.length - 1))
            return null;
          newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
          index += dir;
        }
        return {
          index: index,
          lineN: newN
        };
      }
      function adjustView(cm, from, to) {
        var display = cm.display,
            view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from, to);
          display.viewFrom = from;
        } else {
          if (display.viewFrom > from)
            display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
          else if (display.viewFrom < from)
            display.view = display.view.slice(findViewIndex(cm, from));
          display.viewFrom = from;
          if (display.viewTo < to)
            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
          else if (display.viewTo > to)
            display.view = display.view.slice(0, findViewIndex(cm, to));
        }
        display.viewTo = to;
      }
      function countDirtyView(cm) {
        var view = cm.display.view,
            dirty = 0;
        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (!lineView.hidden && (!lineView.node || lineView.changes))
            ++dirty;
        }
        return dirty;
      }
      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie && ie_version < 11)
          on(d.scroller, "dblclick", operation(cm, function(e) {
            if (signalDOMEvent(cm, e))
              return;
            var pos = posFromMouse(cm, e);
            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
              return;
            e_preventDefault(e);
            var word = cm.findWordAt(pos);
            extendSelection(cm.doc, word.anchor, word.head);
          }));
        else
          on(d.scroller, "dblclick", function(e) {
            signalDOMEvent(cm, e) || e_preventDefault(e);
          });
        if (!captureRightClick)
          on(d.scroller, "contextmenu", function(e) {
            onContextMenu(cm, e);
          });
        var touchFinished,
            prevTouch = {end: 0};
        function finishTouch() {
          if (d.activeTouch) {
            touchFinished = setTimeout(function() {
              d.activeTouch = null;
            }, 1000);
            prevTouch = d.activeTouch;
            prevTouch.end = +new Date;
          }
        }
        ;
        function isMouseLikeTouchEvent(e) {
          if (e.touches.length != 1)
            return false;
          var touch = e.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
          if (other.left == null)
            return true;
          var dx = other.left - touch.left,
              dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20;
        }
        on(d.scroller, "touchstart", function(e) {
          if (!isMouseLikeTouchEvent(e)) {
            clearTimeout(touchFinished);
            var now = +new Date;
            d.activeTouch = {
              start: now,
              moved: false,
              prev: now - prevTouch.end <= 300 ? prevTouch : null
            };
            if (e.touches.length == 1) {
              d.activeTouch.left = e.touches[0].pageX;
              d.activeTouch.top = e.touches[0].pageY;
            }
          }
        });
        on(d.scroller, "touchmove", function() {
          if (d.activeTouch)
            d.activeTouch.moved = true;
        });
        on(d.scroller, "touchend", function(e) {
          var touch = d.activeTouch;
          if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date - touch.start < 300) {
            var pos = cm.coordsChar(d.activeTouch, "page"),
                range;
            if (!touch.prev || farAway(touch, touch.prev))
              range = new Range(pos, pos);
            else if (!touch.prev.prev || farAway(touch, touch.prev.prev))
              range = cm.findWordAt(pos);
            else
              range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
            cm.setSelection(range.anchor, range.head);
            cm.focus();
            e_preventDefault(e);
          }
          finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch);
        on(d.scroller, "scroll", function() {
          if (d.scroller.clientHeight) {
            setScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });
        on(d.scroller, "mousewheel", function(e) {
          onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function(e) {
          onScrollWheel(cm, e);
        });
        on(d.wrapper, "scroll", function() {
          d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
          enter: function(e) {
            if (!signalDOMEvent(cm, e))
              e_stop(e);
          },
          over: function(e) {
            if (!signalDOMEvent(cm, e)) {
              onDragOver(cm, e);
              e_stop(e);
            }
          },
          start: function(e) {
            onDragStart(cm, e);
          },
          drop: operation(cm, onDrop),
          leave: function() {
            clearDragCursor(cm);
          }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function(e) {
          onKeyUp.call(cm, e);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", bind(onFocus, cm));
        on(inp, "blur", bind(onBlur, cm));
      }
      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != CodeMirror.Init;
        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }
      function onResize(cm) {
        var d = cm.display;
        if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
          return;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
      }
      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") || (n.parentNode == display.sizer && n != display.mover))
            return true;
        }
      }
      function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true")
          return null;
        var x,
            y,
            space = display.lineSpace.getBoundingClientRect();
        try {
          x = e.clientX - space.left;
          y = e.clientY - space.top;
        } catch (e) {
          return null;
        }
        var coords = coordsChar(cm, x, y),
            line;
        if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
      }
      function onMouseDown(e) {
        var cm = this,
            display = cm.display;
        if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e))
          return;
        display.shift = e.shiftKey;
        if (eventInWidget(display, e)) {
          if (!webkit) {
            display.scroller.draggable = false;
            setTimeout(function() {
              display.scroller.draggable = true;
            }, 100);
          }
          return;
        }
        if (clickInGutter(cm, e))
          return;
        var start = posFromMouse(cm, e);
        window.focus();
        switch (e_button(e)) {
          case 1:
            if (cm.state.selectingText)
              cm.state.selectingText(e);
            else if (start)
              leftButtonDown(cm, e, start);
            else if (e_target(e) == display.scroller)
              e_preventDefault(e);
            break;
          case 2:
            if (webkit)
              cm.state.lastMiddleDown = +new Date;
            if (start)
              extendSelection(cm.doc, start);
            setTimeout(function() {
              display.input.focus();
            }, 20);
            e_preventDefault(e);
            break;
          case 3:
            if (captureRightClick)
              onContextMenu(cm, e);
            else
              delayBlurEvent(cm);
            break;
        }
      }
      var lastClick,
          lastDoubleClick;
      function leftButtonDown(cm, e, start) {
        if (ie)
          setTimeout(bind(ensureFocus, cm), 0);
        else
          cm.curOp.focus = activeElt();
        var now = +new Date,
            type;
        if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
          type = "triple";
        } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
          type = "double";
          lastDoubleClick = {
            time: now,
            pos: start
          };
        } else {
          type = "single";
          lastClick = {
            time: now,
            pos: start
          };
        }
        var sel = cm.doc.sel,
            modifier = mac ? e.metaKey : e.ctrlKey,
            contained;
        if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && type == "single" && (contained = sel.contains(start)) > -1 && (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) && (cmp(contained.to(), start) > 0 || start.xRel < 0))
          leftButtonStartDrag(cm, e, start, modifier);
        else
          leftButtonSelect(cm, e, start, type, modifier);
      }
      function leftButtonStartDrag(cm, e, start, modifier) {
        var display = cm.display,
            startTime = +new Date;
        var dragEnd = operation(cm, function(e2) {
          if (webkit)
            display.scroller.draggable = false;
          cm.state.draggingText = false;
          off(document, "mouseup", dragEnd);
          off(display.scroller, "drop", dragEnd);
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            if (!modifier && +new Date - 200 < startTime)
              extendSelection(cm.doc, start);
            if (webkit || ie && ie_version == 9)
              setTimeout(function() {
                document.body.focus();
                display.input.focus();
              }, 20);
            else
              display.input.focus();
          }
        });
        if (webkit)
          display.scroller.draggable = true;
        cm.state.draggingText = dragEnd;
        if (display.scroller.dragDrop)
          display.scroller.dragDrop();
        on(document, "mouseup", dragEnd);
        on(display.scroller, "drop", dragEnd);
      }
      function leftButtonSelect(cm, e, start, type, addNew) {
        var display = cm.display,
            doc = cm.doc;
        e_preventDefault(e);
        var ourRange,
            ourIndex,
            startSel = doc.sel,
            ranges = startSel.ranges;
        if (addNew && !e.shiftKey) {
          ourIndex = doc.sel.contains(start);
          if (ourIndex > -1)
            ourRange = ranges[ourIndex];
          else
            ourRange = new Range(start, start);
        } else {
          ourRange = doc.sel.primary();
          ourIndex = doc.sel.primIndex;
        }
        if (e.altKey) {
          type = "rect";
          if (!addNew)
            ourRange = new Range(start, start);
          start = posFromMouse(cm, e, true, true);
          ourIndex = -1;
        } else if (type == "double") {
          var word = cm.findWordAt(start);
          if (cm.display.shift || doc.extend)
            ourRange = extendRange(doc, ourRange, word.anchor, word.head);
          else
            ourRange = word;
        } else if (type == "triple") {
          var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
          if (cm.display.shift || doc.extend)
            ourRange = extendRange(doc, ourRange, line.anchor, line.head);
          else
            ourRange = line;
        } else {
          ourRange = extendRange(doc, ourRange, start);
        }
        if (!addNew) {
          ourIndex = 0;
          setSelection(doc, new Selection([ourRange], 0), sel_mouse);
          startSel = doc.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {
            scroll: false,
            origin: "*mouse"
          });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
          setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
            scroll: false,
            origin: "*mouse"
          });
          startSel = doc.sel;
        } else {
          replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }
        var lastPos = start;
        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0)
            return;
          lastPos = pos;
          if (type == "rect") {
            var ranges = [],
                tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
            var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol),
                right = Math.max(startCol, posCol);
            for (var line = Math.min(start.line, pos.line),
                end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
              var text = getLine(doc, line).text,
                  leftPos = findColumn(text, left, tabSize);
              if (left == right)
                ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
              else if (text.length > leftPos)
                ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
            }
            if (!ranges.length)
              ranges.push(new Range(start, start));
            setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
              origin: "*mouse",
              scroll: false
            });
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var anchor = oldRange.anchor,
                head = pos;
            if (type != "single") {
              if (type == "double")
                var range = cm.findWordAt(pos);
              else
                var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
              if (cmp(range.anchor, anchor) > 0) {
                head = range.head;
                anchor = minPos(oldRange.from(), range.anchor);
              } else {
                head = range.anchor;
                anchor = maxPos(oldRange.to(), range.head);
              }
            }
            var ranges = startSel.ranges.slice(0);
            ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
            setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
          }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true, type == "rect");
          if (!cur)
            return;
          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt();
            extendTo(cur);
            var visible = visibleLines(display, doc);
            if (cur.line >= visible.to || cur.line < visible.from)
              setTimeout(operation(cm, function() {
                if (counter == curCount)
                  extend(e);
              }), 150);
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
            if (outside)
              setTimeout(operation(cm, function() {
                if (counter != curCount)
                  return;
                display.scroller.scrollTop += outside;
                extend(e);
              }), 50);
          }
        }
        function done(e) {
          cm.state.selectingText = false;
          counter = Infinity;
          e_preventDefault(e);
          display.input.focus();
          off(document, "mousemove", move);
          off(document, "mouseup", up);
          doc.history.lastSelOrigin = null;
        }
        var move = operation(cm, function(e) {
          if (!e_button(e))
            done(e);
          else
            extend(e);
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(document, "mousemove", move);
        on(document, "mouseup", up);
      }
      function gutterEvent(cm, e, type, prevent, signalfn) {
        try {
          var mX = e.clientX,
              mY = e.clientY;
        } catch (e) {
          return false;
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
          return false;
        if (prevent)
          e_preventDefault(e);
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type))
          return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
          var g = display.gutters.childNodes[i];
          if (g && g.getBoundingClientRect().right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.options.gutters[i];
            signalfn(cm, type, cm, line, gutter, e);
            return e_defaultPrevented(e);
          }
        }
      }
      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true, signalLater);
      }
      var lastDrop = 0;
      function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
          return;
        e_preventDefault(e);
        if (ie)
          lastDrop = +new Date;
        var pos = posFromMouse(cm, e, true),
            files = e.dataTransfer.files;
        if (!pos || isReadOnly(cm))
          return;
        if (files && files.length && window.FileReader && window.File) {
          var n = files.length,
              text = Array(n),
              read = 0;
          var loadFile = function(file, i) {
            var reader = new FileReader;
            reader.onload = operation(cm, function() {
              text[i] = reader.result;
              if (++read == n) {
                pos = clipPos(cm.doc, pos);
                var change = {
                  from: pos,
                  to: pos,
                  text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                  origin: "paste"
                };
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
              }
            });
            reader.readAsText(file);
          };
          for (var i = 0; i < n; ++i)
            loadFile(files[i], i);
        } else {
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e);
            setTimeout(function() {
              cm.display.input.focus();
            }, 20);
            return;
          }
          try {
            var text = e.dataTransfer.getData("Text");
            if (text) {
              if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))
                var selected = cm.listSelections();
              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
              if (selected)
                for (var i = 0; i < selected.length; ++i)
                  replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
              cm.replaceSelection(text, "around", "paste");
              cm.display.input.focus();
            }
          } catch (e) {}
        }
      }
      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) {
          e_stop(e);
          return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
          return;
        e.dataTransfer.setData("Text", cm.getSelection());
        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            img._top = img.offsetTop;
          }
          e.dataTransfer.setDragImage(img, 0, 0);
          if (presto)
            img.parentNode.removeChild(img);
        }
      }
      function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);
        if (!pos)
          return;
        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }
      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      }
      function setScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2)
          return;
        cm.doc.scrollTop = val;
        if (!gecko)
          updateDisplaySimple(cm, {top: val});
        if (cm.display.scroller.scrollTop != val)
          cm.display.scroller.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (gecko)
          updateDisplaySimple(cm);
        startWorker(cm, 100);
      }
      function setScrollLeft(cm, val, isScroller) {
        if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
          return;
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val)
          cm.display.scroller.scrollLeft = val;
        cm.display.scrollbars.setScrollLeft(val);
      }
      var wheelSamples = 0,
          wheelPixelsPerUnit = null;
      if (ie)
        wheelPixelsPerUnit = -.53;
      else if (gecko)
        wheelPixelsPerUnit = 15;
      else if (chrome)
        wheelPixelsPerUnit = -.7;
      else if (safari)
        wheelPixelsPerUnit = -1 / 3;
      var wheelEventDelta = function(e) {
        var dx = e.wheelDeltaX,
            dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
          dx = e.detail;
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
          dy = e.detail;
        else if (dy == null)
          dy = e.wheelDelta;
        return {
          x: dx,
          y: dy
        };
      };
      CodeMirror.wheelEventPixels = function(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
      };
      function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e),
            dx = delta.x,
            dy = delta.y;
        var display = cm.display,
            scroll = display.scroller;
        if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
          return;
        if (dy && mac && webkit) {
          outer: for (var cur = e.target,
              view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i = 0; i < view.length; i++) {
              if (view[i].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
        }
        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
          if (dy)
            setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
          setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
          e_preventDefault(e);
          display.wheelStartX = null;
          return;
        }
        if (dy && wheelPixelsPerUnit != null) {
          var pixels = dy * wheelPixelsPerUnit;
          var top = cm.doc.scrollTop,
              bot = top + display.wrapper.clientHeight;
          if (pixels < 0)
            top = Math.max(0, top + pixels - 50);
          else
            bot = Math.min(cm.doc.height, bot + pixels + 50);
          updateDisplaySimple(cm, {
            top: top,
            bottom: bot
          });
        }
        if (wheelSamples < 20) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;
            display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;
            display.wheelDY = dy;
            setTimeout(function() {
              if (display.wheelStartX == null)
                return;
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = (movedY && display.wheelDY && movedY / display.wheelDY) || (movedX && display.wheelDX && movedX / display.wheelDX);
              display.wheelStartX = display.wheelStartY = null;
              if (!sample)
                return;
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;
            display.wheelDY += dy;
          }
        }
      }
      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound)
            return false;
        }
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift,
            done = false;
        try {
          if (isReadOnly(cm))
            cm.state.suppressEdits = true;
          if (dropShift)
            cm.display.shift = false;
          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done;
      }
      function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
          var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
          if (result)
            return result;
        }
        return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm)) || lookupKey(name, cm.options.keyMap, handle, cm);
      }
      var stopSeq = new Delayed;
      function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
          if (isModifierKey(name))
            return "handled";
          stopSeq.set(50, function() {
            if (cm.state.keySeq == seq) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          });
          name = seq + " " + name;
        }
        var result = lookupKeyForEditor(cm, name, handle);
        if (result == "multi")
          cm.state.keySeq = name;
        if (result == "handled")
          signalLater(cm, "keyHandled", cm, name, e);
        if (result == "handled" || result == "multi") {
          e_preventDefault(e);
          restartBlink(cm);
        }
        if (seq && !result && /\'$/.test(name)) {
          e_preventDefault(e);
          return true;
        }
        return !!result;
      }
      function handleKeyBinding(cm, e) {
        var name = keyName(e, true);
        if (!name)
          return false;
        if (e.shiftKey && !cm.state.keySeq) {
          return dispatchKey(cm, "Shift-" + name, e, function(b) {
            return doHandleBinding(cm, b, true);
          }) || dispatchKey(cm, name, e, function(b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
              return doHandleBinding(cm, b);
          });
        } else {
          return dispatchKey(cm, name, e, function(b) {
            return doHandleBinding(cm, b);
          });
        }
      }
      function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function(b) {
          return doHandleBinding(cm, b, true);
        });
      }
      var lastStoppedKey = null;
      function onKeyDown(e) {
        var cm = this;
        cm.curOp.focus = activeElt();
        if (signalDOMEvent(cm, e))
          return;
        if (ie && ie_version < 11 && e.keyCode == 27)
          e.returnValue = false;
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
          lastStoppedKey = handled ? code : null;
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
            cm.replaceSelection("", null, "cut");
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
          showCrossHair(cm);
      }
      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");
        function up(e) {
          if (e.keyCode == 18 || !e.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }
        on(document, "keyup", up);
        on(document, "mouseover", up);
      }
      function onKeyUp(e) {
        if (e.keyCode == 16)
          this.doc.sel.shift = false;
        signalDOMEvent(this, e);
      }
      function onKeyPress(e) {
        var cm = this;
        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)
          return;
        var keyCode = e.keyCode,
            charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {
          lastStoppedKey = null;
          e_preventDefault(e);
          return;
        }
        if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e))
          return;
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (handleCharBinding(cm, e, ch))
          return;
        cm.display.input.onKeyPress(e);
      }
      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
          if (cm.state.delayingBlurEvent) {
            cm.state.delayingBlurEvent = false;
            onBlur(cm);
          }
        }, 100);
      }
      function onFocus(cm) {
        if (cm.state.delayingBlurEvent)
          cm.state.delayingBlurEvent = false;
        if (cm.options.readOnly == "nocursor")
          return;
        if (!cm.state.focused) {
          signal(cm, "focus", cm);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused");
          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();
            if (webkit)
              setTimeout(function() {
                cm.display.input.reset(true);
              }, 20);
          }
          cm.display.input.receivedFocus();
        }
        restartBlink(cm);
      }
      function onBlur(cm) {
        if (cm.state.delayingBlurEvent)
          return;
        if (cm.state.focused) {
          signal(cm, "blur", cm);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function() {
          if (!cm.state.focused)
            cm.display.shift = false;
        }, 150);
      }
      function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e))
          return;
        cm.display.input.onContextMenu(e);
      }
      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu"))
          return false;
        return gutterEvent(cm, e, "gutterContextMenu", false, signal);
      }
      var changeEnd = CodeMirror.changeEnd = function(change) {
        if (!change.text)
          return change.to;
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
      };
      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0)
          return pos;
        if (cmp(pos, change.to) <= 0)
          return changeEnd(change);
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
            ch = pos.ch;
        if (pos.line == change.to.line)
          ch += changeEnd(change).ch - change.to.ch;
        return Pos(line, ch);
      }
      function computeSelAfterChange(doc, change) {
        var out = [];
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          var range = doc.sel.ranges[i];
          out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return normalizeSelection(out, doc.sel.primIndex);
      }
      function offsetPos(pos, old, nw) {
        if (pos.line == old.line)
          return Pos(nw.line, pos.ch - old.ch + nw.ch);
        else
          return Pos(nw.line + (pos.line - old.line), pos.ch);
      }
      function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0),
            newPrev = oldPrev;
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          var from = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;
          if (hint == "around") {
            var range = doc.sel.ranges[i],
                inv = cmp(range.head, range.anchor) < 0;
            out[i] = new Range(inv ? to : from, inv ? from : to);
          } else {
            out[i] = new Range(from, from);
          }
        }
        return new Selection(out, doc.sel.primIndex);
      }
      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function() {
            this.canceled = true;
          }
        };
        if (update)
          obj.update = function(from, to, text, origin) {
            if (from)
              this.from = clipPos(doc, from);
            if (to)
              this.to = clipPos(doc, to);
            if (text)
              this.text = text;
            if (origin !== undefined)
              this.origin = origin;
          };
        signal(doc, "beforeChange", doc, obj);
        if (doc.cm)
          signal(doc.cm, "beforeChange", doc.cm, obj);
        if (obj.canceled)
          return null;
        return {
          from: obj.from,
          to: obj.to,
          text: obj.text,
          origin: obj.origin
        };
      }
      function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp)
            return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
          if (doc.cm.state.suppressEdits)
            return;
        }
        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);
          if (!change)
            return;
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
          for (var i = split.length - 1; i >= 0; --i)
            makeChangeInner(doc, {
              from: split[i].from,
              to: split[i].to,
              text: i ? [""] : change.text
            });
        } else {
          makeChangeInner(doc, change);
        }
      }
      function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0)
          return;
        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function(doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }
          makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
      }
      function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (doc.cm && doc.cm.state.suppressEdits)
          return;
        var hist = doc.history,
            event,
            selAfter = doc.sel;
        var source = type == "undo" ? hist.done : hist.undone,
            dest = type == "undo" ? hist.undone : hist.done;
        for (var i = 0; i < source.length; i++) {
          event = source[i];
          if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
            break;
        }
        if (i == source.length)
          return;
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (; ; ) {
          event = source.pop();
          if (event.ranges) {
            pushSelectionToHistory(event, dest);
            if (allowSelectionOnly && !event.equals(doc.sel)) {
              setSelection(doc, event, {clearRedo: false});
              return;
            }
            selAfter = event;
          } else
            break;
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({
          changes: antiChanges,
          generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
        for (var i = event.changes.length - 1; i >= 0; --i) {
          var change = event.changes[i];
          change.origin = type;
          if (filter && !filterChange(doc, change, false)) {
            source.length = 0;
            return;
          }
          antiChanges.push(historyChangeFromChange(doc, change));
          var after = i ? computeSelAfterChange(doc, change) : lst(source);
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
          if (!i && doc.cm)
            doc.cm.scrollIntoView({
              from: change.from,
              to: changeEnd(change)
            });
          var rebased = [];
          linkedDocs(doc, function(doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change);
              rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
          });
        }
      }
      function shiftDoc(doc, distance) {
        if (distance == 0)
          return;
        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function(range) {
          return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex);
        if (doc.cm) {
          regChange(doc.cm, doc.first, doc.first - distance, distance);
          for (var d = doc.cm.display,
              l = d.viewFrom; l < d.viewTo; l++)
            regLineChange(doc.cm, l, "gutter");
        }
      }
      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp)
          return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }
        if (change.from.line > doc.lastLine())
          return;
        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = {
            from: Pos(doc.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)],
            origin: change.origin
          };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
          change = {
            from: change.from,
            to: Pos(last, getLine(doc, last).text.length),
            text: [change.text[0]],
            origin: change.origin
          };
        }
        change.removed = getBetween(doc, change.from, change.to);
        if (!selAfter)
          selAfter = computeSelAfterChange(doc, change);
        if (doc.cm)
          makeChangeSingleDocInEditor(doc.cm, change, spans);
        else
          updateDoc(doc, change, spans);
        setSelectionNoUndo(doc, selAfter, sel_dontScroll);
      }
      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc,
            display = cm.display,
            from = change.from,
            to = change.to;
        var recomputeMaxLength = false,
            checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function(line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }
        if (doc.sel.contains(change.from, change.to) > -1)
          signalCursorActivity(cm);
        updateDoc(doc, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
            var len = lineLength(line);
            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength)
            cm.curOp.updateMaxLine = true;
        }
        doc.frontier = Math.min(doc.frontier, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        if (change.full)
          regChange(cm);
        else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
          regLineChange(cm, from.line, "text");
        else
          regChange(cm, from.line, to.line + 1, lendiff);
        var changesHandler = hasHandler(cm, "changes"),
            changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
          var obj = {
            from: from,
            to: to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };
          if (changeHandler)
            signalLater(cm, "change", cm, obj);
          if (changesHandler)
            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
        cm.display.selForContextMenu = null;
      }
      function replaceRange(doc, code, from, to, origin) {
        if (!to)
          to = from;
        if (cmp(to, from) < 0) {
          var tmp = to;
          to = from;
          from = tmp;
        }
        if (typeof code == "string")
          code = doc.splitLines(code);
        makeChange(doc, {
          from: from,
          to: to,
          text: code,
          origin: origin
        });
      }
      function maybeScrollWindow(cm, coords) {
        if (signalDOMEvent(cm, "scrollCursorIntoView"))
          return;
        var display = cm.display,
            box = display.sizer.getBoundingClientRect(),
            doScroll = null;
        if (coords.top + box.top < 0)
          doScroll = true;
        else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
          doScroll = false;
        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " + coords.left + "px; width: 2px;");
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      }
      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null)
          margin = 0;
        for (var limit = 0; limit < 5; limit++) {
          var changed = false,
              coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
          var startTop = cm.doc.scrollTop,
              startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            setScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1)
              changed = true;
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
              changed = true;
          }
          if (!changed)
            break;
        }
        return coords;
      }
      function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        if (scrollPos.scrollTop != null)
          setScrollTop(cm, scrollPos.scrollTop);
        if (scrollPos.scrollLeft != null)
          setScrollLeft(cm, scrollPos.scrollLeft);
      }
      function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display,
            snapMargin = textHeight(cm.display);
        if (y1 < 0)
          y1 = 0;
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = displayHeight(cm),
            result = {};
        if (y2 - y1 > screen)
          y2 = y1 + screen;
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = y1 < snapMargin,
            atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop) {
          result.scrollTop = atTop ? 0 : y1;
        } else if (y2 > screentop + screen) {
          var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
          if (newTop != screentop)
            result.scrollTop = newTop;
        }
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
        var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
        var tooWide = x2 - x1 > screenw;
        if (tooWide)
          x2 = x1 + screenw;
        if (x1 < 10)
          result.scrollLeft = 0;
        else if (x1 < screenleft)
          result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
        else if (x2 > screenw + screenleft - 3)
          result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
        return result;
      }
      function addToScrollPos(cm, left, top) {
        if (left != null || top != null)
          resolveScrollToPos(cm);
        if (left != null)
          cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
        if (top != null)
          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
      }
      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor(),
            from = cur,
            to = cur;
        if (!cm.options.lineWrapping) {
          from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
          to = Pos(cur.line, cur.ch + 1);
        }
        cm.curOp.scrollToPos = {
          from: from,
          to: to,
          margin: cm.options.cursorScrollMargin,
          isCursor: true
        };
      }
      function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
          cm.curOp.scrollToPos = null;
          var from = estimateCoords(cm, range.from),
              to = estimateCoords(cm, range.to);
          var sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
          cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
        }
      }
      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc,
            state;
        if (how == null)
          how = "add";
        if (how == "smart") {
          if (!doc.mode.indent)
            how = "prev";
          else
            state = getStateBefore(cm, n);
        }
        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n),
            curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter)
          line.stateAfter = null;
        var curSpaceString = line.text.match(/^\s*/)[0],
            indentation;
        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass || indentation > 150) {
            if (!aggressive)
              return;
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n > doc.first)
            indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
          else
            indentation = 0;
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString = "",
            pos = 0;
        if (cm.options.indentWithTabs)
          for (var i = Math.floor(indentation / tabSize); i; --i) {
            pos += tabSize;
            indentString += "\t";
          }
        if (pos < indentation)
          indentString += spaceStr(indentation - pos);
        if (indentString != curSpaceString) {
          replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
          line.stateAfter = null;
          return true;
        } else {
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            if (range.head.line == n && range.head.ch < curSpaceString.length) {
              var pos = Pos(n, curSpaceString.length);
              replaceOneSelection(doc, i, new Range(pos, pos));
              break;
            }
          }
        }
      }
      function changeLine(doc, handle, changeType, op) {
        var no = handle,
            line = handle;
        if (typeof handle == "number")
          line = getLine(doc, clipLine(doc, handle));
        else
          no = lineNo(handle);
        if (no == null)
          return null;
        if (op(line, no) && doc.cm)
          regLineChange(doc.cm, no, changeType);
        return line;
      }
      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges,
            kill = [];
        for (var i = 0; i < ranges.length; i++) {
          var toKill = compute(ranges[i]);
          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();
            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break;
            }
          }
          kill.push(toKill);
        }
        runInOp(cm, function() {
          for (var i = kill.length - 1; i >= 0; i--)
            replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
          ensureCursorVisible(cm);
        });
      }
      function findPosH(doc, pos, dir, unit, visually) {
        var line = pos.line,
            ch = pos.ch,
            origDir = dir;
        var lineObj = getLine(doc, line);
        var possible = true;
        function findNextLine() {
          var l = line + dir;
          if (l < doc.first || l >= doc.first + doc.size)
            return (possible = false);
          line = l;
          return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
          var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
          if (next == null) {
            if (!boundToLine && findNextLine()) {
              if (visually)
                ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
              else
                ch = dir < 0 ? lineObj.text.length : 0;
            } else
              return (possible = false);
          } else
            ch = next;
          return true;
        }
        if (unit == "char")
          moveOnce();
        else if (unit == "column")
          moveOnce(true);
        else if (unit == "word" || unit == "group") {
          var sawType = null,
              group = unit == "group";
          var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
          for (var first = true; ; first = false) {
            if (dir < 0 && !moveOnce(!first))
              break;
            var cur = lineObj.text.charAt(ch) || "\n";
            var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
            if (group && !first && !type)
              type = "s";
            if (sawType && sawType != type) {
              if (dir < 0) {
                dir = 1;
                moveOnce();
              }
              break;
            }
            if (type)
              sawType = type;
            if (dir > 0 && !moveOnce(!first))
              break;
          }
        }
        var result = skipAtomic(doc, Pos(line, ch), origDir, true);
        if (!possible)
          result.hitSide = true;
        return result;
      }
      function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc,
            x = pos.left,
            y;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        for (; ; ) {
          var target = coordsChar(cm, x, y);
          if (!target.outside)
            break;
          if (dir < 0 ? y <= 0 : y >= doc.height) {
            target.hitSide = true;
            break;
          }
          y += dir * 5;
        }
        return target;
      }
      CodeMirror.prototype = {
        constructor: CodeMirror,
        focus: function() {
          window.focus();
          this.display.input.focus();
        },
        setOption: function(option, value) {
          var options = this.options,
              old = options[option];
          if (options[option] == value && option != "mode")
            return;
          options[option] = value;
          if (optionHandlers.hasOwnProperty(option))
            operation(this, optionHandlers[option])(this, value, old);
        },
        getOption: function(option) {
          return this.options[option];
        },
        getDoc: function() {
          return this.doc;
        },
        addKeyMap: function(map, bottom) {
          this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
        },
        removeKeyMap: function(map) {
          var maps = this.state.keyMaps;
          for (var i = 0; i < maps.length; ++i)
            if (maps[i] == map || maps[i].name == map) {
              maps.splice(i, 1);
              return true;
            }
        },
        addOverlay: methodOp(function(spec, options) {
          var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
          if (mode.startState)
            throw new Error("Overlays may not be stateful.");
          this.state.overlays.push({
            mode: mode,
            modeSpec: spec,
            opaque: options && options.opaque
          });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: methodOp(function(spec) {
          var overlays = this.state.overlays;
          for (var i = 0; i < overlays.length; ++i) {
            var cur = overlays[i].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i, 1);
              this.state.modeGen++;
              regChange(this);
              return;
            }
          }
        }),
        indentLine: methodOp(function(n, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null)
              dir = this.options.smartIndent ? "smart" : "prev";
            else
              dir = dir ? "add" : "subtract";
          }
          if (isLine(this.doc, n))
            indentLine(this, n, dir, aggressive);
        }),
        indentSelection: methodOp(function(how) {
          var ranges = this.doc.sel.ranges,
              end = -1;
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (!range.empty()) {
              var from = range.from(),
                  to = range.to();
              var start = Math.max(end, from.line);
              end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
              for (var j = start; j < end; ++j)
                indentLine(this, j, how);
              var newRanges = this.doc.sel.ranges;
              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
                replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
            } else if (range.head.line > end) {
              indentLine(this, range.head.line, how, true);
              end = range.head.line;
              if (i == this.doc.sel.primIndex)
                ensureCursorVisible(this);
            }
          }
        }),
        getTokenAt: function(pos, precise) {
          return takeToken(this, pos, precise);
        },
        getLineTokens: function(line, precise) {
          return takeToken(this, Pos(line), precise, true);
        },
        getTokenTypeAt: function(pos) {
          pos = clipPos(this.doc, pos);
          var styles = getLineStyles(this, getLine(this.doc, pos.line));
          var before = 0,
              after = (styles.length - 1) / 2,
              ch = pos.ch;
          var type;
          if (ch == 0)
            type = styles[2];
          else
            for (; ; ) {
              var mid = (before + after) >> 1;
              if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
                after = mid;
              else if (styles[mid * 2 + 1] < ch)
                before = mid + 1;
              else {
                type = styles[mid * 2 + 2];
                break;
              }
            }
          var cut = type ? type.indexOf("cm-overlay ") : -1;
          return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
        },
        getModeAt: function(pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode)
            return mode;
          return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
        },
        getHelper: function(pos, type) {
          return this.getHelpers(pos, type)[0];
        },
        getHelpers: function(pos, type) {
          var found = [];
          if (!helpers.hasOwnProperty(type))
            return found;
          var help = helpers[type],
              mode = this.getModeAt(pos);
          if (typeof mode[type] == "string") {
            if (help[mode[type]])
              found.push(help[mode[type]]);
          } else if (mode[type]) {
            for (var i = 0; i < mode[type].length; i++) {
              var val = help[mode[type][i]];
              if (val)
                found.push(val);
            }
          } else if (mode.helperType && help[mode.helperType]) {
            found.push(help[mode.helperType]);
          } else if (help[mode.name]) {
            found.push(help[mode.name]);
          }
          for (var i = 0; i < help._global.length; i++) {
            var cur = help._global[i];
            if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
              found.push(cur.val);
          }
          return found;
        },
        getStateAfter: function(line, precise) {
          var doc = this.doc;
          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
          return getStateBefore(this, line + 1, precise);
        },
        cursorCoords: function(start, mode) {
          var pos,
              range = this.doc.sel.primary();
          if (start == null)
            pos = range.head;
          else if (typeof start == "object")
            pos = clipPos(this.doc, start);
          else
            pos = start ? range.from() : range.to();
          return cursorCoords(this, pos, mode || "page");
        },
        charCoords: function(pos, mode) {
          return charCoords(this, clipPos(this.doc, pos), mode || "page");
        },
        coordsChar: function(coords, mode) {
          coords = fromCoordSystem(this, coords, mode || "page");
          return coordsChar(this, coords.left, coords.top);
        },
        lineAtHeight: function(height, mode) {
          height = fromCoordSystem(this, {
            top: height,
            left: 0
          }, mode || "page").top;
          return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function(line, mode) {
          var end = false,
              lineObj;
          if (typeof line == "number") {
            var last = this.doc.first + this.doc.size - 1;
            if (line < this.doc.first)
              line = this.doc.first;
            else if (line > last) {
              line = last;
              end = true;
            }
            lineObj = getLine(this.doc, line);
          } else {
            lineObj = line;
          }
          return intoCoordSystem(this, lineObj, {
            top: 0,
            left: 0
          }, mode || "page").top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
        },
        defaultTextHeight: function() {
          return textHeight(this.display);
        },
        defaultCharWidth: function() {
          return charWidth(this.display);
        },
        setGutterMarker: methodOp(function(line, gutterID, value) {
          return changeLine(this.doc, line, "gutter", function(line) {
            var markers = line.gutterMarkers || (line.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers))
              line.gutterMarkers = null;
            return true;
          });
        }),
        clearGutter: methodOp(function(gutterID) {
          var cm = this,
              doc = cm.doc,
              i = doc.first;
          doc.iter(function(line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              line.gutterMarkers[gutterID] = null;
              regLineChange(cm, i, "gutter");
              if (isEmpty(line.gutterMarkers))
                line.gutterMarkers = null;
            }
            ++i;
          });
        }),
        lineInfo: function(line) {
          if (typeof line == "number") {
            if (!isLine(this.doc, line))
              return null;
            var n = line;
            line = getLine(this.doc, line);
            if (!line)
              return null;
          } else {
            var n = lineNo(line);
            if (n == null)
              return null;
          }
          return {
            line: n,
            handle: line,
            text: line.text,
            gutterMarkers: line.gutterMarkers,
            textClass: line.textClass,
            bgClass: line.bgClass,
            wrapClass: line.wrapClass,
            widgets: line.widgets
          };
        },
        getViewport: function() {
          return {
            from: this.display.viewFrom,
            to: this.display.viewTo
          };
        },
        addWidget: function(pos, node, scroll, vert, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top = pos.bottom,
              left = pos.left;
          node.style.position = "absolute";
          node.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(node);
          display.sizer.appendChild(node);
          if (vert == "over") {
            top = pos.top;
          } else if (vert == "above" || vert == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
              top = pos.top - node.offsetHeight;
            else if (pos.bottom + node.offsetHeight <= vspace)
              top = pos.bottom;
            if (left + node.offsetWidth > hspace)
              left = hspace - node.offsetWidth;
          }
          node.style.top = top + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left")
              left = 0;
            else if (horiz == "middle")
              left = (display.sizer.clientWidth - node.offsetWidth) / 2;
            node.style.left = left + "px";
          }
          if (scroll)
            scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
        },
        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        execCommand: function(cmd) {
          if (commands.hasOwnProperty(cmd))
            return commands[cmd].call(null, this);
        },
        triggerElectric: methodOp(function(text) {
          triggerElectric(this, text);
        }),
        findPosH: function(from, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          for (var i = 0,
              cur = clipPos(this.doc, from); i < amount; ++i) {
            cur = findPosH(this.doc, cur, dir, unit, visually);
            if (cur.hitSide)
              break;
          }
          return cur;
        },
        moveH: methodOp(function(dir, unit) {
          var cm = this;
          cm.extendSelectionsBy(function(range) {
            if (cm.display.shift || cm.doc.extend || range.empty())
              return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
            else
              return dir < 0 ? range.from() : range.to();
          }, sel_move);
        }),
        deleteH: methodOp(function(dir, unit) {
          var sel = this.doc.sel,
              doc = this.doc;
          if (sel.somethingSelected())
            doc.replaceSelection("", null, "+delete");
          else
            deleteNearSelection(this, function(range) {
              var other = findPosH(doc, range.head, dir, unit, false);
              return dir < 0 ? {
                from: other,
                to: range.head
              } : {
                from: range.head,
                to: other
              };
            });
        }),
        findPosV: function(from, amount, unit, goalColumn) {
          var dir = 1,
              x = goalColumn;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          for (var i = 0,
              cur = clipPos(this.doc, from); i < amount; ++i) {
            var coords = cursorCoords(this, cur, "div");
            if (x == null)
              x = coords.left;
            else
              coords.left = x;
            cur = findPosV(this, coords, dir, unit);
            if (cur.hitSide)
              break;
          }
          return cur;
        },
        moveV: methodOp(function(dir, unit) {
          var cm = this,
              doc = this.doc,
              goals = [];
          var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
          doc.extendSelectionsBy(function(range) {
            if (collapse)
              return dir < 0 ? range.from() : range.to();
            var headPos = cursorCoords(cm, range.head, "div");
            if (range.goalColumn != null)
              headPos.left = range.goalColumn;
            goals.push(headPos.left);
            var pos = findPosV(cm, headPos, dir, unit);
            if (unit == "page" && range == doc.sel.primary())
              addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
            return pos;
          }, sel_move);
          if (goals.length)
            for (var i = 0; i < doc.sel.ranges.length; i++)
              doc.sel.ranges[i].goalColumn = goals[i];
        }),
        findWordAt: function(pos) {
          var doc = this.doc,
              line = getLine(doc, pos.line).text;
          var start = pos.ch,
              end = pos.ch;
          if (line) {
            var helper = this.getHelper(pos, "wordChars");
            if ((pos.xRel < 0 || end == line.length) && start)
              --start;
            else
              ++end;
            var startChar = line.charAt(start);
            var check = isWordChar(startChar, helper) ? function(ch) {
              return isWordChar(ch, helper);
            } : /\s/.test(startChar) ? function(ch) {
              return /\s/.test(ch);
            } : function(ch) {
              return !/\s/.test(ch) && !isWordChar(ch);
            };
            while (start > 0 && check(line.charAt(start - 1)))
              --start;
            while (end < line.length && check(line.charAt(end)))
              ++end;
          }
          return new Range(Pos(pos.line, start), Pos(pos.line, end));
        },
        toggleOverwrite: function(value) {
          if (value != null && value == this.state.overwrite)
            return;
          if (this.state.overwrite = !this.state.overwrite)
            addClass(this.display.cursorDiv, "CodeMirror-overwrite");
          else
            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
          signal(this, "overwriteToggle", this, this.state.overwrite);
        },
        hasFocus: function() {
          return this.display.input.getField() == activeElt();
        },
        scrollTo: methodOp(function(x, y) {
          if (x != null || y != null)
            resolveScrollToPos(this);
          if (x != null)
            this.curOp.scrollLeft = x;
          if (y != null)
            this.curOp.scrollTop = y;
        }),
        getScrollInfo: function() {
          var scroller = this.display.scroller;
          return {
            left: scroller.scrollLeft,
            top: scroller.scrollTop,
            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
            clientHeight: displayHeight(this),
            clientWidth: displayWidth(this)
          };
        },
        scrollIntoView: methodOp(function(range, margin) {
          if (range == null) {
            range = {
              from: this.doc.sel.primary().head,
              to: null
            };
            if (margin == null)
              margin = this.options.cursorScrollMargin;
          } else if (typeof range == "number") {
            range = {
              from: Pos(range, 0),
              to: null
            };
          } else if (range.from == null) {
            range = {
              from: range,
              to: null
            };
          }
          if (!range.to)
            range.to = range.from;
          range.margin = margin || 0;
          if (range.from.line != null) {
            resolveScrollToPos(this);
            this.curOp.scrollToPos = range;
          } else {
            var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
            this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
          }
        }),
        setSize: methodOp(function(width, height) {
          var cm = this;
          function interpret(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          }
          if (width != null)
            cm.display.wrapper.style.width = interpret(width);
          if (height != null)
            cm.display.wrapper.style.height = interpret(height);
          if (cm.options.lineWrapping)
            clearLineMeasurementCache(this);
          var lineNo = cm.display.viewFrom;
          cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
            if (line.widgets)
              for (var i = 0; i < line.widgets.length; i++)
                if (line.widgets[i].noHScroll) {
                  regLineChange(cm, lineNo, "widget");
                  break;
                }
            ++lineNo;
          });
          cm.curOp.forceUpdate = true;
          signal(cm, "refresh", this);
        }),
        operation: function(f) {
          return runInOp(this, f);
        },
        refresh: methodOp(function() {
          var oldHeight = this.display.cachedTextHeight;
          regChange(this);
          this.curOp.forceUpdate = true;
          clearCaches(this);
          this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
          updateGutterSpace(this);
          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
            estimateLineHeights(this);
          signal(this, "refresh", this);
        }),
        swapDoc: methodOp(function(doc) {
          var old = this.doc;
          old.cm = null;
          attachDoc(this, doc);
          clearCaches(this);
          this.display.input.reset();
          this.scrollTo(doc.scrollLeft, doc.scrollTop);
          this.curOp.forceScroll = true;
          signalLater(this, "swapDoc", this, old);
          return old;
        }),
        getInputField: function() {
          return this.display.input.getField();
        },
        getWrapperElement: function() {
          return this.display.wrapper;
        },
        getScrollerElement: function() {
          return this.display.scroller;
        },
        getGutterElement: function() {
          return this.display.gutters;
        }
      };
      eventMixin(CodeMirror);
      var defaults = CodeMirror.defaults = {};
      var optionHandlers = CodeMirror.optionHandlers = {};
      function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt;
        if (handle)
          optionHandlers[name] = notOnInit ? function(cm, val, old) {
            if (old != Init)
              handle(cm, val, old);
          } : handle;
      }
      var Init = CodeMirror.Init = {toString: function() {
          return "CodeMirror.Init";
        }};
      option("value", "", function(cm, val) {
        cm.setValue(val);
      }, true);
      option("mode", null, function(cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);
      option("indentUnit", 2, loadMode, true);
      option("indentWithTabs", false);
      option("smartIndent", true);
      option("tabSize", 4, function(cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);
      option("lineSeparator", null, function(cm, val) {
        cm.doc.lineSep = val;
        if (!val)
          return;
        var newBreaks = [],
            lineNo = cm.doc.first;
        cm.doc.iter(function(line) {
          for (var pos = 0; ; ) {
            var found = line.text.indexOf(val, pos);
            if (found == -1)
              break;
            pos = found + val.length;
            newBreaks.push(Pos(lineNo, found));
          }
          lineNo++;
        });
        for (var i = newBreaks.length - 1; i >= 0; i--)
          replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
      });
      option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
        if (old != CodeMirror.Init)
          cm.refresh();
      });
      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
        cm.refresh();
      }, true);
      option("electricChars", true);
      option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
        throw new Error("inputStyle can not (yet) be changed in a running editor");
      }, true);
      option("rtlMoveVisually", !windows);
      option("wholeLineUpdateBefore", true);
      option("theme", "default", function(cm) {
        themeChanged(cm);
        guttersChanged(cm);
      }, true);
      option("keyMap", "default", function(cm, val, old) {
        var next = getKeyMap(val);
        var prev = old != CodeMirror.Init && getKeyMap(old);
        if (prev && prev.detach)
          prev.detach(cm, next);
        if (next.attach)
          next.attach(cm, prev || null);
      });
      option("extraKeys", null);
      option("lineWrapping", false, wrappingChanged, true);
      option("gutters", [], function(cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
      }, true);
      option("fixedGutter", true, function(cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option("coverGutterNextToScrollbar", false, function(cm) {
        updateScrollbars(cm);
      }, true);
      option("scrollbarStyle", "native", function(cm) {
        initScrollbars(cm);
        updateScrollbars(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
      }, true);
      option("lineNumbers", false, function(cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
      }, true);
      option("firstLineNumber", 1, guttersChanged, true);
      option("lineNumberFormatter", function(integer) {
        return integer;
      }, guttersChanged, true);
      option("showCursorWhenSelecting", false, updateSelection, true);
      option("resetSelectionOnContextMenu", true);
      option("lineWiseCopyCut", true);
      option("readOnly", false, function(cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
          cm.display.disabled = true;
        } else {
          cm.display.disabled = false;
        }
        cm.display.input.readOnlyChanged(val);
      });
      option("disableInput", false, function(cm, val) {
        if (!val)
          cm.display.input.reset();
      }, true);
      option("dragDrop", true, dragDropChanged);
      option("cursorBlinkRate", 530);
      option("cursorScrollMargin", 0);
      option("cursorHeight", 1, updateSelection, true);
      option("singleCursorHeightPerLine", true, updateSelection, true);
      option("workTime", 100);
      option("workDelay", 100);
      option("flattenSpans", true, resetModeState, true);
      option("addModeClass", false, resetModeState, true);
      option("pollInterval", 100);
      option("undoDepth", 200, function(cm, val) {
        cm.doc.history.undoDepth = val;
      });
      option("historyEventDelay", 1250);
      option("viewportMargin", 10, function(cm) {
        cm.refresh();
      }, true);
      option("maxHighlightLength", 10000, resetModeState, true);
      option("moveInputWithCursor", true, function(cm, val) {
        if (!val)
          cm.display.input.resetPosition();
      });
      option("tabindex", null, function(cm, val) {
        cm.display.input.getField().tabIndex = val || "";
      });
      option("autofocus", null);
      var modes = CodeMirror.modes = {},
          mimeModes = CodeMirror.mimeModes = {};
      CodeMirror.defineMode = function(name, mode) {
        if (!CodeMirror.defaults.mode && name != "null")
          CodeMirror.defaults.mode = name;
        if (arguments.length > 2)
          mode.dependencies = Array.prototype.slice.call(arguments, 2);
        modes[name] = mode;
      };
      CodeMirror.defineMIME = function(mime, spec) {
        mimeModes[mime] = spec;
      };
      CodeMirror.resolveMode = function(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          if (typeof found == "string")
            found = {name: found};
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return CodeMirror.resolveMode("application/xml");
        }
        if (typeof spec == "string")
          return {name: spec};
        else
          return spec || {name: "null"};
      };
      CodeMirror.getMode = function(options, spec) {
        var spec = CodeMirror.resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory)
          return CodeMirror.getMode(options, "text/plain");
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop))
              continue;
            if (modeObj.hasOwnProperty(prop))
              modeObj["_" + prop] = modeObj[prop];
            modeObj[prop] = exts[prop];
          }
        }
        modeObj.name = spec.name;
        if (spec.helperType)
          modeObj.helperType = spec.helperType;
        if (spec.modeProps)
          for (var prop in spec.modeProps)
            modeObj[prop] = spec.modeProps[prop];
        return modeObj;
      };
      CodeMirror.defineMode("null", function() {
        return {token: function(stream) {
            stream.skipToEnd();
          }};
      });
      CodeMirror.defineMIME("text/plain", "null");
      var modeExtensions = CodeMirror.modeExtensions = {};
      CodeMirror.extendMode = function(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
        copyObj(properties, exts);
      };
      CodeMirror.defineExtension = function(name, func) {
        CodeMirror.prototype[name] = func;
      };
      CodeMirror.defineDocExtension = function(name, func) {
        Doc.prototype[name] = func;
      };
      CodeMirror.defineOption = option;
      var initHooks = [];
      CodeMirror.defineInitHook = function(f) {
        initHooks.push(f);
      };
      var helpers = CodeMirror.helpers = {};
      CodeMirror.registerHelper = function(type, name, value) {
        if (!helpers.hasOwnProperty(type))
          helpers[type] = CodeMirror[type] = {_global: []};
        helpers[type][name] = value;
      };
      CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
        CodeMirror.registerHelper(type, name, value);
        helpers[type]._global.push({
          pred: predicate,
          val: value
        });
      };
      var copyState = CodeMirror.copyState = function(mode, state) {
        if (state === true)
          return state;
        if (mode.copyState)
          return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array)
            val = val.concat([]);
          nstate[n] = val;
        }
        return nstate;
      };
      var startState = CodeMirror.startState = function(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      };
      CodeMirror.innerMode = function(mode, state) {
        while (mode.innerMode) {
          var info = mode.innerMode(state);
          if (!info || info.mode == mode)
            break;
          state = info.state;
          mode = info.mode;
        }
        return info || {
          mode: mode,
          state: state
        };
      };
      var commands = CodeMirror.commands = {
        selectAll: function(cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        },
        singleSelection: function(cm) {
          cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function(cm) {
          deleteNearSelection(cm, function(range) {
            if (range.empty()) {
              var len = getLine(cm.doc, range.head.line).text.length;
              if (range.head.ch == len && range.head.line < cm.lastLine())
                return {
                  from: range.head,
                  to: Pos(range.head.line + 1, 0)
                };
              else
                return {
                  from: range.head,
                  to: Pos(range.head.line, len)
                };
            } else {
              return {
                from: range.from(),
                to: range.to()
              };
            }
          });
        },
        deleteLine: function(cm) {
          deleteNearSelection(cm, function(range) {
            return {
              from: Pos(range.from().line, 0),
              to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function(cm) {
          deleteNearSelection(cm, function(range) {
            return {
              from: Pos(range.from().line, 0),
              to: range.from()
            };
          });
        },
        delWrappedLineLeft: function(cm) {
          deleteNearSelection(cm, function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var leftPos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");
            return {
              from: leftPos,
              to: range.from()
            };
          });
        },
        delWrappedLineRight: function(cm) {
          deleteNearSelection(cm, function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var rightPos = cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
            return {
              from: range.from(),
              to: rightPos
            };
          });
        },
        undo: function(cm) {
          cm.undo();
        },
        redo: function(cm) {
          cm.redo();
        },
        undoSelection: function(cm) {
          cm.undoSelection();
        },
        redoSelection: function(cm) {
          cm.redoSelection();
        },
        goDocStart: function(cm) {
          cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function(cm) {
          cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function(cm) {
          cm.extendSelectionsBy(function(range) {
            return lineStart(cm, range.head.line);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineStartSmart: function(cm) {
          cm.extendSelectionsBy(function(range) {
            return lineStartSmart(cm, range.head);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineEnd: function(cm) {
          cm.extendSelectionsBy(function(range) {
            return lineEnd(cm, range.head.line);
          }, {
            origin: "+move",
            bias: -1
          });
        },
        goLineRight: function(cm) {
          cm.extendSelectionsBy(function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeft: function(cm) {
          cm.extendSelectionsBy(function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: 0,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeftSmart: function(cm) {
          cm.extendSelectionsBy(function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var pos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");
            if (pos.ch < cm.getLine(pos.line).search(/\S/))
              return lineStartSmart(cm, range.head);
            return pos;
          }, sel_move);
        },
        goLineUp: function(cm) {
          cm.moveV(-1, "line");
        },
        goLineDown: function(cm) {
          cm.moveV(1, "line");
        },
        goPageUp: function(cm) {
          cm.moveV(-1, "page");
        },
        goPageDown: function(cm) {
          cm.moveV(1, "page");
        },
        goCharLeft: function(cm) {
          cm.moveH(-1, "char");
        },
        goCharRight: function(cm) {
          cm.moveH(1, "char");
        },
        goColumnLeft: function(cm) {
          cm.moveH(-1, "column");
        },
        goColumnRight: function(cm) {
          cm.moveH(1, "column");
        },
        goWordLeft: function(cm) {
          cm.moveH(-1, "word");
        },
        goGroupRight: function(cm) {
          cm.moveH(1, "group");
        },
        goGroupLeft: function(cm) {
          cm.moveH(-1, "group");
        },
        goWordRight: function(cm) {
          cm.moveH(1, "word");
        },
        delCharBefore: function(cm) {
          cm.deleteH(-1, "char");
        },
        delCharAfter: function(cm) {
          cm.deleteH(1, "char");
        },
        delWordBefore: function(cm) {
          cm.deleteH(-1, "word");
        },
        delWordAfter: function(cm) {
          cm.deleteH(1, "word");
        },
        delGroupBefore: function(cm) {
          cm.deleteH(-1, "group");
        },
        delGroupAfter: function(cm) {
          cm.deleteH(1, "group");
        },
        indentAuto: function(cm) {
          cm.indentSelection("smart");
        },
        indentMore: function(cm) {
          cm.indentSelection("add");
        },
        indentLess: function(cm) {
          cm.indentSelection("subtract");
        },
        insertTab: function(cm) {
          cm.replaceSelection("\t");
        },
        insertSoftTab: function(cm) {
          var spaces = [],
              ranges = cm.listSelections(),
              tabSize = cm.options.tabSize;
          for (var i = 0; i < ranges.length; i++) {
            var pos = ranges[i].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
          }
          cm.replaceSelections(spaces);
        },
        defaultTab: function(cm) {
          if (cm.somethingSelected())
            cm.indentSelection("add");
          else
            cm.execCommand("insertTab");
        },
        transposeChars: function(cm) {
          runInOp(cm, function() {
            var ranges = cm.listSelections(),
                newSel = [];
            for (var i = 0; i < ranges.length; i++) {
              var cur = ranges[i].head,
                  line = getLine(cm.doc, cur.line).text;
              if (line) {
                if (cur.ch == line.length)
                  cur = new Pos(cur.line, cur.ch - 1);
                if (cur.ch > 0) {
                  cur = new Pos(cur.line, cur.ch + 1);
                  cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                } else if (cur.line > cm.doc.first) {
                  var prev = getLine(cm.doc, cur.line - 1).text;
                  if (prev)
                    cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
                }
              }
              newSel.push(new Range(cur, cur));
            }
            cm.setSelections(newSel);
          });
        },
        newlineAndIndent: function(cm) {
          runInOp(cm, function() {
            var len = cm.listSelections().length;
            for (var i = 0; i < len; i++) {
              var range = cm.listSelections()[i];
              cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
              cm.indentLine(range.from().line + 1, null, true);
              ensureCursorVisible(cm);
            }
          });
        },
        toggleOverwrite: function(cm) {
          cm.toggleOverwrite();
        }
      };
      var keyMap = CodeMirror.keyMap = {};
      keyMap.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      };
      keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
      };
      keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight",
        "Alt-B": "goWordLeft",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
      function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/),
            name = parts[parts.length - 1];
        var alt,
            ctrl,
            shift,
            cmd;
        for (var i = 0; i < parts.length - 1; i++) {
          var mod = parts[i];
          if (/^(cmd|meta|m)$/i.test(mod))
            cmd = true;
          else if (/^a(lt)?$/i.test(mod))
            alt = true;
          else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
          else if (/^s(hift)$/i.test(mod))
            shift = true;
          else
            throw new Error("Unrecognized modifier name: " + mod);
        }
        if (alt)
          name = "Alt-" + name;
        if (ctrl)
          name = "Ctrl-" + name;
        if (cmd)
          name = "Cmd-" + name;
        if (shift)
          name = "Shift-" + name;
        return name;
      }
      CodeMirror.normalizeKeyMap = function(keymap) {
        var copy = {};
        for (var keyname in keymap)
          if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];
            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname))
              continue;
            if (value == "...") {
              delete keymap[keyname];
              continue;
            }
            var keys = map(keyname.split(" "), normalizeKeyName);
            for (var i = 0; i < keys.length; i++) {
              var val,
                  name;
              if (i == keys.length - 1) {
                name = keys.join(" ");
                val = value;
              } else {
                name = keys.slice(0, i + 1).join(" ");
                val = "...";
              }
              var prev = copy[name];
              if (!prev)
                copy[name] = val;
              else if (prev != val)
                throw new Error("Inconsistent bindings for " + name);
            }
            delete keymap[keyname];
          }
        for (var prop in copy)
          keymap[prop] = copy[prop];
        return keymap;
      };
      var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];
        if (found === false)
          return "nothing";
        if (found === "...")
          return "multi";
        if (found != null && handle(found))
          return "handled";
        if (map.fallthrough) {
          if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
            return lookupKey(key, map.fallthrough, handle, context);
          for (var i = 0; i < map.fallthrough.length; i++) {
            var result = lookupKey(key, map.fallthrough[i], handle, context);
            if (result)
              return result;
          }
        }
      };
      var isModifierKey = CodeMirror.isModifierKey = function(value) {
        var name = typeof value == "string" ? value : keyNames[value.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
      };
      var keyName = CodeMirror.keyName = function(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"])
          return false;
        var base = keyNames[event.keyCode],
            name = base;
        if (name == null || event.altGraphKey)
          return false;
        if (event.altKey && base != "Alt")
          name = "Alt-" + name;
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl")
          name = "Ctrl-" + name;
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd")
          name = "Cmd-" + name;
        if (!noShift && event.shiftKey && base != "Shift")
          name = "Shift-" + name;
        return name;
      };
      function getKeyMap(val) {
        return typeof val == "string" ? keyMap[val] : val;
      }
      CodeMirror.fromTextArea = function(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex)
          options.tabindex = textarea.tabIndex;
        if (!options.placeholder && textarea.placeholder)
          options.placeholder = textarea.placeholder;
        if (options.autofocus == null) {
          var hasFocus = activeElt();
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }
        function save() {
          textarea.value = cm.getValue();
        }
        if (textarea.form) {
          on(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form,
                realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function() {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {}
          }
        }
        options.finishInit = function(cm) {
          cm.save = save;
          cm.getTextArea = function() {
            return textarea;
          };
          cm.toTextArea = function() {
            cm.toTextArea = isNaN;
            save();
            textarea.parentNode.removeChild(cm.getWrapperElement());
            textarea.style.display = "";
            if (textarea.form) {
              off(textarea.form, "submit", save);
              if (typeof textarea.form.submit == "function")
                textarea.form.submit = realSubmit;
            }
          };
        };
        textarea.style.display = "none";
        var cm = CodeMirror(function(node) {
          textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
      };
      var StringStream = CodeMirror.StringStream = function(string, tabSize) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
      };
      StringStream.prototype = {
        eol: function() {
          return this.pos >= this.string.length;
        },
        sol: function() {
          return this.pos == this.lineStart;
        },
        peek: function() {
          return this.string.charAt(this.pos) || undefined;
        },
        next: function() {
          if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
        },
        eat: function(match) {
          var ch = this.string.charAt(this.pos);
          if (typeof match == "string")
            var ok = ch == match;
          else
            var ok = ch && (match.test ? match.test(ch) : match(ch));
          if (ok) {
            ++this.pos;
            return ch;
          }
        },
        eatWhile: function(match) {
          var start = this.pos;
          while (this.eat(match)) {}
          return this.pos > start;
        },
        eatSpace: function() {
          var start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
          return this.pos > start;
        },
        skipToEnd: function() {
          this.pos = this.string.length;
        },
        skipTo: function(ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        },
        backUp: function(n) {
          this.pos -= n;
        },
        column: function() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        indentation: function() {
          return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        match: function(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function(str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false)
                this.pos += pattern.length;
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
              return null;
            if (match && consume !== false)
              this.pos += match[0].length;
            return match;
          }
        },
        current: function() {
          return this.string.slice(this.start, this.pos);
        },
        hideFirstChars: function(n, inner) {
          this.lineStart += n;
          try {
            return inner();
          } finally {
            this.lineStart -= n;
          }
        }
      };
      var nextMarkerId = 0;
      var TextMarker = CodeMirror.TextMarker = function(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
        this.id = ++nextMarkerId;
      };
      eventMixin(TextMarker);
      TextMarker.prototype.clear = function() {
        if (this.explicitlyCleared)
          return;
        var cm = this.doc.cm,
            withOp = cm && !cm.curOp;
        if (withOp)
          startOperation(cm);
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found)
            signalLater(this, "clear", found.from, found.to);
        }
        var min = null,
            max = null;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (cm && !this.collapsed)
            regLineChange(cm, lineNo(line), "text");
          else if (cm) {
            if (span.to != null)
              max = lineNo(line);
            if (span.from != null)
              min = lineNo(line);
          }
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
            updateLineHeight(line, textHeight(cm.display));
        }
        if (cm && this.collapsed && !cm.options.lineWrapping)
          for (var i = 0; i < this.lines.length; ++i) {
            var visual = visualLine(this.lines[i]),
                len = lineLength(visual);
            if (len > cm.display.maxLineLength) {
              cm.display.maxLine = visual;
              cm.display.maxLineLength = len;
              cm.display.maxLineChanged = true;
            }
          }
        if (min != null && cm && this.collapsed)
          regChange(cm, min, max + 1);
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm)
            reCheckSelection(cm.doc);
        }
        if (cm)
          signalLater(cm, "markerCleared", cm, this);
        if (withOp)
          endOperation(cm);
        if (this.parent)
          this.parent.clear();
      };
      TextMarker.prototype.find = function(side, lineObj) {
        if (side == null && this.type == "bookmark")
          side = 1;
        var from,
            to;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.from != null) {
            from = Pos(lineObj ? line : lineNo(line), span.from);
            if (side == -1)
              return from;
          }
          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);
            if (side == 1)
              return to;
          }
        }
        return from && {
          from: from,
          to: to
        };
      };
      TextMarker.prototype.changed = function() {
        var pos = this.find(-1, true),
            widget = this,
            cm = this.doc.cm;
        if (!pos || !cm)
          return;
        runInOp(cm, function() {
          var line = pos.line,
              lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);
          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }
          cm.curOp.updateMaxLine = true;
          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;
            if (dHeight)
              updateLineHeight(line, line.height + dHeight);
          }
        });
      };
      TextMarker.prototype.attachLine = function(line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(line);
      };
      TextMarker.prototype.detachLine = function(line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };
      var nextMarkerId = 0;
      function markText(doc, from, to, options, type) {
        if (options && options.shared)
          return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp)
          return operation(doc.cm, markText)(doc, from, to, options, type);
        var marker = new TextMarker(doc, type),
            diff = cmp(from, to);
        if (options)
          copyObj(options, marker, false);
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
          return marker;
        if (marker.replacedWith) {
          marker.collapsed = true;
          marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents)
            marker.widgetNode.setAttribute("cm-ignore-events", "true");
          if (options.insertLeft)
            marker.widgetNode.insertLeft = true;
        }
        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          sawCollapsedSpans = true;
        }
        if (marker.addToHistory)
          addChangeToHistory(doc, {
            from: from,
            to: to,
            origin: "markText"
          }, doc.sel, NaN);
        var curLine = from.line,
            cm = doc.cm,
            updateMaxLine;
        doc.iter(curLine, to.line + 1, function(line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
            updateMaxLine = true;
          if (marker.collapsed && curLine != from.line)
            updateLineHeight(line, 0);
          addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
          ++curLine;
        });
        if (marker.collapsed)
          doc.iter(from.line, to.line + 1, function(line) {
            if (lineIsHidden(doc, line))
              updateLineHeight(line, 0);
          });
        if (marker.clearOnEnter)
          on(marker, "beforeCursorEnter", function() {
            marker.clear();
          });
        if (marker.readOnly) {
          sawReadOnlySpans = true;
          if (doc.history.done.length || doc.history.undone.length)
            doc.clearHistory();
        }
        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }
        if (cm) {
          if (updateMaxLine)
            cm.curOp.updateMaxLine = true;
          if (marker.collapsed)
            regChange(cm, from.line, to.line + 1);
          else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
            for (var i = from.line; i <= to.line; i++)
              regLineChange(cm, i, "text");
          if (marker.atomic)
            reCheckSelection(cm.doc);
          signalLater(cm, "markerAdded", cm, marker);
        }
        return marker;
      }
      var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i = 0; i < markers.length; ++i)
          markers[i].parent = this;
      };
      eventMixin(SharedTextMarker);
      SharedTextMarker.prototype.clear = function() {
        if (this.explicitlyCleared)
          return;
        this.explicitlyCleared = true;
        for (var i = 0; i < this.markers.length; ++i)
          this.markers[i].clear();
        signalLater(this, "clear");
      };
      SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj);
      };
      function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type)],
            primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function(doc) {
          if (widget)
            options.widgetNode = widget.cloneNode(true);
          markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
          for (var i = 0; i < doc.linked.length; ++i)
            if (doc.linked[i].isParent)
              return;
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }
      function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
          return m.parent;
        });
      }
      function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
          var marker = markers[i],
              pos = marker.find();
          var mFrom = doc.clipPos(pos.from),
              mTo = doc.clipPos(pos.to);
          if (cmp(mFrom, mTo)) {
            var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }
      function detachSharedMarkers(markers) {
        for (var i = 0; i < markers.length; i++) {
          var marker = markers[i],
              linked = [marker.primary.doc];
          ;
          linkedDocs(marker.primary.doc, function(d) {
            linked.push(d);
          });
          for (var j = 0; j < marker.markers.length; j++) {
            var subMarker = marker.markers[j];
            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j--, 1);
            }
          }
        }
      }
      function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
      }
      function getMarkedSpanFor(spans, marker) {
        if (spans)
          for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if (span.marker == marker)
              return span;
          }
      }
      function removeMarkedSpan(spans, span) {
        for (var r,
            i = 0; i < spans.length; ++i)
          if (spans[i] != span)
            (r || (r = [])).push(spans[i]);
        return r;
      }
      function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
      }
      function markedSpansBefore(old, startCh, isInsert) {
        if (old)
          for (var i = 0,
              nw; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
            if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
          }
        return nw;
      }
      function markedSpansAfter(old, endCh, isInsert) {
        if (old)
          for (var i = 0,
              nw; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
            if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
            }
          }
        return nw;
      }
      function stretchSpansOverChange(doc, change) {
        if (change.full)
          return null;
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast)
          return null;
        var startCh = change.from.ch,
            endCh = change.to.ch,
            isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1,
            offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          for (var i = 0; i < first.length; ++i) {
            var span = first[i];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found)
                span.to = startCh;
              else if (sameLine)
                span.to = found.to == null ? null : found.to + offset;
            }
          }
        }
        if (last) {
          for (var i = 0; i < last.length; ++i) {
            var span = last[i];
            if (span.to != null)
              span.to += offset;
            if (span.from == null) {
              var found = getMarkedSpanFor(first, span.marker);
              if (!found) {
                span.from = offset;
                if (sameLine)
                  (first || (first = [])).push(span);
              }
            } else {
              span.from += offset;
              if (sameLine)
                (first || (first = [])).push(span);
            }
          }
        }
        if (first)
          first = clearEmptySpans(first);
        if (last && last != first)
          last = clearEmptySpans(last);
        var newMarkers = [first];
        if (!sameLine) {
          var gap = change.text.length - 2,
              gapMarkers;
          if (gap > 0 && first)
            for (var i = 0; i < first.length; ++i)
              if (first[i].to == null)
                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
          for (var i = 0; i < gap; ++i)
            newMarkers.push(gapMarkers);
          newMarkers.push(last);
        }
        return newMarkers;
      }
      function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
            spans.splice(i--, 1);
        }
        if (!spans.length)
          return null;
        return spans;
      }
      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old)
          return stretched;
        if (!stretched)
          return old;
        for (var i = 0; i < old.length; ++i) {
          var oldCur = old[i],
              stretchCur = stretched[i];
          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k)
                if (oldCur[k].marker == span.marker)
                  continue spans;
              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i] = stretchCur;
          }
        }
        return old;
      }
      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function(line) {
          if (line.markedSpans)
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var mark = line.markedSpans[i].marker;
              if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
                (markers || (markers = [])).push(mark);
            }
        });
        if (!markers)
          return null;
        var parts = [{
          from: from,
          to: to
        }];
        for (var i = 0; i < markers.length; ++i) {
          var mk = markers[i],
              m = mk.find(0);
          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];
            if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)
              continue;
            var newParts = [j, 1],
                dfrom = cmp(p.from, m.from),
                dto = cmp(p.to, m.to);
            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
              newParts.push({
                from: p.from,
                to: m.from
              });
            if (dto > 0 || !mk.inclusiveRight && !dto)
              newParts.push({
                from: m.to,
                to: p.to
              });
            parts.splice.apply(parts, newParts);
            j += newParts.length - 1;
          }
        }
        return parts;
      }
      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans)
          return;
        for (var i = 0; i < spans.length; ++i)
          spans[i].marker.detachLine(line);
        line.markedSpans = null;
      }
      function attachMarkedSpans(line, spans) {
        if (!spans)
          return;
        for (var i = 0; i < spans.length; ++i)
          spans[i].marker.attachLine(line);
        line.markedSpans = spans;
      }
      function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
      }
      function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
      }
      function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0)
          return lenDiff;
        var aPos = a.find(),
            bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp)
          return -fromCmp;
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp)
          return toCmp;
        return b.id - a.id;
      }
      function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;
        if (sps)
          for (var sp,
              i = 0; i < sps.length; ++i) {
            sp = sps[i];
            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
              found = sp.marker;
          }
        return found;
      }
      function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
      }
      function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
      }
      function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
          for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];
            if (!sp.marker.collapsed)
              continue;
            var found = sp.marker.find(0);
            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)
              continue;
            if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) || fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
              return true;
          }
      }
      function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line))
          line = merged.find(-1, true).line;
        return line;
      }
      function visualLineContinued(line) {
        var merged,
            lines;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          (lines || (lines = [])).push(line);
        }
        return lines;
      }
      function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN),
            vis = visualLine(line);
        if (line == vis)
          return lineN;
        return lineNo(vis);
      }
      function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine())
          return lineN;
        var line = getLine(doc, lineN),
            merged;
        if (!lineIsHidden(doc, line))
          return lineN;
        while (merged = collapsedSpanAtEnd(line))
          line = merged.find(1, true).line;
        return lineNo(line) + 1;
      }
      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
          for (var sp,
              i = 0; i < sps.length; ++i) {
            sp = sps[i];
            if (!sp.marker.collapsed)
              continue;
            if (sp.from == null)
              return true;
            if (sp.marker.widgetNode)
              continue;
            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
              return true;
          }
      }
      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length)
          return true;
        for (var sp,
            i = 0; i < line.markedSpans.length; ++i) {
          sp = line.markedSpans[i];
          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
            return true;
        }
      }
      var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
        if (options)
          for (var opt in options)
            if (options.hasOwnProperty(opt))
              this[opt] = options[opt];
        this.doc = doc;
        this.node = node;
      };
      eventMixin(LineWidget);
      function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
          addToScrollPos(cm, null, diff);
      }
      LineWidget.prototype.clear = function() {
        var cm = this.doc.cm,
            ws = this.line.widgets,
            line = this.line,
            no = lineNo(line);
        if (no == null || !ws)
          return;
        for (var i = 0; i < ws.length; ++i)
          if (ws[i] == this)
            ws.splice(i--, 1);
        if (!ws.length)
          line.widgets = null;
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm)
          runInOp(cm, function() {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
      };
      LineWidget.prototype.changed = function() {
        var oldH = this.height,
            cm = this.doc.cm,
            line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff)
          return;
        updateLineHeight(line, line.height + diff);
        if (cm)
          runInOp(cm, function() {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
          });
      };
      function widgetHeight(widget) {
        if (widget.height != null)
          return widget.height;
        var cm = widget.doc.cm;
        if (!cm)
          return 0;
        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";
          if (widget.coverGutter)
            parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
          if (widget.noHScroll)
            parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.offsetHeight;
      }
      function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;
        if (cm && widget.noHScroll)
          cm.display.alignWidgets = true;
        changeLine(doc, handle, "widget", function(line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null)
            widgets.push(widget);
          else
            widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
          widget.line = line;
          if (cm && !lineIsHidden(doc, line)) {
            var aboveVisible = heightAtLine(line) < doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible)
              addToScrollPos(cm, null, widget.height);
            cm.curOp.forceUpdate = true;
          }
          return true;
        });
        return widget;
      }
      var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
      };
      eventMixin(Line);
      Line.prototype.lineNo = function() {
        return lineNo(this);
      };
      function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter)
          line.stateAfter = null;
        if (line.styles)
          line.styles = null;
        if (line.order != null)
          line.order = null;
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height)
          updateLineHeight(line, estHeight);
      }
      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }
      function extractLineClasses(type, output) {
        if (type)
          for (; ; ) {
            var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!lineClass)
              break;
            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
            var prop = lineClass[1] ? "bgClass" : "textClass";
            if (output[prop] == null)
              output[prop] = lineClass[2];
            else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
              output[prop] += " " + lineClass[2];
          }
        return type;
      }
      function callBlankLine(mode, state) {
        if (mode.blankLine)
          return mode.blankLine(state);
        if (!mode.innerMode)
          return;
        var inner = CodeMirror.innerMode(mode, state);
        if (inner.mode.blankLine)
          return inner.mode.blankLine(inner.state);
      }
      function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
          if (inner)
            inner[0] = CodeMirror.innerMode(mode, state).mode;
          var style = mode.token(stream, state);
          if (stream.pos > stream.start)
            return style;
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
      }
      function takeToken(cm, pos, precise, asArray) {
        function getObj(copy) {
          return {
            start: stream.start,
            end: stream.pos,
            string: stream.current(),
            type: style || null,
            state: copy ? copyState(doc.mode, state) : state
          };
        }
        var doc = cm.doc,
            mode = doc.mode,
            style;
        pos = clipPos(doc, pos);
        var line = getLine(doc, pos.line),
            state = getStateBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize),
            tokens;
        if (asArray)
          tokens = [];
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken(mode, stream, state);
          if (asArray)
            tokens.push(getObj(true));
        }
        return asArray ? tokens : getObj();
      }
      function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null)
          flattenSpans = cm.options.flattenSpans;
        var curStart = 0,
            curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize),
            style;
        var inner = cm.options.addModeClass && [null];
        if (text == "")
          extractLineClasses(callBlankLine(mode, state), lineClasses);
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd)
              processLine(cm, text, state, stream.pos);
            stream.pos = text.length;
            style = null;
          } else {
            style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
          }
          if (inner) {
            var mName = inner[0].name;
            if (mName)
              style = "m-" + (style ? mName + " " + style : mName);
          }
          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 50000);
              f(curStart, curStyle);
            }
            curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          var pos = Math.min(stream.pos, curStart + 50000);
          f(pos, curStyle);
          curStart = pos;
        }
      }
      function highlightLine(cm, line, state, forceToEnd) {
        var st = [cm.state.modeGen],
            lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
          st.push(end, style);
        }, lineClasses, forceToEnd);
        for (var o = 0; o < cm.state.overlays.length; ++o) {
          var overlay = cm.state.overlays[o],
              i = 1,
              at = 0;
          runMode(cm, line.text, overlay.mode, true, function(end, style) {
            var start = i;
            while (at < end) {
              var i_end = st[i];
              if (i_end > end)
                st.splice(i, 1, end, st[i + 1], i_end);
              i += 2;
              at = Math.min(end, i_end);
            }
            if (!style)
              return;
            if (overlay.opaque) {
              st.splice(start, i - start, end, "cm-overlay " + style);
              i = start + 2;
            } else {
              for (; start < i; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = (cur ? cur + " " : "") + "cm-overlay " + style;
              }
            }
          }, lineClasses);
        }
        return {
          styles: st,
          classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
      }
      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var state = getStateBefore(cm, lineNo(line));
          var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
          line.stateAfter = state;
          line.styles = result.styles;
          if (result.classes)
            line.styleClasses = result.classes;
          else if (line.styleClasses)
            line.styleClasses = null;
          if (updateFrontier === cm.doc.frontier)
            cm.doc.frontier++;
        }
        return line.styles;
      }
      function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize);
        stream.start = stream.pos = startAt || 0;
        if (text == "")
          callBlankLine(mode, state);
        while (!stream.eol()) {
          readToken(mode, stream, state);
          stream.start = stream.pos;
        }
      }
      var styleToClassCache = {},
          styleToClassCacheWithMode = {};
      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style))
          return null;
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
      }
      function buildLineContent(cm, lineView) {
        var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
          pre: elt("pre", [content], "CodeMirror-line"),
          content: content,
          col: 0,
          pos: 0,
          cm: cm,
          splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
        };
        lineView.measure = {};
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
          var line = i ? lineView.rest[i - 1] : lineView.line,
              order;
          builder.pos = 0;
          builder.addToken = buildToken;
          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
            builder.addToken = buildTokenBadBidi(builder.addToken, order);
          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
          if (line.styleClasses) {
            if (line.styleClasses.bgClass)
              builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
            if (line.styleClasses.textClass)
              builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
          }
          if (builder.map.length == 0)
            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
          if (i == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
            (lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        }
        if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
          builder.content.className = "cm-tab-wrap-hack";
        signal(cm, "renderLine", cm, lineView.line, builder.pre);
        if (builder.pre.className)
          builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        return builder;
      }
      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
      }
      function buildToken(builder, text, style, startStyle, endStyle, title, css) {
        if (!text)
          return;
        var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
        var special = builder.cm.state.specialChars,
            mustWrap = false;
        if (!special.test(text)) {
          builder.col += text.length;
          var content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text.length, content);
          if (ie && ie_version < 9)
            mustWrap = true;
          builder.pos += text.length;
        } else {
          var content = document.createDocumentFragment(),
              pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;
            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
              if (ie && ie_version < 9)
                content.appendChild(elt("span", [txt]));
              else
                content.appendChild(txt);
              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }
            if (!m)
              break;
            pos += skipped + 1;
            if (m[0] == "\t") {
              var tabSize = builder.cm.options.tabSize,
                  tabWidth = tabSize - builder.col % tabSize;
              var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt.setAttribute("role", "presentation");
              txt.setAttribute("cm-text", "\t");
              builder.col += tabWidth;
            } else if (m[0] == "\r" || m[0] == "\n") {
              var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
              txt.setAttribute("cm-text", m[0]);
              builder.col += 1;
            } else {
              var txt = builder.cm.options.specialCharPlaceholder(m[0]);
              txt.setAttribute("cm-text", m[0]);
              if (ie && ie_version < 9)
                content.appendChild(elt("span", [txt]));
              else
                content.appendChild(txt);
              builder.col += 1;
            }
            builder.map.push(builder.pos, builder.pos + 1, txt);
            builder.pos++;
          }
        }
        if (style || startStyle || endStyle || mustWrap || css) {
          var fullStyle = style || "";
          if (startStyle)
            fullStyle += startStyle;
          if (endStyle)
            fullStyle += endStyle;
          var token = elt("span", [content], fullStyle, css);
          if (title)
            token.title = title;
          return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
      }
      function splitSpaces(old) {
        var out = " ";
        for (var i = 0; i < old.length - 2; ++i)
          out += i % 2 ? " " : "\u00a0";
        out += " ";
        return out;
      }
      function buildTokenBadBidi(inner, order) {
        return function(builder, text, style, startStyle, endStyle, title, css) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start = builder.pos,
              end = start + text.length;
          for (; ; ) {
            for (var i = 0; i < order.length; i++) {
              var part = order[i];
              if (part.to > start && part.from <= start)
                break;
            }
            if (part.to >= end)
              return inner(builder, text, style, startStyle, endStyle, title, css);
            inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
            startStyle = null;
            text = text.slice(part.to - start);
            start = part.to;
          }
        };
      }
      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget)
          builder.map.push(builder.pos, builder.pos + size, widget);
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget)
            widget = builder.content.appendChild(document.createElement("span"));
          widget.setAttribute("cm-marker", marker.id);
        }
        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }
        builder.pos += size;
      }
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans,
            allText = line.text,
            at = 0;
        if (!spans) {
          for (var i = 1; i < styles.length; i += 2)
            builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options));
          return;
        }
        var len = allText.length,
            pos = 0,
            i = 1,
            text = "",
            style,
            css;
        var nextChange = 0,
            spanStyle,
            spanEndStyle,
            spanStartStyle,
            title,
            collapsed;
        for (; ; ) {
          if (nextChange == pos) {
            spanStyle = spanEndStyle = spanStartStyle = title = css = "";
            collapsed = null;
            nextChange = Infinity;
            var foundBookmarks = [];
            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j],
                  m = sp.marker;
              if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                foundBookmarks.push(m);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }
                if (m.className)
                  spanStyle += " " + m.className;
                if (m.css)
                  css = m.css;
                if (m.startStyle && sp.from == pos)
                  spanStartStyle += " " + m.startStyle;
                if (m.endStyle && sp.to == nextChange)
                  spanEndStyle += " " + m.endStyle;
                if (m.title && !title)
                  title = m.title;
                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
                  collapsed = sp;
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
              if (collapsed.to == null)
                return;
              if (collapsed.to == pos)
                collapsed = false;
            }
            if (!collapsed && foundBookmarks.length)
              for (var j = 0; j < foundBookmarks.length; ++j)
                buildCollapsedSpan(builder, 0, foundBookmarks[j]);
          }
          if (pos >= len)
            break;
          var upto = Math.min(len, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
              }
              if (end >= upto) {
                text = text.slice(upto - pos);
                pos = upto;
                break;
              }
              pos = end;
              spanStartStyle = "";
            }
            text = allText.slice(at, at = styles[i++]);
            style = interpretTokenStyle(styles[i++], builder.cm.options);
          }
        }
      }
      function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
      }
      function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
          updateLine(line, text, spans, estimateHeight);
          signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
          for (var i = start,
              result = []; i < end; ++i)
            result.push(new Line(text[i], spansFor(i), estimateHeight));
          return result;
        }
        var from = change.from,
            to = change.to,
            text = change.text;
        var firstLine = getLine(doc, from.line),
            lastLine = getLine(doc, to.line);
        var lastText = lst(text),
            lastSpans = spansFor(text.length - 1),
            nlines = to.line - from.line;
        if (change.full) {
          doc.insert(0, linesFor(0, text.length));
          doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
          var added = linesFor(0, text.length - 1);
          update(lastLine, lastLine.text, lastSpans);
          if (nlines)
            doc.remove(from.line, nlines);
          if (added.length)
            doc.insert(from.line, added);
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added = linesFor(1, text.length - 1);
            added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc.insert(from.line + 1, added);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added = linesFor(1, text.length - 1);
          if (nlines > 1)
            doc.remove(from.line + 1, nlines - 1);
          doc.insert(from.line + 1, added);
        }
        signalLater(doc, "change", doc, change);
      }
      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        for (var i = 0,
            height = 0; i < lines.length; ++i) {
          lines[i].parent = this;
          height += lines[i].height;
        }
        this.height = height;
      }
      LeafChunk.prototype = {
        chunkSize: function() {
          return this.lines.length;
        },
        removeInner: function(at, n) {
          for (var i = at,
              e = at + n; i < e; ++i) {
            var line = this.lines[i];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n);
        },
        collapse: function(lines) {
          lines.push.apply(lines, this.lines);
        },
        insertInner: function(at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i = 0; i < lines.length; ++i)
            lines[i].parent = this;
        },
        iterN: function(at, n, op) {
          for (var e = at + n; at < e; ++at)
            if (op(this.lines[at]))
              return true;
        }
      };
      function BranchChunk(children) {
        this.children = children;
        var size = 0,
            height = 0;
        for (var i = 0; i < children.length; ++i) {
          var ch = children[i];
          size += ch.chunkSize();
          height += ch.height;
          ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }
      BranchChunk.prototype = {
        chunkSize: function() {
          return this.size;
        },
        removeInner: function(at, n) {
          this.size -= n;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n, sz - at),
                  oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;
              if (sz == rm) {
                this.children.splice(i--, 1);
                child.parent = null;
              }
              if ((n -= rm) == 0)
                break;
              at = 0;
            } else
              at -= sz;
          }
          if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function(lines) {
          for (var i = 0; i < this.children.length; ++i)
            this.children[i].collapse(lines);
        },
        insertInner: function(at, lines, height) {
          this.size += lines.length;
          this.height += height;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                while (child.lines.length > 50) {
                  var spilled = child.lines.splice(child.lines.length - 25, 25);
                  var newleaf = new LeafChunk(spilled);
                  child.height -= newleaf.height;
                  this.children.splice(i + 1, 0, newleaf);
                  newleaf.parent = this;
                }
                this.maybeSpill();
              }
              break;
            }
            at -= sz;
          }
        },
        maybeSpill: function() {
          if (this.children.length <= 10)
            return;
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) {
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10);
          me.parent.maybeSpill();
        },
        iterN: function(at, n, op) {
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n, sz - at);
              if (child.iterN(at, used, op))
                return true;
              if ((n -= used) == 0)
                break;
              at = 0;
            } else
              at -= sz;
          }
        }
      };
      var nextDocId = 0;
      var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
        if (!(this instanceof Doc))
          return new Doc(text, mode, firstLine, lineSep);
        if (firstLine == null)
          firstLine = 0;
        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        if (typeof text == "string")
          text = this.splitLines(text);
        updateDoc(this, {
          from: start,
          to: start,
          text: text
        });
        setSelection(this, simpleSelection(start), sel_dontScroll);
      };
      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function(from, to, op) {
          if (op)
            this.iterN(from - this.first, to - from, op);
          else
            this.iterN(this.first, this.first + this.size, from);
        },
        insert: function(at, lines) {
          var height = 0;
          for (var i = 0; i < lines.length; ++i)
            height += lines[i].height;
          this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n) {
          this.removeInner(at - this.first, n);
        },
        getValue: function(lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false)
            return lines;
          return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function(code) {
          var top = Pos(this.first, 0),
              last = this.first + this.size - 1;
          makeChange(this, {
            from: top,
            to: Pos(last, getLine(this, last).text.length),
            text: this.splitLines(code),
            origin: "setValue",
            full: true
          }, true);
          setSelection(this, simpleSelection(top));
        }),
        replaceRange: function(code, from, to, origin) {
          from = clipPos(this, from);
          to = to ? clipPos(this, to) : from;
          replaceRange(this, code, from, to, origin);
        },
        getRange: function(from, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
          if (lineSep === false)
            return lines;
          return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function(line) {
          var l = this.getLineHandle(line);
          return l && l.text;
        },
        getLineHandle: function(line) {
          if (isLine(this, line))
            return getLine(this, line);
        },
        getLineNumber: function(line) {
          return lineNo(line);
        },
        getLineHandleVisualStart: function(line) {
          if (typeof line == "number")
            line = getLine(this, line);
          return visualLine(line);
        },
        lineCount: function() {
          return this.size;
        },
        firstLine: function() {
          return this.first;
        },
        lastLine: function() {
          return this.first + this.size - 1;
        },
        clipPos: function(pos) {
          return clipPos(this, pos);
        },
        getCursor: function(start) {
          var range = this.sel.primary(),
              pos;
          if (start == null || start == "head")
            pos = range.head;
          else if (start == "anchor")
            pos = range.anchor;
          else if (start == "end" || start == "to" || start === false)
            pos = range.to();
          else
            pos = range.from();
          return pos;
        },
        listSelections: function() {
          return this.sel.ranges;
        },
        somethingSelected: function() {
          return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function(line, ch, options) {
          setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
          setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
          extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
          extendSelections(this, clipPosArray(this, heads, options));
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
          extendSelections(this, map(this.sel.ranges, f), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
          if (!ranges.length)
            return;
          for (var i = 0,
              out = []; i < ranges.length; i++)
            out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
          if (primary == null)
            primary = Math.min(ranges.length - 1, this.sel.primIndex);
          setSelection(this, normalizeSelection(out, primary), options);
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
        }),
        getSelection: function(lineSep) {
          var ranges = this.sel.ranges,
              lines;
          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());
            lines = lines ? lines.concat(sel) : sel;
          }
          if (lineSep === false)
            return lines;
          else
            return lines.join(lineSep || this.lineSeparator());
        },
        getSelections: function(lineSep) {
          var parts = [],
              ranges = this.sel.ranges;
          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());
            if (lineSep !== false)
              sel = sel.join(lineSep || this.lineSeparator());
            parts[i] = sel;
          }
          return parts;
        },
        replaceSelection: function(code, collapse, origin) {
          var dup = [];
          for (var i = 0; i < this.sel.ranges.length; i++)
            dup[i] = code;
          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
          var changes = [],
              sel = this.sel;
          for (var i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i];
            changes[i] = {
              from: range.from(),
              to: range.to(),
              text: this.splitLines(code[i]),
              origin: origin
            };
          }
          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
          for (var i = changes.length - 1; i >= 0; i--)
            makeChange(this, changes[i]);
          if (newSel)
            setSelectionReplaceHistory(this, newSel);
          else if (this.cm)
            ensureCursorVisible(this.cm);
        }),
        undo: docMethodOp(function() {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function() {
          makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function(val) {
          this.extend = val;
        },
        getExtending: function() {
          return this.extend;
        },
        historySize: function() {
          var hist = this.history,
              done = 0,
              undone = 0;
          for (var i = 0; i < hist.done.length; i++)
            if (!hist.done[i].ranges)
              ++done;
          for (var i = 0; i < hist.undone.length; i++)
            if (!hist.undone[i].ranges)
              ++undone;
          return {
            undo: done,
            redo: undone
          };
        },
        clearHistory: function() {
          this.history = new History(this.history.maxGeneration);
        },
        markClean: function() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(forceSplit) {
          if (forceSplit)
            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
          return this.history.generation;
        },
        isClean: function(gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function() {
          return {
            done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)
          };
        },
        setHistory: function(histData) {
          var hist = this.history = new History(this.history.maxGeneration);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            if (!line[prop])
              line[prop] = cls;
            else if (classTest(cls).test(line[prop]))
              return false;
            else
              line[prop] += " " + cls;
            return true;
          });
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop];
            if (!cur)
              return false;
            else if (cls == null)
              line[prop] = null;
            else {
              var found = cur.match(classTest(cls));
              if (!found)
                return false;
              var end = found.index + found[0].length;
              line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true;
          });
        }),
        addLineWidget: docMethodOp(function(handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function(widget) {
          widget.clear();
        },
        markText: function(from, to, options) {
          return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
        },
        setBookmark: function(pos, options) {
          var realOpts = {
            replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft,
            clearWhenEmpty: false,
            shared: options && options.shared,
            handleMouseEvents: options && options.handleMouseEvents
          };
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function(pos) {
          pos = clipPos(this, pos);
          var markers = [],
              spans = getLine(this, pos.line).markedSpans;
          if (spans)
            for (var i = 0; i < spans.length; ++i) {
              var span = spans[i];
              if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
                markers.push(span.marker.parent || span.marker);
            }
          return markers;
        },
        findMarks: function(from, to, filter) {
          from = clipPos(this, from);
          to = clipPos(this, to);
          var found = [],
              lineNo = from.line;
          this.iter(from.line, to.line + 1, function(line) {
            var spans = line.markedSpans;
            if (spans)
              for (var i = 0; i < spans.length; i++) {
                var span = spans[i];
                if (!(lineNo == from.line && from.ch > span.to || span.from == null && lineNo != from.line || lineNo == to.line && span.from > to.ch) && (!filter || filter(span.marker)))
                  found.push(span.marker.parent || span.marker);
              }
            ++lineNo;
          });
          return found;
        },
        getAllMarks: function() {
          var markers = [];
          this.iter(function(line) {
            var sps = line.markedSpans;
            if (sps)
              for (var i = 0; i < sps.length; ++i)
                if (sps[i].from != null)
                  markers.push(sps[i].marker);
          });
          return markers;
        },
        posFromIndex: function(off) {
          var ch,
              lineNo = this.first;
          this.iter(function(line) {
            var sz = line.text.length + 1;
            if (sz > off) {
              ch = off;
              return true;
            }
            off -= sz;
            ++lineNo;
          });
          return clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function(coords) {
          coords = clipPos(this, coords);
          var index = coords.ch;
          if (coords.line < this.first || coords.ch < 0)
            return 0;
          this.iter(this.first, coords.line, function(line) {
            index += line.text.length + 1;
          });
          return index;
        },
        copy: function(copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep);
          doc.scrollTop = this.scrollTop;
          doc.scrollLeft = this.scrollLeft;
          doc.sel = this.sel;
          doc.extend = false;
          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }
          return doc;
        },
        linkedDoc: function(options) {
          if (!options)
            options = {};
          var from = this.first,
              to = this.first + this.size;
          if (options.from != null && options.from > from)
            from = options.from;
          if (options.to != null && options.to < to)
            to = options.to;
          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
          if (options.sharedHist)
            copy.history = this.history;
          (this.linked || (this.linked = [])).push({
            doc: copy,
            sharedHist: options.sharedHist
          });
          copy.linked = [{
            doc: this,
            isParent: true,
            sharedHist: options.sharedHist
          }];
          copySharedMarkers(copy, findSharedMarkers(this));
          return copy;
        },
        unlinkDoc: function(other) {
          if (other instanceof CodeMirror)
            other = other.doc;
          if (this.linked)
            for (var i = 0; i < this.linked.length; ++i) {
              var link = this.linked[i];
              if (link.doc != other)
                continue;
              this.linked.splice(i, 1);
              other.unlinkDoc(this);
              detachSharedMarkers(findSharedMarkers(this));
              break;
            }
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function(doc) {
              splitIds.push(doc.id);
            }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function(f) {
          linkedDocs(this, f);
        },
        getMode: function() {
          return this.mode;
        },
        getEditor: function() {
          return this.cm;
        },
        splitLines: function(str) {
          if (this.lineSep)
            return str.split(this.lineSep);
          return splitLinesAuto(str);
        },
        lineSeparator: function() {
          return this.lineSep || "\n";
        }
      });
      Doc.prototype.eachLine = Doc.prototype.iter;
      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
      for (var prop in Doc.prototype)
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
          CodeMirror.prototype[prop] = (function(method) {
            return function() {
              return method.apply(this.doc, arguments);
            };
          })(Doc.prototype[prop]);
      eventMixin(Doc);
      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
          if (doc.linked)
            for (var i = 0; i < doc.linked.length; ++i) {
              var rel = doc.linked[i];
              if (rel.doc == skip)
                continue;
              var shared = sharedHist && rel.sharedHist;
              if (sharedHistOnly && !shared)
                continue;
              f(rel.doc, shared);
              propagate(rel.doc, doc, shared);
            }
        }
        propagate(doc, null, true);
      }
      function attachDoc(cm, doc) {
        if (doc.cm)
          throw new Error("This document is already in use.");
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        if (!cm.options.lineWrapping)
          findMaxLine(cm);
        cm.options.mode = doc.modeOption;
        regChange(cm);
      }
      function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size)
          throw new Error("There is no line " + (n + doc.first) + " in the document.");
        for (var chunk = doc; !chunk.lines; ) {
          for (var i = 0; ; ++i) {
            var child = chunk.children[i],
                sz = child.chunkSize();
            if (n < sz) {
              chunk = child;
              break;
            }
            n -= sz;
          }
        }
        return chunk.lines[n];
      }
      function getBetween(doc, start, end) {
        var out = [],
            n = start.line;
        doc.iter(start.line, end.line + 1, function(line) {
          var text = line.text;
          if (n == end.line)
            text = text.slice(0, end.ch);
          if (n == start.line)
            text = text.slice(start.ch);
          out.push(text);
          ++n;
        });
        return out;
      }
      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function(line) {
          out.push(line.text);
        });
        return out;
      }
      function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff)
          for (var n = line; n; n = n.parent)
            n.height += diff;
      }
      function lineNo(line) {
        if (line.parent == null)
          return null;
        var cur = line.parent,
            no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i = 0; ; ++i) {
            if (chunk.children[i] == cur)
              break;
            no += chunk.children[i].chunkSize();
          }
        }
        return no + cur.first;
      }
      function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
          for (var i = 0; i < chunk.children.length; ++i) {
            var child = chunk.children[i],
                ch = child.height;
            if (h < ch) {
              chunk = child;
              continue outer;
            }
            h -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i],
              lh = line.height;
          if (h < lh)
            break;
          h -= lh;
        }
        return n + i;
      }
      function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0,
            chunk = lineObj.parent;
        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i];
          if (line == lineObj)
            break;
          else
            h += line.height;
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i = 0; i < p.children.length; ++i) {
            var cur = p.children[i];
            if (cur == chunk)
              break;
            else
              h += cur.height;
          }
        }
        return h;
      }
      function getOrder(line) {
        var order = line.order;
        if (order == null)
          order = line.order = bidiOrdering(line.text);
        return order;
      }
      function History(startGen) {
        this.done = [];
        this.undone = [];
        this.undoDepth = Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = startGen || 1;
      }
      function historyChangeFromChange(doc, change) {
        var histChange = {
          from: copyPos(change.from),
          to: changeEnd(change),
          text: getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function(doc) {
          attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      }
      function clearSelectionEvents(array) {
        while (array.length) {
          var last = lst(array);
          if (last.ranges)
            array.pop();
          else
            break;
        }
      }
      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done);
        }
      }
      function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date,
            cur;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          var last = lst(cur.changes);
          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            last.to = changeEnd(change);
          } else {
            cur.changes.push(historyChangeFromChange(doc, change));
          }
        } else {
          var before = lst(hist.done);
          if (!before || !before.ranges)
            pushSelectionToHistory(doc.sel, hist.done);
          cur = {
            changes: [historyChangeFromChange(doc, change)],
            generation: hist.generation
          };
          hist.done.push(cur);
          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();
            if (!hist.done[0].ranges)
              hist.done.shift();
          }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last)
          signal(doc, "historyAdded");
      }
      function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
      }
      function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history,
            origin = options && options.origin;
        if (opId == hist.lastSelOp || (origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
          hist.done[hist.done.length - 1] = sel;
        else
          pushSelectionToHistory(sel, hist.done);
        hist.lastSelTime = +new Date;
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false)
          clearSelectionEvents(hist.undone);
      }
      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel)))
          dest.push(sel);
      }
      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id],
            n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
          if (line.markedSpans)
            (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
          ++n;
        });
      }
      function removeClearedSpans(spans) {
        if (!spans)
          return null;
        for (var i = 0,
            out; i < spans.length; ++i) {
          if (spans[i].marker.explicitlyCleared) {
            if (!out)
              out = spans.slice(0, i);
          } else if (out)
            out.push(spans[i]);
        }
        return !out ? spans : out.length ? out : null;
      }
      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found)
          return null;
        for (var i = 0,
            nw = []; i < change.text.length; ++i)
          nw.push(removeClearedSpans(found[i]));
        return nw;
      }
      function copyHistoryArray(events, newGroup, instantiateSel) {
        for (var i = 0,
            copy = []; i < events.length; ++i) {
          var event = events[i];
          if (event.ranges) {
            copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            continue;
          }
          var changes = event.changes,
              newChanges = [];
          copy.push({changes: newChanges});
          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j],
                m;
            newChanges.push({
              from: change.from,
              to: change.to,
              text: change.text
            });
            if (newGroup)
              for (var prop in change)
                if (m = prop.match(/^spans_(\d+)$/)) {
                  if (indexOf(newGroup, Number(m[1])) > -1) {
                    lst(newChanges)[prop] = change[prop];
                    delete change[prop];
                  }
                }
          }
        }
        return copy;
      }
      function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      }
      function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i],
              ok = true;
          if (sub.ranges) {
            if (!sub.copied) {
              sub = array[i] = sub.deepCopy();
              sub.copied = true;
            }
            for (var j = 0; j < sub.ranges.length; j++) {
              rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
              rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
            }
            continue;
          }
          for (var j = 0; j < sub.changes.length; ++j) {
            var cur = sub.changes[j];
            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff, cur.from.ch);
              cur.to = Pos(cur.to.line + diff, cur.to.ch);
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }
          if (!ok) {
            array.splice(0, i + 1);
            i = 0;
          }
        }
      }
      function rebaseHist(hist, change) {
        var from = change.from.line,
            to = change.to.line,
            diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      }
      var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;
      };
      var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
        if (e.stopPropagation)
          e.stopPropagation();
        else
          e.cancelBubble = true;
      };
      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }
      var e_stop = CodeMirror.e_stop = function(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
      };
      function e_target(e) {
        return e.target || e.srcElement;
      }
      function e_button(e) {
        var b = e.which;
        if (b == null) {
          if (e.button & 1)
            b = 1;
          else if (e.button & 2)
            b = 3;
          else if (e.button & 4)
            b = 2;
        }
        if (mac && e.ctrlKey && b == 1)
          b = 3;
        return b;
      }
      var on = CodeMirror.on = function(emitter, type, f) {
        if (emitter.addEventListener)
          emitter.addEventListener(type, f, false);
        else if (emitter.attachEvent)
          emitter.attachEvent("on" + type, f);
        else {
          var map = emitter._handlers || (emitter._handlers = {});
          var arr = map[type] || (map[type] = []);
          arr.push(f);
        }
      };
      var off = CodeMirror.off = function(emitter, type, f) {
        if (emitter.removeEventListener)
          emitter.removeEventListener(type, f, false);
        else if (emitter.detachEvent)
          emitter.detachEvent("on" + type, f);
        else {
          var arr = emitter._handlers && emitter._handlers[type];
          if (!arr)
            return;
          for (var i = 0; i < arr.length; ++i)
            if (arr[i] == f) {
              arr.splice(i, 1);
              break;
            }
        }
      };
      var signal = CodeMirror.signal = function(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr)
          return;
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i = 0; i < arr.length; ++i)
          arr[i].apply(null, args);
      };
      var orphanDelayedCallbacks = null;
      function signalLater(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr)
          return;
        var args = Array.prototype.slice.call(arguments, 2),
            list;
        if (operationGroup) {
          list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list = orphanDelayedCallbacks;
        } else {
          list = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }
        function bnd(f) {
          return function() {
            f.apply(null, args);
          };
        }
        ;
        for (var i = 0; i < arr.length; ++i)
          list.push(bnd(arr[i]));
      }
      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i)
          delayed[i]();
      }
      function signalDOMEvent(cm, e, override) {
        if (typeof e == "string")
          e = {
            type: e,
            preventDefault: function() {
              this.defaultPrevented = true;
            }
          };
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }
      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr)
          return;
        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i = 0; i < arr.length; ++i)
          if (indexOf(set, arr[i]) == -1)
            set.push(arr[i]);
      }
      function hasHandler(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        return arr && arr.length > 0;
      }
      function eventMixin(ctor) {
        ctor.prototype.on = function(type, f) {
          on(this, type, f);
        };
        ctor.prototype.off = function(type, f) {
          off(this, type, f);
        };
      }
      var scrollerGap = 30;
      var Pass = CodeMirror.Pass = {toString: function() {
          return "CodeMirror.Pass";
        }};
      var sel_dontScroll = {scroll: false},
          sel_mouse = {origin: "*mouse"},
          sel_move = {origin: "+move"};
      function Delayed() {
        this.id = null;
      }
      Delayed.prototype.set = function(ms, f) {
        clearTimeout(this.id);
        this.id = setTimeout(f, ms);
      };
      var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1)
            end = string.length;
        }
        for (var i = startIndex || 0,
            n = startValue || 0; ; ) {
          var nextTab = string.indexOf("\t", i);
          if (nextTab < 0 || nextTab >= end)
            return n + (end - i);
          n += nextTab - i;
          n += tabSize - (n % tabSize);
          i = nextTab + 1;
        }
      };
      var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
        for (var pos = 0,
            col = 0; ; ) {
          var nextTab = string.indexOf("\t", pos);
          if (nextTab == -1)
            nextTab = string.length;
          var skipped = nextTab - pos;
          if (nextTab == string.length || col + skipped >= goal)
            return pos + Math.min(skipped, goal - col);
          col += nextTab - pos;
          col += tabSize - (col % tabSize);
          pos = nextTab + 1;
          if (col >= goal)
            return pos;
        }
      };
      var spaceStrs = [""];
      function spaceStr(n) {
        while (spaceStrs.length <= n)
          spaceStrs.push(lst(spaceStrs) + " ");
        return spaceStrs[n];
      }
      function lst(arr) {
        return arr[arr.length - 1];
      }
      var selectInput = function(node) {
        node.select();
      };
      if (ios)
        selectInput = function(node) {
          node.selectionStart = 0;
          node.selectionEnd = node.value.length;
        };
      else if (ie)
        selectInput = function(node) {
          try {
            node.select();
          } catch (_e) {}
        };
      function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i)
          if (array[i] == elt)
            return i;
        return -1;
      }
      function map(array, f) {
        var out = [];
        for (var i = 0; i < array.length; i++)
          out[i] = f(array[i], i);
        return out;
      }
      function nothing() {}
      function createObj(base, props) {
        var inst;
        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }
        if (props)
          copyObj(props, inst);
        return inst;
      }
      ;
      function copyObj(obj, target, overwrite) {
        if (!target)
          target = {};
        for (var prop in obj)
          if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
            target[prop] = obj[prop];
        return target;
      }
      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          return f.apply(null, args);
        };
      }
      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
        return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
      };
      function isWordChar(ch, helper) {
        if (!helper)
          return isWordCharBasic(ch);
        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch))
          return true;
        return helper.test(ch);
      }
      function isEmpty(obj) {
        for (var n in obj)
          if (obj.hasOwnProperty(n) && obj[n])
            return false;
        return true;
      }
      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
      }
      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className)
          e.className = className;
        if (style)
          e.style.cssText = style;
        if (typeof content == "string")
          e.appendChild(document.createTextNode(content));
        else if (content)
          for (var i = 0; i < content.length; ++i)
            e.appendChild(content[i]);
        return e;
      }
      var range;
      if (document.createRange)
        range = function(node, start, end, endNode) {
          var r = document.createRange();
          r.setEnd(endNode || node, end);
          r.setStart(node, start);
          return r;
        };
      else
        range = function(node, start, end) {
          var r = document.body.createTextRange();
          try {
            r.moveToElementText(node.parentNode);
          } catch (e) {
            return r;
          }
          r.collapse(true);
          r.moveEnd("character", end);
          r.moveStart("character", start);
          return r;
        };
      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count)
          e.removeChild(e.firstChild);
        return e;
      }
      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
      }
      var contains = CodeMirror.contains = function(parent, child) {
        if (child.nodeType == 3)
          child = child.parentNode;
        if (parent.contains)
          return parent.contains(child);
        do {
          if (child.nodeType == 11)
            child = child.host;
          if (child == parent)
            return true;
        } while (child = child.parentNode);
      };
      function activeElt() {
        var activeElement = document.activeElement;
        while (activeElement && activeElement.root && activeElement.root.activeElement)
          activeElement = activeElement.root.activeElement;
        return activeElement;
      }
      if (ie && ie_version < 11)
        activeElt = function() {
          try {
            return document.activeElement;
          } catch (e) {
            return document.body;
          }
        };
      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }
      var rmClass = CodeMirror.rmClass = function(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };
      var addClass = CodeMirror.addClass = function(node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current))
          node.className += (current ? " " : "") + cls;
      };
      function joinClasses(a, b) {
        var as = a.split(" ");
        for (var i = 0; i < as.length; i++)
          if (as[i] && !classTest(as[i]).test(b))
            b += " " + as[i];
        return b;
      }
      function forEachCodeMirror(f) {
        if (!document.body.getElementsByClassName)
          return;
        var byClass = document.body.getElementsByClassName("CodeMirror");
        for (var i = 0; i < byClass.length; i++) {
          var cm = byClass[i].CodeMirror;
          if (cm)
            f(cm);
        }
      }
      var globalsRegistered = false;
      function ensureGlobalHandlers() {
        if (globalsRegistered)
          return;
        registerGlobalHandlers();
        globalsRegistered = true;
      }
      function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function() {
          if (resizeTimer == null)
            resizeTimer = setTimeout(function() {
              resizeTimer = null;
              forEachCodeMirror(onResize);
            }, 100);
        });
        on(window, "blur", function() {
          forEachCodeMirror(onBlur);
        });
      }
      var dragAndDrop = function() {
        if (ie && ie_version < 9)
          return false;
        var div = elt('div');
        return "draggable" in div || "dragDrop" in div;
      }();
      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200b");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0)
            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
        }
        var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
      }
      var badBidiRects;
      function hasBadBidiRects(measure) {
        if (badBidiRects != null)
          return badBidiRects;
        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        if (!r0 || r0.left == r0.right)
          return false;
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        return badBidiRects = (r1.right - r0.right < 3);
      }
      var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
        var pos = 0,
            result = [],
            l = string.length;
        while (pos <= l) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1)
            nl = string.length;
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result;
      } : function(string) {
        return string.split(/\r\n?|\n/);
      };
      var hasSelection = window.getSelection ? function(te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function(te) {
        try {
          var range = te.ownerDocument.selection.createRange();
        } catch (e) {}
        if (!range || range.parentElement() != te)
          return false;
        return range.compareEndPoints("StartToEnd", range) != 0;
      };
      var hasCopyEvent = (function() {
        var e = elt("div");
        if ("oncopy" in e)
          return true;
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function";
      })();
      var badZoomedRects = null;
      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null)
          return badZoomedRects;
        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
      }
      var keyNames = CodeMirror.keyNames = {
        3: "Enter",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        127: "Delete",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      };
      (function() {
        for (var i = 0; i < 10; i++)
          keyNames[i + 48] = keyNames[i + 96] = String(i);
        for (var i = 65; i <= 90; i++)
          keyNames[i] = String.fromCharCode(i);
        for (var i = 1; i <= 12; i++)
          keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
      })();
      function iterateBidiSections(order, from, to, f) {
        if (!order)
          return f(from, to, "ltr");
        var found = false;
        for (var i = 0; i < order.length; ++i) {
          var part = order[i];
          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
            found = true;
          }
        }
        if (!found)
          f(from, to, "ltr");
      }
      function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from;
      }
      function bidiRight(part) {
        return part.level % 2 ? part.from : part.to;
      }
      function lineLeft(line) {
        var order = getOrder(line);
        return order ? bidiLeft(order[0]) : 0;
      }
      function lineRight(line) {
        var order = getOrder(line);
        if (!order)
          return line.text.length;
        return bidiRight(lst(order));
      }
      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line)
          lineN = lineNo(visual);
        var order = getOrder(visual);
        var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
        return Pos(lineN, ch);
      }
      function lineEnd(cm, lineN) {
        var merged,
            line = getLine(cm.doc, lineN);
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          lineN = null;
        }
        var order = getOrder(line);
        var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
        return Pos(lineN == null ? lineNo(line) : lineN, ch);
      }
      function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
      }
      function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        if (a == linedir)
          return true;
        if (b == linedir)
          return false;
        return a < b;
      }
      var bidiOther;
      function getBidiPartAt(order, pos) {
        bidiOther = null;
        for (var i = 0,
            found; i < order.length; ++i) {
          var cur = order[i];
          if (cur.from < pos && cur.to > pos)
            return i;
          if ((cur.from == pos || cur.to == pos)) {
            if (found == null) {
              found = i;
            } else if (compareBidiLevel(order, cur.level, order[found].level)) {
              if (cur.from != cur.to)
                bidiOther = found;
              return i;
            } else {
              if (cur.from != cur.to)
                bidiOther = i;
              return found;
            }
          }
        }
        return found;
      }
      function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit)
          return pos + dir;
        do
          pos += dir;
 while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
        return pos;
      }
      function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi)
          return moveLogically(line, start, dir, byUnit);
        var pos = getBidiPartAt(bidi, start),
            part = bidi[pos];
        var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
        for (; ; ) {
          if (target > part.from && target < part.to)
            return target;
          if (target == part.from || target == part.to) {
            if (getBidiPartAt(bidi, target) == pos)
              return target;
            part = bidi[pos += dir];
            return (dir > 0) == part.level % 2 ? part.to : part.from;
          } else {
            part = bidi[pos += dir];
            if (!part)
              return null;
            if ((dir > 0) == part.level % 2)
              target = moveInLine(line, part.to, -1, byUnit);
            else
              target = moveInLine(line, part.from, 1, byUnit);
          }
        }
      }
      function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit)
          while (target > 0 && isExtendingChar(line.text.charAt(target)))
            target += dir;
        return target < 0 || target > line.text.length ? null : target;
      }
      var bidiOrdering = (function() {
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
        var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
        function charType(code) {
          if (code <= 0xf7)
            return lowTypes.charAt(code);
          else if (0x590 <= code && code <= 0x5f4)
            return "R";
          else if (0x600 <= code && code <= 0x6ed)
            return arabicTypes.charAt(code - 0x600);
          else if (0x6ee <= code && code <= 0x8ac)
            return "r";
          else if (0x2000 <= code && code <= 0x200b)
            return "w";
          else if (code == 0x200c)
            return "b";
          else
            return "L";
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/,
            isStrong = /[LRr]/,
            countsAsLeft = /[Lb1n]/,
            countsAsNum = /[1n]/;
        var outerType = "L";
        function BidiSpan(level, from, to) {
          this.level = level;
          this.from = from;
          this.to = to;
        }
        return function(str) {
          if (!bidiRE.test(str))
            return false;
          var len = str.length,
              types = [];
          for (var i = 0,
              type; i < len; ++i)
            types.push(type = charType(str.charCodeAt(i)));
          for (var i = 0,
              prev = outerType; i < len; ++i) {
            var type = types[i];
            if (type == "m")
              types[i] = prev;
            else
              prev = type;
          }
          for (var i = 0,
              cur = outerType; i < len; ++i) {
            var type = types[i];
            if (type == "1" && cur == "r")
              types[i] = "n";
            else if (isStrong.test(type)) {
              cur = type;
              if (type == "r")
                types[i] = "R";
            }
          }
          for (var i = 1,
              prev = types[0]; i < len - 1; ++i) {
            var type = types[i];
            if (type == "+" && prev == "1" && types[i + 1] == "1")
              types[i] = "1";
            else if (type == "," && prev == types[i + 1] && (prev == "1" || prev == "n"))
              types[i] = prev;
            prev = type;
          }
          for (var i = 0; i < len; ++i) {
            var type = types[i];
            if (type == ",")
              types[i] = "N";
            else if (type == "%") {
              for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
              var replace = (i && types[i - 1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
              for (var j = i; j < end; ++j)
                types[j] = replace;
              i = end - 1;
            }
          }
          for (var i = 0,
              cur = outerType; i < len; ++i) {
            var type = types[i];
            if (cur == "L" && type == "1")
              types[i] = "L";
            else if (isStrong.test(type))
              cur = type;
          }
          for (var i = 0; i < len; ++i) {
            if (isNeutral.test(types[i])) {
              for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
              var before = (i ? types[i - 1] : outerType) == "L";
              var after = (end < len ? types[end] : outerType) == "L";
              var replace = before || after ? "L" : "R";
              for (var j = i; j < end; ++j)
                types[j] = replace;
              i = end - 1;
            }
          }
          var order = [],
              m;
          for (var i = 0; i < len; ) {
            if (countsAsLeft.test(types[i])) {
              var start = i;
              for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
              order.push(new BidiSpan(0, start, i));
            } else {
              var pos = i,
                  at = order.length;
              for (++i; i < len && types[i] != "L"; ++i) {}
              for (var j = pos; j < i; ) {
                if (countsAsNum.test(types[j])) {
                  if (pos < j)
                    order.splice(at, 0, new BidiSpan(1, pos, j));
                  var nstart = j;
                  for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
                  order.splice(at, 0, new BidiSpan(2, nstart, j));
                  pos = j;
                } else
                  ++j;
              }
              if (pos < i)
                order.splice(at, 0, new BidiSpan(1, pos, i));
            }
          }
          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
            order[0].from = m[0].length;
            order.unshift(new BidiSpan(0, 0, m[0].length));
          }
          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
            lst(order).to -= m[0].length;
            order.push(new BidiSpan(0, len - m[0].length, len));
          }
          if (order[0].level == 2)
            order.unshift(new BidiSpan(1, order[0].to, order[0].to));
          if (order[0].level != lst(order).level)
            order.push(new BidiSpan(order[0].level, len, len));
          return order;
        };
      })();
      CodeMirror.version = "5.7.0";
      return CodeMirror;
    });
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ca", ["c9"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("c9");
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cb", ["c9"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require("c9"));
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("javascript", function(config, parserConfig) {
      var indentUnit = config.indentUnit;
      var statementIndent = parserConfig.statementIndent;
      var jsonldMode = parserConfig.jsonld;
      var jsonMode = parserConfig.json || jsonldMode;
      var isTS = parserConfig.typescript;
      var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
      var keywords = function() {
        function kw(type) {
          return {
            type: type,
            style: "keyword"
          };
        }
        var A = kw("keyword a"),
            B = kw("keyword b"),
            C = kw("keyword c");
        var operator = kw("operator"),
            atom = {
              type: "atom",
              style: "atom"
            };
        var jsKeywords = {
          "if": kw("if"),
          "while": A,
          "with": A,
          "else": B,
          "do": B,
          "try": B,
          "finally": B,
          "return": C,
          "break": C,
          "continue": C,
          "new": C,
          "delete": C,
          "throw": C,
          "debugger": C,
          "var": kw("var"),
          "const": kw("var"),
          "let": kw("var"),
          "async": kw("async"),
          "function": kw("function"),
          "catch": kw("catch"),
          "for": kw("for"),
          "switch": kw("switch"),
          "case": kw("case"),
          "default": kw("default"),
          "in": operator,
          "typeof": operator,
          "instanceof": operator,
          "true": atom,
          "false": atom,
          "null": atom,
          "undefined": atom,
          "NaN": atom,
          "Infinity": atom,
          "this": kw("this"),
          "class": kw("class"),
          "super": kw("atom"),
          "await": C,
          "yield": C,
          "export": kw("export"),
          "import": kw("import"),
          "extends": C
        };
        if (isTS) {
          var type = {
            type: "variable",
            style: "variable-3"
          };
          var tsKeywords = {
            "interface": kw("interface"),
            "extends": kw("extends"),
            "constructor": kw("constructor"),
            "public": kw("public"),
            "private": kw("private"),
            "protected": kw("protected"),
            "static": kw("static"),
            "string": type,
            "number": type,
            "bool": type,
            "any": type
          };
          for (var attr in tsKeywords) {
            jsKeywords[attr] = tsKeywords[attr];
          }
        }
        return jsKeywords;
      }();
      var isOperatorChar = /[+\-*&%=<>!?|~^]/;
      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
      function readRegexp(stream) {
        var escaped = false,
            next,
            inSet = false;
        while ((next = stream.next()) != null) {
          if (!escaped) {
            if (next == "/" && !inSet)
              return;
            if (next == "[")
              inSet = true;
            else if (inSet && next == "]")
              inSet = false;
          }
          escaped = !escaped && next == "\\";
        }
      }
      var type,
          content;
      function ret(tp, style, cont) {
        type = tp;
        content = cont;
        return style;
      }
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
          return ret("number", "number");
        } else if (ch == "." && stream.match("..")) {
          return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return ret(ch);
        } else if (ch == "=" && stream.eat(">")) {
          return ret("=>", "operator");
        } else if (ch == "0" && stream.eat(/x/i)) {
          stream.eatWhile(/[\da-f]/i);
          return ret("number", "number");
        } else if (ch == "0" && stream.eat(/o/i)) {
          stream.eatWhile(/[0-7]/i);
          return ret("number", "number");
        } else if (ch == "0" && stream.eat(/b/i)) {
          stream.eatWhile(/[01]/i);
          return ret("number", "number");
        } else if (/\d/.test(ch)) {
          stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
          return ret("number", "number");
        } else if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (state.lastType == "operator" || state.lastType == "keyword c" || state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
            readRegexp(stream);
            stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
            return ret("regexp", "string-2");
          } else {
            stream.eatWhile(isOperatorChar);
            return ret("operator", "operator", stream.current());
          }
        } else if (ch == "`") {
          state.tokenize = tokenQuasi;
          return tokenQuasi(stream, state);
        } else if (ch == "#") {
          stream.skipToEnd();
          return ret("error", "error");
        } else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return ret("operator", "operator", stream.current());
        } else if (wordRE.test(ch)) {
          stream.eatWhile(wordRE);
          var word = stream.current(),
              known = keywords.propertyIsEnumerable(word) && keywords[word];
          return (known && state.lastType != ".") ? ret(known.type, known.style, word) : ret("variable", "variable", word);
        }
      }
      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false,
              next;
          if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
            state.tokenize = tokenBase;
            return ret("jsonld-keyword", "meta");
          }
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped)
              break;
            escaped = !escaped && next == "\\";
          }
          if (!escaped)
            state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }
      function tokenComment(stream, state) {
        var maybeEnd = false,
            ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return ret("comment", "comment");
      }
      function tokenQuasi(stream, state) {
        var escaped = false,
            next;
        while ((next = stream.next()) != null) {
          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
            state.tokenize = tokenBase;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
      }
      var brackets = "([{}])";
      function findFatArrow(stream, state) {
        if (state.fatArrowAt)
          state.fatArrowAt = null;
        var arrow = stream.string.indexOf("=>", stream.start);
        if (arrow < 0)
          return;
        var depth = 0,
            sawSomething = false;
        for (var pos = arrow - 1; pos >= 0; --pos) {
          var ch = stream.string.charAt(pos);
          var bracket = brackets.indexOf(ch);
          if (bracket >= 0 && bracket < 3) {
            if (!depth) {
              ++pos;
              break;
            }
            if (--depth == 0)
              break;
          } else if (bracket >= 3 && bracket < 6) {
            ++depth;
          } else if (wordRE.test(ch)) {
            sawSomething = true;
          } else if (/["'\/]/.test(ch)) {
            return;
          } else if (sawSomething && !depth) {
            ++pos;
            break;
          }
        }
        if (sawSomething && !depth)
          state.fatArrowAt = pos;
      }
      var atomicTypes = {
        "atom": true,
        "number": true,
        "variable": true,
        "string": true,
        "regexp": true,
        "this": true,
        "jsonld-keyword": true
      };
      function JSLexical(indented, column, type, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.prev = prev;
        this.info = info;
        if (align != null)
          this.align = align;
      }
      function inScope(state, varname) {
        for (var v = state.localVars; v; v = v.next)
          if (v.name == varname)
            return true;
        for (var cx = state.context; cx; cx = cx.prev) {
          for (var v = cx.vars; v; v = v.next)
            if (v.name == varname)
              return true;
        }
      }
      function parseJS(state, style, type, content, stream) {
        var cc = state.cc;
        cx.state = state;
        cx.stream = stream;
        cx.marked = null, cx.cc = cc;
        cx.style = style;
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = true;
        while (true) {
          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
          if (combinator(type, content)) {
            while (cc.length && cc[cc.length - 1].lex)
              cc.pop()();
            if (cx.marked)
              return cx.marked;
            if (type == "variable" && inScope(state, content))
              return "variable-2";
            return style;
          }
        }
      }
      var cx = {
        state: null,
        column: null,
        marked: null,
        cc: null
      };
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--)
          cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function register(varname) {
        function inList(list) {
          for (var v = list; v; v = v.next)
            if (v.name == varname)
              return true;
          return false;
        }
        var state = cx.state;
        if (state.context) {
          cx.marked = "def";
          if (inList(state.localVars))
            return;
          state.localVars = {
            name: varname,
            next: state.localVars
          };
        } else {
          if (inList(state.globalVars))
            return;
          if (parserConfig.globalVars)
            state.globalVars = {
              name: varname,
              next: state.globalVars
            };
        }
      }
      var defaultVars = {
        name: "this",
        next: {name: "arguments"}
      };
      function pushcontext() {
        cx.state.context = {
          prev: cx.state.context,
          vars: cx.state.localVars
        };
        cx.state.localVars = defaultVars;
      }
      function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
      }
      function pushlex(type, info) {
        var result = function() {
          var state = cx.state,
              indent = state.indented;
          if (state.lexical.type == "stat")
            indent = state.lexical.indented;
          else
            for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
              indent = outer.indented;
          state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
        };
        result.lex = true;
        return result;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")")
            state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;
      function expect(wanted) {
        function exp(type) {
          if (type == wanted)
            return cont();
          else if (wanted == ";")
            return pass();
          else
            return cont(exp);
        }
        ;
        return exp;
      }
      function statement(type, value) {
        if (type == "var")
          return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
        if (type == "keyword a")
          return cont(pushlex("form"), expression, statement, poplex);
        if (type == "keyword b")
          return cont(pushlex("form"), statement, poplex);
        if (type == "{")
          return cont(pushlex("}"), block, poplex);
        if (type == ";")
          return cont();
        if (type == "if") {
          if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
            cx.state.cc.pop()();
          return cont(pushlex("form"), expression, statement, poplex, maybeelse);
        }
        if (type == "function")
          return cont(functiondef);
        if (type == "for")
          return cont(pushlex("form"), forspec, statement, poplex);
        if (type == "variable")
          return cont(pushlex("stat"), maybelabel);
        if (type == "switch")
          return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"), block, poplex, poplex);
        if (type == "case")
          return cont(expression, expect(":"));
        if (type == "default")
          return cont(expect(":"));
        if (type == "catch")
          return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext);
        if (type == "class")
          return cont(pushlex("form"), className, poplex);
        if (type == "export")
          return cont(pushlex("stat"), afterExport, poplex);
        if (type == "import")
          return cont(pushlex("stat"), afterImport, poplex);
        return pass(pushlex("stat"), expression, expect(";"), poplex);
      }
      function expression(type) {
        return expressionInner(type, false);
      }
      function expressionNoComma(type) {
        return expressionInner(type, true);
      }
      function expressionInner(type, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
          var body = noComma ? arrowBodyNoComma : arrowBody;
          if (type == "(")
            return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
          else if (type == "variable")
            return pass(pushcontext, pattern, expect("=>"), body, popcontext);
        }
        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type))
          return cont(maybeop);
        if (type == "async")
          return cont(expression);
        if (type == "function")
          return cont(functiondef, maybeop);
        if (type == "keyword c")
          return cont(noComma ? maybeexpressionNoComma : maybeexpression);
        if (type == "(")
          return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
        if (type == "operator" || type == "spread")
          return cont(noComma ? expressionNoComma : expression);
        if (type == "[")
          return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
        if (type == "{")
          return contCommasep(objprop, "}", null, maybeop);
        if (type == "quasi") {
          return pass(quasi, maybeop);
        }
        return cont();
      }
      function maybeexpression(type) {
        if (type.match(/[;\}\)\],]/))
          return pass();
        return pass(expression);
      }
      function maybeexpressionNoComma(type) {
        if (type.match(/[;\}\)\],]/))
          return pass();
        return pass(expressionNoComma);
      }
      function maybeoperatorComma(type, value) {
        if (type == ",")
          return cont(expression);
        return maybeoperatorNoComma(type, value, false);
      }
      function maybeoperatorNoComma(type, value, noComma) {
        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (type == "=>")
          return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type == "operator") {
          if (/\+\+|--/.test(value))
            return cont(me);
          if (value == "?")
            return cont(expression, expect(":"), expr);
          return cont(expr);
        }
        if (type == "quasi") {
          return pass(quasi, me);
        }
        if (type == ";")
          return;
        if (type == "(")
          return contCommasep(expressionNoComma, ")", "call", me);
        if (type == ".")
          return cont(property, me);
        if (type == "[")
          return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      }
      function quasi(type, value) {
        if (type != "quasi")
          return pass();
        if (value.slice(value.length - 2) != "${")
          return cont(quasi);
        return cont(expression, continueQuasi);
      }
      function continueQuasi(type) {
        if (type == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasi);
        }
      }
      function arrowBody(type) {
        findFatArrow(cx.stream, cx.state);
        return pass(type == "{" ? statement : expression);
      }
      function arrowBodyNoComma(type) {
        findFatArrow(cx.stream, cx.state);
        return pass(type == "{" ? statement : expressionNoComma);
      }
      function maybelabel(type) {
        if (type == ":")
          return cont(poplex, statement);
        return pass(maybeoperatorComma, expect(";"), poplex);
      }
      function property(type) {
        if (type == "variable") {
          cx.marked = "property";
          return cont();
        }
      }
      function objprop(type, value) {
        if (type == "async") {
          return cont(objprop);
        } else if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          if (value == "get" || value == "set")
            return cont(getterSetter);
          return cont(afterprop);
        } else if (type == "number" || type == "string") {
          cx.marked = jsonldMode ? "property" : (cx.style + " property");
          return cont(afterprop);
        } else if (type == "jsonld-keyword") {
          return cont(afterprop);
        } else if (type == "[") {
          return cont(expression, expect("]"), afterprop);
        }
      }
      function getterSetter(type) {
        if (type != "variable")
          return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
      }
      function afterprop(type) {
        if (type == ":")
          return cont(expressionNoComma);
        if (type == "(")
          return pass(functiondef);
      }
      function commasep(what, end) {
        function proceed(type) {
          if (type == ",") {
            var lex = cx.state.lexical;
            if (lex.info == "call")
              lex.pos = (lex.pos || 0) + 1;
            return cont(what, proceed);
          }
          if (type == end)
            return cont();
          return cont(expect(end));
        }
        return function(type) {
          if (type == end)
            return cont();
          return pass(what, proceed);
        };
      }
      function contCommasep(what, end, info) {
        for (var i = 3; i < arguments.length; i++)
          cx.cc.push(arguments[i]);
        return cont(pushlex(end, info), commasep(what, end), poplex);
      }
      function block(type) {
        if (type == "}")
          return cont();
        return pass(statement, block);
      }
      function maybetype(type) {
        if (isTS && type == ":")
          return cont(typedef);
      }
      function maybedefault(_, value) {
        if (value == "=")
          return cont(expressionNoComma);
      }
      function typedef(type) {
        if (type == "variable") {
          cx.marked = "variable-3";
          return cont();
        }
      }
      function vardef() {
        return pass(pattern, maybetype, maybeAssign, vardefCont);
      }
      function pattern(type, value) {
        if (type == "variable") {
          register(value);
          return cont();
        }
        if (type == "[")
          return contCommasep(pattern, "]");
        if (type == "{")
          return contCommasep(proppattern, "}");
      }
      function proppattern(type, value) {
        if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
          register(value);
          return cont(maybeAssign);
        }
        if (type == "variable")
          cx.marked = "property";
        return cont(expect(":"), pattern, maybeAssign);
      }
      function maybeAssign(_type, value) {
        if (value == "=")
          return cont(expressionNoComma);
      }
      function vardefCont(type) {
        if (type == ",")
          return cont(vardef);
      }
      function maybeelse(type, value) {
        if (type == "keyword b" && value == "else")
          return cont(pushlex("form", "else"), statement, poplex);
      }
      function forspec(type) {
        if (type == "(")
          return cont(pushlex(")"), forspec1, expect(")"), poplex);
      }
      function forspec1(type) {
        if (type == "var")
          return cont(vardef, expect(";"), forspec2);
        if (type == ";")
          return cont(forspec2);
        if (type == "variable")
          return cont(formaybeinof);
        return pass(expression, expect(";"), forspec2);
      }
      function formaybeinof(_type, value) {
        if (value == "in" || value == "of") {
          cx.marked = "keyword";
          return cont(expression);
        }
        return cont(maybeoperatorComma, forspec2);
      }
      function forspec2(type, value) {
        if (type == ";")
          return cont(forspec3);
        if (value == "in" || value == "of") {
          cx.marked = "keyword";
          return cont(expression);
        }
        return pass(expression, expect(";"), forspec3);
      }
      function forspec3(type) {
        if (type != ")")
          cont(expression);
      }
      function functiondef(type, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(functiondef);
        }
        if (type == "variable") {
          register(value);
          return cont(functiondef);
        }
        if (type == "(")
          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
      }
      function funarg(type) {
        if (type == "spread")
          return cont(funarg);
        return pass(pattern, maybetype, maybedefault);
      }
      function className(type, value) {
        if (type == "variable") {
          register(value);
          return cont(classNameAfter);
        }
      }
      function classNameAfter(type, value) {
        if (value == "extends")
          return cont(expression, classNameAfter);
        if (type == "{")
          return cont(pushlex("}"), classBody, poplex);
      }
      function classBody(type, value) {
        if (type == "variable" || cx.style == "keyword") {
          if (value == "static") {
            cx.marked = "keyword";
            return cont(classBody);
          }
          cx.marked = "property";
          if (value == "get" || value == "set")
            return cont(classGetterSetter, functiondef, classBody);
          return cont(functiondef, classBody);
        }
        if (value == "*") {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (type == ";")
          return cont(classBody);
        if (type == "}")
          return cont();
      }
      function classGetterSetter(type) {
        if (type != "variable")
          return pass();
        cx.marked = "property";
        return cont();
      }
      function afterExport(_type, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(maybeFrom, expect(";"));
        }
        if (value == "default") {
          cx.marked = "keyword";
          return cont(expression, expect(";"));
        }
        return pass(statement);
      }
      function afterImport(type) {
        if (type == "string")
          return cont();
        return pass(importSpec, maybeFrom);
      }
      function importSpec(type, value) {
        if (type == "{")
          return contCommasep(importSpec, "}");
        if (type == "variable")
          register(value);
        if (value == "*")
          cx.marked = "keyword";
        return cont(maybeAs);
      }
      function maybeAs(_type, value) {
        if (value == "as") {
          cx.marked = "keyword";
          return cont(importSpec);
        }
      }
      function maybeFrom(_type, value) {
        if (value == "from") {
          cx.marked = "keyword";
          return cont(expression);
        }
      }
      function arrayLiteral(type) {
        if (type == "]")
          return cont();
        return pass(expressionNoComma, maybeArrayComprehension);
      }
      function maybeArrayComprehension(type) {
        if (type == "for")
          return pass(comprehension, expect("]"));
        if (type == ",")
          return cont(commasep(maybeexpressionNoComma, "]"));
        return pass(commasep(expressionNoComma, "]"));
      }
      function comprehension(type) {
        if (type == "for")
          return cont(forspec, comprehension);
        if (type == "if")
          return cont(expression, comprehension);
      }
      function isContinuedStatement(state, textAfter) {
        return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
      }
      return {
        startState: function(basecolumn) {
          var state = {
            tokenize: tokenBase,
            lastType: "sof",
            cc: [],
            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            context: parserConfig.localVars && {vars: parserConfig.localVars},
            indented: 0
          };
          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
            state.globalVars = parserConfig.globalVars;
          return state;
        },
        token: function(stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = false;
            state.indented = stream.indentation();
            findFatArrow(stream, state);
          }
          if (state.tokenize != tokenComment && stream.eatSpace())
            return null;
          var style = state.tokenize(stream, state);
          if (type == "comment")
            return style;
          state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
          return parseJS(state, style, type, content, stream);
        },
        indent: function(state, textAfter) {
          if (state.tokenize == tokenComment)
            return CodeMirror.Pass;
          if (state.tokenize != tokenBase)
            return 0;
          var firstChar = textAfter && textAfter.charAt(0),
              lexical = state.lexical;
          if (!/^\s*else\b/.test(textAfter))
            for (var i = state.cc.length - 1; i >= 0; --i) {
              var c = state.cc[i];
              if (c == poplex)
                lexical = lexical.prev;
              else if (c != maybeelse)
                break;
            }
          if (lexical.type == "stat" && firstChar == "}")
            lexical = lexical.prev;
          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
            lexical = lexical.prev;
          var type = lexical.type,
              closing = firstChar == type;
          if (type == "vardef")
            return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
          else if (type == "form" && firstChar == "{")
            return lexical.indented;
          else if (type == "form")
            return lexical.indented + indentUnit;
          else if (type == "stat")
            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
          else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
            return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
          else if (lexical.align)
            return lexical.column + (closing ? 0 : 1);
          else
            return lexical.indented + (closing ? 0 : indentUnit);
        },
        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        lineComment: jsonMode ? null : "//",
        fold: "brace",
        closeBrackets: "()[]{}''\"\"``",
        helperType: jsonMode ? "json" : "javascript",
        jsonldMode: jsonldMode,
        jsonMode: jsonMode
      };
    });
    CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
    CodeMirror.defineMIME("text/javascript", "javascript");
    CodeMirror.defineMIME("text/ecmascript", "javascript");
    CodeMirror.defineMIME("application/javascript", "javascript");
    CodeMirror.defineMIME("application/x-javascript", "javascript");
    CodeMirror.defineMIME("application/ecmascript", "javascript");
    CodeMirror.defineMIME("application/json", {
      name: "javascript",
      json: true
    });
    CodeMirror.defineMIME("application/x-json", {
      name: "javascript",
      json: true
    });
    CodeMirror.defineMIME("application/ld+json", {
      name: "javascript",
      jsonld: true
    });
    CodeMirror.defineMIME("text/typescript", {
      name: "javascript",
      typescript: true
    });
    CodeMirror.defineMIME("application/typescript", {
      name: "javascript",
      typescript: true
    });
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ce", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, "babel", null);
  (function() {
    "format global";
    "exports babel";
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.babel = f();
      }
    })(function() {
      var define,
          module,
          exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof require == "function" && require;
              if (!u && a)
                return a(o, !0);
              if (i)
                return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {exports: {}};
            t[o][0].call(l.exports, function(e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      })({
        1: [function(require, module, exports) {}, {}],
        2: [function(require, module, exports) {
          var util = require('util/');
          var pSlice = Array.prototype.slice;
          var hasOwn = Object.prototype.hasOwnProperty;
          var assert = module.exports = ok;
          assert.AssertionError = function AssertionError(options) {
            this.name = 'AssertionError';
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator;
            if (options.message) {
              this.message = options.message;
              this.generatedMessage = false;
            } else {
              this.message = getMessage(this);
              this.generatedMessage = true;
            }
            var stackStartFunction = options.stackStartFunction || fail;
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, stackStartFunction);
            } else {
              var err = new Error();
              if (err.stack) {
                var out = err.stack;
                var fn_name = stackStartFunction.name;
                var idx = out.indexOf('\n' + fn_name);
                if (idx >= 0) {
                  var next_line = out.indexOf('\n', idx + 1);
                  out = out.substring(next_line + 1);
                }
                this.stack = out;
              }
            }
          };
          util.inherits(assert.AssertionError, Error);
          function replacer(key, value) {
            if (util.isUndefined(value)) {
              return '' + value;
            }
            if (util.isNumber(value) && !isFinite(value)) {
              return value.toString();
            }
            if (util.isFunction(value) || util.isRegExp(value)) {
              return value.toString();
            }
            return value;
          }
          function truncate(s, n) {
            if (util.isString(s)) {
              return s.length < n ? s : s.slice(0, n);
            } else {
              return s;
            }
          }
          function getMessage(self) {
            return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' + self.operator + ' ' + truncate(JSON.stringify(self.expected, replacer), 128);
          }
          function fail(actual, expected, message, operator, stackStartFunction) {
            throw new assert.AssertionError({
              message: message,
              actual: actual,
              expected: expected,
              operator: operator,
              stackStartFunction: stackStartFunction
            });
          }
          assert.fail = fail;
          function ok(value, message) {
            if (!value)
              fail(value, true, message, '==', assert.ok);
          }
          assert.ok = ok;
          assert.equal = function equal(actual, expected, message) {
            if (actual != expected)
              fail(actual, expected, message, '==', assert.equal);
          };
          assert.notEqual = function notEqual(actual, expected, message) {
            if (actual == expected) {
              fail(actual, expected, message, '!=', assert.notEqual);
            }
          };
          assert.deepEqual = function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected)) {
              fail(actual, expected, message, 'deepEqual', assert.deepEqual);
            }
          };
          function _deepEqual(actual, expected) {
            if (actual === expected) {
              return true;
            } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
              if (actual.length != expected.length)
                return false;
              for (var i = 0; i < actual.length; i++) {
                if (actual[i] !== expected[i])
                  return false;
              }
              return true;
            } else if (util.isDate(actual) && util.isDate(expected)) {
              return actual.getTime() === expected.getTime();
            } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
              return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
            } else if (!util.isObject(actual) && !util.isObject(expected)) {
              return actual == expected;
            } else {
              return objEquiv(actual, expected);
            }
          }
          function isArguments(object) {
            return Object.prototype.toString.call(object) == '[object Arguments]';
          }
          function objEquiv(a, b) {
            if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
              return false;
            if (a.prototype !== b.prototype)
              return false;
            if (util.isPrimitive(a) || util.isPrimitive(b)) {
              return a === b;
            }
            var aIsArgs = isArguments(a),
                bIsArgs = isArguments(b);
            if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
              return false;
            if (aIsArgs) {
              a = pSlice.call(a);
              b = pSlice.call(b);
              return _deepEqual(a, b);
            }
            var ka = objectKeys(a),
                kb = objectKeys(b),
                key,
                i;
            if (ka.length != kb.length)
              return false;
            ka.sort();
            kb.sort();
            for (i = ka.length - 1; i >= 0; i--) {
              if (ka[i] != kb[i])
                return false;
            }
            for (i = ka.length - 1; i >= 0; i--) {
              key = ka[i];
              if (!_deepEqual(a[key], b[key]))
                return false;
            }
            return true;
          }
          assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected)) {
              fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
            }
          };
          assert.strictEqual = function strictEqual(actual, expected, message) {
            if (actual !== expected) {
              fail(actual, expected, message, '===', assert.strictEqual);
            }
          };
          assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
              fail(actual, expected, message, '!==', assert.notStrictEqual);
            }
          };
          function expectedException(actual, expected) {
            if (!actual || !expected) {
              return false;
            }
            if (Object.prototype.toString.call(expected) == '[object RegExp]') {
              return expected.test(actual);
            } else if (actual instanceof expected) {
              return true;
            } else if (expected.call({}, actual) === true) {
              return true;
            }
            return false;
          }
          function _throws(shouldThrow, block, expected, message) {
            var actual;
            if (util.isString(expected)) {
              message = expected;
              expected = null;
            }
            try {
              block();
            } catch (e) {
              actual = e;
            }
            message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
            if (shouldThrow && !actual) {
              fail(actual, expected, 'Missing expected exception' + message);
            }
            if (!shouldThrow && expectedException(actual, expected)) {
              fail(actual, expected, 'Got unwanted exception' + message);
            }
            if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {
              throw actual;
            }
          }
          assert.throws = function(block, error, message) {
            _throws.apply(this, [true].concat(pSlice.call(arguments)));
          };
          assert.doesNotThrow = function(block, message) {
            _throws.apply(this, [false].concat(pSlice.call(arguments)));
          };
          assert.ifError = function(err) {
            if (err) {
              throw err;
            }
          };
          var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj) {
              if (hasOwn.call(obj, key))
                keys.push(key);
            }
            return keys;
          };
        }, {"util/": 30}],
        3: [function(require, module, exports) {
          arguments[4][1][0].apply(exports, arguments);
        }, {"dup": 1}],
        4: [function(require, module, exports) {
          var base64 = require('base64-js');
          var ieee754 = require('ieee754');
          var isArray = require('is-array');
          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;
          Buffer.poolSize = 8192;
          var rootParent = {};
          Buffer.TYPED_ARRAY_SUPPORT = (function() {
            function Bar() {}
            try {
              var arr = new Uint8Array(1);
              arr.foo = function() {
                return 42;
              };
              arr.constructor = Bar;
              return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
            } catch (e) {
              return false;
            }
          })();
          function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
          }
          function Buffer(arg) {
            if (!(this instanceof Buffer)) {
              if (arguments.length > 1)
                return new Buffer(arg, arguments[1]);
              return new Buffer(arg);
            }
            this.length = 0;
            this.parent = undefined;
            if (typeof arg === 'number') {
              return fromNumber(this, arg);
            }
            if (typeof arg === 'string') {
              return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
            }
            return fromObject(this, arg);
          }
          function fromNumber(that, length) {
            that = allocate(that, length < 0 ? 0 : checked(length) | 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < length; i++) {
                that[i] = 0;
              }
            }
            return that;
          }
          function fromString(that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '')
              encoding = 'utf8';
            var length = byteLength(string, encoding) | 0;
            that = allocate(that, length);
            that.write(string, encoding);
            return that;
          }
          function fromObject(that, object) {
            if (Buffer.isBuffer(object))
              return fromBuffer(that, object);
            if (isArray(object))
              return fromArray(that, object);
            if (object == null) {
              throw new TypeError('must start with number, buffer, array or string');
            }
            if (typeof ArrayBuffer !== 'undefined') {
              if (object.buffer instanceof ArrayBuffer) {
                return fromTypedArray(that, object);
              }
              if (object instanceof ArrayBuffer) {
                return fromArrayBuffer(that, object);
              }
            }
            if (object.length)
              return fromArrayLike(that, object);
            return fromJsonObject(that, object);
          }
          function fromBuffer(that, buffer) {
            var length = checked(buffer.length) | 0;
            that = allocate(that, length);
            buffer.copy(that, 0, 0, length);
            return that;
          }
          function fromArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromTypedArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromArrayBuffer(that, array) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              array.byteLength;
              that = Buffer._augment(new Uint8Array(array));
            } else {
              that = fromTypedArray(that, new Uint8Array(array));
            }
            return that;
          }
          function fromArrayLike(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromJsonObject(that, object) {
            var array;
            var length = 0;
            if (object.type === 'Buffer' && isArray(object.data)) {
              array = object.data;
              length = checked(array.length) | 0;
            }
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function allocate(that, length) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              that = Buffer._augment(new Uint8Array(length));
            } else {
              that.length = length;
              that._isBuffer = true;
            }
            var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
            if (fromPool)
              that.parent = rootParent;
            return that;
          }
          function checked(length) {
            if (length >= kMaxLength()) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
            }
            return length | 0;
          }
          function SlowBuffer(subject, encoding) {
            if (!(this instanceof SlowBuffer))
              return new SlowBuffer(subject, encoding);
            var buf = new Buffer(subject, encoding);
            delete buf.parent;
            return buf;
          }
          Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
          };
          Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('Arguments must be Buffers');
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            var i = 0;
            var len = Math.min(x, y);
            while (i < len) {
              if (a[i] !== b[i])
                break;
              ++i;
            }
            if (i !== len) {
              x = a[i];
              y = b[i];
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'binary':
              case 'base64':
              case 'raw':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;
              default:
                return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!isArray(list))
              throw new TypeError('list argument must be an Array of Buffers.');
            if (list.length === 0) {
              return new Buffer(0);
            }
            var i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; i++) {
                length += list[i].length;
              }
            }
            var buf = new Buffer(length);
            var pos = 0;
            for (i = 0; i < list.length; i++) {
              var item = list[i];
              item.copy(buf, pos);
              pos += item.length;
            }
            return buf;
          };
          function byteLength(string, encoding) {
            if (typeof string !== 'string')
              string = '' + string;
            var len = string.length;
            if (len === 0)
              return 0;
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case 'ascii':
                case 'binary':
                case 'raw':
                case 'raws':
                  return len;
                case 'utf8':
                case 'utf-8':
                  return utf8ToBytes(string).length;
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2;
                case 'hex':
                  return len >>> 1;
                case 'base64':
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase)
                    return utf8ToBytes(string).length;
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          Buffer.prototype.length = undefined;
          Buffer.prototype.parent = undefined;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            start = start | 0;
            end = end === undefined || end === Infinity ? this.length : end | 0;
            if (!encoding)
              encoding = 'utf8';
            if (start < 0)
              start = 0;
            if (end > this.length)
              end = this.length;
            if (end <= start)
              return '';
            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end);
                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);
                case 'ascii':
                  return asciiSlice(this, start, end);
                case 'binary':
                  return binarySlice(this, start, end);
                case 'base64':
                  return base64Slice(this, start, end);
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = (encoding + '').toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0)
              return '';
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError('Argument must be a Buffer');
            if (this === b)
              return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = exports.INSPECT_MAX_BYTES;
            if (this.length > 0) {
              str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
              if (this.length > max)
                str += ' ... ';
            }
            return '<Buffer ' + str + '>';
          };
          Buffer.prototype.compare = function compare(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError('Argument must be a Buffer');
            if (this === b)
              return 0;
            return Buffer.compare(this, b);
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
            if (byteOffset > 0x7fffffff)
              byteOffset = 0x7fffffff;
            else if (byteOffset < -0x80000000)
              byteOffset = -0x80000000;
            byteOffset >>= 0;
            if (this.length === 0)
              return -1;
            if (byteOffset >= this.length)
              return -1;
            if (byteOffset < 0)
              byteOffset = Math.max(this.length + byteOffset, 0);
            if (typeof val === 'string') {
              if (val.length === 0)
                return -1;
              return String.prototype.indexOf.call(this, val, byteOffset);
            }
            if (Buffer.isBuffer(val)) {
              return arrayIndexOf(this, val, byteOffset);
            }
            if (typeof val === 'number') {
              if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
              }
              return arrayIndexOf(this, [val], byteOffset);
            }
            function arrayIndexOf(arr, val, byteOffset) {
              var foundIndex = -1;
              for (var i = 0; byteOffset + i < arr.length; i++) {
                if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === val.length)
                    return byteOffset + foundIndex;
                } else {
                  foundIndex = -1;
                }
              }
              return -1;
            }
            throw new TypeError('val must be string, number or Buffer');
          };
          Buffer.prototype.get = function get(offset) {
            console.log('.get() is deprecated. Access using array indexes instead.');
            return this.readUInt8(offset);
          };
          Buffer.prototype.set = function set(v, offset) {
            console.log('.set() is deprecated. Access using array indexes instead.');
            return this.writeUInt8(v, offset);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (strLen % 2 !== 0)
              throw new Error('Invalid hex string');
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; i++) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed))
                throw new Error('Invalid hex string');
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0;
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset | 0;
              if (isFinite(length)) {
                length = length | 0;
                if (encoding === undefined)
                  encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              }
            } else {
              var swap = encoding;
              encoding = offset;
              offset = length | 0;
              length = swap;
            }
            var remaining = this.length - offset;
            if (length === undefined || length > remaining)
              length = remaining;
            if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
              throw new RangeError('attempt to write outside buffer bounds');
            }
            if (!encoding)
              encoding = 'utf8';
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length);
                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length);
                case 'ascii':
                  return asciiWrite(this, string, offset, length);
                case 'binary':
                  return binaryWrite(this, string, offset, length);
                case 'base64':
                  return base64Write(this, string, offset, length);
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase)
                    throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte,
                    thirdByte,
                    fourthByte,
                    tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                      if (tempCodePoint > 0x7F) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 0xFFFD;
                bytesPerSequence = 1;
              } else if (codePoint > 0xFFFF) {
                codePoint -= 0x10000;
                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                codePoint = 0xDC00 | codePoint & 0x3FF;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          var MAX_ARGUMENTS_LENGTH = 0x1000;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            var res = '';
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i] & 0x7F);
            }
            return ret;
          }
          function binarySlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = '';
            for (var i = start; i < end; i++) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              newBuf = Buffer._augment(this.subarray(start, end));
            } else {
              var sliceLen = end - start;
              newBuf = new Buffer(sliceLen, undefined);
              for (var i = 0; i < sliceLen; i++) {
                newBuf[i] = this[i + start];
              }
            }
            if (newBuf.length)
              newBuf.parent = this.parent || this;
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if ((offset % 1) !== 0 || offset < 0)
              throw new RangeError('offset is not uint');
            if (offset + ext > length)
              throw new RangeError('Trying to access beyond buffer length');
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | (this[offset + 1] << 8);
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return (this[offset] << 8) | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            mul *= 0x80;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul;
            }
            mul *= 0x80;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80))
              return (this[offset]);
            return ((0xff - this[offset] + 1) * -1);
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | (this[offset + 1] << 8);
            return (val & 0x8000) ? val | 0xFFFF0000 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | (this[offset] << 8);
            return (val & 0x8000) ? val | 0xFFFF0000 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError('buffer must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('value is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError('index out of range');
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var mul = 1;
            var i = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = (value / mul) & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = (value / mul) & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 0xff, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            this[offset] = value;
            return offset + 1;
          };
          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 0xffff + value + 1;
            for (var i = 0,
                j = Math.min(buf.length - offset, 2); i < j; i++) {
              buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
            }
          }
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 0xffff, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value;
              this[offset + 1] = (value >>> 8);
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 0xffff, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value >>> 8);
              this[offset + 1] = value;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 0xffffffff + value + 1;
            for (var i = 0,
                j = Math.min(buf.length - offset, 4); i < j; i++) {
              buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
            }
          }
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 0xffffffff, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = (value >>> 24);
              this[offset + 2] = (value >>> 16);
              this[offset + 1] = (value >>> 8);
              this[offset] = value;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 0xffffffff, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value >>> 24);
              this[offset + 1] = (value >>> 16);
              this[offset + 2] = (value >>> 8);
              this[offset + 3] = value;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 0x7f, -0x80);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            if (value < 0)
              value = 0xff + value + 1;
            this[offset] = value;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value;
              this[offset + 1] = (value >>> 8);
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value >>> 8);
              this[offset + 1] = value;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value;
              this[offset + 1] = (value >>> 8);
              this[offset + 2] = (value >>> 16);
              this[offset + 3] = (value >>> 24);
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0)
              value = 0xffffffff + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value >>> 24);
              this[offset + 1] = (value >>> 16);
              this[offset + 2] = (value >>> 8);
              this[offset + 3] = value;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (value > max || value < min)
              throw new RangeError('value is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError('index out of range');
            if (offset < 0)
              throw new RangeError('index out of range');
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }
            if (start < 0 || start >= this.length)
              throw new RangeError('sourceStart out of bounds');
            if (end < 0)
              throw new RangeError('sourceEnd out of bounds');
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            var i;
            if (this === target && start < targetStart && targetStart < end) {
              for (i = len - 1; i >= 0; i--) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
              for (i = 0; i < len; i++) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              target._set(this.subarray(start, start + len), targetStart);
            }
            return len;
          };
          Buffer.prototype.fill = function fill(value, start, end) {
            if (!value)
              value = 0;
            if (!start)
              start = 0;
            if (!end)
              end = this.length;
            if (end < start)
              throw new RangeError('end < start');
            if (end === start)
              return;
            if (this.length === 0)
              return;
            if (start < 0 || start >= this.length)
              throw new RangeError('start out of bounds');
            if (end < 0 || end > this.length)
              throw new RangeError('end out of bounds');
            var i;
            if (typeof value === 'number') {
              for (i = start; i < end; i++) {
                this[i] = value;
              }
            } else {
              var bytes = utf8ToBytes(value.toString());
              var len = bytes.length;
              for (i = start; i < end; i++) {
                this[i] = bytes[i % len];
              }
            }
            return this;
          };
          Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
            if (typeof Uint8Array !== 'undefined') {
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                return (new Buffer(this)).buffer;
              } else {
                var buf = new Uint8Array(this.length);
                for (var i = 0,
                    len = buf.length; i < len; i += 1) {
                  buf[i] = this[i];
                }
                return buf.buffer;
              }
            } else {
              throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
            }
          };
          var BP = Buffer.prototype;
          Buffer._augment = function _augment(arr) {
            arr.constructor = Buffer;
            arr._isBuffer = true;
            arr._set = arr.set;
            arr.get = BP.get;
            arr.set = BP.set;
            arr.write = BP.write;
            arr.toString = BP.toString;
            arr.toLocaleString = BP.toString;
            arr.toJSON = BP.toJSON;
            arr.equals = BP.equals;
            arr.compare = BP.compare;
            arr.indexOf = BP.indexOf;
            arr.copy = BP.copy;
            arr.slice = BP.slice;
            arr.readUIntLE = BP.readUIntLE;
            arr.readUIntBE = BP.readUIntBE;
            arr.readUInt8 = BP.readUInt8;
            arr.readUInt16LE = BP.readUInt16LE;
            arr.readUInt16BE = BP.readUInt16BE;
            arr.readUInt32LE = BP.readUInt32LE;
            arr.readUInt32BE = BP.readUInt32BE;
            arr.readIntLE = BP.readIntLE;
            arr.readIntBE = BP.readIntBE;
            arr.readInt8 = BP.readInt8;
            arr.readInt16LE = BP.readInt16LE;
            arr.readInt16BE = BP.readInt16BE;
            arr.readInt32LE = BP.readInt32LE;
            arr.readInt32BE = BP.readInt32BE;
            arr.readFloatLE = BP.readFloatLE;
            arr.readFloatBE = BP.readFloatBE;
            arr.readDoubleLE = BP.readDoubleLE;
            arr.readDoubleBE = BP.readDoubleBE;
            arr.writeUInt8 = BP.writeUInt8;
            arr.writeUIntLE = BP.writeUIntLE;
            arr.writeUIntBE = BP.writeUIntBE;
            arr.writeUInt16LE = BP.writeUInt16LE;
            arr.writeUInt16BE = BP.writeUInt16BE;
            arr.writeUInt32LE = BP.writeUInt32LE;
            arr.writeUInt32BE = BP.writeUInt32BE;
            arr.writeIntLE = BP.writeIntLE;
            arr.writeIntBE = BP.writeIntBE;
            arr.writeInt8 = BP.writeInt8;
            arr.writeInt16LE = BP.writeInt16LE;
            arr.writeInt16BE = BP.writeInt16BE;
            arr.writeInt32LE = BP.writeInt32LE;
            arr.writeInt32BE = BP.writeInt32BE;
            arr.writeFloatLE = BP.writeFloatLE;
            arr.writeFloatBE = BP.writeFloatBE;
            arr.writeDoubleLE = BP.writeDoubleLE;
            arr.writeDoubleBE = BP.writeDoubleBE;
            arr.fill = BP.fill;
            arr.inspect = BP.inspect;
            arr.toArrayBuffer = BP.toArrayBuffer;
            return arr;
          };
          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, '');
            if (str.length < 2)
              return '';
            while (str.length % 4 !== 0) {
              str = str + '=';
            }
            return str;
          }
          function stringtrim(str) {
            if (str.trim)
              return str.trim();
            return str.replace(/^\s+|\s+$/g, '');
          }
          function toHex(n) {
            if (n < 16)
              return '0' + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; i++) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 0xD7FF && codePoint < 0xE000) {
                if (!leadSurrogate) {
                  if (codePoint > 0xDBFF) {
                    if ((units -= 3) > -1)
                      bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1)
                      bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 0xDC00) {
                  if ((units -= 3) > -1)
                    bytes.push(0xEF, 0xBF, 0xBD);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1)
                  bytes.push(0xEF, 0xBF, 0xBD);
              }
              leadSurrogate = null;
              if (codePoint < 0x80) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else {
                throw new Error('Invalid code point');
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
              byteArray.push(str.charCodeAt(i) & 0xFF);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c,
                hi,
                lo;
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
              if ((units -= 2) < 0)
                break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
              if ((i + offset >= dst.length) || (i >= src.length))
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
        }, {
          "base64-js": 5,
          "ieee754": 6,
          "is-array": 7
        }],
        5: [function(require, module, exports) {
          var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
          ;
          (function(exports) {
            'use strict';
            var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
            var PLUS = '+'.charCodeAt(0);
            var SLASH = '/'.charCodeAt(0);
            var NUMBER = '0'.charCodeAt(0);
            var LOWER = 'a'.charCodeAt(0);
            var UPPER = 'A'.charCodeAt(0);
            var PLUS_URL_SAFE = '-'.charCodeAt(0);
            var SLASH_URL_SAFE = '_'.charCodeAt(0);
            function decode(elt) {
              var code = elt.charCodeAt(0);
              if (code === PLUS || code === PLUS_URL_SAFE)
                return 62;
              if (code === SLASH || code === SLASH_URL_SAFE)
                return 63;
              if (code < NUMBER)
                return -1;
              if (code < NUMBER + 10)
                return code - NUMBER + 26 + 26;
              if (code < UPPER + 26)
                return code - UPPER;
              if (code < LOWER + 26)
                return code - LOWER + 26;
            }
            function b64ToByteArray(b64) {
              var i,
                  j,
                  l,
                  tmp,
                  placeHolders,
                  arr;
              if (b64.length % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4');
              }
              var len = b64.length;
              placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
              arr = new Arr(b64.length * 3 / 4 - placeHolders);
              l = placeHolders > 0 ? b64.length - 4 : b64.length;
              var L = 0;
              function push(v) {
                arr[L++] = v;
              }
              for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
                push((tmp & 0xFF0000) >> 16);
                push((tmp & 0xFF00) >> 8);
                push(tmp & 0xFF);
              }
              if (placeHolders === 2) {
                tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
                push(tmp & 0xFF);
              } else if (placeHolders === 1) {
                tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
                push((tmp >> 8) & 0xFF);
                push(tmp & 0xFF);
              }
              return arr;
            }
            function uint8ToBase64(uint8) {
              var i,
                  extraBytes = uint8.length % 3,
                  output = "",
                  temp,
                  length;
              function encode(num) {
                return lookup.charAt(num);
              }
              function tripletToBase64(num) {
                return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
              }
              for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                output += tripletToBase64(temp);
              }
              switch (extraBytes) {
                case 1:
                  temp = uint8[uint8.length - 1];
                  output += encode(temp >> 2);
                  output += encode((temp << 4) & 0x3F);
                  output += '==';
                  break;
                case 2:
                  temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
                  output += encode(temp >> 10);
                  output += encode((temp >> 4) & 0x3F);
                  output += encode((temp << 2) & 0x3F);
                  output += '=';
                  break;
              }
              return output;
            }
            exports.toByteArray = b64ToByteArray;
            exports.fromByteArray = uint8ToBase64;
          }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
        }, {}],
        6: [function(require, module, exports) {
          exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e,
                m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? (nBytes - 1) : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & ((1 << (-nBits)) - 1);
            s >>= (-nBits);
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
            m = e & ((1 << (-nBits)) - 1);
            e >>= (-nBits);
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : ((s ? -1 : 1) * Infinity);
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };
          exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e,
                m,
                c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
            var i = isLE ? 0 : (nBytes - 1);
            var d = isLE ? 1 : -1;
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);
              if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }
              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }
              if (value * c >= 2) {
                e++;
                c /= 2;
              }
              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }
            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
            e = (e << mLen) | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
            buffer[offset + i - d] |= s * 128;
          };
        }, {}],
        7: [function(require, module, exports) {
          var isArray = Array.isArray;
          var str = Object.prototype.toString;
          module.exports = isArray || function(val) {
            return !!val && '[object Array]' == str.call(val);
          };
        }, {}],
        8: [function(require, module, exports) {
          function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || undefined;
          }
          module.exports = EventEmitter;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = undefined;
          EventEmitter.prototype._maxListeners = undefined;
          EventEmitter.defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function(n) {
            if (!isNumber(n) || n < 0 || isNaN(n))
              throw TypeError('n must be a positive number');
            this._maxListeners = n;
            return this;
          };
          EventEmitter.prototype.emit = function(type) {
            var er,
                handler,
                len,
                args,
                i,
                listeners;
            if (!this._events)
              this._events = {};
            if (type === 'error') {
              if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
                er = arguments[1];
                if (er instanceof Error) {
                  throw er;
                }
                throw TypeError('Uncaught, unspecified "error" event.');
              }
            }
            handler = this._events[type];
            if (isUndefined(handler))
              return false;
            if (isFunction(handler)) {
              switch (arguments.length) {
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  len = arguments.length;
                  args = new Array(len - 1);
                  for (i = 1; i < len; i++)
                    args[i - 1] = arguments[i];
                  handler.apply(this, args);
              }
            } else if (isObject(handler)) {
              len = arguments.length;
              args = new Array(len - 1);
              for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];
              listeners = handler.slice();
              len = listeners.length;
              for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
            }
            return true;
          };
          EventEmitter.prototype.addListener = function(type, listener) {
            var m;
            if (!isFunction(listener))
              throw TypeError('listener must be a function');
            if (!this._events)
              this._events = {};
            if (this._events.newListener)
              this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
            if (!this._events[type])
              this._events[type] = listener;
            else if (isObject(this._events[type]))
              this._events[type].push(listener);
            else
              this._events[type] = [this._events[type], listener];
            if (isObject(this._events[type]) && !this._events[type].warned) {
              var m;
              if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
              } else {
                m = EventEmitter.defaultMaxListeners;
              }
              if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
                if (typeof console.trace === 'function') {
                  console.trace();
                }
              }
            }
            return this;
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.once = function(type, listener) {
            if (!isFunction(listener))
              throw TypeError('listener must be a function');
            var fired = false;
            function g() {
              this.removeListener(type, g);
              if (!fired) {
                fired = true;
                listener.apply(this, arguments);
              }
            }
            g.listener = listener;
            this.on(type, g);
            return this;
          };
          EventEmitter.prototype.removeListener = function(type, listener) {
            var list,
                position,
                length,
                i;
            if (!isFunction(listener))
              throw TypeError('listener must be a function');
            if (!this._events || !this._events[type])
              return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
              delete this._events[type];
              if (this._events.removeListener)
                this.emit('removeListener', type, listener);
            } else if (isObject(list)) {
              for (i = length; i-- > 0; ) {
                if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
                  position = i;
                  break;
                }
              }
              if (position < 0)
                return this;
              if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
              } else {
                list.splice(position, 1);
              }
              if (this._events.removeListener)
                this.emit('removeListener', type, listener);
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners = function(type) {
            var key,
                listeners;
            if (!this._events)
              return this;
            if (!this._events.removeListener) {
              if (arguments.length === 0)
                this._events = {};
              else if (this._events[type])
                delete this._events[type];
              return this;
            }
            if (arguments.length === 0) {
              for (key in this._events) {
                if (key === 'removeListener')
                  continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners('removeListener');
              this._events = {};
              return this;
            }
            listeners = this._events[type];
            if (isFunction(listeners)) {
              this.removeListener(type, listeners);
            } else {
              while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];
            return this;
          };
          EventEmitter.prototype.listeners = function(type) {
            var ret;
            if (!this._events || !this._events[type])
              ret = [];
            else if (isFunction(this._events[type]))
              ret = [this._events[type]];
            else
              ret = this._events[type].slice();
            return ret;
          };
          EventEmitter.listenerCount = function(emitter, type) {
            var ret;
            if (!emitter._events || !emitter._events[type])
              ret = 0;
            else if (isFunction(emitter._events[type]))
              ret = 1;
            else
              ret = emitter._events[type].length;
            return ret;
          };
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          function isUndefined(arg) {
            return arg === void 0;
          }
        }, {}],
        9: [function(require, module, exports) {
          if (typeof Object.create === 'function') {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }});
            };
          } else {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }
        }, {}],
        10: [function(require, module, exports) {
          module.exports = Array.isArray || function(arr) {
            return Object.prototype.toString.call(arr) == '[object Array]';
          };
        }, {}],
        11: [function(require, module, exports) {
          (function(process) {
            function normalizeArray(parts, allowAboveRoot) {
              var up = 0;
              for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];
                if (last === '.') {
                  parts.splice(i, 1);
                } else if (last === '..') {
                  parts.splice(i, 1);
                  up++;
                } else if (up) {
                  parts.splice(i, 1);
                  up--;
                }
              }
              if (allowAboveRoot) {
                for (; up--; up) {
                  parts.unshift('..');
                }
              }
              return parts;
            }
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            var splitPath = function(filename) {
              return splitPathRe.exec(filename).slice(1);
            };
            exports.resolve = function() {
              var resolvedPath = '',
                  resolvedAbsolute = false;
              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path = (i >= 0) ? arguments[i] : process.cwd();
                if (typeof path !== 'string') {
                  throw new TypeError('Arguments to path.resolve must be strings');
                } else if (!path) {
                  continue;
                }
                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charAt(0) === '/';
              }
              resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
                return !!p;
              }), !resolvedAbsolute).join('/');
              return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
            };
            exports.normalize = function(path) {
              var isAbsolute = exports.isAbsolute(path),
                  trailingSlash = substr(path, -1) === '/';
              path = normalizeArray(filter(path.split('/'), function(p) {
                return !!p;
              }), !isAbsolute).join('/');
              if (!path && !isAbsolute) {
                path = '.';
              }
              if (path && trailingSlash) {
                path += '/';
              }
              return (isAbsolute ? '/' : '') + path;
            };
            exports.isAbsolute = function(path) {
              return path.charAt(0) === '/';
            };
            exports.join = function() {
              var paths = Array.prototype.slice.call(arguments, 0);
              return exports.normalize(filter(paths, function(p, index) {
                if (typeof p !== 'string') {
                  throw new TypeError('Arguments to path.join must be strings');
                }
                return p;
              }).join('/'));
            };
            exports.relative = function(from, to) {
              from = exports.resolve(from).substr(1);
              to = exports.resolve(to).substr(1);
              function trim(arr) {
                var start = 0;
                for (; start < arr.length; start++) {
                  if (arr[start] !== '')
                    break;
                }
                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== '')
                    break;
                }
                if (start > end)
                  return [];
                return arr.slice(start, end - start + 1);
              }
              var fromParts = trim(from.split('/'));
              var toParts = trim(to.split('/'));
              var length = Math.min(fromParts.length, toParts.length);
              var samePartsLength = length;
              for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                  samePartsLength = i;
                  break;
                }
              }
              var outputParts = [];
              for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push('..');
              }
              outputParts = outputParts.concat(toParts.slice(samePartsLength));
              return outputParts.join('/');
            };
            exports.sep = '/';
            exports.delimiter = ':';
            exports.dirname = function(path) {
              var result = splitPath(path),
                  root = result[0],
                  dir = result[1];
              if (!root && !dir) {
                return '.';
              }
              if (dir) {
                dir = dir.substr(0, dir.length - 1);
              }
              return root + dir;
            };
            exports.basename = function(path, ext) {
              var f = splitPath(path)[2];
              if (ext && f.substr(-1 * ext.length) === ext) {
                f = f.substr(0, f.length - ext.length);
              }
              return f;
            };
            exports.extname = function(path) {
              return splitPath(path)[3];
            };
            function filter(xs, f) {
              if (xs.filter)
                return xs.filter(f);
              var res = [];
              for (var i = 0; i < xs.length; i++) {
                if (f(xs[i], i, xs))
                  res.push(xs[i]);
              }
              return res;
            }
            var substr = 'ab'.substr(-1) === 'b' ? function(str, start, len) {
              return str.substr(start, len);
            } : function(str, start, len) {
              if (start < 0)
                start = str.length + start;
              return str.substr(start, len);
            };
            ;
          }).call(this, require('_process'));
        }, {"_process": 12}],
        12: [function(require, module, exports) {
          var process = module.exports = {};
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = setTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            clearTimeout(timeout);
          }
          process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              setTimeout(drainQueue, 0);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process.title = 'browser';
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = '';
          process.versions = {};
          function noop() {}
          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.binding = function(name) {
            throw new Error('process.binding is not supported');
          };
          process.cwd = function() {
            return '/';
          };
          process.chdir = function(dir) {
            throw new Error('process.chdir is not supported');
          };
          process.umask = function() {
            return 0;
          };
        }, {}],
        13: [function(require, module, exports) {
          module.exports = require("./lib/_stream_duplex.js");
        }, {"./lib/_stream_duplex.js": 14}],
        14: [function(require, module, exports) {
          'use strict';
          var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj)
              keys.push(key);
            return keys;
          };
          module.exports = Duplex;
          var processNextTick = require('process-nextick-args');
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var Readable = require('./_stream_readable');
          var Writable = require('./_stream_writable');
          util.inherits(Duplex, Readable);
          var keys = objectKeys(Writable.prototype);
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
          function Duplex(options) {
            if (!(this instanceof Duplex))
              return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            if (options && options.readable === false)
              this.readable = false;
            if (options && options.writable === false)
              this.writable = false;
            this.allowHalfOpen = true;
            if (options && options.allowHalfOpen === false)
              this.allowHalfOpen = false;
            this.once('end', onend);
          }
          function onend() {
            if (this.allowHalfOpen || this._writableState.ended)
              return;
            processNextTick(onEndNT, this);
          }
          function onEndNT(self) {
            self.end();
          }
          function forEach(xs, f) {
            for (var i = 0,
                l = xs.length; i < l; i++) {
              f(xs[i], i);
            }
          }
        }, {
          "./_stream_readable": 16,
          "./_stream_writable": 18,
          "core-util-is": 19,
          "inherits": 9,
          "process-nextick-args": 20
        }],
        15: [function(require, module, exports) {
          'use strict';
          module.exports = PassThrough;
          var Transform = require('./_stream_transform');
          var util = require('core-util-is');
          util.inherits = require('inherits');
          util.inherits(PassThrough, Transform);
          function PassThrough(options) {
            if (!(this instanceof PassThrough))
              return new PassThrough(options);
            Transform.call(this, options);
          }
          PassThrough.prototype._transform = function(chunk, encoding, cb) {
            cb(null, chunk);
          };
        }, {
          "./_stream_transform": 17,
          "core-util-is": 19,
          "inherits": 9
        }],
        16: [function(require, module, exports) {
          (function(process) {
            'use strict';
            module.exports = Readable;
            var processNextTick = require('process-nextick-args');
            var isArray = require('isarray');
            var Buffer = require('buffer').Buffer;
            Readable.ReadableState = ReadableState;
            var EE = require('events').EventEmitter;
            if (!EE.listenerCount)
              EE.listenerCount = function(emitter, type) {
                return emitter.listeners(type).length;
              };
            var Stream;
            (function() {
              try {
                Stream = require('st' + 'ream');
              } catch (_) {} finally {
                if (!Stream)
                  Stream = require('events').EventEmitter;
              }
            }());
            var Buffer = require('buffer').Buffer;
            var util = require('core-util-is');
            util.inherits = require('inherits');
            var debug = require('util');
            if (debug && debug.debuglog) {
              debug = debug.debuglog('stream');
            } else {
              debug = function() {};
            }
            var StringDecoder;
            util.inherits(Readable, Stream);
            function ReadableState(options, stream) {
              var Duplex = require('./_stream_duplex');
              options = options || {};
              this.objectMode = !!options.objectMode;
              if (stream instanceof Duplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;
              var hwm = options.highWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
              this.highWaterMark = ~~this.highWaterMark;
              this.buffer = [];
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.defaultEncoding = options.defaultEncoding || 'utf8';
              this.ranOut = false;
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = require('string_decoder/').StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              var Duplex = require('./_stream_duplex');
              if (!(this instanceof Readable))
                return new Readable(options);
              this._readableState = new ReadableState(options, this);
              this.readable = true;
              if (options && typeof options.read === 'function')
                this._read = options.read;
              Stream.call(this);
            }
            Readable.prototype.push = function(chunk, encoding) {
              var state = this._readableState;
              if (!state.objectMode && typeof chunk === 'string') {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = new Buffer(chunk, encoding);
                  encoding = '';
                }
              }
              return readableAddChunk(this, state, chunk, encoding, false);
            };
            Readable.prototype.unshift = function(chunk) {
              var state = this._readableState;
              return readableAddChunk(this, state, chunk, '', true);
            };
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            function readableAddChunk(stream, state, chunk, encoding, addToFront) {
              var er = chunkInvalid(state, chunk);
              if (er) {
                stream.emit('error', er);
              } else if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (state.ended && !addToFront) {
                  var e = new Error('stream.push() after EOF');
                  stream.emit('error', e);
                } else if (state.endEmitted && addToFront) {
                  var e = new Error('stream.unshift() after end event');
                  stream.emit('error', e);
                } else {
                  if (state.decoder && !addToFront && !encoding)
                    chunk = state.decoder.write(chunk);
                  if (!addToFront)
                    state.reading = false;
                  if (state.flowing && state.length === 0 && !state.sync) {
                    stream.emit('data', chunk);
                    stream.read(0);
                  } else {
                    state.length += state.objectMode ? 1 : chunk.length;
                    if (addToFront)
                      state.buffer.unshift(chunk);
                    else
                      state.buffer.push(chunk);
                    if (state.needReadable)
                      emitReadable(stream);
                  }
                  maybeReadMore(stream, state);
                }
              } else if (!addToFront) {
                state.reading = false;
              }
              return needMoreData(state);
            }
            function needMoreData(state) {
              return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
            }
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
              this._readableState.decoder = new StringDecoder(enc);
              this._readableState.encoding = enc;
              return this;
            };
            var MAX_HWM = 0x800000;
            function roundUpToNextPowerOf2(n) {
              if (n >= MAX_HWM) {
                n = MAX_HWM;
              } else {
                n--;
                for (var p = 1; p < 32; p <<= 1)
                  n |= n >> p;
                n++;
              }
              return n;
            }
            function howMuchToRead(n, state) {
              if (state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return n === 0 ? 0 : 1;
              if (n === null || isNaN(n)) {
                if (state.flowing && state.buffer.length)
                  return state.buffer[0].length;
                else
                  return state.length;
              }
              if (n <= 0)
                return 0;
              if (n > state.highWaterMark)
                state.highWaterMark = roundUpToNextPowerOf2(n);
              if (n > state.length) {
                if (!state.ended) {
                  state.needReadable = true;
                  return 0;
                } else {
                  return state.length;
                }
              }
              return n;
            }
            Readable.prototype.read = function(n) {
              debug('read', n);
              var state = this._readableState;
              var nOrig = n;
              if (typeof n !== 'number' || n > 0)
                state.emittedReadable = false;
              if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                debug('read: emitReadable', state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n = howMuchToRead(n, state);
              if (n === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug('need readable', doRead);
              if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug('length less than watermark', doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug('reading or ended', doRead);
              }
              if (doRead) {
                debug('do read');
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
              }
              if (doRead && !state.reading)
                n = howMuchToRead(nOrig, state);
              var ret;
              if (n > 0)
                ret = fromList(n, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = true;
                n = 0;
              }
              state.length -= n;
              if (state.length === 0 && !state.ended)
                state.needReadable = true;
              if (nOrig !== n && state.ended && state.length === 0)
                endReadable(this);
              if (ret !== null)
                this.emit('data', ret);
              return ret;
            };
            function chunkInvalid(state, chunk) {
              var er = null;
              if (!(Buffer.isBuffer(chunk)) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
                er = new TypeError('Invalid non-string/buffer chunk');
              }
              return er;
            }
            function onEofChunk(stream, state) {
              if (state.ended)
                return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              emitReadable(stream);
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug('emitReadable', state.flowing);
                state.emittedReadable = true;
                if (state.sync)
                  processNextTick(emitReadable_, stream);
                else
                  emitReadable_(stream);
              }
            }
            function emitReadable_(stream) {
              debug('emit readable');
              stream.emit('readable');
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                processNextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              var len = state.length;
              while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                debug('maybeReadMore read 0');
                stream.read(0);
                if (len === state.length)
                  break;
                else
                  len = state.length;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n) {
              this.emit('error', new Error('not implemented'));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              var endFn = doEnd ? onend : cleanup;
              if (state.endEmitted)
                processNextTick(endFn);
              else
                src.once('end', endFn);
              dest.on('unpipe', onunpipe);
              function onunpipe(readable) {
                debug('onunpipe');
                if (readable === src) {
                  cleanup();
                }
              }
              function onend() {
                debug('onend');
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on('drain', ondrain);
              function cleanup() {
                debug('cleanup');
                dest.removeListener('close', onclose);
                dest.removeListener('finish', onfinish);
                dest.removeListener('drain', ondrain);
                dest.removeListener('error', onerror);
                dest.removeListener('unpipe', onunpipe);
                src.removeListener('end', onend);
                src.removeListener('end', cleanup);
                src.removeListener('data', ondata);
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              src.on('data', ondata);
              function ondata(chunk) {
                debug('ondata');
                var ret = dest.write(chunk);
                if (false === ret) {
                  debug('false write response, pause', src._readableState.awaitDrain);
                  src._readableState.awaitDrain++;
                  src.pause();
                }
              }
              function onerror(er) {
                debug('onerror', er);
                unpipe();
                dest.removeListener('error', onerror);
                if (EE.listenerCount(dest, 'error') === 0)
                  dest.emit('error', er);
              }
              if (!dest._events || !dest._events.error)
                dest.on('error', onerror);
              else if (isArray(dest._events.error))
                dest._events.error.unshift(onerror);
              else
                dest._events.error = [onerror, dest._events.error];
              function onclose() {
                dest.removeListener('finish', onfinish);
                unpipe();
              }
              dest.once('close', onclose);
              function onfinish() {
                debug('onfinish');
                dest.removeListener('close', onclose);
                unpipe();
              }
              dest.once('finish', onfinish);
              function unpipe() {
                debug('unpipe');
                src.unpipe(dest);
              }
              dest.emit('pipe', src);
              if (!state.flowing) {
                debug('pipe resume');
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function() {
                var state = src._readableState;
                debug('pipeOnDrain', state.awaitDrain);
                if (state.awaitDrain)
                  state.awaitDrain--;
                if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              if (state.pipesCount === 0)
                return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes)
                  return this;
                if (!dest)
                  dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                  dest.emit('unpipe', this);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++)
                  dests[i].emit('unpipe', this);
                return this;
              }
              var i = indexOf(state.pipes, dest);
              if (i === -1)
                return this;
              state.pipes.splice(i, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1)
                state.pipes = state.pipes[0];
              dest.emit('unpipe', this);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              if (ev === 'data' && false !== this._readableState.flowing) {
                this.resume();
              }
              if (ev === 'readable' && this.readable) {
                var state = this._readableState;
                if (!state.readableListening) {
                  state.readableListening = true;
                  state.emittedReadable = false;
                  state.needReadable = true;
                  if (!state.reading) {
                    processNextTick(nReadingNextTick, this);
                  } else if (state.length) {
                    emitReadable(this, state);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            function nReadingNextTick(self) {
              debug('readable nexttick read 0');
              self.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug('resume');
                state.flowing = true;
                resume(this, state);
              }
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                processNextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              if (!state.reading) {
                debug('resume read 0');
                stream.read(0);
              }
              state.resumeScheduled = false;
              stream.emit('resume');
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug('call pause flowing=%j', this._readableState.flowing);
              if (false !== this._readableState.flowing) {
                debug('pause');
                this._readableState.flowing = false;
                this.emit('pause');
              }
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug('flow', state.flowing);
              if (state.flowing) {
                do {
                  var chunk = stream.read();
                } while (null !== chunk && state.flowing);
              }
            }
            Readable.prototype.wrap = function(stream) {
              var state = this._readableState;
              var paused = false;
              var self = this;
              stream.on('end', function() {
                debug('wrapped end');
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length)
                    self.push(chunk);
                }
                self.push(null);
              });
              stream.on('data', function(chunk) {
                debug('wrapped data');
                if (state.decoder)
                  chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === undefined))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                  return;
                var ret = self.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i in stream) {
                if (this[i] === undefined && typeof stream[i] === 'function') {
                  this[i] = function(method) {
                    return function() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i);
                }
              }
              var events = ['error', 'close', 'destroy', 'pause', 'resume'];
              forEach(events, function(ev) {
                stream.on(ev, self.emit.bind(self, ev));
              });
              self._read = function(n) {
                debug('wrapped _read', n);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return self;
            };
            Readable._fromList = fromList;
            function fromList(n, state) {
              var list = state.buffer;
              var length = state.length;
              var stringMode = !!state.decoder;
              var objectMode = !!state.objectMode;
              var ret;
              if (list.length === 0)
                return null;
              if (length === 0)
                ret = null;
              else if (objectMode)
                ret = list.shift();
              else if (!n || n >= length) {
                if (stringMode)
                  ret = list.join('');
                else
                  ret = Buffer.concat(list, length);
                list.length = 0;
              } else {
                if (n < list[0].length) {
                  var buf = list[0];
                  ret = buf.slice(0, n);
                  list[0] = buf.slice(n);
                } else if (n === list[0].length) {
                  ret = list.shift();
                } else {
                  if (stringMode)
                    ret = '';
                  else
                    ret = new Buffer(n);
                  var c = 0;
                  for (var i = 0,
                      l = list.length; i < l && c < n; i++) {
                    var buf = list[0];
                    var cpy = Math.min(n - c, buf.length);
                    if (stringMode)
                      ret += buf.slice(0, cpy);
                    else
                      buf.copy(ret, c, 0, cpy);
                    if (cpy < buf.length)
                      list[0] = buf.slice(cpy);
                    else
                      list.shift();
                    c += cpy;
                  }
                }
              }
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              if (state.length > 0)
                throw new Error('endReadable called on non-empty stream');
              if (!state.endEmitted) {
                state.ended = true;
                processNextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit('end');
              }
            }
            function forEach(xs, f) {
              for (var i = 0,
                  l = xs.length; i < l; i++) {
                f(xs[i], i);
              }
            }
            function indexOf(xs, x) {
              for (var i = 0,
                  l = xs.length; i < l; i++) {
                if (xs[i] === x)
                  return i;
              }
              return -1;
            }
          }).call(this, require('_process'));
        }, {
          "./_stream_duplex": 14,
          "_process": 12,
          "buffer": 4,
          "core-util-is": 19,
          "events": 8,
          "inherits": 9,
          "isarray": 10,
          "process-nextick-args": 20,
          "string_decoder/": 27,
          "util": 3
        }],
        17: [function(require, module, exports) {
          'use strict';
          module.exports = Transform;
          var Duplex = require('./_stream_duplex');
          var util = require('core-util-is');
          util.inherits = require('inherits');
          util.inherits(Transform, Duplex);
          function TransformState(stream) {
            this.afterTransform = function(er, data) {
              return afterTransform(stream, er, data);
            };
            this.needTransform = false;
            this.transforming = false;
            this.writecb = null;
            this.writechunk = null;
          }
          function afterTransform(stream, er, data) {
            var ts = stream._transformState;
            ts.transforming = false;
            var cb = ts.writecb;
            if (!cb)
              return stream.emit('error', new Error('no writecb in Transform class'));
            ts.writechunk = null;
            ts.writecb = null;
            if (data !== null && data !== undefined)
              stream.push(data);
            if (cb)
              cb(er);
            var rs = stream._readableState;
            rs.reading = false;
            if (rs.needReadable || rs.length < rs.highWaterMark) {
              stream._read(rs.highWaterMark);
            }
          }
          function Transform(options) {
            if (!(this instanceof Transform))
              return new Transform(options);
            Duplex.call(this, options);
            this._transformState = new TransformState(this);
            var stream = this;
            this._readableState.needReadable = true;
            this._readableState.sync = false;
            if (options) {
              if (typeof options.transform === 'function')
                this._transform = options.transform;
              if (typeof options.flush === 'function')
                this._flush = options.flush;
            }
            this.once('prefinish', function() {
              if (typeof this._flush === 'function')
                this._flush(function(er) {
                  done(stream, er);
                });
              else
                done(stream);
            });
          }
          Transform.prototype.push = function(chunk, encoding) {
            this._transformState.needTransform = false;
            return Duplex.prototype.push.call(this, chunk, encoding);
          };
          Transform.prototype._transform = function(chunk, encoding, cb) {
            throw new Error('not implemented');
          };
          Transform.prototype._write = function(chunk, encoding, cb) {
            var ts = this._transformState;
            ts.writecb = cb;
            ts.writechunk = chunk;
            ts.writeencoding = encoding;
            if (!ts.transforming) {
              var rs = this._readableState;
              if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                this._read(rs.highWaterMark);
            }
          };
          Transform.prototype._read = function(n) {
            var ts = this._transformState;
            if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
              ts.transforming = true;
              this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
            } else {
              ts.needTransform = true;
            }
          };
          function done(stream, er) {
            if (er)
              return stream.emit('error', er);
            var ws = stream._writableState;
            var ts = stream._transformState;
            if (ws.length)
              throw new Error('calling transform done when ws.length != 0');
            if (ts.transforming)
              throw new Error('calling transform done when still transforming');
            return stream.push(null);
          }
        }, {
          "./_stream_duplex": 14,
          "core-util-is": 19,
          "inherits": 9
        }],
        18: [function(require, module, exports) {
          'use strict';
          module.exports = Writable;
          var processNextTick = require('process-nextick-args');
          var Buffer = require('buffer').Buffer;
          Writable.WritableState = WritableState;
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var Stream;
          (function() {
            try {
              Stream = require('st' + 'ream');
            } catch (_) {} finally {
              if (!Stream)
                Stream = require('events').EventEmitter;
            }
          }());
          var Buffer = require('buffer').Buffer;
          util.inherits(Writable, Stream);
          function nop() {}
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
          }
          function WritableState(options, stream) {
            var Duplex = require('./_stream_duplex');
            options = options || {};
            this.objectMode = !!options.objectMode;
            if (stream instanceof Duplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            var hwm = options.highWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
            this.highWaterMark = ~~this.highWaterMark;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
          }
          WritableState.prototype.getBuffer = function writableStateGetBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function() {
            try {
              Object.defineProperty(WritableState.prototype, 'buffer', {get: require('util-deprecate')(function() {
                  return this.getBuffer();
                }, '_writableState.buffer is deprecated. Use ' + '_writableState.getBuffer() instead.')});
            } catch (_) {}
          }());
          function Writable(options) {
            var Duplex = require('./_stream_duplex');
            if (!(this instanceof Writable) && !(this instanceof Duplex))
              return new Writable(options);
            this._writableState = new WritableState(options, this);
            this.writable = true;
            if (options) {
              if (typeof options.write === 'function')
                this._write = options.write;
              if (typeof options.writev === 'function')
                this._writev = options.writev;
            }
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            this.emit('error', new Error('Cannot pipe. Not readable.'));
          };
          function writeAfterEnd(stream, cb) {
            var er = new Error('write after end');
            stream.emit('error', er);
            processNextTick(cb, er);
          }
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            if (!(Buffer.isBuffer(chunk)) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
              var er = new TypeError('Invalid non-string/buffer chunk');
              stream.emit('error', er);
              processNextTick(cb, er);
              valid = false;
            }
            return valid;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (Buffer.isBuffer(chunk))
              encoding = 'buffer';
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== 'function')
              cb = nop;
            if (state.ended)
              writeAfterEnd(this, cb);
            else if (validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function() {
            var state = this._writableState;
            state.corked++;
          };
          Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            if (typeof encoding === 'string')
              encoding = encoding.toLowerCase();
            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1))
              throw new TypeError('Unknown encoding: ' + encoding);
            this._writableState.defaultEncoding = encoding;
          };
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = new Buffer(chunk, encoding);
            }
            return chunk;
          }
          function writeOrBuffer(stream, state, chunk, encoding, cb) {
            chunk = decodeChunk(state, chunk, encoding);
            if (Buffer.isBuffer(chunk))
              encoding = 'buffer';
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync)
              processNextTick(cb, er);
            else
              cb(er);
            stream._writableState.errorEmitted = true;
            stream.emit('error', er);
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(state);
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                processNextTick(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit('drain');
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              var buffer = [];
              var cbs = [];
              while (entry) {
                cbs.push(entry.callback);
                buffer.push(entry);
                entry = entry.next;
              }
              state.pendingcb++;
              state.lastBufferedRequest = null;
              doWrite(stream, state, true, state.length, buffer, '', function(err) {
                for (var i = 0; i < cbs.length; i++) {
                  state.pendingcb--;
                  cbs[i](err);
                }
              });
            } else {
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error('not implemented'));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === 'function') {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== undefined)
              this.write(chunk, encoding);
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            if (!state.ending && !state.finished)
              endWritable(this, state, cb);
          };
          function needFinish(state) {
            return (state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing);
          }
          function prefinish(stream, state) {
            if (!state.prefinished) {
              state.prefinished = true;
              stream.emit('prefinish');
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              if (state.pendingcb === 0) {
                prefinish(stream, state);
                state.finished = true;
                stream.emit('finish');
              } else {
                prefinish(stream, state);
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                processNextTick(cb);
              else
                stream.once('finish', cb);
            }
            state.ended = true;
          }
        }, {
          "./_stream_duplex": 14,
          "buffer": 4,
          "core-util-is": 19,
          "events": 8,
          "inherits": 9,
          "process-nextick-args": 20,
          "util-deprecate": 21
        }],
        19: [function(require, module, exports) {
          (function(Buffer) {
            function isArray(ar) {
              return Array.isArray(ar);
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
              return typeof arg === 'boolean';
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
              return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === 'number';
            }
            exports.isNumber = isNumber;
            function isString(arg) {
              return typeof arg === 'string';
            }
            exports.isString = isString;
            function isSymbol(arg) {
              return typeof arg === 'symbol';
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
              return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
              return isObject(re) && objectToString(re) === '[object RegExp]';
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
              return typeof arg === 'object' && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
              return isObject(d) && objectToString(d) === '[object Date]';
            }
            exports.isDate = isDate;
            function isError(e) {
              return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
            }
            exports.isError = isError;
            function isFunction(arg) {
              return typeof arg === 'function';
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
              return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
            }
            exports.isPrimitive = isPrimitive;
            function isBuffer(arg) {
              return Buffer.isBuffer(arg);
            }
            exports.isBuffer = isBuffer;
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
          }).call(this, require("buffer").Buffer);
        }, {"buffer": 4}],
        20: [function(require, module, exports) {
          (function(process) {
            'use strict';
            module.exports = nextTick;
            function nextTick(fn) {
              var args = new Array(arguments.length - 1);
              var i = 0;
              while (i < args.length) {
                args[i++] = arguments[i];
              }
              process.nextTick(function afterTick() {
                fn.apply(null, args);
              });
            }
          }).call(this, require('_process'));
        }, {"_process": 12}],
        21: [function(require, module, exports) {
          (function(global) {
            module.exports = deprecate;
            function deprecate(fn, msg) {
              if (config('noDeprecation')) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config('throwDeprecation')) {
                    throw new Error(msg);
                  } else if (config('traceDeprecation')) {
                    console.trace(msg);
                  } else {
                    console.warn(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            }
            function config(name) {
              if (!global.localStorage)
                return false;
              var val = global.localStorage[name];
              if (null == val)
                return false;
              return String(val).toLowerCase() === 'true';
            }
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        22: [function(require, module, exports) {
          module.exports = require("./lib/_stream_passthrough.js");
        }, {"./lib/_stream_passthrough.js": 15}],
        23: [function(require, module, exports) {
          var Stream = (function() {
            try {
              return require('st' + 'ream');
            } catch (_) {}
          }());
          exports = module.exports = require('./lib/_stream_readable.js');
          exports.Stream = Stream || exports;
          exports.Readable = exports;
          exports.Writable = require('./lib/_stream_writable.js');
          exports.Duplex = require('./lib/_stream_duplex.js');
          exports.Transform = require('./lib/_stream_transform.js');
          exports.PassThrough = require('./lib/_stream_passthrough.js');
        }, {
          "./lib/_stream_duplex.js": 14,
          "./lib/_stream_passthrough.js": 15,
          "./lib/_stream_readable.js": 16,
          "./lib/_stream_transform.js": 17,
          "./lib/_stream_writable.js": 18
        }],
        24: [function(require, module, exports) {
          module.exports = require("./lib/_stream_transform.js");
        }, {"./lib/_stream_transform.js": 17}],
        25: [function(require, module, exports) {
          module.exports = require("./lib/_stream_writable.js");
        }, {"./lib/_stream_writable.js": 18}],
        26: [function(require, module, exports) {
          module.exports = Stream;
          var EE = require('events').EventEmitter;
          var inherits = require('inherits');
          inherits(Stream, EE);
          Stream.Readable = require('readable-stream/readable.js');
          Stream.Writable = require('readable-stream/writable.js');
          Stream.Duplex = require('readable-stream/duplex.js');
          Stream.Transform = require('readable-stream/transform.js');
          Stream.PassThrough = require('readable-stream/passthrough.js');
          Stream.Stream = Stream;
          function Stream() {
            EE.call(this);
          }
          Stream.prototype.pipe = function(dest, options) {
            var source = this;
            function ondata(chunk) {
              if (dest.writable) {
                if (false === dest.write(chunk) && source.pause) {
                  source.pause();
                }
              }
            }
            source.on('data', ondata);
            function ondrain() {
              if (source.readable && source.resume) {
                source.resume();
              }
            }
            dest.on('drain', ondrain);
            if (!dest._isStdio && (!options || options.end !== false)) {
              source.on('end', onend);
              source.on('close', onclose);
            }
            var didOnEnd = false;
            function onend() {
              if (didOnEnd)
                return;
              didOnEnd = true;
              dest.end();
            }
            function onclose() {
              if (didOnEnd)
                return;
              didOnEnd = true;
              if (typeof dest.destroy === 'function')
                dest.destroy();
            }
            function onerror(er) {
              cleanup();
              if (EE.listenerCount(this, 'error') === 0) {
                throw er;
              }
            }
            source.on('error', onerror);
            dest.on('error', onerror);
            function cleanup() {
              source.removeListener('data', ondata);
              dest.removeListener('drain', ondrain);
              source.removeListener('end', onend);
              source.removeListener('close', onclose);
              source.removeListener('error', onerror);
              dest.removeListener('error', onerror);
              source.removeListener('end', cleanup);
              source.removeListener('close', cleanup);
              dest.removeListener('close', cleanup);
            }
            source.on('end', cleanup);
            source.on('close', cleanup);
            dest.on('close', cleanup);
            dest.emit('pipe', source);
            return dest;
          };
        }, {
          "events": 8,
          "inherits": 9,
          "readable-stream/duplex.js": 13,
          "readable-stream/passthrough.js": 22,
          "readable-stream/readable.js": 23,
          "readable-stream/transform.js": 24,
          "readable-stream/writable.js": 25
        }],
        27: [function(require, module, exports) {
          var Buffer = require('buffer').Buffer;
          var isBufferEncoding = Buffer.isEncoding || function(encoding) {
            switch (encoding && encoding.toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
              case 'raw':
                return true;
              default:
                return false;
            }
          };
          function assertEncoding(encoding) {
            if (encoding && !isBufferEncoding(encoding)) {
              throw new Error('Unknown encoding: ' + encoding);
            }
          }
          var StringDecoder = exports.StringDecoder = function(encoding) {
            this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
            assertEncoding(encoding);
            switch (this.encoding) {
              case 'utf8':
                this.surrogateSize = 3;
                break;
              case 'ucs2':
              case 'utf16le':
                this.surrogateSize = 2;
                this.detectIncompleteChar = utf16DetectIncompleteChar;
                break;
              case 'base64':
                this.surrogateSize = 3;
                this.detectIncompleteChar = base64DetectIncompleteChar;
                break;
              default:
                this.write = passThroughWrite;
                return;
            }
            this.charBuffer = new Buffer(6);
            this.charReceived = 0;
            this.charLength = 0;
          };
          StringDecoder.prototype.write = function(buffer) {
            var charStr = '';
            while (this.charLength) {
              var available = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length;
              buffer.copy(this.charBuffer, this.charReceived, 0, available);
              this.charReceived += available;
              if (this.charReceived < this.charLength) {
                return '';
              }
              buffer = buffer.slice(available, buffer.length);
              charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
              var charCode = charStr.charCodeAt(charStr.length - 1);
              if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                this.charLength += this.surrogateSize;
                charStr = '';
                continue;
              }
              this.charReceived = this.charLength = 0;
              if (buffer.length === 0) {
                return charStr;
              }
              break;
            }
            this.detectIncompleteChar(buffer);
            var end = buffer.length;
            if (this.charLength) {
              buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
              end -= this.charReceived;
            }
            charStr += buffer.toString(this.encoding, 0, end);
            var end = charStr.length - 1;
            var charCode = charStr.charCodeAt(end);
            if (charCode >= 0xD800 && charCode <= 0xDBFF) {
              var size = this.surrogateSize;
              this.charLength += size;
              this.charReceived += size;
              this.charBuffer.copy(this.charBuffer, size, 0, size);
              buffer.copy(this.charBuffer, 0, 0, size);
              return charStr.substring(0, end);
            }
            return charStr;
          };
          StringDecoder.prototype.detectIncompleteChar = function(buffer) {
            var i = (buffer.length >= 3) ? 3 : buffer.length;
            for (; i > 0; i--) {
              var c = buffer[buffer.length - i];
              if (i == 1 && c >> 5 == 0x06) {
                this.charLength = 2;
                break;
              }
              if (i <= 2 && c >> 4 == 0x0E) {
                this.charLength = 3;
                break;
              }
              if (i <= 3 && c >> 3 == 0x1E) {
                this.charLength = 4;
                break;
              }
            }
            this.charReceived = i;
          };
          StringDecoder.prototype.end = function(buffer) {
            var res = '';
            if (buffer && buffer.length)
              res = this.write(buffer);
            if (this.charReceived) {
              var cr = this.charReceived;
              var buf = this.charBuffer;
              var enc = this.encoding;
              res += buf.slice(0, cr).toString(enc);
            }
            return res;
          };
          function passThroughWrite(buffer) {
            return buffer.toString(this.encoding);
          }
          function utf16DetectIncompleteChar(buffer) {
            this.charReceived = buffer.length % 2;
            this.charLength = this.charReceived ? 2 : 0;
          }
          function base64DetectIncompleteChar(buffer) {
            this.charReceived = buffer.length % 3;
            this.charLength = this.charReceived ? 3 : 0;
          }
        }, {"buffer": 4}],
        28: [function(require, module, exports) {
          exports.isatty = function() {
            return false;
          };
          function ReadStream() {
            throw new Error('tty.ReadStream is not implemented');
          }
          exports.ReadStream = ReadStream;
          function WriteStream() {
            throw new Error('tty.ReadStream is not implemented');
          }
          exports.WriteStream = WriteStream;
        }, {}],
        29: [function(require, module, exports) {
          module.exports = function isBuffer(arg) {
            return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
          };
        }, {}],
        30: [function(require, module, exports) {
          (function(process, global) {
            var formatRegExp = /%[sdj%]/g;
            exports.format = function(f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
              }
              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%')
                  return '%';
                if (i >= len)
                  return x;
                switch (x) {
                  case '%s':
                    return String(args[i++]);
                  case '%d':
                    return Number(args[i++]);
                  case '%j':
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return '[Circular]';
                    }
                  default:
                    return x;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += ' ' + x;
                } else {
                  str += ' ' + inspect(x);
                }
              }
              return str;
            };
            exports.deprecate = function(fn, msg) {
              if (isUndefined(global.process)) {
                return function() {
                  return exports.deprecate(fn, msg).apply(this, arguments);
                };
              }
              if (process.noDeprecation === true) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnviron;
            exports.debuglog = function(set) {
              if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || '';
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                  var pid = process.pid;
                  debugs[set] = function() {
                    var msg = exports.format.apply(exports, arguments);
                    console.error('%s %d: %s', set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {};
                }
              }
              return debugs[set];
            };
            function inspect(obj, opts) {
              var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
              if (arguments.length >= 3)
                ctx.depth = arguments[2];
              if (arguments.length >= 4)
                ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports._extend(ctx, opts);
              }
              if (isUndefined(ctx.showHidden))
                ctx.showHidden = false;
              if (isUndefined(ctx.depth))
                ctx.depth = 2;
              if (isUndefined(ctx.colors))
                ctx.colors = false;
              if (isUndefined(ctx.customInspect))
                ctx.customInspect = true;
              if (ctx.colors)
                ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports.inspect = inspect;
            inspect.colors = {
              'bold': [1, 22],
              'italic': [3, 23],
              'underline': [4, 24],
              'inverse': [7, 27],
              'white': [37, 39],
              'grey': [90, 39],
              'black': [30, 39],
              'blue': [34, 39],
              'cyan': [36, 39],
              'green': [32, 39],
              'magenta': [35, 39],
              'red': [31, 39],
              'yellow': [33, 39]
            };
            inspect.styles = {
              'special': 'cyan',
              'number': 'yellow',
              'boolean': 'yellow',
              'undefined': 'grey',
              'null': 'bold',
              'string': 'green',
              'date': 'magenta',
              'regexp': 'red'
            };
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash = {};
              array.forEach(function(val, idx) {
                hash[val] = true;
              });
              return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ': ' + value.name : '';
                  return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = '',
                  array = false,
                  braces = ['{', '}'];
              if (isArray(value)) {
                array = true;
                braces = ['[', ']'];
              }
              if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
              }
              if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
              }
              if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = ' ' + formatError(value);
              }
              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                  return ctx.stylize('[Object]', 'special');
                }
              }
              ctx.seen.push(value);
              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
              if (isString(value)) {
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');
              }
              if (isNumber(value))
                return ctx.stylize('' + value, 'number');
              if (isBoolean(value))
                return ctx.stylize('' + value, 'boolean');
              if (isNull(value))
                return ctx.stylize('null', 'null');
            }
            function formatError(value) {
              return '[' + Error.prototype.toString.call(value) + ']';
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0,
                  l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                } else {
                  output.push('');
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                }
              });
              return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name,
                  str,
                  desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                  str = ctx.stylize('[Getter]', 'special');
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize('[Setter]', 'special');
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf('\n') > -1) {
                    if (array) {
                      str = str.split('\n').map(function(line) {
                        return '  ' + line;
                      }).join('\n').substr(2);
                    } else {
                      str = '\n' + str.split('\n').map(function(line) {
                        return '   ' + line;
                      }).join('\n');
                    }
                  }
                } else {
                  str = ctx.stylize('[Circular]', 'special');
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, 'name');
                } else {
                  name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, 'string');
                }
              }
              return name + ': ' + str;
            }
            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0)
                  numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
              }, 0);
              if (length > 60) {
                return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
              }
              return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
            }
            function isArray(ar) {
              return Array.isArray(ar);
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
              return typeof arg === 'boolean';
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
              return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === 'number';
            }
            exports.isNumber = isNumber;
            function isString(arg) {
              return typeof arg === 'string';
            }
            exports.isString = isString;
            function isSymbol(arg) {
              return typeof arg === 'symbol';
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
              return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
              return isObject(re) && objectToString(re) === '[object RegExp]';
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
              return typeof arg === 'object' && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
              return isObject(d) && objectToString(d) === '[object Date]';
            }
            exports.isDate = isDate;
            function isError(e) {
              return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
            }
            exports.isError = isError;
            function isFunction(arg) {
              return typeof arg === 'function';
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
              return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
            }
            exports.isPrimitive = isPrimitive;
            exports.isBuffer = require('./support/isBuffer');
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
            function pad(n) {
              return n < 10 ? '0' + n.toString(10) : n.toString(10);
            }
            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            function timestamp() {
              var d = new Date();
              var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
              return [d.getDate(), months[d.getMonth()], time].join(' ');
            }
            exports.log = function() {
              console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
            };
            exports.inherits = require('inherits');
            exports._extend = function(origin, add) {
              if (!add || !isObject(add))
                return origin;
              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            };
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
          }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {
          "./support/isBuffer": 29,
          "_process": 12,
          "inherits": 9
        }],
        31: [function(require, module, exports) {
          (function(global) {
            "use strict";
            require("./node");
            var transform = module.exports = require("../transformation");
            transform.options = require("../transformation/file/options");
            transform.version = require("../../package").version;
            transform.transform = transform;
            transform.run = function(code) {
              var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              opts.sourceMaps = "inline";
              return new Function(transform(code, opts).code)();
            };
            transform.load = function(url, callback, opts, hold) {
              if (opts === undefined)
                opts = {};
              opts.filename = opts.filename || url;
              var xhr = global.ActiveXObject ? new global.ActiveXObject("Microsoft.XMLHTTP") : new global.XMLHttpRequest();
              xhr.open("GET", url, true);
              if ("overrideMimeType" in xhr)
                xhr.overrideMimeType("text/plain");
              xhr.onreadystatechange = function() {
                if (xhr.readyState !== 4)
                  return;
                var status = xhr.status;
                if (status === 0 || status === 200) {
                  var param = [xhr.responseText, opts];
                  if (!hold)
                    transform.run.apply(transform, param);
                  if (callback)
                    callback(param);
                } else {
                  throw new Error("Could not load " + url);
                }
              };
              xhr.send(null);
            };
            var runScripts = function runScripts() {
              var scripts = [];
              var types = ["text/ecmascript-6", "text/6to5", "text/babel", "module"];
              var index = 0;
              var exec = function exec() {
                var param = scripts[index];
                if (param instanceof Array) {
                  transform.run.apply(transform, param);
                  index++;
                  exec();
                }
              };
              var run = function run(script, i) {
                var opts = {};
                if (script.src) {
                  transform.load(script.src, function(param) {
                    scripts[i] = param;
                    exec();
                  }, opts, true);
                } else {
                  opts.filename = "embedded";
                  scripts[i] = [script.innerHTML, opts];
                }
              };
              var _scripts = global.document.getElementsByTagName("script");
              for (var i = 0; i < _scripts.length; ++i) {
                var _script = _scripts[i];
                if (types.indexOf(_script.type) >= 0)
                  scripts.push(_script);
              }
              for (i in scripts) {
                run(scripts[i], i);
              }
              exec();
            };
            if (global.addEventListener) {
              global.addEventListener("DOMContentLoaded", runScripts, false);
            } else if (global.attachEvent) {
              global.attachEvent("onload", runScripts);
            }
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {
          "../../package": 622,
          "../transformation": 83,
          "../transformation/file/options": 66,
          "./node": 32
        }],
        32: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.register = register;
          exports.polyfill = polyfill;
          exports.transformFile = transformFile;
          exports.transformFileSync = transformFileSync;
          exports.parse = parse;
          function _interopRequire(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashLangIsFunction = require("lodash/lang/isFunction");
          var _lodashLangIsFunction2 = _interopRequireDefault(_lodashLangIsFunction);
          var _transformation = require("../transformation");
          var _transformation2 = _interopRequireDefault(_transformation);
          var _babylon = require("babylon");
          var babylon = _interopRequireWildcard(_babylon);
          var _util = require("../util");
          var util = _interopRequireWildcard(_util);
          var _fs = require("fs");
          var _fs2 = _interopRequireDefault(_fs);
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          exports.util = util;
          exports.acorn = babylon;
          exports.transform = _transformation2["default"];
          exports.pipeline = _transformation.pipeline;
          exports.canCompile = _util.canCompile;
          var _transformationFile = require("../transformation/file");
          exports.File = _interopRequire(_transformationFile);
          var _transformationFileOptionsConfig = require("../transformation/file/options/config");
          exports.options = _interopRequire(_transformationFileOptionsConfig);
          var _transformationPlugin = require("../transformation/plugin");
          exports.Plugin = _interopRequire(_transformationPlugin);
          var _transformationTransformer = require("../transformation/transformer");
          exports.Transformer = _interopRequire(_transformationTransformer);
          var _transformationPipeline = require("../transformation/pipeline");
          exports.Pipeline = _interopRequire(_transformationPipeline);
          var _traversal = require("../traversal");
          exports.traverse = _interopRequire(_traversal);
          var _toolsBuildExternalHelpers = require("../tools/build-external-helpers");
          exports.buildExternalHelpers = _interopRequire(_toolsBuildExternalHelpers);
          var _package = require("../../package");
          exports.version = _package.version;
          exports.types = t;
          function register(opts) {
            var callback = require("./register/node-polyfill");
            if (opts != null)
              callback(opts);
            return callback;
          }
          function polyfill() {
            require("../polyfill");
          }
          function transformFile(filename, opts, callback) {
            if (_lodashLangIsFunction2["default"](opts)) {
              callback = opts;
              opts = {};
            }
            opts.filename = filename;
            _fs2["default"].readFile(filename, function(err, code) {
              if (err)
                return callback(err);
              var result;
              try {
                result = _transformation2["default"](code, opts);
              } catch (err) {
                return callback(err);
              }
              callback(null, result);
            });
          }
          function transformFileSync(filename) {
            var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            opts.filename = filename;
            return _transformation2["default"](_fs2["default"].readFileSync(filename, "utf8"), opts);
          }
          function parse(code) {
            var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            opts.allowHashBang = true;
            opts.sourceType = "module";
            opts.ecmaVersion = Infinity;
            opts.plugins = {
              jsx: true,
              flow: true
            };
            opts.features = {};
            for (var key in _transformation2["default"].pipeline.transformers) {
              opts.features[key] = true;
            }
            var ast = babylon.parse(code, opts);
            if (opts.onToken) {
              var _opts$onToken;
              (_opts$onToken = opts.onToken).push.apply(_opts$onToken, ast.tokens);
            }
            if (opts.onComment) {
              var _opts$onComment;
              (_opts$onComment = opts.onComment).push.apply(_opts$onComment, ast.comments);
            }
            return ast.program;
          }
        }, {
          "../../package": 622,
          "../polyfill": 61,
          "../tools/build-external-helpers": 62,
          "../transformation": 83,
          "../transformation/file": 63,
          "../transformation/file/options/config": 65,
          "../transformation/pipeline": 97,
          "../transformation/plugin": 99,
          "../transformation/transformer": 100,
          "../traversal": 165,
          "../types": 196,
          "../util": 199,
          "./register/node-polyfill": 34,
          "babylon": 624,
          "fs": 1,
          "lodash/lang/isFunction": 517
        }],
        33: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          require("../../polyfill");
          exports["default"] = function() {};
          module.exports = exports["default"];
        }, {"../../polyfill": 61}],
        34: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequire(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
          }
          require("../../polyfill");
          var _node = require("./node");
          exports["default"] = _interopRequire(_node);
          module.exports = exports["default"];
        }, {
          "../../polyfill": 61,
          "./node": 33
        }],
        35: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _repeating = require("repeating");
          var _repeating2 = _interopRequireDefault(_repeating);
          var _trimRight = require("trim-right");
          var _trimRight2 = _interopRequireDefault(_trimRight);
          var _lodashLangIsBoolean = require("lodash/lang/isBoolean");
          var _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);
          var _lodashCollectionIncludes = require("lodash/collection/includes");
          var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
          var _lodashLangIsNumber = require("lodash/lang/isNumber");
          var _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);
          var Buffer = (function() {
            function Buffer(position, format) {
              _classCallCheck(this, Buffer);
              this.parenPushNewlineState = null;
              this.position = position;
              this._indent = format.indent.base;
              this.format = format;
              this.buf = "";
            }
            Buffer.prototype.get = function get() {
              return _trimRight2["default"](this.buf);
            };
            Buffer.prototype.getIndent = function getIndent() {
              if (this.format.compact || this.format.concise) {
                return "";
              } else {
                return _repeating2["default"](this.format.indent.style, this._indent);
              }
            };
            Buffer.prototype.indentSize = function indentSize() {
              return this.getIndent().length;
            };
            Buffer.prototype.indent = function indent() {
              this._indent++;
            };
            Buffer.prototype.dedent = function dedent() {
              this._indent--;
            };
            Buffer.prototype.semicolon = function semicolon() {
              this.push(";");
            };
            Buffer.prototype.ensureSemicolon = function ensureSemicolon() {
              if (!this.isLast(";"))
                this.semicolon();
            };
            Buffer.prototype.rightBrace = function rightBrace() {
              this.newline(true);
              this.push("}");
            };
            Buffer.prototype.keyword = function keyword(name) {
              this.push(name);
              this.space();
            };
            Buffer.prototype.space = function space(force) {
              if (!force && this.format.compact)
                return;
              if (force || this.buf && !this.isLast(" ") && !this.isLast("\n")) {
                this.push(" ");
              }
            };
            Buffer.prototype.removeLast = function removeLast(cha) {
              if (this.format.compact)
                return;
              if (!this.isLast(cha))
                return;
              this.buf = this.buf.substr(0, this.buf.length - 1);
              this.position.unshift(cha);
            };
            Buffer.prototype.startTerminatorless = function startTerminatorless() {
              return this.parenPushNewlineState = {printed: false};
            };
            Buffer.prototype.endTerminatorless = function endTerminatorless(state) {
              if (state.printed) {
                this.dedent();
                this.newline();
                this.push(")");
              }
            };
            Buffer.prototype.newline = function newline(i, removeLast) {
              if (this.format.compact || this.format.retainLines)
                return;
              if (this.format.concise) {
                this.space();
                return;
              }
              removeLast = removeLast || false;
              if (_lodashLangIsNumber2["default"](i)) {
                i = Math.min(2, i);
                if (this.endsWith("{\n") || this.endsWith(":\n"))
                  i--;
                if (i <= 0)
                  return;
                while (i > 0) {
                  this._newline(removeLast);
                  i--;
                }
                return;
              }
              if (_lodashLangIsBoolean2["default"](i)) {
                removeLast = i;
              }
              this._newline(removeLast);
            };
            Buffer.prototype._newline = function _newline(removeLast) {
              if (this.endsWith("\n\n"))
                return;
              if (removeLast && this.isLast("\n"))
                this.removeLast("\n");
              this.removeLast(" ");
              this._removeSpacesAfterLastNewline();
              this._push("\n");
            };
            Buffer.prototype._removeSpacesAfterLastNewline = function _removeSpacesAfterLastNewline() {
              var lastNewlineIndex = this.buf.lastIndexOf("\n");
              if (lastNewlineIndex === -1) {
                return;
              }
              var index = this.buf.length - 1;
              while (index > lastNewlineIndex) {
                if (this.buf[index] !== " ") {
                  break;
                }
                index--;
              }
              if (index === lastNewlineIndex) {
                this.buf = this.buf.substring(0, index + 1);
              }
            };
            Buffer.prototype.push = function push(str, noIndent) {
              if (!this.format.compact && this._indent && !noIndent && str !== "\n") {
                var indent = this.getIndent();
                str = str.replace(/\n/g, "\n" + indent);
                if (this.isLast("\n"))
                  this._push(indent);
              }
              this._push(str);
            };
            Buffer.prototype._push = function _push(str) {
              var parenPushNewlineState = this.parenPushNewlineState;
              if (parenPushNewlineState) {
                for (var i = 0; i < str.length; i++) {
                  var cha = str[i];
                  if (cha === " ")
                    continue;
                  this.parenPushNewlineState = null;
                  if (cha === "\n" || cha === "/") {
                    this._push("(");
                    this.indent();
                    parenPushNewlineState.printed = true;
                  }
                  break;
                }
              }
              this.position.push(str);
              this.buf += str;
            };
            Buffer.prototype.endsWith = function endsWith(str) {
              var buf = arguments.length <= 1 || arguments[1] === undefined ? this.buf : arguments[1];
              if (str.length === 1) {
                return buf[buf.length - 1] === str;
              } else {
                return buf.slice(-str.length) === str;
              }
            };
            Buffer.prototype.isLast = function isLast(cha) {
              if (this.format.compact)
                return false;
              var buf = this.buf;
              var last = buf[buf.length - 1];
              if (Array.isArray(cha)) {
                return _lodashCollectionIncludes2["default"](cha, last);
              } else {
                return cha === last;
              }
            };
            return Buffer;
          })();
          exports["default"] = Buffer;
          module.exports = exports["default"];
        }, {
          "lodash/collection/includes": 430,
          "lodash/lang/isBoolean": 515,
          "lodash/lang/isNumber": 519,
          "repeating": 602,
          "trim-right": 620
        }],
        36: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.File = File;
          exports.Program = Program;
          exports.BlockStatement = BlockStatement;
          exports.Noop = Noop;
          function File(node, print) {
            print.plain(node.program);
          }
          function Program(node, print) {
            print.sequence(node.body);
          }
          function BlockStatement(node, print) {
            this.push("{");
            if (node.body.length) {
              this.newline();
              print.sequence(node.body, {indent: true});
              if (!this.format.retainLines)
                this.removeLast("\n");
              this.rightBrace();
            } else {
              print.printInnerComments();
              this.push("}");
            }
          }
          function Noop() {}
        }, {}],
        37: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.ClassDeclaration = ClassDeclaration;
          exports.ClassBody = ClassBody;
          exports.ClassProperty = ClassProperty;
          exports.MethodDefinition = MethodDefinition;
          function ClassDeclaration(node, print) {
            print.list(node.decorators, {separator: ""});
            this.push("class");
            if (node.id) {
              this.push(" ");
              print.plain(node.id);
            }
            print.plain(node.typeParameters);
            if (node.superClass) {
              this.push(" extends ");
              print.plain(node.superClass);
              print.plain(node.superTypeParameters);
            }
            if (node["implements"]) {
              this.push(" implements ");
              print.join(node["implements"], {separator: ", "});
            }
            this.space();
            print.plain(node.body);
          }
          exports.ClassExpression = ClassDeclaration;
          function ClassBody(node, print) {
            this.push("{");
            if (node.body.length === 0) {
              print.printInnerComments();
              this.push("}");
            } else {
              this.newline();
              this.indent();
              print.sequence(node.body);
              this.dedent();
              this.rightBrace();
            }
          }
          function ClassProperty(node, print) {
            print.list(node.decorators, {separator: ""});
            if (node["static"])
              this.push("static ");
            print.plain(node.key);
            print.plain(node.typeAnnotation);
            if (node.value) {
              this.space();
              this.push("=");
              this.space();
              print.plain(node.value);
            }
            this.semicolon();
          }
          function MethodDefinition(node, print) {
            print.list(node.decorators, {separator: ""});
            if (node["static"]) {
              this.push("static ");
            }
            this._method(node, print);
          }
        }, {}],
        38: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.ComprehensionBlock = ComprehensionBlock;
          exports.ComprehensionExpression = ComprehensionExpression;
          function ComprehensionBlock(node, print) {
            this.keyword("for");
            this.push("(");
            print.plain(node.left);
            this.push(" of ");
            print.plain(node.right);
            this.push(")");
          }
          function ComprehensionExpression(node, print) {
            this.push(node.generator ? "(" : "[");
            print.join(node.blocks, {separator: " "});
            this.space();
            if (node.filter) {
              this.keyword("if");
              this.push("(");
              print.plain(node.filter);
              this.push(")");
              this.space();
            }
            print.plain(node.body);
            this.push(node.generator ? ")" : "]");
          }
        }, {}],
        39: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.UnaryExpression = UnaryExpression;
          exports.DoExpression = DoExpression;
          exports.ParenthesizedExpression = ParenthesizedExpression;
          exports.UpdateExpression = UpdateExpression;
          exports.ConditionalExpression = ConditionalExpression;
          exports.NewExpression = NewExpression;
          exports.SequenceExpression = SequenceExpression;
          exports.ThisExpression = ThisExpression;
          exports.Super = Super;
          exports.Decorator = Decorator;
          exports.CallExpression = CallExpression;
          exports.EmptyStatement = EmptyStatement;
          exports.ExpressionStatement = ExpressionStatement;
          exports.AssignmentPattern = AssignmentPattern;
          exports.AssignmentExpression = AssignmentExpression;
          exports.BindExpression = BindExpression;
          exports.MemberExpression = MemberExpression;
          exports.MetaProperty = MetaProperty;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _isInteger = require("is-integer");
          var _isInteger2 = _interopRequireDefault(_isInteger);
          var _lodashLangIsNumber = require("lodash/lang/isNumber");
          var _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var SCIENTIFIC_NOTATION = /e/i;
          function UnaryExpression(node, print) {
            var needsSpace = /[a-z]$/.test(node.operator);
            var arg = node.argument;
            if (t.isUpdateExpression(arg) || t.isUnaryExpression(arg)) {
              needsSpace = true;
            }
            if (t.isUnaryExpression(arg) && arg.operator === "!") {
              needsSpace = false;
            }
            this.push(node.operator);
            if (needsSpace)
              this.push(" ");
            print.plain(node.argument);
          }
          function DoExpression(node, print) {
            this.push("do");
            this.space();
            print.plain(node.body);
          }
          function ParenthesizedExpression(node, print) {
            this.push("(");
            print.plain(node.expression);
            this.push(")");
          }
          function UpdateExpression(node, print) {
            if (node.prefix) {
              this.push(node.operator);
              print.plain(node.argument);
            } else {
              print.plain(node.argument);
              this.push(node.operator);
            }
          }
          function ConditionalExpression(node, print) {
            print.plain(node.test);
            this.space();
            this.push("?");
            this.space();
            print.plain(node.consequent);
            this.space();
            this.push(":");
            this.space();
            print.plain(node.alternate);
          }
          function NewExpression(node, print) {
            this.push("new ");
            print.plain(node.callee);
            this.push("(");
            print.list(node.arguments);
            this.push(")");
          }
          function SequenceExpression(node, print) {
            print.list(node.expressions);
          }
          function ThisExpression() {
            this.push("this");
          }
          function Super() {
            this.push("super");
          }
          function Decorator(node, print) {
            this.push("@");
            print.plain(node.expression);
            this.newline();
          }
          function CallExpression(node, print) {
            print.plain(node.callee);
            this.push("(");
            var isPrettyCall = node._prettyCall && !this.format.retainLines && !this.format.compact;
            var separator;
            if (isPrettyCall) {
              separator = ",\n";
              this.newline();
              this.indent();
            }
            print.list(node.arguments, {separator: separator});
            if (isPrettyCall) {
              this.newline();
              this.dedent();
            }
            this.push(")");
          }
          var buildYieldAwait = function buildYieldAwait(keyword) {
            return function(node, print) {
              this.push(keyword);
              if (node.delegate || node.all) {
                this.push("*");
              }
              if (node.argument) {
                this.push(" ");
                var terminatorState = this.startTerminatorless();
                print.plain(node.argument);
                this.endTerminatorless(terminatorState);
              }
            };
          };
          var YieldExpression = buildYieldAwait("yield");
          exports.YieldExpression = YieldExpression;
          var AwaitExpression = buildYieldAwait("await");
          exports.AwaitExpression = AwaitExpression;
          function EmptyStatement() {
            this.semicolon();
          }
          function ExpressionStatement(node, print) {
            print.plain(node.expression);
            this.semicolon();
          }
          function AssignmentPattern(node, print) {
            print.plain(node.left);
            this.push(" = ");
            print.plain(node.right);
          }
          function AssignmentExpression(node, print) {
            print.plain(node.left);
            var spaces = node.operator === "in" || node.operator === "instanceof";
            spaces = true;
            this.space(spaces);
            this.push(node.operator);
            if (!spaces) {
              spaces = node.operator === "<" && t.isUnaryExpression(node.right, {
                prefix: true,
                operator: "!"
              }) && t.isUnaryExpression(node.right.argument, {
                prefix: true,
                operator: "--"
              });
            }
            this.space(spaces);
            print.plain(node.right);
          }
          function BindExpression(node, print) {
            print.plain(node.object);
            this.push("::");
            print.plain(node.callee);
          }
          exports.BinaryExpression = AssignmentExpression;
          exports.LogicalExpression = AssignmentExpression;
          function MemberExpression(node, print) {
            var obj = node.object;
            print.plain(obj);
            if (!node.computed && t.isMemberExpression(node.property)) {
              throw new TypeError("Got a MemberExpression for MemberExpression property");
            }
            var computed = node.computed;
            if (t.isLiteral(node.property) && _lodashLangIsNumber2["default"](node.property.value)) {
              computed = true;
            }
            if (computed) {
              this.push("[");
              print.plain(node.property);
              this.push("]");
            } else {
              if (t.isLiteral(node.object)) {
                var val = this._Literal(node.object);
                if (_isInteger2["default"](+val) && !SCIENTIFIC_NOTATION.test(val) && !this.endsWith(".")) {
                  this.push(".");
                }
              }
              this.push(".");
              print.plain(node.property);
            }
          }
          function MetaProperty(node, print) {
            print.plain(node.meta);
            this.push(".");
            print.plain(node.property);
          }
        }, {
          "../../types": 196,
          "is-integer": 415,
          "lodash/lang/isNumber": 519
        }],
        40: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.AnyTypeAnnotation = AnyTypeAnnotation;
          exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
          exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
          exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
          exports.DeclareClass = DeclareClass;
          exports.DeclareFunction = DeclareFunction;
          exports.DeclareModule = DeclareModule;
          exports.DeclareVariable = DeclareVariable;
          exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
          exports.FunctionTypeParam = FunctionTypeParam;
          exports.InterfaceExtends = InterfaceExtends;
          exports._interfaceish = _interfaceish;
          exports.InterfaceDeclaration = InterfaceDeclaration;
          exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
          exports.MixedTypeAnnotation = MixedTypeAnnotation;
          exports.NullableTypeAnnotation = NullableTypeAnnotation;
          exports.NumberTypeAnnotation = NumberTypeAnnotation;
          exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;
          exports.StringTypeAnnotation = StringTypeAnnotation;
          exports.TupleTypeAnnotation = TupleTypeAnnotation;
          exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
          exports.TypeAlias = TypeAlias;
          exports.TypeAnnotation = TypeAnnotation;
          exports.TypeParameterInstantiation = TypeParameterInstantiation;
          exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
          exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
          exports.ObjectTypeIndexer = ObjectTypeIndexer;
          exports.ObjectTypeProperty = ObjectTypeProperty;
          exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
          exports.UnionTypeAnnotation = UnionTypeAnnotation;
          exports.TypeCastExpression = TypeCastExpression;
          exports.VoidTypeAnnotation = VoidTypeAnnotation;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function AnyTypeAnnotation() {
            this.push("any");
          }
          function ArrayTypeAnnotation(node, print) {
            print.plain(node.elementType);
            this.push("[");
            this.push("]");
          }
          function BooleanTypeAnnotation() {
            this.push("bool");
          }
          function BooleanLiteralTypeAnnotation(node) {
            this.push(node.value ? "true" : "false");
          }
          function DeclareClass(node, print) {
            this.push("declare class ");
            this._interfaceish(node, print);
          }
          function DeclareFunction(node, print) {
            this.push("declare function ");
            print.plain(node.id);
            print.plain(node.id.typeAnnotation.typeAnnotation);
            this.semicolon();
          }
          function DeclareModule(node, print) {
            this.push("declare module ");
            print.plain(node.id);
            this.space();
            print.plain(node.body);
          }
          function DeclareVariable(node, print) {
            this.push("declare var ");
            print.plain(node.id);
            print.plain(node.id.typeAnnotation);
            this.semicolon();
          }
          function FunctionTypeAnnotation(node, print, parent) {
            print.plain(node.typeParameters);
            this.push("(");
            print.list(node.params);
            if (node.rest) {
              if (node.params.length) {
                this.push(",");
                this.space();
              }
              this.push("...");
              print.plain(node.rest);
            }
            this.push(")");
            if (parent.type === "ObjectTypeProperty" || parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction") {
              this.push(":");
            } else {
              this.space();
              this.push("=>");
            }
            this.space();
            print.plain(node.returnType);
          }
          function FunctionTypeParam(node, print) {
            print.plain(node.name);
            if (node.optional)
              this.push("?");
            this.push(":");
            this.space();
            print.plain(node.typeAnnotation);
          }
          function InterfaceExtends(node, print) {
            print.plain(node.id);
            print.plain(node.typeParameters);
          }
          exports.ClassImplements = InterfaceExtends;
          exports.GenericTypeAnnotation = InterfaceExtends;
          function _interfaceish(node, print) {
            print.plain(node.id);
            print.plain(node.typeParameters);
            if (node["extends"].length) {
              this.push(" extends ");
              print.join(node["extends"], {separator: ", "});
            }
            this.space();
            print.plain(node.body);
          }
          function InterfaceDeclaration(node, print) {
            this.push("interface ");
            this._interfaceish(node, print);
          }
          function IntersectionTypeAnnotation(node, print) {
            print.join(node.types, {separator: " & "});
          }
          function MixedTypeAnnotation() {
            this.push("mixed");
          }
          function NullableTypeAnnotation(node, print) {
            this.push("?");
            print.plain(node.typeAnnotation);
          }
          var _types2 = require("./types");
          exports.NumberLiteralTypeAnnotation = _types2.Literal;
          function NumberTypeAnnotation() {
            this.push("number");
          }
          function StringLiteralTypeAnnotation(node) {
            this.push(this._stringLiteral(node.value));
          }
          function StringTypeAnnotation() {
            this.push("string");
          }
          function TupleTypeAnnotation(node, print) {
            this.push("[");
            print.join(node.types, {separator: ", "});
            this.push("]");
          }
          function TypeofTypeAnnotation(node, print) {
            this.push("typeof ");
            print.plain(node.argument);
          }
          function TypeAlias(node, print) {
            this.push("type ");
            print.plain(node.id);
            print.plain(node.typeParameters);
            this.space();
            this.push("=");
            this.space();
            print.plain(node.right);
            this.semicolon();
          }
          function TypeAnnotation(node, print) {
            this.push(":");
            this.space();
            if (node.optional)
              this.push("?");
            print.plain(node.typeAnnotation);
          }
          function TypeParameterInstantiation(node, print) {
            this.push("<");
            print.join(node.params, {
              separator: ", ",
              iterator: function iterator(node) {
                print.plain(node.typeAnnotation);
              }
            });
            this.push(">");
          }
          exports.TypeParameterDeclaration = TypeParameterInstantiation;
          function ObjectTypeAnnotation(node, print) {
            var _this = this;
            this.push("{");
            var props = node.properties.concat(node.callProperties, node.indexers);
            if (props.length) {
              this.space();
              print.list(props, {
                separator: false,
                indent: true,
                iterator: function iterator() {
                  if (props.length !== 1) {
                    _this.semicolon();
                    _this.space();
                  }
                }
              });
              this.space();
            }
            this.push("}");
          }
          function ObjectTypeCallProperty(node, print) {
            if (node["static"])
              this.push("static ");
            print.plain(node.value);
          }
          function ObjectTypeIndexer(node, print) {
            if (node["static"])
              this.push("static ");
            this.push("[");
            print.plain(node.id);
            this.push(":");
            this.space();
            print.plain(node.key);
            this.push("]");
            this.push(":");
            this.space();
            print.plain(node.value);
          }
          function ObjectTypeProperty(node, print) {
            if (node["static"])
              this.push("static ");
            print.plain(node.key);
            if (node.optional)
              this.push("?");
            if (!t.isFunctionTypeAnnotation(node.value)) {
              this.push(":");
              this.space();
            }
            print.plain(node.value);
          }
          function QualifiedTypeIdentifier(node, print) {
            print.plain(node.qualification);
            this.push(".");
            print.plain(node.id);
          }
          function UnionTypeAnnotation(node, print) {
            print.join(node.types, {separator: " | "});
          }
          function TypeCastExpression(node, print) {
            this.push("(");
            print.plain(node.expression);
            print.plain(node.typeAnnotation);
            this.push(")");
          }
          function VoidTypeAnnotation() {
            this.push("void");
          }
        }, {
          "../../types": 196,
          "./types": 46
        }],
        41: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.JSXAttribute = JSXAttribute;
          exports.JSXIdentifier = JSXIdentifier;
          exports.JSXNamespacedName = JSXNamespacedName;
          exports.JSXMemberExpression = JSXMemberExpression;
          exports.JSXSpreadAttribute = JSXSpreadAttribute;
          exports.JSXExpressionContainer = JSXExpressionContainer;
          exports.JSXElement = JSXElement;
          exports.JSXOpeningElement = JSXOpeningElement;
          exports.JSXClosingElement = JSXClosingElement;
          exports.JSXEmptyExpression = JSXEmptyExpression;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function JSXAttribute(node, print) {
            print.plain(node.name);
            if (node.value) {
              this.push("=");
              print.plain(node.value);
            }
          }
          function JSXIdentifier(node) {
            this.push(node.name);
          }
          function JSXNamespacedName(node, print) {
            print.plain(node.namespace);
            this.push(":");
            print.plain(node.name);
          }
          function JSXMemberExpression(node, print) {
            print.plain(node.object);
            this.push(".");
            print.plain(node.property);
          }
          function JSXSpreadAttribute(node, print) {
            this.push("{...");
            print.plain(node.argument);
            this.push("}");
          }
          function JSXExpressionContainer(node, print) {
            this.push("{");
            print.plain(node.expression);
            this.push("}");
          }
          function JSXElement(node, print) {
            var open = node.openingElement;
            print.plain(open);
            if (open.selfClosing)
              return;
            this.indent();
            var _arr = node.children;
            for (var _i = 0; _i < _arr.length; _i++) {
              var child = _arr[_i];
              if (t.isLiteral(child)) {
                this.push(child.value, true);
              } else {
                print.plain(child);
              }
            }
            this.dedent();
            print.plain(node.closingElement);
          }
          function JSXOpeningElement(node, print) {
            this.push("<");
            print.plain(node.name);
            if (node.attributes.length > 0) {
              this.push(" ");
              print.join(node.attributes, {separator: " "});
            }
            this.push(node.selfClosing ? " />" : ">");
          }
          function JSXClosingElement(node, print) {
            this.push("</");
            print.plain(node.name);
            this.push(">");
          }
          function JSXEmptyExpression() {}
        }, {"../../types": 196}],
        42: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports._params = _params;
          exports._method = _method;
          exports.FunctionExpression = FunctionExpression;
          exports.ArrowFunctionExpression = ArrowFunctionExpression;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function _params(node, print) {
            var _this = this;
            print.plain(node.typeParameters);
            this.push("(");
            print.list(node.params, {iterator: function iterator(node) {
                if (node.optional)
                  _this.push("?");
                print.plain(node.typeAnnotation);
              }});
            this.push(")");
            if (node.returnType) {
              print.plain(node.returnType);
            }
          }
          function _method(node, print) {
            var value = node.value;
            var kind = node.kind;
            var key = node.key;
            if (kind === "method" || kind === "init") {
              if (value.generator) {
                this.push("*");
              }
            }
            if (kind === "get" || kind === "set") {
              this.push(kind + " ");
            }
            if (value.async)
              this.push("async ");
            if (node.computed) {
              this.push("[");
              print.plain(key);
              this.push("]");
            } else {
              print.plain(key);
            }
            this._params(value, print);
            this.space();
            print.plain(value.body);
          }
          function FunctionExpression(node, print) {
            if (node.async)
              this.push("async ");
            this.push("function");
            if (node.generator)
              this.push("*");
            if (node.id) {
              this.push(" ");
              print.plain(node.id);
            } else {
              this.space();
            }
            this._params(node, print);
            this.space();
            print.plain(node.body);
          }
          exports.FunctionDeclaration = FunctionExpression;
          function ArrowFunctionExpression(node, print) {
            if (node.async)
              this.push("async ");
            if (node.params.length === 1 && t.isIdentifier(node.params[0])) {
              print.plain(node.params[0]);
            } else {
              this._params(node, print);
            }
            this.push(" => ");
            var bodyNeedsParens = t.isObjectExpression(node.body);
            if (bodyNeedsParens) {
              this.push("(");
            }
            print.plain(node.body);
            if (bodyNeedsParens) {
              this.push(")");
            }
          }
        }, {"../../types": 196}],
        43: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.ImportSpecifier = ImportSpecifier;
          exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
          exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
          exports.ExportSpecifier = ExportSpecifier;
          exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
          exports.ExportAllDeclaration = ExportAllDeclaration;
          exports.ExportNamedDeclaration = ExportNamedDeclaration;
          exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
          exports.ImportDeclaration = ImportDeclaration;
          exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function ImportSpecifier(node, print) {
            print.plain(node.imported);
            if (node.local && node.local.name !== node.imported.name) {
              this.push(" as ");
              print.plain(node.local);
            }
          }
          function ImportDefaultSpecifier(node, print) {
            print.plain(node.local);
          }
          function ExportDefaultSpecifier(node, print) {
            print.plain(node.exported);
          }
          function ExportSpecifier(node, print) {
            print.plain(node.local);
            if (node.exported && node.local.name !== node.exported.name) {
              this.push(" as ");
              print.plain(node.exported);
            }
          }
          function ExportNamespaceSpecifier(node, print) {
            this.push("* as ");
            print.plain(node.exported);
          }
          function ExportAllDeclaration(node, print) {
            this.push("export *");
            if (node.exported) {
              this.push(" as ");
              print.plain(node.exported);
            }
            this.push(" from ");
            print.plain(node.source);
            this.semicolon();
          }
          function ExportNamedDeclaration(node, print) {
            this.push("export ");
            ExportDeclaration.call(this, node, print);
          }
          function ExportDefaultDeclaration(node, print) {
            this.push("export default ");
            ExportDeclaration.call(this, node, print);
          }
          function ExportDeclaration(node, print) {
            var specifiers = node.specifiers;
            if (node.declaration) {
              var declar = node.declaration;
              print.plain(declar);
              if (t.isStatement(declar) || t.isFunction(declar) || t.isClass(declar))
                return;
            } else {
              if (node.exportKind === "type") {
                this.push("type ");
              }
              var first = specifiers[0];
              var hasSpecial = false;
              if (t.isExportDefaultSpecifier(first) || t.isExportNamespaceSpecifier(first)) {
                hasSpecial = true;
                print.plain(specifiers.shift());
                if (specifiers.length) {
                  this.push(", ");
                }
              }
              if (specifiers.length || !specifiers.length && !hasSpecial) {
                this.push("{");
                if (specifiers.length) {
                  this.space();
                  print.join(specifiers, {separator: ", "});
                  this.space();
                }
                this.push("}");
              }
              if (node.source) {
                this.push(" from ");
                print.plain(node.source);
              }
            }
            this.ensureSemicolon();
          }
          function ImportDeclaration(node, print) {
            this.push("import ");
            if (node.importKind === "type" || node.importKind === "typeof") {
              this.push(node.importKind + " ");
            }
            var specfiers = node.specifiers;
            if (specfiers && specfiers.length) {
              var first = node.specifiers[0];
              if (t.isImportDefaultSpecifier(first) || t.isImportNamespaceSpecifier(first)) {
                print.plain(node.specifiers.shift());
                if (node.specifiers.length) {
                  this.push(", ");
                }
              }
              if (node.specifiers.length) {
                this.push("{");
                this.space();
                print.join(node.specifiers, {separator: ", "});
                this.space();
                this.push("}");
              }
              this.push(" from ");
            }
            print.plain(node.source);
            this.semicolon();
          }
          function ImportNamespaceSpecifier(node, print) {
            this.push("* as ");
            print.plain(node.local);
          }
        }, {"../../types": 196}],
        44: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.WithStatement = WithStatement;
          exports.IfStatement = IfStatement;
          exports.ForStatement = ForStatement;
          exports.WhileStatement = WhileStatement;
          exports.DoWhileStatement = DoWhileStatement;
          exports.LabeledStatement = LabeledStatement;
          exports.TryStatement = TryStatement;
          exports.CatchClause = CatchClause;
          exports.SwitchStatement = SwitchStatement;
          exports.SwitchCase = SwitchCase;
          exports.DebuggerStatement = DebuggerStatement;
          exports.VariableDeclaration = VariableDeclaration;
          exports.VariableDeclarator = VariableDeclarator;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _repeating = require("repeating");
          var _repeating2 = _interopRequireDefault(_repeating);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function WithStatement(node, print) {
            this.keyword("with");
            this.push("(");
            print.plain(node.object);
            this.push(")");
            print.block(node.body);
          }
          function IfStatement(node, print) {
            this.keyword("if");
            this.push("(");
            print.plain(node.test);
            this.push(")");
            this.space();
            print.indentOnComments(node.consequent);
            if (node.alternate) {
              if (this.isLast("}"))
                this.space();
              this.push("else ");
              print.indentOnComments(node.alternate);
            }
          }
          function ForStatement(node, print) {
            this.keyword("for");
            this.push("(");
            print.plain(node.init);
            this.push(";");
            if (node.test) {
              this.space();
              print.plain(node.test);
            }
            this.push(";");
            if (node.update) {
              this.space();
              print.plain(node.update);
            }
            this.push(")");
            print.block(node.body);
          }
          function WhileStatement(node, print) {
            this.keyword("while");
            this.push("(");
            print.plain(node.test);
            this.push(")");
            print.block(node.body);
          }
          var buildForXStatement = function buildForXStatement(op) {
            return function(node, print) {
              this.keyword("for");
              this.push("(");
              print.plain(node.left);
              this.push(" " + op + " ");
              print.plain(node.right);
              this.push(")");
              print.block(node.body);
            };
          };
          var ForInStatement = buildForXStatement("in");
          exports.ForInStatement = ForInStatement;
          var ForOfStatement = buildForXStatement("of");
          exports.ForOfStatement = ForOfStatement;
          function DoWhileStatement(node, print) {
            this.push("do ");
            print.plain(node.body);
            this.space();
            this.keyword("while");
            this.push("(");
            print.plain(node.test);
            this.push(");");
          }
          var buildLabelStatement = function buildLabelStatement(prefix) {
            var key = arguments.length <= 1 || arguments[1] === undefined ? "label" : arguments[1];
            return function(node, print) {
              this.push(prefix);
              var label = node[key];
              if (label) {
                this.push(" ");
                var terminatorState = this.startTerminatorless();
                print.plain(label);
                this.endTerminatorless(terminatorState);
              }
              this.semicolon();
            };
          };
          var ContinueStatement = buildLabelStatement("continue");
          exports.ContinueStatement = ContinueStatement;
          var ReturnStatement = buildLabelStatement("return", "argument");
          exports.ReturnStatement = ReturnStatement;
          var BreakStatement = buildLabelStatement("break");
          exports.BreakStatement = BreakStatement;
          var ThrowStatement = buildLabelStatement("throw", "argument");
          exports.ThrowStatement = ThrowStatement;
          function LabeledStatement(node, print) {
            print.plain(node.label);
            this.push(": ");
            print.plain(node.body);
          }
          function TryStatement(node, print) {
            this.keyword("try");
            print.plain(node.block);
            this.space();
            if (node.handlers) {
              print.plain(node.handlers[0]);
            } else {
              print.plain(node.handler);
            }
            if (node.finalizer) {
              this.space();
              this.push("finally ");
              print.plain(node.finalizer);
            }
          }
          function CatchClause(node, print) {
            this.keyword("catch");
            this.push("(");
            print.plain(node.param);
            this.push(") ");
            print.plain(node.body);
          }
          function SwitchStatement(node, print) {
            this.keyword("switch");
            this.push("(");
            print.plain(node.discriminant);
            this.push(")");
            this.space();
            this.push("{");
            print.sequence(node.cases, {
              indent: true,
              addNewlines: function addNewlines(leading, cas) {
                if (!leading && node.cases[node.cases.length - 1] === cas)
                  return -1;
              }
            });
            this.push("}");
          }
          function SwitchCase(node, print) {
            if (node.test) {
              this.push("case ");
              print.plain(node.test);
              this.push(":");
            } else {
              this.push("default:");
            }
            if (node.consequent.length) {
              this.newline();
              print.sequence(node.consequent, {indent: true});
            }
          }
          function DebuggerStatement() {
            this.push("debugger;");
          }
          function VariableDeclaration(node, print, parent) {
            this.push(node.kind + " ");
            var hasInits = false;
            if (!t.isFor(parent)) {
              var _arr = node.declarations;
              for (var _i = 0; _i < _arr.length; _i++) {
                var declar = _arr[_i];
                if (declar.init) {
                  hasInits = true;
                }
              }
            }
            var sep;
            if (!this.format.compact && !this.format.concise && hasInits && !this.format.retainLines) {
              sep = ",\n" + _repeating2["default"](" ", node.kind.length + 1);
            }
            print.list(node.declarations, {separator: sep});
            if (t.isFor(parent)) {
              if (parent.left === node || parent.init === node)
                return;
            }
            this.semicolon();
          }
          function VariableDeclarator(node, print) {
            print.plain(node.id);
            print.plain(node.id.typeAnnotation);
            if (node.init) {
              this.space();
              this.push("=");
              this.space();
              print.plain(node.init);
            }
          }
        }, {
          "../../types": 196,
          "repeating": 602
        }],
        45: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.TaggedTemplateExpression = TaggedTemplateExpression;
          exports.TemplateElement = TemplateElement;
          exports.TemplateLiteral = TemplateLiteral;
          function TaggedTemplateExpression(node, print) {
            print.plain(node.tag);
            print.plain(node.quasi);
          }
          function TemplateElement(node) {
            this._push(node.value.raw);
          }
          function TemplateLiteral(node, print) {
            this.push("`");
            var quasis = node.quasis;
            var len = quasis.length;
            for (var i = 0; i < len; i++) {
              print.plain(quasis[i]);
              if (i + 1 < len) {
                this.push("${ ");
                print.plain(node.expressions[i]);
                this.push(" }");
              }
            }
            this._push("`");
          }
        }, {}],
        46: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.Identifier = Identifier;
          exports.RestElement = RestElement;
          exports.ObjectExpression = ObjectExpression;
          exports.Property = Property;
          exports.ArrayExpression = ArrayExpression;
          exports.Literal = Literal;
          exports._Literal = _Literal;
          exports._stringLiteral = _stringLiteral;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function Identifier(node) {
            this.push(node.name);
          }
          function RestElement(node, print) {
            this.push("...");
            print.plain(node.argument);
          }
          exports.SpreadElement = RestElement;
          exports.SpreadProperty = RestElement;
          function ObjectExpression(node, print) {
            var props = node.properties;
            this.push("{");
            print.printInnerComments();
            if (props.length) {
              this.space();
              print.list(props, {indent: true});
              this.space();
            }
            this.push("}");
          }
          exports.ObjectPattern = ObjectExpression;
          function Property(node, print) {
            print.list(node.decorators, {separator: ""});
            if (node.method || node.kind === "get" || node.kind === "set") {
              this._method(node, print);
            } else {
              if (node.computed) {
                this.push("[");
                print.plain(node.key);
                this.push("]");
              } else {
                if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) {
                  print.plain(node.value);
                  return;
                }
                print.plain(node.key);
                if (node.shorthand && (t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name)) {
                  return;
                }
              }
              this.push(":");
              this.space();
              print.plain(node.value);
            }
          }
          function ArrayExpression(node, print) {
            var elems = node.elements;
            var len = elems.length;
            this.push("[");
            print.printInnerComments();
            for (var i = 0; i < elems.length; i++) {
              var elem = elems[i];
              if (elem) {
                if (i > 0)
                  this.space();
                print.plain(elem);
                if (i < len - 1)
                  this.push(",");
              } else {
                this.push(",");
              }
            }
            this.push("]");
          }
          exports.ArrayPattern = ArrayExpression;
          function Literal(node) {
            this.push("");
            this._push(this._Literal(node));
          }
          function _Literal(node) {
            var val = node.value;
            if (node.regex) {
              return "/" + node.regex.pattern + "/" + node.regex.flags;
            }
            if (node.raw != null && node.rawValue != null && val === node.rawValue) {
              return node.raw;
            }
            switch (typeof val) {
              case "string":
                return this._stringLiteral(val);
              case "number":
                return val + "";
              case "boolean":
                return val ? "true" : "false";
              default:
                if (val === null) {
                  return "null";
                } else {
                  throw new Error("Invalid Literal type");
                }
            }
          }
          function _stringLiteral(val) {
            val = JSON.stringify(val);
            val = val.replace(/[\u000A\u000D\u2028\u2029]/g, function(c) {
              return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
            });
            if (this.format.quotes === "single") {
              val = val.slice(1, -1);
              val = val.replace(/\\"/g, '"');
              val = val.replace(/'/g, "\\'");
              val = "'" + val + "'";
            }
            return val;
          }
        }, {"../../types": 196}],
        47: [function(require, module, exports) {
          "use strict";
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _detectIndent = require("detect-indent");
          var _detectIndent2 = _interopRequireDefault(_detectIndent);
          var _whitespace = require("./whitespace");
          var _whitespace2 = _interopRequireDefault(_whitespace);
          var _nodePrinter = require("./node/printer");
          var _nodePrinter2 = _interopRequireDefault(_nodePrinter);
          var _repeating = require("repeating");
          var _repeating2 = _interopRequireDefault(_repeating);
          var _sourceMap = require("./source-map");
          var _sourceMap2 = _interopRequireDefault(_sourceMap);
          var _position = require("./position");
          var _position2 = _interopRequireDefault(_position);
          var _messages = require("../messages");
          var messages = _interopRequireWildcard(_messages);
          var _buffer = require("./buffer");
          var _buffer2 = _interopRequireDefault(_buffer);
          var _lodashObjectExtend = require("lodash/object/extend");
          var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
          var _lodashCollectionEach = require("lodash/collection/each");
          var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
          var _node2 = require("./node");
          var _node3 = _interopRequireDefault(_node2);
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          var CodeGenerator = (function() {
            function CodeGenerator(ast, opts, code) {
              _classCallCheck(this, CodeGenerator);
              opts = opts || {};
              this.comments = ast.comments || [];
              this.tokens = ast.tokens || [];
              this.format = CodeGenerator.normalizeOptions(code, opts, this.tokens);
              this.opts = opts;
              this.ast = ast;
              this.whitespace = new _whitespace2["default"](this.tokens);
              this.position = new _position2["default"]();
              this.map = new _sourceMap2["default"](this.position, opts, code);
              this.buffer = new _buffer2["default"](this.position, this.format);
            }
            CodeGenerator.normalizeOptions = function normalizeOptions(code, opts, tokens) {
              var style = "  ";
              if (code) {
                var indent = _detectIndent2["default"](code).indent;
                if (indent && indent !== " ")
                  style = indent;
              }
              var format = {
                shouldPrintComment: opts.shouldPrintComment,
                retainLines: opts.retainLines,
                comments: opts.comments == null || opts.comments,
                compact: opts.compact,
                quotes: CodeGenerator.findCommonStringDelimiter(code, tokens),
                indent: {
                  adjustMultilineComment: true,
                  style: style,
                  base: 0
                }
              };
              if (format.compact === "auto") {
                format.compact = code.length > 100000;
                if (format.compact) {
                  console.error("[BABEL] " + messages.get("codeGeneratorDeopt", opts.filename, "100KB"));
                }
              }
              if (format.compact) {
                format.indent.adjustMultilineComment = false;
              }
              return format;
            };
            CodeGenerator.findCommonStringDelimiter = function findCommonStringDelimiter(code, tokens) {
              var occurences = {
                single: 0,
                double: 0
              };
              var checked = 0;
              for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (token.type.label !== "string")
                  continue;
                var raw = code.slice(token.start, token.end);
                if (raw[0] === "'") {
                  occurences.single++;
                } else {
                  occurences.double++;
                }
                checked++;
                if (checked >= 3)
                  break;
              }
              if (occurences.single > occurences.double) {
                return "single";
              } else {
                return "double";
              }
            };
            CodeGenerator.prototype.generate = function generate() {
              var ast = this.ast;
              this.print(ast);
              if (ast.comments) {
                var comments = [];
                var _arr = ast.comments;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var comment = _arr[_i];
                  if (!comment._displayed)
                    comments.push(comment);
                }
                this._printComments(comments);
              }
              return {
                map: this.map.get(),
                code: this.buffer.get()
              };
            };
            CodeGenerator.prototype.buildPrint = function buildPrint(parent) {
              return new _nodePrinter2["default"](this, parent);
            };
            CodeGenerator.prototype.catchUp = function catchUp(node) {
              if (node.loc && this.format.retainLines && this.buffer.buf) {
                while (this.position.line < node.loc.start.line) {
                  this._push("\n");
                }
              }
            };
            CodeGenerator.prototype._printNewline = function _printNewline(leading, node, parent, opts) {
              if (!opts.statement && !_node3["default"].isUserWhitespacable(node, parent)) {
                return;
              }
              var lines = 0;
              if (node.start != null && !node._ignoreUserWhitespace) {
                if (leading) {
                  lines = this.whitespace.getNewlinesBefore(node);
                } else {
                  lines = this.whitespace.getNewlinesAfter(node);
                }
              } else {
                if (!leading)
                  lines++;
                if (opts.addNewlines)
                  lines += opts.addNewlines(leading, node) || 0;
                var needs = _node3["default"].needsWhitespaceAfter;
                if (leading)
                  needs = _node3["default"].needsWhitespaceBefore;
                if (needs(node, parent))
                  lines++;
                if (!this.buffer.buf)
                  lines = 0;
              }
              this.newline(lines);
            };
            CodeGenerator.prototype.print = function print(node, parent) {
              var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
              if (!node)
                return;
              if (parent && parent._compact) {
                node._compact = true;
              }
              var oldConcise = this.format.concise;
              if (node._compact) {
                this.format.concise = true;
              }
              if (!this[node.type]) {
                throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node && node.constructor.name));
              }
              var needsParens = _node3["default"].needsParens(node, parent);
              if (needsParens)
                this.push("(");
              this.printLeadingComments(node, parent);
              this.catchUp(node);
              this._printNewline(true, node, parent, opts);
              if (opts.before)
                opts.before();
              this.map.mark(node, "start");
              this[node.type](node, this.buildPrint(node), parent);
              if (needsParens)
                this.push(")");
              this.map.mark(node, "end");
              if (opts.after)
                opts.after();
              this.format.concise = oldConcise;
              this._printNewline(false, node, parent, opts);
              this.printTrailingComments(node, parent);
            };
            CodeGenerator.prototype.printJoin = function printJoin(print, nodes) {
              var _this = this;
              var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
              if (!nodes || !nodes.length)
                return;
              var len = nodes.length;
              if (opts.indent)
                this.indent();
              var printOpts = {
                statement: opts.statement,
                addNewlines: opts.addNewlines,
                after: function after() {
                  if (opts.iterator) {
                    opts.iterator(node, i);
                  }
                  if (opts.separator && i < len - 1) {
                    _this.push(opts.separator);
                  }
                }
              };
              for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                print.plain(node, printOpts);
              }
              if (opts.indent)
                this.dedent();
            };
            CodeGenerator.prototype.printAndIndentOnComments = function printAndIndentOnComments(print, node) {
              var indent = !!node.leadingComments;
              if (indent)
                this.indent();
              print.plain(node);
              if (indent)
                this.dedent();
            };
            CodeGenerator.prototype.printBlock = function printBlock(print, node) {
              if (t.isEmptyStatement(node)) {
                this.semicolon();
              } else {
                this.push(" ");
                print.plain(node);
              }
            };
            CodeGenerator.prototype.generateComment = function generateComment(comment) {
              var val = comment.value;
              if (comment.type === "CommentLine") {
                val = "//" + val;
              } else {
                val = "/*" + val + "*/";
              }
              return val;
            };
            CodeGenerator.prototype.printTrailingComments = function printTrailingComments(node, parent) {
              this._printComments(this.getComments("trailingComments", node, parent));
            };
            CodeGenerator.prototype.printLeadingComments = function printLeadingComments(node, parent) {
              this._printComments(this.getComments("leadingComments", node, parent));
            };
            CodeGenerator.prototype.getComments = function getComments(key, node, parent) {
              if (t.isExpressionStatement(parent)) {
                return [];
              }
              var comments = [];
              var nodes = [node];
              if (t.isExpressionStatement(node)) {
                nodes.push(node.argument);
              }
              var _arr2 = nodes;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var _node = _arr2[_i2];
                comments = comments.concat(this._getComments(key, _node));
              }
              return comments;
            };
            CodeGenerator.prototype._getComments = function _getComments(key, node) {
              return node && node[key] || [];
            };
            CodeGenerator.prototype.shouldPrintComment = function shouldPrintComment(comment) {
              if (this.format.shouldPrintComment) {
                return this.format.shouldPrintComment(comment.value);
              } else {
                if (comment.value.indexOf("@license") >= 0 || comment.value.indexOf("@preserve") >= 0) {
                  return true;
                } else {
                  return this.format.comments;
                }
              }
            };
            CodeGenerator.prototype._printComments = function _printComments(comments) {
              if (!comments || !comments.length)
                return;
              var _arr3 = comments;
              for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var comment = _arr3[_i3];
                if (!this.shouldPrintComment(comment))
                  continue;
                if (comment._displayed)
                  continue;
                comment._displayed = true;
                this.catchUp(comment);
                this.newline(this.whitespace.getNewlinesBefore(comment));
                var column = this.position.column;
                var val = this.generateComment(comment);
                if (column && !this.isLast(["\n", " ", "[", "{"])) {
                  this._push(" ");
                  column++;
                }
                if (comment.type === "CommentBlock" && this.format.indent.adjustMultilineComment) {
                  var offset = comment.loc && comment.loc.start.column;
                  if (offset) {
                    var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
                    val = val.replace(newlineRegex, "\n");
                  }
                  var indent = Math.max(this.indentSize(), column);
                  val = val.replace(/\n/g, "\n" + _repeating2["default"](" ", indent));
                }
                if (column === 0) {
                  val = this.getIndent() + val;
                }
                if ((this.format.compact || this.format.retainLines) && comment.type === "CommentLine") {
                  val += "\n";
                }
                this._push(val);
                this.newline(this.whitespace.getNewlinesAfter(comment));
              }
            };
            _createClass(CodeGenerator, null, [{
              key: "generators",
              value: {
                templateLiterals: require("./generators/template-literals"),
                comprehensions: require("./generators/comprehensions"),
                expressions: require("./generators/expressions"),
                statements: require("./generators/statements"),
                classes: require("./generators/classes"),
                methods: require("./generators/methods"),
                modules: require("./generators/modules"),
                types: require("./generators/types"),
                flow: require("./generators/flow"),
                base: require("./generators/base"),
                jsx: require("./generators/jsx")
              },
              enumerable: true
            }]);
            return CodeGenerator;
          })();
          _lodashCollectionEach2["default"](_buffer2["default"].prototype, function(fn, key) {
            CodeGenerator.prototype[key] = function() {
              return fn.apply(this.buffer, arguments);
            };
          });
          _lodashCollectionEach2["default"](CodeGenerator.generators, function(generator) {
            _lodashObjectExtend2["default"](CodeGenerator.prototype, generator);
          });
          module.exports = function(ast, opts, code) {
            var gen = new CodeGenerator(ast, opts, code);
            return gen.generate();
          };
          module.exports.CodeGenerator = CodeGenerator;
        }, {
          "../messages": 60,
          "../types": 196,
          "./buffer": 35,
          "./generators/base": 36,
          "./generators/classes": 37,
          "./generators/comprehensions": 38,
          "./generators/expressions": 39,
          "./generators/flow": 40,
          "./generators/jsx": 41,
          "./generators/methods": 42,
          "./generators/modules": 43,
          "./generators/statements": 44,
          "./generators/template-literals": 45,
          "./generators/types": 46,
          "./node": 48,
          "./node/printer": 50,
          "./position": 52,
          "./source-map": 53,
          "./whitespace": 54,
          "detect-indent": 408,
          "lodash/collection/each": 428,
          "lodash/object/extend": 528,
          "repeating": 602
        }],
        48: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _whitespace = require("./whitespace");
          var _whitespace2 = _interopRequireDefault(_whitespace);
          var _parentheses = require("./parentheses");
          var parens = _interopRequireWildcard(_parentheses);
          var _lodashCollectionEach = require("lodash/collection/each");
          var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
          var _lodashCollectionSome = require("lodash/collection/some");
          var _lodashCollectionSome2 = _interopRequireDefault(_lodashCollectionSome);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var find = function find(obj, node, parent) {
            if (!obj)
              return;
            var result;
            var types = Object.keys(obj);
            for (var i = 0; i < types.length; i++) {
              var type = types[i];
              if (t.is(type, node)) {
                var fn = obj[type];
                result = fn(node, parent);
                if (result != null)
                  break;
              }
            }
            return result;
          };
          var Node = (function() {
            function Node(node, parent) {
              _classCallCheck(this, Node);
              this.parent = parent;
              this.node = node;
            }
            Node.isUserWhitespacable = function isUserWhitespacable(node) {
              return t.isUserWhitespacable(node);
            };
            Node.needsWhitespace = function needsWhitespace(node, parent, type) {
              if (!node)
                return 0;
              if (t.isExpressionStatement(node)) {
                node = node.expression;
              }
              var linesInfo = find(_whitespace2["default"].nodes, node, parent);
              if (!linesInfo) {
                var items = find(_whitespace2["default"].list, node, parent);
                if (items) {
                  for (var i = 0; i < items.length; i++) {
                    linesInfo = Node.needsWhitespace(items[i], node, type);
                    if (linesInfo)
                      break;
                  }
                }
              }
              return linesInfo && linesInfo[type] || 0;
            };
            Node.needsWhitespaceBefore = function needsWhitespaceBefore(node, parent) {
              return Node.needsWhitespace(node, parent, "before");
            };
            Node.needsWhitespaceAfter = function needsWhitespaceAfter(node, parent) {
              return Node.needsWhitespace(node, parent, "after");
            };
            Node.needsParens = function needsParens(node, parent) {
              if (!parent)
                return false;
              if (t.isNewExpression(parent) && parent.callee === node) {
                if (t.isCallExpression(node))
                  return true;
                var hasCall = _lodashCollectionSome2["default"](node, function(val) {
                  return t.isCallExpression(val);
                });
                if (hasCall)
                  return true;
              }
              return find(parens, node, parent);
            };
            return Node;
          })();
          exports["default"] = Node;
          _lodashCollectionEach2["default"](Node, function(fn, key) {
            Node.prototype[key] = function() {
              var args = new Array(arguments.length + 2);
              args[0] = this.node;
              args[1] = this.parent;
              for (var i = 0; i < args.length; i++) {
                args[i + 2] = arguments[i];
              }
              return Node[key].apply(null, args);
            };
          });
          module.exports = exports["default"];
        }, {
          "../../types": 196,
          "./parentheses": 49,
          "./whitespace": 51,
          "lodash/collection/each": 428,
          "lodash/collection/some": 433
        }],
        49: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.NullableTypeAnnotation = NullableTypeAnnotation;
          exports.UpdateExpression = UpdateExpression;
          exports.ObjectExpression = ObjectExpression;
          exports.Binary = Binary;
          exports.BinaryExpression = BinaryExpression;
          exports.SequenceExpression = SequenceExpression;
          exports.YieldExpression = YieldExpression;
          exports.ClassExpression = ClassExpression;
          exports.UnaryLike = UnaryLike;
          exports.FunctionExpression = FunctionExpression;
          exports.ConditionalExpression = ConditionalExpression;
          exports.AssignmentExpression = AssignmentExpression;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashCollectionEach = require("lodash/collection/each");
          var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var PRECEDENCE = {};
          _lodashCollectionEach2["default"]([["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]], function(tier, i) {
            _lodashCollectionEach2["default"](tier, function(op) {
              PRECEDENCE[op] = i;
            });
          });
          function NullableTypeAnnotation(node, parent) {
            return t.isArrayTypeAnnotation(parent);
          }
          exports.FunctionTypeAnnotation = NullableTypeAnnotation;
          function UpdateExpression(node, parent) {
            if (t.isMemberExpression(parent) && parent.object === node) {
              return true;
            }
          }
          function ObjectExpression(node, parent) {
            if (t.isExpressionStatement(parent)) {
              return true;
            }
            if (t.isMemberExpression(parent) && parent.object === node) {
              return true;
            }
            return false;
          }
          function Binary(node, parent) {
            if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node) {
              return true;
            }
            if (t.isUnaryLike(parent)) {
              return true;
            }
            if (t.isMemberExpression(parent) && parent.object === node) {
              return true;
            }
            if (t.isBinary(parent)) {
              var parentOp = parent.operator;
              var parentPos = PRECEDENCE[parentOp];
              var nodeOp = node.operator;
              var nodePos = PRECEDENCE[nodeOp];
              if (parentPos > nodePos) {
                return true;
              }
              if (parentPos === nodePos && parent.right === node) {
                return true;
              }
            }
          }
          function BinaryExpression(node, parent) {
            if (node.operator === "in") {
              if (t.isVariableDeclarator(parent)) {
                return true;
              }
              if (t.isFor(parent)) {
                return true;
              }
            }
          }
          function SequenceExpression(node, parent) {
            if (t.isForStatement(parent)) {
              return false;
            }
            if (t.isExpressionStatement(parent) && parent.expression === node) {
              return false;
            }
            return true;
          }
          function YieldExpression(node, parent) {
            return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isConditionalExpression(parent) || t.isYieldExpression(parent);
          }
          function ClassExpression(node, parent) {
            return t.isExpressionStatement(parent);
          }
          function UnaryLike(node, parent) {
            return t.isMemberExpression(parent) && parent.object === node;
          }
          function FunctionExpression(node, parent) {
            if (t.isExpressionStatement(parent)) {
              return true;
            }
            if (t.isMemberExpression(parent) && parent.object === node) {
              return true;
            }
            if (t.isCallExpression(parent) && parent.callee === node) {
              return true;
            }
          }
          function ConditionalExpression(node, parent) {
            if (t.isUnaryLike(parent)) {
              return true;
            }
            if (t.isBinary(parent)) {
              return true;
            }
            if (t.isCallExpression(parent) || t.isNewExpression(parent)) {
              if (parent.callee === node) {
                return true;
              }
            }
            if (t.isConditionalExpression(parent) && parent.test === node) {
              return true;
            }
            if (t.isMemberExpression(parent) && parent.object === node) {
              return true;
            }
            return false;
          }
          function AssignmentExpression(node) {
            if (t.isObjectPattern(node.left)) {
              return true;
            } else {
              return ConditionalExpression.apply(undefined, arguments);
            }
          }
        }, {
          "../../types": 196,
          "lodash/collection/each": 428
        }],
        50: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var NodePrinter = (function() {
            function NodePrinter(generator, parent) {
              _classCallCheck(this, NodePrinter);
              this.generator = generator;
              this.parent = parent;
            }
            NodePrinter.prototype.printInnerComments = function printInnerComments() {
              if (!this.parent.innerComments)
                return;
              var gen = this.generator;
              gen.indent();
              gen._printComments(this.parent.innerComments);
              gen.dedent();
            };
            NodePrinter.prototype.plain = function plain(node, opts) {
              return this.generator.print(node, this.parent, opts);
            };
            NodePrinter.prototype.sequence = function sequence(nodes) {
              var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              opts.statement = true;
              return this.generator.printJoin(this, nodes, opts);
            };
            NodePrinter.prototype.join = function join(nodes, opts) {
              return this.generator.printJoin(this, nodes, opts);
            };
            NodePrinter.prototype.list = function list(items) {
              var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              if (opts.separator == null) {
                opts.separator = ",";
                if (!this.generator.format.compact)
                  opts.separator += " ";
              }
              return this.join(items, opts);
            };
            NodePrinter.prototype.block = function block(node) {
              return this.generator.printBlock(this, node);
            };
            NodePrinter.prototype.indentOnComments = function indentOnComments(node) {
              return this.generator.printAndIndentOnComments(this, node);
            };
            return NodePrinter;
          })();
          exports["default"] = NodePrinter;
          module.exports = exports["default"];
        }, {}],
        51: [function(require, module, exports) {
          "use strict";
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashLangIsBoolean = require("lodash/lang/isBoolean");
          var _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);
          var _lodashCollectionEach = require("lodash/collection/each");
          var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
          var _lodashCollectionMap = require("lodash/collection/map");
          var _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function crawl(node) {
            var state = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            if (t.isMemberExpression(node)) {
              crawl(node.object, state);
              if (node.computed)
                crawl(node.property, state);
            } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
              crawl(node.left, state);
              crawl(node.right, state);
            } else if (t.isCallExpression(node)) {
              state.hasCall = true;
              crawl(node.callee, state);
            } else if (t.isFunction(node)) {
              state.hasFunction = true;
            } else if (t.isIdentifier(node)) {
              state.hasHelper = state.hasHelper || isHelper(node.callee);
            }
            return state;
          }
          function isHelper(node) {
            if (t.isMemberExpression(node)) {
              return isHelper(node.object) || isHelper(node.property);
            } else if (t.isIdentifier(node)) {
              return node.name === "require" || node.name[0] === "_";
            } else if (t.isCallExpression(node)) {
              return isHelper(node.callee);
            } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
              return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
            } else {
              return false;
            }
          }
          function isType(node) {
            return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);
          }
          exports.nodes = {
            AssignmentExpression: function AssignmentExpression(node) {
              var state = crawl(node.right);
              if (state.hasCall && state.hasHelper || state.hasFunction) {
                return {
                  before: state.hasFunction,
                  after: true
                };
              }
            },
            SwitchCase: function SwitchCase(node, parent) {
              return {before: node.consequent.length || parent.cases[0] === node};
            },
            LogicalExpression: function LogicalExpression(node) {
              if (t.isFunction(node.left) || t.isFunction(node.right)) {
                return {after: true};
              }
            },
            Literal: function Literal(node) {
              if (node.value === "use strict") {
                return {after: true};
              }
            },
            CallExpression: function CallExpression(node) {
              if (t.isFunction(node.callee) || isHelper(node)) {
                return {
                  before: true,
                  after: true
                };
              }
            },
            VariableDeclaration: function VariableDeclaration(node) {
              for (var i = 0; i < node.declarations.length; i++) {
                var declar = node.declarations[i];
                var enabled = isHelper(declar.id) && !isType(declar.init);
                if (!enabled) {
                  var state = crawl(declar.init);
                  enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
                }
                if (enabled) {
                  return {
                    before: true,
                    after: true
                  };
                }
              }
            },
            IfStatement: function IfStatement(node) {
              if (t.isBlockStatement(node.consequent)) {
                return {
                  before: true,
                  after: true
                };
              }
            }
          };
          exports.nodes.Property = exports.nodes.SpreadProperty = function(node, parent) {
            if (parent.properties[0] === node) {
              return {before: true};
            }
          };
          exports.list = {
            VariableDeclaration: function VariableDeclaration(node) {
              return _lodashCollectionMap2["default"](node.declarations, "init");
            },
            ArrayExpression: function ArrayExpression(node) {
              return node.elements;
            },
            ObjectExpression: function ObjectExpression(node) {
              return node.properties;
            }
          };
          _lodashCollectionEach2["default"]({
            Function: true,
            Class: true,
            Loop: true,
            LabeledStatement: true,
            SwitchStatement: true,
            TryStatement: true
          }, function(amounts, type) {
            if (_lodashLangIsBoolean2["default"](amounts)) {
              amounts = {
                after: amounts,
                before: amounts
              };
            }
            _lodashCollectionEach2["default"]([type].concat(t.FLIPPED_ALIAS_KEYS[type] || []), function(type) {
              exports.nodes[type] = function() {
                return amounts;
              };
            });
          });
        }, {
          "../../types": 196,
          "lodash/collection/each": 428,
          "lodash/collection/map": 431,
          "lodash/lang/isBoolean": 515
        }],
        52: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Position = (function() {
            function Position() {
              _classCallCheck(this, Position);
              this.line = 1;
              this.column = 0;
            }
            Position.prototype.push = function push(str) {
              for (var i = 0; i < str.length; i++) {
                if (str[i] === "\n") {
                  this.line++;
                  this.column = 0;
                } else {
                  this.column++;
                }
              }
            };
            Position.prototype.unshift = function unshift(str) {
              for (var i = 0; i < str.length; i++) {
                if (str[i] === "\n") {
                  this.line--;
                } else {
                  this.column--;
                }
              }
            };
            return Position;
          })();
          exports["default"] = Position;
          module.exports = exports["default"];
        }, {}],
        53: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _sourceMap = require("source-map");
          var _sourceMap2 = _interopRequireDefault(_sourceMap);
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          var SourceMap = (function() {
            function SourceMap(position, opts, code) {
              _classCallCheck(this, SourceMap);
              this.position = position;
              this.opts = opts;
              if (opts.sourceMaps) {
                this.map = new _sourceMap2["default"].SourceMapGenerator({
                  file: opts.sourceMapTarget,
                  sourceRoot: opts.sourceRoot
                });
                this.map.setSourceContent(opts.sourceFileName, code);
              } else {
                this.map = null;
              }
            }
            SourceMap.prototype.get = function get() {
              var map = this.map;
              if (map) {
                return map.toJSON();
              } else {
                return map;
              }
            };
            SourceMap.prototype.mark = function mark(node, type) {
              var loc = node.loc;
              if (!loc)
                return;
              var map = this.map;
              if (!map)
                return;
              if (t.isProgram(node) || t.isFile(node))
                return;
              var position = this.position;
              var generated = {
                line: position.line,
                column: position.column
              };
              var original = loc[type];
              map.addMapping({
                source: this.opts.sourceFileName,
                generated: generated,
                original: original
              });
            };
            return SourceMap;
          })();
          exports["default"] = SourceMap;
          module.exports = exports["default"];
        }, {
          "../types": 196,
          "source-map": 607
        }],
        54: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function getLookupIndex(i, base, max) {
            i += base;
            if (i >= max) {
              i -= max;
            }
            return i;
          }
          var Whitespace = (function() {
            function Whitespace(tokens) {
              _classCallCheck(this, Whitespace);
              this.tokens = tokens;
              this.used = {};
              this._lastFoundIndex = 0;
            }
            Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(node) {
              var startToken;
              var endToken;
              var tokens = this.tokens;
              for (var j = 0; j < tokens.length; j++) {
                var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);
                var token = tokens[i];
                if (node.start === token.start) {
                  startToken = tokens[i - 1];
                  endToken = token;
                  this._lastFoundIndex = i;
                  break;
                }
              }
              return this.getNewlinesBetween(startToken, endToken);
            };
            Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(node) {
              var startToken;
              var endToken;
              var tokens = this.tokens;
              for (var j = 0; j < tokens.length; j++) {
                var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);
                var token = tokens[i];
                if (node.end === token.end) {
                  startToken = token;
                  endToken = tokens[i + 1];
                  if (endToken.type.label === ",")
                    endToken = tokens[i + 2];
                  this._lastFoundIndex = i;
                  break;
                }
              }
              if (endToken && endToken.type.label === "eof") {
                return 1;
              } else {
                var lines = this.getNewlinesBetween(startToken, endToken);
                if (node.type === "CommentLine" && !lines) {
                  return 1;
                } else {
                  return lines;
                }
              }
            };
            Whitespace.prototype.getNewlinesBetween = function getNewlinesBetween(startToken, endToken) {
              if (!endToken || !endToken.loc)
                return 0;
              var start = startToken ? startToken.loc.end.line : 1;
              var end = endToken.loc.start.line;
              var lines = 0;
              for (var line = start; line < end; line++) {
                if (typeof this.used[line] === "undefined") {
                  this.used[line] = true;
                  lines++;
                }
              }
              return lines;
            };
            return Whitespace;
          })();
          exports["default"] = Whitespace;
          module.exports = exports["default"];
        }, {}],
        55: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lineNumbers = require("line-numbers");
          var _lineNumbers2 = _interopRequireDefault(_lineNumbers);
          var _repeating = require("repeating");
          var _repeating2 = _interopRequireDefault(_repeating);
          var _jsTokens = require("js-tokens");
          var _jsTokens2 = _interopRequireDefault(_jsTokens);
          var _esutils = require("esutils");
          var _esutils2 = _interopRequireDefault(_esutils);
          var _chalk = require("chalk");
          var _chalk2 = _interopRequireDefault(_chalk);
          var defs = {
            string: _chalk2["default"].red,
            punctuator: _chalk2["default"].bold,
            curly: _chalk2["default"].green,
            parens: _chalk2["default"].blue.bold,
            square: _chalk2["default"].yellow,
            keyword: _chalk2["default"].cyan,
            number: _chalk2["default"].magenta,
            regex: _chalk2["default"].magenta,
            comment: _chalk2["default"].grey,
            invalid: _chalk2["default"].inverse
          };
          var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
          function getTokenType(match) {
            var token = _jsTokens2["default"].matchToToken(match);
            if (token.type === "name" && _esutils2["default"].keyword.isReservedWordES6(token.value)) {
              return "keyword";
            }
            if (token.type === "punctuator") {
              switch (token.value) {
                case "{":
                case "}":
                  return "curly";
                case "(":
                case ")":
                  return "parens";
                case "[":
                case "]":
                  return "square";
              }
            }
            return token.type;
          }
          function highlight(text) {
            return text.replace(_jsTokens2["default"], function() {
              for (var _len = arguments.length,
                  args = Array(_len),
                  _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var type = getTokenType(args);
              var colorize = defs[type];
              if (colorize) {
                return args[0].split(NEWLINE).map(function(str) {
                  return colorize(str);
                }).join("\n");
              } else {
                return args[0];
              }
            });
          }
          exports["default"] = function(lines, lineNumber, colNumber) {
            var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
            colNumber = Math.max(colNumber, 0);
            var highlighted = opts.highlightCode && _chalk2["default"].supportsColor;
            if (highlighted)
              lines = highlight(lines);
            lines = lines.split(NEWLINE);
            var start = Math.max(lineNumber - 3, 0);
            var end = Math.min(lines.length, lineNumber + 3);
            if (!lineNumber && !colNumber) {
              start = 0;
              end = lines.length;
            }
            var frame = _lineNumbers2["default"](lines.slice(start, end), {
              start: start + 1,
              before: "  ",
              after: " | ",
              transform: function transform(params) {
                if (params.number !== lineNumber) {
                  return;
                }
                if (colNumber) {
                  params.line += "\n" + params.before + _repeating2["default"](" ", params.width) + params.after + _repeating2["default"](" ", colNumber - 1) + "^";
                }
                params.before = params.before.replace(/^./, ">");
              }
            }).join("\n");
            if (highlighted) {
              return _chalk2["default"].reset(frame);
            } else {
              return frame;
            }
          };
          module.exports = exports["default"];
        }, {
          "chalk": 217,
          "esutils": 412,
          "js-tokens": 418,
          "line-numbers": 420,
          "repeating": 602
        }],
        56: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashObjectMerge = require("lodash/object/merge");
          var _lodashObjectMerge2 = _interopRequireDefault(_lodashObjectMerge);
          exports["default"] = function(dest, src) {
            if (!dest || !src)
              return;
            return _lodashObjectMerge2["default"](dest, src, function(a, b) {
              if (b && Array.isArray(a)) {
                var c = a.slice(0);
                for (var _iterator = b,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
                  var _ref;
                  if (_isArray) {
                    if (_i >= _iterator.length)
                      break;
                    _ref = _iterator[_i++];
                  } else {
                    _i = _iterator.next();
                    if (_i.done)
                      break;
                    _ref = _i.value;
                  }
                  var v = _ref;
                  if (a.indexOf(v) < 0) {
                    c.push(v);
                  }
                }
                return c;
              }
            });
          };
          module.exports = exports["default"];
        }, {"lodash/object/merge": 532}],
        57: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          exports["default"] = function(ast, comments, tokens) {
            if (ast && ast.type === "Program") {
              return t.file(ast, comments || [], tokens || []);
            } else {
              throw new Error("Not a valid ast?");
            }
          };
          module.exports = exports["default"];
        }, {"../types": 196}],
        58: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports["default"] = function() {
            return Object.create(null);
          };
          module.exports = exports["default"];
        }, {}],
        59: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _babylon = require("babylon");
          var babylon = _interopRequireWildcard(_babylon);
          exports["default"] = function(code) {
            var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var parseOpts = {
              allowImportExportEverywhere: opts.looseModules,
              allowReturnOutsideFunction: opts.looseModules,
              allowHashBang: true,
              ecmaVersion: 6,
              strictMode: opts.strictMode,
              sourceType: opts.sourceType,
              locations: true,
              features: opts.features || {},
              plugins: opts.plugins || {}
            };
            if (opts.nonStandard) {
              parseOpts.plugins.jsx = true;
              parseOpts.plugins.flow = true;
            }
            return babylon.parse(code, parseOpts);
          };
          module.exports = exports["default"];
        }, {"babylon": 624}],
        60: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.get = get;
          exports.parseArgs = parseArgs;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _util = require("util");
          var util = _interopRequireWildcard(_util);
          var MESSAGES = {
            tailCallReassignmentDeopt: "Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence",
            JSXNamespacedTags: "Namespace tags are not supported. ReactJSX is not XML.",
            classesIllegalBareSuper: "Illegal use of bare super",
            classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
            scopeDuplicateDeclaration: "Duplicate declaration $1",
            settersNoRest: "Setters aren't allowed to have a rest",
            noAssignmentsInForHead: "No assignments allowed in for-in/of head",
            expectedMemberExpressionOrIdentifier: "Expected type MemberExpression or Identifier",
            invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
            readOnly: "$1 is read-only",
            unknownForHead: "Unknown node type $1 in ForStatement",
            didYouMean: "Did you mean $1?",
            codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.",
            missingTemplatesDirectory: "no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues",
            unsupportedOutputType: "Unsupported output type $1",
            illegalMethodName: "Illegal method name $1",
            lostTrackNodePath: "We lost track of this node's position, likely because the AST was directly manipulated",
            modulesIllegalExportName: "Illegal export $1",
            modulesDuplicateDeclarations: "Duplicate module declarations with the same source but in different scopes",
            undeclaredVariable: "Reference to undeclared variable $1",
            undeclaredVariableType: "Referencing a type alias outside of a type annotation",
            undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",
            traverseNeedsParent: "You must pass a scope and parentPath unless traversing a Program/File got a $1 node",
            traverseVerifyRootFunction: "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",
            traverseVerifyVisitorProperty: "You passed `traverse()` a visitor object with the property $1 that has the invalid property $2",
            traverseVerifyNodeType: "You gave us a visitor for the node type $1 but it's not a valid type",
            pluginIllegalKind: "Illegal kind $1 for plugin $2",
            pluginIllegalPosition: "Illegal position $1 for plugin $2",
            pluginKeyCollision: "The plugin $1 collides with another of the same name",
            pluginNotTransformer: "The plugin $1 didn't export a Plugin instance",
            pluginUnknown: "Unknown plugin $1",
            pluginNotFile: "Plugin $1 is resolving to a different Babel version than what is performing the transformation.",
            pluginInvalidProperty: "Plugin $1 provided an invalid property of $2.",
            pluginInvalidPropertyVisitor: "Define your visitor methods inside a `visitor` property like so:\n\n  new Plugin(\"foobar\", {\n    visitor: {\n      // define your visitor methods here!\n    }\n  });\n"
          };
          exports.MESSAGES = MESSAGES;
          function get(key) {
            for (var _len = arguments.length,
                args = Array(_len > 1 ? _len - 1 : 0),
                _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var msg = MESSAGES[key];
            if (!msg)
              throw new ReferenceError("Unknown message " + JSON.stringify(key));
            args = parseArgs(args);
            return msg.replace(/\$(\d+)/g, function(str, i) {
              return args[--i];
            });
          }
          function parseArgs(args) {
            return args.map(function(val) {
              if (val != null && val.inspect) {
                return val.inspect();
              } else {
                try {
                  return JSON.stringify(val) || val + "";
                } catch (e) {
                  return util.inspect(val);
                }
              }
            });
          }
        }, {"util": 30}],
        61: [function(require, module, exports) {
          (function(global) {
            "use strict";
            require("core-js/shim");
            require("regenerator/runtime");
            if (global._babelPolyfill) {
              throw new Error("only one instance of babel/polyfill is allowed");
            }
            global._babelPolyfill = true;
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {
          "core-js/shim": 404,
          "regenerator/runtime": 595
        }],
        62: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _generation = require("../generation");
          var _generation2 = _interopRequireDefault(_generation);
          var _messages = require("../messages");
          var messages = _interopRequireWildcard(_messages);
          var _util = require("../util");
          var util = _interopRequireWildcard(_util);
          var _transformationFile = require("../transformation/file");
          var _transformationFile2 = _interopRequireDefault(_transformationFile);
          var _lodashCollectionEach = require("lodash/collection/each");
          var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          function buildGlobal(namespace, builder) {
            var body = [];
            var container = t.functionExpression(null, [t.identifier("global")], t.blockStatement(body));
            var tree = t.program([t.expressionStatement(t.callExpression(container, [util.template("helper-self-global")]))]);
            body.push(t.variableDeclaration("var", [t.variableDeclarator(namespace, t.assignmentExpression("=", t.memberExpression(t.identifier("global"), namespace), t.objectExpression([])))]));
            builder(body);
            return tree;
          }
          function buildUmd(namespace, builder) {
            var body = [];
            body.push(t.variableDeclaration("var", [t.variableDeclarator(namespace, t.identifier("global"))]));
            builder(body);
            var container = util.template("umd-commonjs-strict", {
              FACTORY_PARAMETERS: t.identifier("global"),
              BROWSER_ARGUMENTS: t.assignmentExpression("=", t.memberExpression(t.identifier("root"), namespace), t.objectExpression({})),
              COMMON_ARGUMENTS: t.identifier("exports"),
              AMD_ARGUMENTS: t.arrayExpression([t.literal("exports")]),
              FACTORY_BODY: body,
              UMD_ROOT: t.identifier("this")
            });
            return t.program([container]);
          }
          function buildVar(namespace, builder) {
            var body = [];
            body.push(t.variableDeclaration("var", [t.variableDeclarator(namespace, t.objectExpression({}))]));
            builder(body);
            return t.program(body);
          }
          function buildHelpers(body, namespace, whitelist) {
            _lodashCollectionEach2["default"](_transformationFile2["default"].helpers, function(name) {
              if (whitelist && whitelist.indexOf(name) === -1)
                return;
              var key = t.identifier(t.toIdentifier(name));
              body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(namespace, key), util.template("helper-" + name))));
            });
          }
          exports["default"] = function(whitelist) {
            var outputType = arguments.length <= 1 || arguments[1] === undefined ? "global" : arguments[1];
            var namespace = t.identifier("babelHelpers");
            var builder = function builder(body) {
              return buildHelpers(body, namespace, whitelist);
            };
            var tree;
            var build = ({
              global: buildGlobal,
              umd: buildUmd,
              "var": buildVar
            })[outputType];
            if (build) {
              tree = build(namespace, builder);
            } else {
              throw new Error(messages.get("unsupportedOutputType", outputType));
            }
            return _generation2["default"](tree).code;
          };
          module.exports = exports["default"];
        }, {
          "../generation": 47,
          "../messages": 60,
          "../transformation/file": 63,
          "../types": 196,
          "../util": 199,
          "lodash/collection/each": 428
        }],
        63: [function(require, module, exports) {
          (function(process) {
            "use strict";
            exports.__esModule = true;
            var _createClass = (function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            })();
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj;
              } else {
                var newObj = {};
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                      newObj[key] = obj[key];
                  }
                }
                newObj["default"] = obj;
                return newObj;
              }
            }
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {"default": obj};
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var _convertSourceMap = require("convert-source-map");
            var _convertSourceMap2 = _interopRequireDefault(_convertSourceMap);
            var _modules = require("../modules");
            var _modules2 = _interopRequireDefault(_modules);
            var _optionsOptionManager = require("./options/option-manager");
            var _optionsOptionManager2 = _interopRequireDefault(_optionsOptionManager);
            var _pluginManager = require("./plugin-manager");
            var _pluginManager2 = _interopRequireDefault(_pluginManager);
            var _shebangRegex = require("shebang-regex");
            var _shebangRegex2 = _interopRequireDefault(_shebangRegex);
            var _traversalPath = require("../../traversal/path");
            var _traversalPath2 = _interopRequireDefault(_traversalPath);
            var _lodashLangIsFunction = require("lodash/lang/isFunction");
            var _lodashLangIsFunction2 = _interopRequireDefault(_lodashLangIsFunction);
            var _sourceMap = require("source-map");
            var _sourceMap2 = _interopRequireDefault(_sourceMap);
            var _generation = require("../../generation");
            var _generation2 = _interopRequireDefault(_generation);
            var _helpersCodeFrame = require("../../helpers/code-frame");
            var _helpersCodeFrame2 = _interopRequireDefault(_helpersCodeFrame);
            var _lodashObjectDefaults = require("lodash/object/defaults");
            var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
            var _lodashCollectionIncludes = require("lodash/collection/includes");
            var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
            var _traversal = require("../../traversal");
            var _traversal2 = _interopRequireDefault(_traversal);
            var _tryResolve = require("try-resolve");
            var _tryResolve2 = _interopRequireDefault(_tryResolve);
            var _logger = require("./logger");
            var _logger2 = _interopRequireDefault(_logger);
            var _plugin = require("../plugin");
            var _plugin2 = _interopRequireDefault(_plugin);
            var _helpersParse = require("../../helpers/parse");
            var _helpersParse2 = _interopRequireDefault(_helpersParse);
            var _traversalHub = require("../../traversal/hub");
            var _traversalHub2 = _interopRequireDefault(_traversalHub);
            var _util = require("../../util");
            var util = _interopRequireWildcard(_util);
            var _path = require("path");
            var _path2 = _interopRequireDefault(_path);
            var _types = require("../../types");
            var t = _interopRequireWildcard(_types);
            var File = (function() {
              function File(opts, pipeline) {
                if (opts === undefined)
                  opts = {};
                _classCallCheck(this, File);
                this.transformerDependencies = {};
                this.dynamicImportTypes = {};
                this.dynamicImportIds = {};
                this.dynamicImports = [];
                this.declarations = {};
                this.usedHelpers = {};
                this.dynamicData = {};
                this.data = {};
                this.ast = {};
                this.metadata = {modules: {
                    imports: [],
                    exports: {
                      exported: [],
                      specifiers: []
                    }
                  }};
                this.hub = new _traversalHub2["default"](this);
                this.pipeline = pipeline;
                this.log = new _logger2["default"](this, opts.filename || "unknown");
                this.opts = this.initOptions(opts);
                this.buildTransformers();
              }
              File.prototype.initOptions = function initOptions(opts) {
                opts = new _optionsOptionManager2["default"](this.log, this.pipeline).init(opts);
                if (opts.inputSourceMap) {
                  opts.sourceMaps = true;
                }
                if (opts.moduleId) {
                  opts.moduleIds = true;
                }
                opts.basename = _path2["default"].basename(opts.filename, _path2["default"].extname(opts.filename));
                opts.ignore = util.arrayify(opts.ignore, util.regexify);
                if (opts.only)
                  opts.only = util.arrayify(opts.only, util.regexify);
                _lodashObjectDefaults2["default"](opts, {moduleRoot: opts.sourceRoot});
                _lodashObjectDefaults2["default"](opts, {sourceRoot: opts.moduleRoot});
                _lodashObjectDefaults2["default"](opts, {filenameRelative: opts.filename});
                _lodashObjectDefaults2["default"](opts, {
                  sourceFileName: opts.filenameRelative,
                  sourceMapTarget: opts.filenameRelative
                });
                if (opts.externalHelpers) {
                  this.set("helpersNamespace", t.identifier("babelHelpers"));
                }
                return opts;
              };
              File.prototype.isLoose = function isLoose(key) {
                return _lodashCollectionIncludes2["default"](this.opts.loose, key);
              };
              File.prototype.buildTransformers = function buildTransformers() {
                var file = this;
                var transformers = this.transformers = {};
                var secondaryStack = [];
                var stack = [];
                for (var key in this.pipeline.transformers) {
                  var transformer = this.pipeline.transformers[key];
                  var pass = transformers[key] = transformer.buildPass(file);
                  if (pass.canTransform()) {
                    stack.push(pass);
                    if (transformer.metadata.secondPass) {
                      secondaryStack.push(pass);
                    }
                    if (transformer.manipulateOptions) {
                      transformer.manipulateOptions(file.opts, file);
                    }
                  }
                }
                var beforePlugins = [];
                var afterPlugins = [];
                var pluginManager = new _pluginManager2["default"]({
                  file: this,
                  transformers: this.transformers,
                  before: beforePlugins,
                  after: afterPlugins
                });
                for (var i = 0; i < file.opts.plugins.length; i++) {
                  pluginManager.add(file.opts.plugins[i]);
                }
                stack = beforePlugins.concat(stack, afterPlugins);
                this.uncollapsedTransformerStack = stack = stack.concat(secondaryStack);
                var _arr = stack;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var pass = _arr[_i];
                  var _arr2 = pass.plugin.dependencies;
                  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                    var dep = _arr2[_i2];
                    this.transformerDependencies[dep] = pass.key;
                  }
                }
                this.transformerStack = this.collapseStack(stack);
              };
              File.prototype.collapseStack = function collapseStack(_stack) {
                var stack = [];
                var ignore = [];
                var _arr3 = _stack;
                for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                  var pass = _arr3[_i3];
                  if (ignore.indexOf(pass) >= 0)
                    continue;
                  var group = pass.plugin.metadata.group;
                  if (!pass.canTransform() || !group) {
                    stack.push(pass);
                    continue;
                  }
                  var mergeStack = [];
                  var _arr4 = _stack;
                  for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
                    var _pass = _arr4[_i4];
                    if (_pass.plugin.metadata.group === group) {
                      mergeStack.push(_pass);
                      ignore.push(_pass);
                    }
                  }
                  var visitors = [];
                  var _arr5 = mergeStack;
                  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
                    var _pass2 = _arr5[_i5];
                    visitors.push(_pass2.plugin.visitor);
                  }
                  var visitor = _traversal2["default"].visitors.merge(visitors);
                  var mergePlugin = new _plugin2["default"](group, {visitor: visitor});
                  stack.push(mergePlugin.buildPass(this));
                }
                return stack;
              };
              File.prototype.set = function set(key, val) {
                return this.data[key] = val;
              };
              File.prototype.setDynamic = function setDynamic(key, fn) {
                this.dynamicData[key] = fn;
              };
              File.prototype.get = function get(key) {
                var data = this.data[key];
                if (data) {
                  return data;
                } else {
                  var dynamic = this.dynamicData[key];
                  if (dynamic) {
                    return this.set(key, dynamic());
                  }
                }
              };
              File.prototype.resolveModuleSource = function resolveModuleSource(source) {
                var resolveModuleSource = this.opts.resolveModuleSource;
                if (resolveModuleSource)
                  source = resolveModuleSource(source, this.opts.filename);
                return source;
              };
              File.prototype.addImport = function addImport(source, name, type) {
                name = name || source;
                var id = this.dynamicImportIds[name];
                if (!id) {
                  source = this.resolveModuleSource(source);
                  id = this.dynamicImportIds[name] = this.scope.generateUidIdentifier(name);
                  var specifiers = [t.importDefaultSpecifier(id)];
                  var declar = t.importDeclaration(specifiers, t.literal(source));
                  declar._blockHoist = 3;
                  if (type) {
                    var modules = this.dynamicImportTypes[type] = this.dynamicImportTypes[type] || [];
                    modules.push(declar);
                  }
                  if (this.transformers["es6.modules"].canTransform()) {
                    this.moduleFormatter.importSpecifier(specifiers[0], declar, this.dynamicImports, this.scope);
                    this.moduleFormatter.hasLocalImports = true;
                  } else {
                    this.dynamicImports.push(declar);
                  }
                }
                return id;
              };
              File.prototype.attachAuxiliaryComment = function attachAuxiliaryComment(node) {
                var beforeComment = this.opts.auxiliaryCommentBefore;
                if (beforeComment) {
                  node.leadingComments = node.leadingComments || [];
                  node.leadingComments.push({
                    type: "CommentLine",
                    value: " " + beforeComment
                  });
                }
                var afterComment = this.opts.auxiliaryCommentAfter;
                if (afterComment) {
                  node.trailingComments = node.trailingComments || [];
                  node.trailingComments.push({
                    type: "CommentLine",
                    value: " " + afterComment
                  });
                }
                return node;
              };
              File.prototype.addHelper = function addHelper(name) {
                var isSolo = _lodashCollectionIncludes2["default"](File.soloHelpers, name);
                if (!isSolo && !_lodashCollectionIncludes2["default"](File.helpers, name)) {
                  throw new ReferenceError("Unknown helper " + name);
                }
                var declar = this.declarations[name];
                if (declar)
                  return declar;
                this.usedHelpers[name] = true;
                if (!isSolo) {
                  var generator = this.get("helperGenerator");
                  var runtime = this.get("helpersNamespace");
                  if (generator) {
                    return generator(name);
                  } else if (runtime) {
                    var id = t.identifier(t.toIdentifier(name));
                    return t.memberExpression(runtime, id);
                  }
                }
                var ref = util.template("helper-" + name);
                var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
                if (t.isFunctionExpression(ref) && !ref.id) {
                  ref.body._compact = true;
                  ref._generated = true;
                  ref.id = uid;
                  ref.type = "FunctionDeclaration";
                  this.attachAuxiliaryComment(ref);
                  this.path.unshiftContainer("body", ref);
                } else {
                  ref._compact = true;
                  this.scope.push({
                    id: uid,
                    init: ref,
                    unique: true
                  });
                }
                return uid;
              };
              File.prototype.addTemplateObject = function addTemplateObject(helperName, strings, raw) {
                var stringIds = raw.elements.map(function(string) {
                  return string.value;
                });
                var name = helperName + "_" + raw.elements.length + "_" + stringIds.join(",");
                var declar = this.declarations[name];
                if (declar)
                  return declar;
                var uid = this.declarations[name] = this.scope.generateUidIdentifier("templateObject");
                var helperId = this.addHelper(helperName);
                var init = t.callExpression(helperId, [strings, raw]);
                init._compact = true;
                this.scope.push({
                  id: uid,
                  init: init,
                  _blockHoist: 1.9
                });
                return uid;
              };
              File.prototype.errorWithNode = function errorWithNode(node, msg) {
                var Error = arguments.length <= 2 || arguments[2] === undefined ? SyntaxError : arguments[2];
                var err;
                var loc = node && (node.loc || node._loc);
                if (loc) {
                  err = new Error("Line " + loc.start.line + ": " + msg);
                  err.loc = loc.start;
                } else {
                  err = new Error("There's been an error on a dynamic node. This is almost certainly an internal error. Please report it.");
                }
                return err;
              };
              File.prototype.mergeSourceMap = function mergeSourceMap(map) {
                var opts = this.opts;
                var inputMap = opts.inputSourceMap;
                if (inputMap) {
                  map.sources[0] = inputMap.file;
                  var inputMapConsumer = new _sourceMap2["default"].SourceMapConsumer(inputMap);
                  var outputMapConsumer = new _sourceMap2["default"].SourceMapConsumer(map);
                  var outputMapGenerator = _sourceMap2["default"].SourceMapGenerator.fromSourceMap(outputMapConsumer);
                  outputMapGenerator.applySourceMap(inputMapConsumer);
                  var mergedMap = outputMapGenerator.toJSON();
                  mergedMap.sources = inputMap.sources;
                  mergedMap.file = inputMap.file;
                  return mergedMap;
                }
                return map;
              };
              File.prototype.getModuleFormatter = function getModuleFormatter(type) {
                if (_lodashLangIsFunction2["default"](type) || !_modules2["default"][type]) {
                  this.log.deprecate("Custom module formatters are deprecated and will be removed in the next major. Please use Babel plugins instead.");
                }
                var ModuleFormatter = _lodashLangIsFunction2["default"](type) ? type : _modules2["default"][type];
                if (!ModuleFormatter) {
                  var loc = _tryResolve2["default"].relative(type);
                  if (loc)
                    ModuleFormatter = require(loc);
                }
                if (!ModuleFormatter) {
                  throw new ReferenceError("Unknown module formatter type " + JSON.stringify(type));
                }
                return new ModuleFormatter(this);
              };
              File.prototype.parse = function parse(code) {
                var opts = this.opts;
                var parseOpts = {
                  highlightCode: opts.highlightCode,
                  nonStandard: opts.nonStandard,
                  sourceType: opts.sourceType,
                  filename: opts.filename,
                  plugins: {}
                };
                var features = parseOpts.features = {};
                for (var key in this.transformers) {
                  var transformer = this.transformers[key];
                  features[key] = transformer.canTransform();
                }
                parseOpts.looseModules = this.isLoose("es6.modules");
                parseOpts.strictMode = features.strict;
                this.log.debug("Parse start");
                var ast = _helpersParse2["default"](code, parseOpts);
                this.log.debug("Parse stop");
                return ast;
              };
              File.prototype._addAst = function _addAst(ast) {
                this.path = _traversalPath2["default"].get({
                  hub: this.hub,
                  parentPath: null,
                  parent: ast,
                  container: ast,
                  key: "program"
                }).setContext();
                this.scope = this.path.scope;
                this.ast = ast;
              };
              File.prototype.addAst = function addAst(ast) {
                this.log.debug("Start set AST");
                this._addAst(ast);
                this.log.debug("End set AST");
                this.log.debug("Start module formatter init");
                var modFormatter = this.moduleFormatter = this.getModuleFormatter(this.opts.modules);
                if (modFormatter.init && this.transformers["es6.modules"].canTransform()) {
                  modFormatter.init();
                }
                this.log.debug("End module formatter init");
              };
              File.prototype.transform = function transform() {
                this.call("pre");
                var _arr6 = this.transformerStack;
                for (var _i6 = 0; _i6 < _arr6.length; _i6++) {
                  var pass = _arr6[_i6];
                  pass.transform();
                }
                this.call("post");
                return this.generate();
              };
              File.prototype.wrap = function wrap(code, callback) {
                code = code + "";
                try {
                  if (this.shouldIgnore()) {
                    return this.makeResult({
                      code: code,
                      ignored: true
                    });
                  } else {
                    return callback();
                  }
                } catch (err) {
                  if (err._babel) {
                    throw err;
                  } else {
                    err._babel = true;
                  }
                  var message = err.message = this.opts.filename + ": " + err.message;
                  var loc = err.loc;
                  if (loc) {
                    err.codeFrame = _helpersCodeFrame2["default"](code, loc.line, loc.column + 1, this.opts);
                    message += "\n" + err.codeFrame;
                  }
                  if (process.browser) {
                    err.message = message;
                  }
                  if (err.stack) {
                    var newStack = err.stack.replace(err.message, message);
                    try {
                      err.stack = newStack;
                    } catch (e) {}
                  }
                  throw err;
                }
              };
              File.prototype.addCode = function addCode(code) {
                code = (code || "") + "";
                code = this.parseInputSourceMap(code);
                this.code = code;
              };
              File.prototype.parseCode = function parseCode() {
                this.parseShebang();
                var ast = this.parse(this.code);
                this.addAst(ast);
              };
              File.prototype.shouldIgnore = function shouldIgnore() {
                var opts = this.opts;
                return util.shouldIgnore(opts.filename, opts.ignore, opts.only);
              };
              File.prototype.call = function call(key) {
                var _arr7 = this.uncollapsedTransformerStack;
                for (var _i7 = 0; _i7 < _arr7.length; _i7++) {
                  var pass = _arr7[_i7];
                  var fn = pass.plugin[key];
                  if (fn)
                    fn(this);
                }
              };
              File.prototype.parseInputSourceMap = function parseInputSourceMap(code) {
                var opts = this.opts;
                if (opts.inputSourceMap !== false) {
                  var inputMap = _convertSourceMap2["default"].fromSource(code);
                  if (inputMap) {
                    opts.inputSourceMap = inputMap.toObject();
                    code = _convertSourceMap2["default"].removeComments(code);
                  }
                }
                return code;
              };
              File.prototype.parseShebang = function parseShebang() {
                var shebangMatch = _shebangRegex2["default"].exec(this.code);
                if (shebangMatch) {
                  this.shebang = shebangMatch[0];
                  this.code = this.code.replace(_shebangRegex2["default"], "");
                }
              };
              File.prototype.makeResult = function makeResult(_ref) {
                var code = _ref.code;
                var _ref$map = _ref.map;
                var map = _ref$map === undefined ? null : _ref$map;
                var ast = _ref.ast;
                var ignored = _ref.ignored;
                var result = {
                  metadata: null,
                  ignored: !!ignored,
                  code: null,
                  ast: null,
                  map: map
                };
                if (this.opts.code) {
                  result.code = code;
                }
                if (this.opts.ast) {
                  result.ast = ast;
                }
                if (this.opts.metadata) {
                  result.metadata = this.metadata;
                  result.metadata.usedHelpers = Object.keys(this.usedHelpers);
                }
                return result;
              };
              File.prototype.generate = function generate() {
                var opts = this.opts;
                var ast = this.ast;
                var result = {ast: ast};
                if (!opts.code)
                  return this.makeResult(result);
                this.log.debug("Generation start");
                var _result = _generation2["default"](ast, opts, this.code);
                result.code = _result.code;
                result.map = _result.map;
                this.log.debug("Generation end");
                if (this.shebang) {
                  result.code = this.shebang + "\n" + result.code;
                }
                if (result.map) {
                  result.map = this.mergeSourceMap(result.map);
                }
                if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
                  result.code += "\n" + _convertSourceMap2["default"].fromObject(result.map).toComment();
                }
                if (opts.sourceMaps === "inline") {
                  result.map = null;
                }
                return this.makeResult(result);
              };
              _createClass(File, null, [{
                key: "helpers",
                value: ["inherits", "defaults", "create-class", "create-decorated-class", "create-decorated-object", "define-decorated-property-descriptor", "tagged-template-literal", "tagged-template-literal-loose", "to-array", "to-consumable-array", "sliced-to-array", "sliced-to-array-loose", "object-without-properties", "has-own", "slice", "bind", "define-property", "async-to-generator", "interop-export-wildcard", "interop-require-wildcard", "interop-require-default", "typeof", "extends", "get", "set", "new-arrow-check", "class-call-check", "object-destructuring-empty", "temporal-undefined", "temporal-assert-defined", "self-global", "typeof-react-element", "default-props", "instanceof", "interop-require"],
                enumerable: true
              }, {
                key: "soloHelpers",
                value: [],
                enumerable: true
              }]);
              return File;
            })();
            exports["default"] = File;
            module.exports = exports["default"];
          }).call(this, require('_process'));
        }, {
          "../../generation": 47,
          "../../helpers/code-frame": 55,
          "../../helpers/parse": 59,
          "../../traversal": 165,
          "../../traversal/hub": 164,
          "../../traversal/path": 172,
          "../../types": 196,
          "../../util": 199,
          "../modules": 91,
          "../plugin": 99,
          "./logger": 64,
          "./options/option-manager": 67,
          "./plugin-manager": 69,
          "_process": 12,
          "convert-source-map": 225,
          "lodash/collection/includes": 430,
          "lodash/lang/isFunction": 517,
          "lodash/object/defaults": 527,
          "path": 11,
          "shebang-regex": 605,
          "source-map": 607,
          "try-resolve": 621
        }],
        64: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _debugNode = require("debug/node");
          var _debugNode2 = _interopRequireDefault(_debugNode);
          var verboseDebug = _debugNode2["default"]("babel:verbose");
          var generalDebug = _debugNode2["default"]("babel");
          var seenDeprecatedMessages = [];
          var Logger = (function() {
            function Logger(file, filename) {
              _classCallCheck(this, Logger);
              this.filename = filename;
              this.file = file;
            }
            Logger.prototype._buildMessage = function _buildMessage(msg) {
              var parts = "[BABEL] " + this.filename;
              if (msg)
                parts += ": " + msg;
              return parts;
            };
            Logger.prototype.warn = function warn(msg) {
              console.warn(this._buildMessage(msg));
            };
            Logger.prototype.error = function error(msg) {
              var Constructor = arguments.length <= 1 || arguments[1] === undefined ? Error : arguments[1];
              throw new Constructor(this._buildMessage(msg));
            };
            Logger.prototype.deprecate = function deprecate(msg) {
              if (this.file.opts && this.file.opts.suppressDeprecationMessages)
                return;
              msg = this._buildMessage(msg);
              if (seenDeprecatedMessages.indexOf(msg) >= 0)
                return;
              seenDeprecatedMessages.push(msg);
              console.error(msg);
            };
            Logger.prototype.verbose = function verbose(msg) {
              if (verboseDebug.enabled)
                verboseDebug(this._buildMessage(msg));
            };
            Logger.prototype.debug = function debug(msg) {
              if (generalDebug.enabled)
                generalDebug(this._buildMessage(msg));
            };
            Logger.prototype.deopt = function deopt(node, msg) {
              this.debug(msg);
            };
            return Logger;
          })();
          exports["default"] = Logger;
          module.exports = exports["default"];
        }, {"debug/node": 406}],
        65: [function(require, module, exports) {
          module.exports = {
            "filename": {
              "type": "filename",
              "description": "filename to use when reading from stdin - this will be used in source-maps, errors etc",
              "default": "unknown",
              "shorthand": "f"
            },
            "filenameRelative": {
              "hidden": true,
              "type": "string"
            },
            "inputSourceMap": {"hidden": true},
            "extra": {
              "hidden": true,
              "default": {}
            },
            "env": {
              "hidden": true,
              "default": {}
            },
            "moduleId": {
              "description": "specify a custom name for module ids",
              "type": "string"
            },
            "getModuleId": {"hidden": true},
            "retainLines": {
              "type": "boolean",
              "default": false,
              "description": "retain line numbers - will result in really ugly code"
            },
            "nonStandard": {
              "type": "boolean",
              "default": true,
              "description": "enable/disable support for JSX and Flow (on by default)"
            },
            "experimental": {
              "type": "boolean",
              "description": "allow use of experimental transformers",
              "default": false
            },
            "highlightCode": {
              "description": "enable/disable ANSI syntax highlighting of code frames (on by default)",
              "type": "boolean",
              "default": true
            },
            "suppressDeprecationMessages": {
              "type": "boolean",
              "default": false,
              "hidden": true
            },
            "resolveModuleSource": {"hidden": true},
            "stage": {
              "description": "ECMAScript proposal stage version to allow [0-4]",
              "shorthand": "e",
              "type": "number",
              "default": 2
            },
            "blacklist": {
              "type": "transformerList",
              "description": "blacklist of transformers to NOT use",
              "shorthand": "b",
              "default": []
            },
            "whitelist": {
              "type": "transformerList",
              "optional": true,
              "description": "whitelist of transformers to ONLY use",
              "shorthand": "l"
            },
            "optional": {
              "type": "transformerList",
              "description": "list of optional transformers to enable",
              "default": []
            },
            "modules": {
              "type": "string",
              "description": "module formatter type to use [common]",
              "default": "common",
              "shorthand": "m"
            },
            "moduleIds": {
              "type": "boolean",
              "default": false,
              "shorthand": "M",
              "description": "insert an explicit id for modules"
            },
            "loose": {
              "type": "transformerList",
              "description": "list of transformers to enable loose mode ON",
              "shorthand": "L"
            },
            "jsxPragma": {
              "type": "string",
              "description": "custom pragma to use with JSX (same functionality as @jsx comments)",
              "default": "React.createElement",
              "shorthand": "P"
            },
            "plugins": {
              "type": "list",
              "description": "",
              "default": []
            },
            "ignore": {
              "type": "list",
              "description": "list of glob paths to **not** compile",
              "default": []
            },
            "only": {
              "type": "list",
              "description": "list of glob paths to **only** compile"
            },
            "code": {
              "hidden": true,
              "default": true,
              "type": "boolean"
            },
            "metadata": {
              "hidden": true,
              "default": true,
              "type": "boolean"
            },
            "ast": {
              "hidden": true,
              "default": true,
              "type": "boolean"
            },
            "comments": {
              "type": "boolean",
              "default": true,
              "description": "strip/output comments in generated output (on by default)"
            },
            "shouldPrintComment": {
              "hidden": true,
              "description": "optional callback to control whether a comment should be inserted, when this is used the comments option is ignored"
            },
            "compact": {
              "type": "booleanString",
              "default": "auto",
              "description": "do not include superfluous whitespace characters and line terminators [true|false|auto]"
            },
            "keepModuleIdExtensions": {
              "type": "boolean",
              "description": "keep extensions when generating module ids",
              "default": false,
              "shorthand": "k"
            },
            "auxiliaryComment": {
              "deprecated": "renamed to auxiliaryCommentBefore",
              "shorthand": "a",
              "alias": "auxiliaryCommentBefore"
            },
            "auxiliaryCommentBefore": {
              "type": "string",
              "default": "",
              "description": "attach a comment before all helper declarations and auxiliary code"
            },
            "auxiliaryCommentAfter": {
              "type": "string",
              "default": "",
              "description": "attach a comment after all helper declarations and auxiliary code"
            },
            "externalHelpers": {
              "type": "boolean",
              "default": false,
              "shorthand": "r",
              "description": "uses a reference to `babelHelpers` instead of placing helpers at the top of your code."
            },
            "metadataUsedHelpers": {
              "deprecated": "Not required anymore as this is enabled by default",
              "type": "boolean",
              "default": false,
              "hidden": true
            },
            "sourceMap": {
              "alias": "sourceMaps",
              "hidden": true
            },
            "sourceMaps": {
              "type": "booleanString",
              "description": "[true|false|inline]",
              "default": false,
              "shorthand": "s"
            },
            "sourceMapName": {
              "alias": "sourceMapTarget",
              "description": "DEPRECATED - Please use sourceMapTarget"
            },
            "sourceMapTarget": {
              "type": "string",
              "description": "set `file` on returned source map"
            },
            "sourceFileName": {
              "type": "string",
              "description": "set `sources[0]` on returned source map"
            },
            "sourceRoot": {
              "type": "filename",
              "description": "the root from which all sources are relative"
            },
            "moduleRoot": {
              "type": "filename",
              "description": "optional prefix for the AMD module formatter that will be prepend to the filename on module definitions"
            },
            "breakConfig": {
              "type": "boolean",
              "default": false,
              "hidden": true,
              "description": "stop trying to load .babelrc files"
            },
            "babelrc": {
              "description": "Specify a custom list of babelrc files to use",
              "type": "list"
            },
            "sourceType": {
              "description": "",
              "default": "module"
            }
          };
        }, {}],
        66: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.validateOption = validateOption;
          exports.normaliseOptions = normaliseOptions;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _parsers = require("./parsers");
          var parsers = _interopRequireWildcard(_parsers);
          var _config = require("./config");
          var _config2 = _interopRequireDefault(_config);
          exports.config = _config2["default"];
          function validateOption(key, val, pipeline) {
            var opt = _config2["default"][key];
            var parser = opt && parsers[opt.type];
            if (parser && parser.validate) {
              return parser.validate(key, val, pipeline);
            } else {
              return val;
            }
          }
          function normaliseOptions() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
            for (var key in options) {
              var val = options[key];
              if (val == null)
                continue;
              var opt = _config2["default"][key];
              if (!opt)
                continue;
              var parser = parsers[opt.type];
              if (parser)
                val = parser(val);
              options[key] = val;
            }
            return options;
          }
        }, {
          "./config": 65,
          "./parsers": 68
        }],
        67: [function(require, module, exports) {
          (function(process) {
            "use strict";
            exports.__esModule = true;
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {"default": obj};
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var _index = require("./index");
            var _json5 = require("json5");
            var _json52 = _interopRequireDefault(_json5);
            var _pathIsAbsolute = require("path-is-absolute");
            var _pathIsAbsolute2 = _interopRequireDefault(_pathIsAbsolute);
            var _pathExists = require("path-exists");
            var _pathExists2 = _interopRequireDefault(_pathExists);
            var _lodashLangClone = require("lodash/lang/clone");
            var _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);
            var _helpersMerge = require("../../../helpers/merge");
            var _helpersMerge2 = _interopRequireDefault(_helpersMerge);
            var _config = require("./config");
            var _config2 = _interopRequireDefault(_config);
            var _path = require("path");
            var _path2 = _interopRequireDefault(_path);
            var _fs = require("fs");
            var _fs2 = _interopRequireDefault(_fs);
            var existsCache = {};
            var jsonCache = {};
            var BABELIGNORE_FILENAME = ".babelignore";
            var BABELRC_FILENAME = ".babelrc";
            var PACKAGE_FILENAME = "package.json";
            function exists(filename) {
              var cached = existsCache[filename];
              if (cached != null) {
                return cached;
              } else {
                return existsCache[filename] = _pathExists2["default"].sync(filename);
              }
            }
            var OptionManager = (function() {
              function OptionManager(log, pipeline) {
                _classCallCheck(this, OptionManager);
                this.resolvedConfigs = [];
                this.options = OptionManager.createBareOptions();
                this.pipeline = pipeline;
                this.log = log;
              }
              OptionManager.createBareOptions = function createBareOptions() {
                var opts = {};
                for (var key in _config2["default"]) {
                  var opt = _config2["default"][key];
                  opts[key] = _lodashLangClone2["default"](opt["default"]);
                }
                return opts;
              };
              OptionManager.prototype.addConfig = function addConfig(loc, key) {
                var json = arguments.length <= 2 || arguments[2] === undefined ? _json52["default"] : arguments[2];
                if (this.resolvedConfigs.indexOf(loc) >= 0)
                  return;
                var content = _fs2["default"].readFileSync(loc, "utf8");
                var opts;
                try {
                  opts = jsonCache[content] = jsonCache[content] || json.parse(content);
                  if (key)
                    opts = opts[key];
                } catch (err) {
                  err.message = loc + ": Error while parsing JSON - " + err.message;
                  throw err;
                }
                this.mergeOptions(opts, loc);
                this.resolvedConfigs.push(loc);
              };
              OptionManager.prototype.mergeOptions = function mergeOptions(opts) {
                var alias = arguments.length <= 1 || arguments[1] === undefined ? "foreign" : arguments[1];
                if (!opts)
                  return;
                for (var key in opts) {
                  if (key[0] === "_")
                    continue;
                  var option = _config2["default"][key];
                  if (!option)
                    this.log.error("Unknown option: " + alias + "." + key, ReferenceError);
                }
                _index.normaliseOptions(opts);
                _helpersMerge2["default"](this.options, opts);
              };
              OptionManager.prototype.addIgnoreConfig = function addIgnoreConfig(loc) {
                var file = _fs2["default"].readFileSync(loc, "utf8");
                var lines = file.split("\n");
                lines = lines.map(function(line) {
                  return line.replace(/#(.*?)$/, "").trim();
                }).filter(function(line) {
                  return !!line;
                });
                this.mergeOptions({ignore: lines}, loc);
              };
              OptionManager.prototype.findConfigs = function findConfigs(loc) {
                if (!loc)
                  return;
                if (!_pathIsAbsolute2["default"](loc)) {
                  loc = _path2["default"].join(process.cwd(), loc);
                }
                while (loc !== (loc = _path2["default"].dirname(loc))) {
                  if (this.options.breakConfig)
                    return;
                  var configLoc = _path2["default"].join(loc, BABELRC_FILENAME);
                  if (exists(configLoc))
                    this.addConfig(configLoc);
                  var pkgLoc = _path2["default"].join(loc, PACKAGE_FILENAME);
                  if (exists(pkgLoc))
                    this.addConfig(pkgLoc, "babel", JSON);
                  var ignoreLoc = _path2["default"].join(loc, BABELIGNORE_FILENAME);
                  if (exists(ignoreLoc))
                    this.addIgnoreConfig(ignoreLoc);
                }
              };
              OptionManager.prototype.normaliseOptions = function normaliseOptions() {
                var opts = this.options;
                for (var key in _config2["default"]) {
                  var option = _config2["default"][key];
                  var val = opts[key];
                  if (!val && option.optional)
                    continue;
                  if (this.log && val && option.deprecated) {
                    this.log.deprecate("Deprecated option " + key + ": " + option.deprecated);
                  }
                  if (this.pipeline && val) {
                    val = _index.validateOption(key, val, this.pipeline);
                  }
                  if (option.alias) {
                    opts[option.alias] = opts[option.alias] || val;
                  } else {
                    opts[key] = val;
                  }
                }
              };
              OptionManager.prototype.init = function init(opts) {
                this.mergeOptions(opts, "direct");
                if (opts.babelrc) {
                  var _arr = opts.babelrc;
                  for (var _i = 0; _i < _arr.length; _i++) {
                    var loc = _arr[_i];
                    this.addConfig(loc);
                  }
                }
                if (opts.babelrc !== false) {
                  this.findConfigs(opts.filename);
                }
                var envKey = process.env.BABEL_ENV || process.env.NODE_ENV || "development";
                if (this.options.env) {
                  this.mergeOptions(this.options.env[envKey], "direct.env." + envKey);
                }
                this.normaliseOptions(opts);
                return this.options;
              };
              return OptionManager;
            })();
            exports["default"] = OptionManager;
            module.exports = exports["default"];
          }).call(this, require('_process'));
        }, {
          "../../../helpers/merge": 56,
          "./config": 65,
          "./index": 66,
          "_process": 12,
          "fs": 1,
          "json5": 419,
          "lodash/lang/clone": 511,
          "path": 11,
          "path-exists": 543,
          "path-is-absolute": 544
        }],
        68: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.transformerList = transformerList;
          exports.number = number;
          exports.boolean = boolean;
          exports.booleanString = booleanString;
          exports.list = list;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _slash = require("slash");
          var _slash2 = _interopRequireDefault(_slash);
          var _util = require("../../../util");
          var util = _interopRequireWildcard(_util);
          function transformerList(val) {
            return util.arrayify(val);
          }
          transformerList.validate = function(key, val, pipeline) {
            if (val.indexOf("all") >= 0 || val.indexOf(true) >= 0) {
              val = Object.keys(pipeline.transformers);
            }
            return pipeline._ensureTransformerNames(key, val);
          };
          function number(val) {
            return +val;
          }
          var filename = _slash2["default"];
          exports.filename = filename;
          function boolean(val) {
            return !!val;
          }
          function booleanString(val) {
            return util.booleanify(val);
          }
          function list(val) {
            return util.list(val);
          }
        }, {
          "../../../util": 199,
          "slash": 606
        }],
        69: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _transformer = require("../transformer");
          var _transformer2 = _interopRequireDefault(_transformer);
          var _plugin = require("../plugin");
          var _plugin2 = _interopRequireDefault(_plugin);
          var _types = require("../../types");
          var types = _interopRequireWildcard(_types);
          var _messages = require("../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _tryResolve = require("try-resolve");
          var _tryResolve2 = _interopRequireDefault(_tryResolve);
          var _traversal = require("../../traversal");
          var _traversal2 = _interopRequireDefault(_traversal);
          var _helpersParse = require("../../helpers/parse");
          var _helpersParse2 = _interopRequireDefault(_helpersParse);
          var context = {
            messages: messages,
            Transformer: _transformer2["default"],
            Plugin: _plugin2["default"],
            types: types,
            parse: _helpersParse2["default"],
            traverse: _traversal2["default"]
          };
          var PluginManager = (function() {
            PluginManager.memoisePluginContainer = function memoisePluginContainer(fn) {
              for (var i = 0; i < PluginManager.memoisedPlugins.length; i++) {
                var plugin = PluginManager.memoisedPlugins[i];
                if (plugin.container === fn)
                  return plugin.transformer;
              }
              var transformer = fn(context);
              PluginManager.memoisedPlugins.push({
                container: fn,
                transformer: transformer
              });
              return transformer;
            };
            _createClass(PluginManager, null, [{
              key: "memoisedPlugins",
              value: [],
              enumerable: true
            }, {
              key: "positions",
              value: ["before", "after"],
              enumerable: true
            }]);
            function PluginManager() {
              var _ref = arguments.length <= 0 || arguments[0] === undefined ? {
                transformers: {},
                before: [],
                after: []
              } : arguments[0];
              var file = _ref.file;
              var transformers = _ref.transformers;
              var before = _ref.before;
              var after = _ref.after;
              _classCallCheck(this, PluginManager);
              this.transformers = transformers;
              this.file = file;
              this.before = before;
              this.after = after;
            }
            PluginManager.prototype.subnormaliseString = function subnormaliseString(name, position) {
              var match = name.match(/^(.*?):(after|before)$/);
              if (match) {
                ;
                name = match[1];
                position = match[2];
              }
              var loc = _tryResolve2["default"].relative("babel-plugin-" + name) || _tryResolve2["default"].relative(name);
              if (loc) {
                var plugin = require(loc);
                return {
                  position: position,
                  plugin: plugin["default"] || plugin
                };
              } else {
                throw new ReferenceError(messages.get("pluginUnknown", name));
              }
            };
            PluginManager.prototype.validate = function validate(name, plugin) {
              var key = plugin.key;
              if (this.transformers[key]) {
                throw new ReferenceError(messages.get("pluginKeyCollision", key));
              }
              if (!plugin.buildPass || plugin.constructor.name !== "Plugin") {
                throw new TypeError(messages.get("pluginNotTransformer", name));
              }
              plugin.metadata.plugin = true;
            };
            PluginManager.prototype.add = function add(name) {
              var position;
              var plugin;
              if (name) {
                if (typeof name === "object" && name.transformer) {
                  plugin = name.transformer;
                  position = name.position;
                } else if (typeof name !== "string") {
                  plugin = name;
                }
                if (typeof name === "string") {
                  var _subnormaliseString = this.subnormaliseString(name, position);
                  plugin = _subnormaliseString.plugin;
                  position = _subnormaliseString.position;
                }
              } else {
                throw new TypeError(messages.get("pluginIllegalKind", typeof name, name));
              }
              position = position || "before";
              if (PluginManager.positions.indexOf(position) < 0) {
                throw new TypeError(messages.get("pluginIllegalPosition", position, name));
              }
              if (typeof plugin === "function") {
                plugin = PluginManager.memoisePluginContainer(plugin);
              }
              this.validate(name, plugin);
              var pass = this.transformers[plugin.key] = plugin.buildPass(this.file);
              if (pass.canTransform()) {
                var stack = position === "before" ? this.before : this.after;
                stack.push(pass);
              }
            };
            return PluginManager;
          })();
          exports["default"] = PluginManager;
          module.exports = exports["default"];
        }, {
          "../../helpers/parse": 59,
          "../../messages": 60,
          "../../traversal": 165,
          "../../types": 196,
          "../plugin": 99,
          "../transformer": 100,
          "try-resolve": 621
        }],
        70: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _explodeAssignableExpression = require("./explode-assignable-expression");
          var _explodeAssignableExpression2 = _interopRequireDefault(_explodeAssignableExpression);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          exports["default"] = function(opts) {
            var exports = {};
            var isAssignment = function isAssignment(node) {
              return node.operator === opts.operator + "=";
            };
            var buildAssignment = function buildAssignment(left, right) {
              return t.assignmentExpression("=", left, right);
            };
            exports.ExpressionStatement = function(node, parent, scope, file) {
              if (this.isCompletionRecord())
                return;
              var expr = node.expression;
              if (!isAssignment(expr))
                return;
              var nodes = [];
              var exploded = _explodeAssignableExpression2["default"](expr.left, nodes, file, scope, true);
              nodes.push(t.expressionStatement(buildAssignment(exploded.ref, opts.build(exploded.uid, expr.right))));
              return nodes;
            };
            exports.AssignmentExpression = function(node, parent, scope, file) {
              if (!isAssignment(node))
                return;
              var nodes = [];
              var exploded = _explodeAssignableExpression2["default"](node.left, nodes, file, scope);
              nodes.push(buildAssignment(exploded.ref, opts.build(exploded.uid, node.right)));
              return nodes;
            };
            exports.BinaryExpression = function(node) {
              if (node.operator !== opts.operator)
                return;
              return opts.build(node.left, node.right);
            };
            return exports;
          };
          module.exports = exports["default"];
        }, {
          "../../types": 196,
          "./explode-assignable-expression": 75
        }],
        71: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports["default"] = build;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function build(node, buildBody) {
            var self = node.blocks.shift();
            if (!self)
              return;
            var child = build(node, buildBody);
            if (!child) {
              child = buildBody();
              if (node.filter) {
                child = t.ifStatement(node.filter, t.blockStatement([child]));
              }
            }
            return t.forOfStatement(t.variableDeclaration("let", [t.variableDeclarator(self.left)]), self.right, t.blockStatement([child]));
          }
          module.exports = exports["default"];
        }, {"../../types": 196}],
        72: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashLangIsString = require("lodash/lang/isString");
          var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
          var _messages = require("../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _esutils = require("esutils");
          var _esutils2 = _interopRequireDefault(_esutils);
          var _react = require("./react");
          var react = _interopRequireWildcard(_react);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          exports["default"] = function(opts) {
            var visitor = {};
            visitor.JSXIdentifier = function(node) {
              if (node.name === "this" && this.isReferenced()) {
                return t.thisExpression();
              } else if (_esutils2["default"].keyword.isIdentifierNameES6(node.name)) {
                node.type = "Identifier";
              } else {
                return t.literal(node.name);
              }
            };
            visitor.JSXNamespacedName = function() {
              throw this.errorWithNode(messages.get("JSXNamespacedTags"));
            };
            visitor.JSXMemberExpression = {exit: function exit(node) {
                node.computed = t.isLiteral(node.property);
                node.type = "MemberExpression";
              }};
            visitor.JSXExpressionContainer = function(node) {
              return node.expression;
            };
            visitor.JSXAttribute = {
              enter: function enter(node) {
                var value = node.value;
                if (t.isLiteral(value) && _lodashLangIsString2["default"](value.value)) {
                  value.value = value.value.replace(/\n\s+/g, " ");
                }
              },
              exit: function exit(node) {
                var value = node.value || t.literal(true);
                return t.inherits(t.property("init", node.name, value), node);
              }
            };
            visitor.JSXOpeningElement = {exit: function exit(node, parent, scope, file) {
                parent.children = react.buildChildren(parent);
                var tagExpr = node.name;
                var args = [];
                var tagName;
                if (t.isIdentifier(tagExpr)) {
                  tagName = tagExpr.name;
                } else if (t.isLiteral(tagExpr)) {
                  tagName = tagExpr.value;
                }
                var state = {
                  tagExpr: tagExpr,
                  tagName: tagName,
                  args: args
                };
                if (opts.pre) {
                  opts.pre(state, file);
                }
                var attribs = node.attributes;
                if (attribs.length) {
                  attribs = buildJSXOpeningElementAttributes(attribs, file);
                } else {
                  attribs = t.literal(null);
                }
                args.push(attribs);
                if (opts.post) {
                  opts.post(state, file);
                }
                return state.call || t.callExpression(state.callee, args);
              }};
            var buildJSXOpeningElementAttributes = function buildJSXOpeningElementAttributes(attribs, file) {
              var _props = [];
              var objs = [];
              var pushProps = function pushProps() {
                if (!_props.length)
                  return;
                objs.push(t.objectExpression(_props));
                _props = [];
              };
              while (attribs.length) {
                var prop = attribs.shift();
                if (t.isJSXSpreadAttribute(prop)) {
                  pushProps();
                  objs.push(prop.argument);
                } else {
                  _props.push(prop);
                }
              }
              pushProps();
              if (objs.length === 1) {
                attribs = objs[0];
              } else {
                if (!t.isObjectExpression(objs[0])) {
                  objs.unshift(t.objectExpression([]));
                }
                attribs = t.callExpression(file.addHelper("extends"), objs);
              }
              return attribs;
            };
            visitor.JSXElement = {exit: function exit(node) {
                var callExpr = node.openingElement;
                callExpr.arguments = callExpr.arguments.concat(node.children);
                if (callExpr.arguments.length >= 3) {
                  callExpr._prettyCall = true;
                }
                return t.inherits(callExpr, node);
              }};
            return visitor;
          };
          module.exports = exports["default"];
        }, {
          "../../messages": 60,
          "../../types": 196,
          "./react": 79,
          "esutils": 412,
          "lodash/lang/isString": 523
        }],
        73: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var visitor = {
            enter: function enter(node, parent, scope, state) {
              if (this.isThisExpression() || this.isReferencedIdentifier({name: "arguments"})) {
                state.found = true;
                this.stop();
              }
            },
            Function: function Function() {
              this.skip();
            }
          };
          exports["default"] = function(node, scope) {
            var container = t.functionExpression(null, [], node.body, node.generator, node.async);
            var callee = container;
            var args = [];
            var state = {found: false};
            scope.traverse(node, visitor, state);
            if (state.found) {
              callee = t.memberExpression(container, t.identifier("apply"));
              args = [t.thisExpression(), t.identifier("arguments")];
            }
            var call = t.callExpression(callee, args);
            if (node.generator)
              call = t.yieldExpression(call, true);
            return t.returnStatement(call);
          };
          module.exports = exports["default"];
        }, {"../../types": 196}],
        74: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.push = push;
          exports.hasComputed = hasComputed;
          exports.toComputedObjectFromClass = toComputedObjectFromClass;
          exports.toClassObject = toClassObject;
          exports.toDefineObject = toDefineObject;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashCollectionEach = require("lodash/collection/each");
          var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
          var _lodashObjectHas = require("lodash/object/has");
          var _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function push(mutatorMap, node, kind, file) {
            var alias = t.toKeyAlias(node);
            var map = {};
            if (_lodashObjectHas2["default"](mutatorMap, alias))
              map = mutatorMap[alias];
            mutatorMap[alias] = map;
            map._inherits = map._inherits || [];
            map._inherits.push(node);
            map._key = node.key;
            if (node.computed) {
              map._computed = true;
            }
            if (node.decorators) {
              var decorators = map.decorators = map.decorators || t.arrayExpression([]);
              decorators.elements = decorators.elements.concat(node.decorators.map(function(dec) {
                return dec.expression;
              }).reverse());
            }
            if (map.value || map.initializer) {
              throw file.errorWithNode(node, "Key conflict with sibling node");
            }
            if (node.value) {
              if (node.kind === "init")
                kind = "value";
              if (node.kind === "get")
                kind = "get";
              if (node.kind === "set")
                kind = "set";
              t.inheritsComments(node.value, node);
              map[kind] = node.value;
            }
            return map;
          }
          function hasComputed(mutatorMap) {
            for (var key in mutatorMap) {
              if (mutatorMap[key]._computed) {
                return true;
              }
            }
            return false;
          }
          function toComputedObjectFromClass(obj) {
            var objExpr = t.arrayExpression([]);
            for (var i = 0; i < obj.properties.length; i++) {
              var prop = obj.properties[i];
              var val = prop.value;
              val.properties.unshift(t.property("init", t.identifier("key"), t.toComputedKey(prop)));
              objExpr.elements.push(val);
            }
            return objExpr;
          }
          function toClassObject(mutatorMap) {
            var objExpr = t.objectExpression([]);
            _lodashCollectionEach2["default"](mutatorMap, function(map) {
              var mapNode = t.objectExpression([]);
              var propNode = t.property("init", map._key, mapNode, map._computed);
              _lodashCollectionEach2["default"](map, function(node, key) {
                if (key[0] === "_")
                  return;
                var inheritNode = node;
                if (t.isMethodDefinition(node) || t.isClassProperty(node))
                  node = node.value;
                var prop = t.property("init", t.identifier(key), node);
                t.inheritsComments(prop, inheritNode);
                t.removeComments(inheritNode);
                mapNode.properties.push(prop);
              });
              objExpr.properties.push(propNode);
            });
            return objExpr;
          }
          function toDefineObject(mutatorMap) {
            _lodashCollectionEach2["default"](mutatorMap, function(map) {
              if (map.value)
                map.writable = t.literal(true);
              map.configurable = t.literal(true);
              map.enumerable = t.literal(true);
            });
            return toClassObject(mutatorMap);
          }
        }, {
          "../../types": 196,
          "lodash/collection/each": 428,
          "lodash/object/has": 529
        }],
        75: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var getObjRef = function getObjRef(node, nodes, file, scope) {
            var ref;
            if (t.isIdentifier(node)) {
              if (scope.hasBinding(node.name)) {
                return node;
              } else {
                ref = node;
              }
            } else if (t.isMemberExpression(node)) {
              ref = node.object;
              if (t.isIdentifier(ref) && scope.hasGlobal(ref.name)) {
                return ref;
              }
            } else {
              throw new Error("We can't explode this node type " + node.type);
            }
            var temp = scope.generateUidIdentifierBasedOnNode(ref);
            nodes.push(t.variableDeclaration("var", [t.variableDeclarator(temp, ref)]));
            return temp;
          };
          var getPropRef = function getPropRef(node, nodes, file, scope) {
            var prop = node.property;
            var key = t.toComputedKey(node, prop);
            if (t.isLiteral(key))
              return key;
            var temp = scope.generateUidIdentifierBasedOnNode(prop);
            nodes.push(t.variableDeclaration("var", [t.variableDeclarator(temp, prop)]));
            return temp;
          };
          exports["default"] = function(node, nodes, file, scope, allowedSingleIdent) {
            var obj;
            if (t.isIdentifier(node) && allowedSingleIdent) {
              obj = node;
            } else {
              obj = getObjRef(node, nodes, file, scope);
            }
            var ref,
                uid;
            if (t.isIdentifier(node)) {
              ref = node;
              uid = obj;
            } else {
              var prop = getPropRef(node, nodes, file, scope);
              var computed = node.computed || t.isLiteral(prop);
              uid = ref = t.memberExpression(obj, prop, computed);
            }
            return {
              uid: uid,
              ref: ref
            };
          };
          module.exports = exports["default"];
        }, {"../../types": 196}],
        76: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          exports["default"] = function(node) {
            var lastNonDefault = 0;
            for (var i = 0; i < node.params.length; i++) {
              var param = node.params[i];
              if (!t.isAssignmentPattern(param) && !t.isRestElement(param)) {
                lastNonDefault = i + 1;
              }
            }
            return lastNonDefault;
          };
          module.exports = exports["default"];
        }, {"../../types": 196}],
        77: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          exports["default"] = function(decorators, scope) {
            for (var i = 0; i < decorators.length; i++) {
              var decorator = decorators[i];
              var expression = decorator.expression;
              if (!t.isMemberExpression(expression))
                continue;
              var temp = scope.maybeGenerateMemoised(expression.object);
              var ref;
              var nodes = [];
              if (temp) {
                ref = temp;
                nodes.push(t.assignmentExpression("=", temp, expression.object));
              } else {
                ref = expression.object;
              }
              nodes.push(t.callExpression(t.memberExpression(t.memberExpression(ref, expression.property, expression.computed), t.identifier("bind")), [ref]));
              if (nodes.length === 1) {
                decorator.expression = nodes[0];
              } else {
                decorator.expression = t.sequenceExpression(nodes);
              }
            }
            return decorators;
          };
          module.exports = exports["default"];
        }, {"../../types": 196}],
        78: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.custom = custom;
          exports.property = property;
          exports.bare = bare;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _getFunctionArity = require("./get-function-arity");
          var _getFunctionArity2 = _interopRequireDefault(_getFunctionArity);
          var _util = require("../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function visitIdentifier(context, node, scope, state) {
            if (node.name !== state.name)
              return;
            var localDeclar = scope.getBindingIdentifier(state.name);
            if (localDeclar !== state.outerDeclar)
              return;
            state.selfReference = true;
            context.stop();
          }
          var visitor = {
            ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              visitIdentifier(this, node, scope, state);
            },
            BindingIdentifier: function BindingIdentifier(node, parent, scope, state) {
              visitIdentifier(this, node, scope, state);
            }
          };
          var wrap = function wrap(state, method, id, scope) {
            if (state.selfReference) {
              if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
                scope.rename(id.name);
              } else {
                var templateName = "property-method-assignment-wrapper";
                if (method.generator)
                  templateName += "-generator";
                var template = util.template(templateName, {
                  FUNCTION: method,
                  FUNCTION_ID: id,
                  FUNCTION_KEY: scope.generateUidIdentifier(id.name)
                });
                template.callee._skipModulesRemap = true;
                var params = template.callee.body.body[0].params;
                for (var i = 0,
                    len = _getFunctionArity2["default"](method); i < len; i++) {
                  params.push(scope.generateUidIdentifier("x"));
                }
                return template;
              }
            }
            method.id = id;
            scope.getProgramParent().references[id.name] = true;
          };
          var visit = function visit(node, name, scope) {
            var state = {
              selfAssignment: false,
              selfReference: false,
              outerDeclar: scope.getBindingIdentifier(name),
              references: [],
              name: name
            };
            var binding = scope.getOwnBinding(name);
            if (binding) {
              if (binding.kind === "param") {
                state.selfReference = true;
              } else {}
            } else if (state.outerDeclar || scope.hasGlobal(name)) {
              scope.traverse(node, visitor, state);
            }
            return state;
          };
          function custom(node, id, scope) {
            var state = visit(node, id.name, scope);
            return wrap(state, node, id, scope);
          }
          function property(node, file, scope) {
            var key = t.toComputedKey(node, node.key);
            if (!t.isLiteral(key))
              return;
            var name = t.toBindingIdentifierName(key.value);
            var id = t.identifier(name);
            var method = node.value;
            var state = visit(method, name, scope);
            node.value = wrap(state, method, id, scope) || method;
          }
          function bare(node, parent, scope) {
            if (node.id)
              return;
            var id;
            if (t.isProperty(parent) && parent.kind === "init" && (!parent.computed || t.isLiteral(parent.key))) {
              id = parent.key;
            } else if (t.isVariableDeclarator(parent)) {
              id = parent.id;
              if (t.isIdentifier(id)) {
                var binding = scope.parent.getBinding(id.name);
                if (binding && binding.constant && scope.getBinding(id.name) === binding) {
                  node.id = id;
                  return;
                }
              }
            } else {
              return;
            }
            var name;
            if (t.isLiteral(id)) {
              name = id.value;
            } else if (t.isIdentifier(id)) {
              name = id.name;
            } else {
              return;
            }
            name = t.toBindingIdentifierName(name);
            id = t.identifier(name);
            var state = visit(node, name, scope);
            return wrap(state, node, id, scope);
          }
        }, {
          "../../types": 196,
          "../../util": 199,
          "./get-function-arity": 76
        }],
        79: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.isCompatTag = isCompatTag;
          exports.buildChildren = buildChildren;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var isReactComponent = t.buildMatchMemberExpression("React.Component");
          exports.isReactComponent = isReactComponent;
          function isCompatTag(tagName) {
            return tagName && /^[a-z]|\-/.test(tagName);
          }
          function cleanJSXElementLiteralChild(child, args) {
            var lines = child.value.split(/\r\n|\n|\r/);
            var lastNonEmptyLine = 0;
            for (var i = 0; i < lines.length; i++) {
              if (lines[i].match(/[^ \t]/)) {
                lastNonEmptyLine = i;
              }
            }
            var str = "";
            for (var i = 0; i < lines.length; i++) {
              var line = lines[i];
              var isFirstLine = i === 0;
              var isLastLine = i === lines.length - 1;
              var isLastNonEmptyLine = i === lastNonEmptyLine;
              var trimmedLine = line.replace(/\t/g, " ");
              if (!isFirstLine) {
                trimmedLine = trimmedLine.replace(/^[ ]+/, "");
              }
              if (!isLastLine) {
                trimmedLine = trimmedLine.replace(/[ ]+$/, "");
              }
              if (trimmedLine) {
                if (!isLastNonEmptyLine) {
                  trimmedLine += " ";
                }
                str += trimmedLine;
              }
            }
            if (str)
              args.push(t.literal(str));
          }
          function buildChildren(node) {
            var elems = [];
            for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              if (t.isLiteral(child) && typeof child.value === "string") {
                cleanJSXElementLiteralChild(child, elems);
                continue;
              }
              if (t.isJSXExpressionContainer(child))
                child = child.expression;
              if (t.isJSXEmptyExpression(child))
                continue;
              elems.push(child);
            }
            return elems;
          }
        }, {"../../types": 196}],
        80: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.is = is;
          exports.pullFlag = pullFlag;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashArrayPull = require("lodash/array/pull");
          var _lodashArrayPull2 = _interopRequireDefault(_lodashArrayPull);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function is(node, flag) {
            return t.isLiteral(node) && node.regex && node.regex.flags.indexOf(flag) >= 0;
          }
          function pullFlag(node, flag) {
            var flags = node.regex.flags.split("");
            if (node.regex.flags.indexOf(flag) < 0)
              return;
            _lodashArrayPull2["default"](flags, flag);
            node.regex.flags = flags.join("");
          }
        }, {
          "../../types": 196,
          "lodash/array/pull": 425
        }],
        81: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var awaitVisitor = {
            Function: function Function() {
              this.skip();
            },
            AwaitExpression: function AwaitExpression(node) {
              node.type = "YieldExpression";
              if (node.all) {
                node.all = false;
                node.argument = t.callExpression(t.memberExpression(t.identifier("Promise"), t.identifier("all")), [node.argument]);
              }
            }
          };
          var referenceVisitor = {ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              var name = state.id.name;
              if (node.name === name && scope.bindingIdentifierEquals(name, state.id)) {
                return state.ref = state.ref || scope.generateUidIdentifier(name);
              }
            }};
          exports["default"] = function(path, callId) {
            var node = path.node;
            node.async = false;
            node.generator = true;
            path.traverse(awaitVisitor, state);
            var call = t.callExpression(callId, [node]);
            var id = node.id;
            node.id = null;
            if (t.isFunctionDeclaration(node)) {
              var declar = t.variableDeclaration("let", [t.variableDeclarator(id, call)]);
              declar._blockHoist = true;
              return declar;
            } else {
              if (id) {
                var state = {id: id};
                path.traverse(referenceVisitor, state);
                if (state.ref) {
                  path.scope.parent.push({id: state.ref});
                  return t.assignmentExpression("=", state.ref, call);
                }
              }
              return call;
            }
          };
          module.exports = exports["default"];
        }, {"../../types": 196}],
        82: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _messages = require("../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function isIllegalBareSuper(node, parent) {
            if (!t.isSuper(node))
              return false;
            if (t.isMemberExpression(parent, {computed: false}))
              return false;
            if (t.isCallExpression(parent, {callee: node}))
              return false;
            return true;
          }
          function isMemberExpressionSuper(node) {
            return t.isMemberExpression(node) && t.isSuper(node.object);
          }
          var visitor = {enter: function enter(node, parent, scope, state) {
              var topLevel = state.topLevel;
              var self = state.self;
              if (t.isFunction(node) && !t.isArrowFunctionExpression(node)) {
                self.traverseLevel(this, false);
                return this.skip();
              }
              if (t.isProperty(node, {method: true}) || t.isMethodDefinition(node)) {
                return this.skip();
              }
              var getThisReference = topLevel ? t.thisExpression : self.getThisReference.bind(self);
              var callback = self.specHandle;
              if (self.isLoose)
                callback = self.looseHandle;
              var result = callback.call(self, this, getThisReference);
              if (result)
                this.hasSuper = true;
              if (result === true)
                return;
              return result;
            }};
          var ReplaceSupers = (function() {
            function ReplaceSupers(opts) {
              var inClass = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
              _classCallCheck(this, ReplaceSupers);
              this.topLevelThisReference = opts.topLevelThisReference;
              this.methodPath = opts.methodPath;
              this.methodNode = opts.methodNode;
              this.superRef = opts.superRef;
              this.isStatic = opts.isStatic;
              this.hasSuper = false;
              this.inClass = inClass;
              this.isLoose = opts.isLoose;
              this.scope = opts.scope;
              this.file = opts.file;
              this.opts = opts;
            }
            ReplaceSupers.prototype.getObjectRef = function getObjectRef() {
              return this.opts.objectRef || this.opts.getObjectRef();
            };
            ReplaceSupers.prototype.setSuperProperty = function setSuperProperty(property, value, isComputed, thisExpression) {
              return t.callExpression(this.file.addHelper("set"), [t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("getPrototypeOf")), [this.isStatic ? this.getObjectRef() : t.memberExpression(this.getObjectRef(), t.identifier("prototype"))]), isComputed ? property : t.literal(property.name), value, thisExpression]);
            };
            ReplaceSupers.prototype.getSuperProperty = function getSuperProperty(property, isComputed, thisExpression) {
              return t.callExpression(this.file.addHelper("get"), [t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("getPrototypeOf")), [this.isStatic ? this.getObjectRef() : t.memberExpression(this.getObjectRef(), t.identifier("prototype"))]), isComputed ? property : t.literal(property.name), thisExpression]);
            };
            ReplaceSupers.prototype.replace = function replace() {
              this.traverseLevel(this.methodPath.get("value"), true);
            };
            ReplaceSupers.prototype.traverseLevel = function traverseLevel(path, topLevel) {
              var state = {
                self: this,
                topLevel: topLevel
              };
              path.traverse(visitor, state);
            };
            ReplaceSupers.prototype.getThisReference = function getThisReference() {
              if (this.topLevelThisReference) {
                return this.topLevelThisReference;
              } else {
                var ref = this.topLevelThisReference = this.scope.generateUidIdentifier("this");
                this.methodNode.value.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(this.topLevelThisReference, t.thisExpression())]));
                return ref;
              }
            };
            ReplaceSupers.prototype.getLooseSuperProperty = function getLooseSuperProperty(id, parent) {
              var methodNode = this.methodNode;
              var methodName = methodNode.key;
              var superRef = this.superRef || t.identifier("Function");
              if (parent.property === id) {
                return;
              } else if (t.isCallExpression(parent, {callee: id})) {
                parent.arguments.unshift(t.thisExpression());
                if (methodName.name === "constructor") {
                  if (parent.arguments.length === 2 && t.isSpreadElement(parent.arguments[1]) && t.isIdentifier(parent.arguments[1].argument, {name: "arguments"})) {
                    parent.arguments[1] = parent.arguments[1].argument;
                    return t.memberExpression(superRef, t.identifier("apply"));
                  } else {
                    return t.memberExpression(superRef, t.identifier("call"));
                  }
                } else {
                  id = superRef;
                  if (!methodNode["static"]) {
                    id = t.memberExpression(id, t.identifier("prototype"));
                  }
                  id = t.memberExpression(id, methodName, methodNode.computed);
                  return t.memberExpression(id, t.identifier("call"));
                }
              } else if (t.isMemberExpression(parent) && !methodNode["static"]) {
                return t.memberExpression(superRef, t.identifier("prototype"));
              } else {
                return superRef;
              }
            };
            ReplaceSupers.prototype.looseHandle = function looseHandle(path, getThisReference) {
              var node = path.node;
              if (path.isSuper()) {
                return this.getLooseSuperProperty(node, path.parent);
              } else if (path.isCallExpression()) {
                var callee = node.callee;
                if (!t.isMemberExpression(callee))
                  return;
                if (!t.isSuper(callee.object))
                  return;
                t.appendToMemberExpression(callee, t.identifier("call"));
                node.arguments.unshift(getThisReference());
                return true;
              }
            };
            ReplaceSupers.prototype.specHandleAssignmentExpression = function specHandleAssignmentExpression(ref, path, node, getThisReference) {
              if (node.operator === "=") {
                return this.setSuperProperty(node.left.property, node.right, node.left.computed, getThisReference());
              } else {
                ref = ref || path.scope.generateUidIdentifier("ref");
                return [t.variableDeclaration("var", [t.variableDeclarator(ref, node.left)]), t.expressionStatement(t.assignmentExpression("=", node.left, t.binaryExpression(node.operator[0], ref, node.right)))];
              }
            };
            ReplaceSupers.prototype.specHandle = function specHandle(path, getThisReference) {
              var methodNode = this.methodNode;
              var property;
              var computed;
              var args;
              var thisReference;
              var parent = path.parent;
              var node = path.node;
              if (isIllegalBareSuper(node, parent)) {
                throw path.errorWithNode(messages.get("classesIllegalBareSuper"));
              }
              if (t.isCallExpression(node)) {
                var callee = node.callee;
                if (t.isSuper(callee)) {
                  property = methodNode.key;
                  computed = methodNode.computed;
                  args = node.arguments;
                  if (methodNode.key.name !== "constructor" || !this.inClass) {
                    var methodName = methodNode.key.name || "METHOD_NAME";
                    throw this.file.errorWithNode(node, messages.get("classesIllegalSuperCall", methodName));
                  }
                } else if (isMemberExpressionSuper(callee)) {
                  property = callee.property;
                  computed = callee.computed;
                  args = node.arguments;
                }
              } else if (t.isMemberExpression(node) && t.isSuper(node.object)) {
                property = node.property;
                computed = node.computed;
              } else if (t.isUpdateExpression(node) && isMemberExpressionSuper(node.argument)) {
                var binary = t.binaryExpression(node.operator[0], node.argument, t.literal(1));
                if (node.prefix) {
                  return this.specHandleAssignmentExpression(null, path, binary, getThisReference);
                } else {
                  var ref = path.scope.generateUidIdentifier("ref");
                  return this.specHandleAssignmentExpression(ref, path, binary, getThisReference).concat(t.expressionStatement(ref));
                }
              } else if (t.isAssignmentExpression(node) && isMemberExpressionSuper(node.left)) {
                return this.specHandleAssignmentExpression(null, path, node, getThisReference);
              }
              if (!property)
                return;
              thisReference = getThisReference();
              var superProperty = this.getSuperProperty(property, computed, thisReference);
              if (args) {
                if (args.length === 1 && t.isSpreadElement(args[0])) {
                  return t.callExpression(t.memberExpression(superProperty, t.identifier("apply")), [thisReference, args[0].argument]);
                } else {
                  return t.callExpression(t.memberExpression(superProperty, t.identifier("call")), [thisReference].concat(args));
                }
              } else {
                return superProperty;
              }
            };
            return ReplaceSupers;
          })();
          exports["default"] = ReplaceSupers;
          module.exports = exports["default"];
        }, {
          "../../messages": 60,
          "../../types": 196
        }],
        83: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _pipeline = require("./pipeline");
          var _pipeline2 = _interopRequireDefault(_pipeline);
          var _transformers = require("./transformers");
          var _transformers2 = _interopRequireDefault(_transformers);
          var _transformersDeprecated = require("./transformers/deprecated");
          var _transformersDeprecated2 = _interopRequireDefault(_transformersDeprecated);
          var _transformersAliases = require("./transformers/aliases");
          var _transformersAliases2 = _interopRequireDefault(_transformersAliases);
          var _transformersFilters = require("./transformers/filters");
          var filters = _interopRequireWildcard(_transformersFilters);
          var pipeline = new _pipeline2["default"]();
          for (var key in _transformers2["default"]) {
            var transformer = _transformers2["default"][key];
            if (typeof transformer === "object") {
              var metadata = transformer.metadata = transformer.metadata || {};
              metadata.group = metadata.group || "builtin-basic";
            }
          }
          pipeline.addTransformers(_transformers2["default"]);
          pipeline.addDeprecated(_transformersDeprecated2["default"]);
          pipeline.addAliases(_transformersAliases2["default"]);
          pipeline.addFilter(filters.internal);
          pipeline.addFilter(filters.blacklist);
          pipeline.addFilter(filters.whitelist);
          pipeline.addFilter(filters.stage);
          pipeline.addFilter(filters.optional);
          var transform = pipeline.transform.bind(pipeline);
          transform.fromAst = pipeline.transformFromAst.bind(pipeline);
          transform.pipeline = pipeline;
          exports["default"] = transform;
          module.exports = exports["default"];
        }, {
          "./pipeline": 97,
          "./transformers": 143,
          "./transformers/aliases": 101,
          "./transformers/deprecated": 102,
          "./transformers/filters": 142
        }],
        84: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _libMetadata = require("./lib/metadata");
          var metadataVisitor = _interopRequireWildcard(_libMetadata);
          var _messages = require("../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _libRemaps = require("./lib/remaps");
          var _libRemaps2 = _interopRequireDefault(_libRemaps);
          var _helpersObject = require("../../helpers/object");
          var _helpersObject2 = _interopRequireDefault(_helpersObject);
          var _util = require("../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var DefaultFormatter = (function() {
            function DefaultFormatter(file) {
              _classCallCheck(this, DefaultFormatter);
              this.sourceScopes = _helpersObject2["default"]();
              this.defaultIds = _helpersObject2["default"]();
              this.ids = _helpersObject2["default"]();
              this.remaps = new _libRemaps2["default"](file, this);
              this.scope = file.scope;
              this.file = file;
              this.hasNonDefaultExports = false;
              this.hasLocalExports = false;
              this.hasLocalImports = false;
              this.localExports = _helpersObject2["default"]();
              this.localImports = _helpersObject2["default"]();
              this.metadata = file.metadata.modules;
              this.getMetadata();
            }
            DefaultFormatter.prototype.addScope = function addScope(path) {
              var source = path.node.source && path.node.source.value;
              if (!source)
                return;
              var existingScope = this.sourceScopes[source];
              if (existingScope && existingScope !== path.scope) {
                throw path.errorWithNode(messages.get("modulesDuplicateDeclarations"));
              }
              this.sourceScopes[source] = path.scope;
            };
            DefaultFormatter.prototype.isModuleType = function isModuleType(node, type) {
              var modules = this.file.dynamicImportTypes[type];
              return modules && modules.indexOf(node) >= 0;
            };
            DefaultFormatter.prototype.transform = function transform() {
              this.remapAssignments();
            };
            DefaultFormatter.prototype.doDefaultExportInterop = function doDefaultExportInterop(node) {
              return (t.isExportDefaultDeclaration(node) || t.isSpecifierDefault(node)) && !this.noInteropRequireExport && !this.hasNonDefaultExports;
            };
            DefaultFormatter.prototype.getMetadata = function getMetadata() {
              var has = false;
              var _arr = this.file.ast.program.body;
              for (var _i = 0; _i < _arr.length; _i++) {
                var node = _arr[_i];
                if (t.isModuleDeclaration(node)) {
                  has = true;
                  break;
                }
              }
              if (has || this.isLoose()) {
                this.file.path.traverse(metadataVisitor, this);
              }
            };
            DefaultFormatter.prototype.remapAssignments = function remapAssignments() {
              if (this.hasLocalExports || this.hasLocalImports) {
                this.remaps.run();
              }
            };
            DefaultFormatter.prototype.remapExportAssignment = function remapExportAssignment(node, exported) {
              var assign = node;
              for (var i = 0; i < exported.length; i++) {
                assign = t.assignmentExpression("=", t.memberExpression(t.identifier("exports"), exported[i]), assign);
              }
              return assign;
            };
            DefaultFormatter.prototype._addExport = function _addExport(name, exported) {
              var info = this.localExports[name] = this.localExports[name] || {
                binding: this.scope.getBindingIdentifier(name),
                exported: []
              };
              info.exported.push(exported);
            };
            DefaultFormatter.prototype.getExport = function getExport(node, scope) {
              if (!t.isIdentifier(node))
                return;
              var local = this.localExports[node.name];
              if (local && local.binding === scope.getBindingIdentifier(node.name)) {
                return local.exported;
              }
            };
            DefaultFormatter.prototype.getModuleName = function getModuleName() {
              var opts = this.file.opts;
              if (opts.moduleId != null && !opts.getModuleId) {
                return opts.moduleId;
              }
              var filenameRelative = opts.filenameRelative;
              var moduleName = "";
              if (opts.moduleRoot != null) {
                moduleName = opts.moduleRoot + "/";
              }
              if (!opts.filenameRelative) {
                return moduleName + opts.filename.replace(/^\//, "");
              }
              if (opts.sourceRoot != null) {
                var sourceRootRegEx = new RegExp("^" + opts.sourceRoot + "\/?");
                filenameRelative = filenameRelative.replace(sourceRootRegEx, "");
              }
              if (!opts.keepModuleIdExtensions) {
                filenameRelative = filenameRelative.replace(/\.(\w*?)$/, "");
              }
              moduleName += filenameRelative;
              moduleName = moduleName.replace(/\\/g, "/");
              if (opts.getModuleId) {
                return opts.getModuleId(moduleName) || moduleName;
              } else {
                return moduleName;
              }
            };
            DefaultFormatter.prototype._pushStatement = function _pushStatement(ref, nodes) {
              if (t.isClass(ref) || t.isFunction(ref)) {
                if (ref.id) {
                  nodes.push(t.toStatement(ref));
                  ref = ref.id;
                }
              }
              return ref;
            };
            DefaultFormatter.prototype._hoistExport = function _hoistExport(declar, assign, priority) {
              if (t.isFunctionDeclaration(declar)) {
                assign._blockHoist = priority || 2;
              }
              return assign;
            };
            DefaultFormatter.prototype.getExternalReference = function getExternalReference(node, nodes) {
              var ids = this.ids;
              var id = node.source.value;
              if (ids[id]) {
                return ids[id];
              } else {
                return this.ids[id] = this._getExternalReference(node, nodes);
              }
            };
            DefaultFormatter.prototype.checkExportIdentifier = function checkExportIdentifier(node) {
              if (t.isIdentifier(node, {name: "__esModule"})) {
                throw this.file.errorWithNode(node, messages.get("modulesIllegalExportName", node.name));
              }
            };
            DefaultFormatter.prototype.exportAllDeclaration = function exportAllDeclaration(node, nodes) {
              var ref = this.getExternalReference(node, nodes);
              nodes.push(this.buildExportsWildcard(ref, node));
            };
            DefaultFormatter.prototype.isLoose = function isLoose() {
              return this.file.isLoose("es6.modules");
            };
            DefaultFormatter.prototype.exportSpecifier = function exportSpecifier(specifier, node, nodes) {
              if (node.source) {
                var ref = this.getExternalReference(node, nodes);
                if (specifier.local.name === "default" && !this.noInteropRequireExport) {
                  ref = t.callExpression(this.file.addHelper("interop-require"), [ref]);
                } else {
                  ref = t.memberExpression(ref, specifier.local);
                  if (!this.isLoose()) {
                    nodes.push(this.buildExportsFromAssignment(specifier.exported, ref, node));
                    return;
                  }
                }
                nodes.push(this.buildExportsAssignment(specifier.exported, ref, node));
              } else {
                nodes.push(this.buildExportsAssignment(specifier.exported, specifier.local, node));
              }
            };
            DefaultFormatter.prototype.buildExportsWildcard = function buildExportsWildcard(objectIdentifier) {
              return t.expressionStatement(t.callExpression(this.file.addHelper("defaults"), [t.identifier("exports"), t.callExpression(this.file.addHelper("interop-export-wildcard"), [objectIdentifier, this.file.addHelper("defaults")])]));
            };
            DefaultFormatter.prototype.buildExportsFromAssignment = function buildExportsFromAssignment(id, init) {
              this.checkExportIdentifier(id);
              return util.template("exports-from-assign", {
                INIT: init,
                ID: t.literal(id.name)
              }, true);
            };
            DefaultFormatter.prototype.buildExportsAssignment = function buildExportsAssignment(id, init) {
              this.checkExportIdentifier(id);
              return util.template("exports-assign", {
                VALUE: init,
                KEY: id
              }, true);
            };
            DefaultFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
              var declar = node.declaration;
              var id = declar.id;
              if (t.isExportDefaultDeclaration(node)) {
                id = t.identifier("default");
              }
              var assign;
              if (t.isVariableDeclaration(declar)) {
                for (var i = 0; i < declar.declarations.length; i++) {
                  var decl = declar.declarations[i];
                  decl.init = this.buildExportsAssignment(decl.id, decl.init, node).expression;
                  var newDeclar = t.variableDeclaration(declar.kind, [decl]);
                  if (i === 0)
                    t.inherits(newDeclar, declar);
                  nodes.push(newDeclar);
                }
              } else {
                var ref = declar;
                if (t.isFunctionDeclaration(declar) || t.isClassDeclaration(declar)) {
                  ref = declar.id;
                  nodes.push(declar);
                }
                assign = this.buildExportsAssignment(id, ref, node);
                nodes.push(assign);
                this._hoistExport(declar, assign);
              }
            };
            return DefaultFormatter;
          })();
          exports["default"] = DefaultFormatter;
          module.exports = exports["default"];
        }, {
          "../../helpers/object": 58,
          "../../messages": 60,
          "../../types": 196,
          "../../util": 199,
          "./lib/metadata": 92,
          "./lib/remaps": 93
        }],
        85: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _util = require("../../util");
          var util = _interopRequireWildcard(_util);
          exports["default"] = function(Parent) {
            var Constructor = function Constructor() {
              this.noInteropRequireImport = true;
              this.noInteropRequireExport = true;
              Parent.apply(this, arguments);
            };
            util.inherits(Constructor, Parent);
            return Constructor;
          };
          module.exports = exports["default"];
        }, {"../../util": 199}],
        86: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _amd = require("./amd");
          var _amd2 = _interopRequireDefault(_amd);
          var _strict = require("./_strict");
          var _strict2 = _interopRequireDefault(_strict);
          exports["default"] = _strict2["default"](_amd2["default"]);
          module.exports = exports["default"];
        }, {
          "./_strict": 85,
          "./amd": 87
        }],
        87: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }});
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _default = require("./_default");
          var _default2 = _interopRequireDefault(_default);
          var _common = require("./common");
          var _common2 = _interopRequireDefault(_common);
          var _lodashCollectionIncludes = require("lodash/collection/includes");
          var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
          var _lodashObjectValues = require("lodash/object/values");
          var _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);
          var _util = require("../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var AMDFormatter = (function(_DefaultFormatter) {
            _inherits(AMDFormatter, _DefaultFormatter);
            function AMDFormatter() {
              _classCallCheck(this, AMDFormatter);
              _DefaultFormatter.apply(this, arguments);
            }
            AMDFormatter.prototype.setup = function setup() {
              _common2["default"].prototype._setup.call(this, this.hasNonDefaultExports);
            };
            AMDFormatter.prototype.buildDependencyLiterals = function buildDependencyLiterals() {
              var names = [];
              for (var name in this.ids) {
                names.push(t.literal(name));
              }
              return names;
            };
            AMDFormatter.prototype.transform = function transform(program) {
              _common2["default"].prototype.transform.apply(this, arguments);
              var body = program.body;
              var names = [t.literal("exports")];
              if (this.passModuleArg)
                names.push(t.literal("module"));
              names = names.concat(this.buildDependencyLiterals());
              names = t.arrayExpression(names);
              var params = _lodashObjectValues2["default"](this.ids);
              if (this.passModuleArg)
                params.unshift(t.identifier("module"));
              params.unshift(t.identifier("exports"));
              var container = t.functionExpression(null, params, t.blockStatement(body));
              var defineArgs = [names, container];
              var moduleName = this.getModuleName();
              if (moduleName)
                defineArgs.unshift(t.literal(moduleName));
              var call = t.callExpression(t.identifier("define"), defineArgs);
              program.body = [t.expressionStatement(call)];
            };
            AMDFormatter.prototype.getModuleName = function getModuleName() {
              if (this.file.opts.moduleIds) {
                return _default2["default"].prototype.getModuleName.apply(this, arguments);
              } else {
                return null;
              }
            };
            AMDFormatter.prototype._getExternalReference = function _getExternalReference(node) {
              return this.scope.generateUidIdentifier(node.source.value);
            };
            AMDFormatter.prototype.importDeclaration = function importDeclaration(node) {
              this.getExternalReference(node);
            };
            AMDFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes, scope) {
              var key = node.source.value;
              var ref = this.getExternalReference(node);
              if (t.isImportNamespaceSpecifier(specifier) || t.isImportDefaultSpecifier(specifier)) {
                this.defaultIds[key] = specifier.local;
              }
              if (this.isModuleType(node, "absolute")) {} else if (this.isModuleType(node, "absoluteDefault")) {
                this.ids[node.source.value] = ref;
                ref = t.memberExpression(ref, t.identifier("default"));
              } else if (t.isImportNamespaceSpecifier(specifier)) {} else if (!_lodashCollectionIncludes2["default"](this.file.dynamicImported, node) && t.isSpecifierDefault(specifier) && !this.noInteropRequireImport) {
                var uid = scope.generateUidIdentifier(specifier.local.name);
                nodes.push(t.variableDeclaration("var", [t.variableDeclarator(uid, t.callExpression(this.file.addHelper("interop-require-default"), [ref]))]));
                ref = t.memberExpression(uid, t.identifier("default"));
              } else {
                var imported = specifier.imported;
                if (t.isSpecifierDefault(specifier))
                  imported = t.identifier("default");
                ref = t.memberExpression(ref, imported);
              }
              this.remaps.add(scope, specifier.local.name, ref);
            };
            AMDFormatter.prototype.exportSpecifier = function exportSpecifier(specifier, node, nodes) {
              if (this.doDefaultExportInterop(specifier)) {
                this.passModuleArg = true;
                if (specifier.exported !== specifier.local && !node.source) {
                  nodes.push(util.template("exports-default-assign", {VALUE: specifier.local}, true));
                  return;
                }
              }
              _common2["default"].prototype.exportSpecifier.apply(this, arguments);
            };
            AMDFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
              if (this.doDefaultExportInterop(node)) {
                this.passModuleArg = true;
                var declar = node.declaration;
                var assign = util.template("exports-default-assign", {VALUE: this._pushStatement(declar, nodes)}, true);
                if (t.isFunctionDeclaration(declar)) {
                  assign._blockHoist = 3;
                }
                nodes.push(assign);
                return;
              }
              _default2["default"].prototype.exportDeclaration.apply(this, arguments);
            };
            return AMDFormatter;
          })(_default2["default"]);
          exports["default"] = AMDFormatter;
          module.exports = exports["default"];
        }, {
          "../../types": 196,
          "../../util": 199,
          "./_default": 84,
          "./common": 89,
          "lodash/collection/includes": 430,
          "lodash/object/values": 534
        }],
        88: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _common = require("./common");
          var _common2 = _interopRequireDefault(_common);
          var _strict = require("./_strict");
          var _strict2 = _interopRequireDefault(_strict);
          exports["default"] = _strict2["default"](_common2["default"]);
          module.exports = exports["default"];
        }, {
          "./_strict": 85,
          "./common": 89
        }],
        89: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }});
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _default = require("./_default");
          var _default2 = _interopRequireDefault(_default);
          var _util = require("../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var CommonJSFormatter = (function(_DefaultFormatter) {
            _inherits(CommonJSFormatter, _DefaultFormatter);
            function CommonJSFormatter() {
              _classCallCheck(this, CommonJSFormatter);
              _DefaultFormatter.apply(this, arguments);
            }
            CommonJSFormatter.prototype.setup = function setup() {
              this._setup(this.hasLocalExports);
            };
            CommonJSFormatter.prototype._setup = function _setup(conditional) {
              var file = this.file;
              var scope = file.scope;
              scope.rename("module");
              scope.rename("exports");
              if (!this.noInteropRequireImport && conditional) {
                var templateName = "exports-module-declaration";
                if (this.file.isLoose("es6.modules"))
                  templateName += "-loose";
                var declar = util.template(templateName, true);
                declar._blockHoist = 3;
                file.path.unshiftContainer("body", [declar]);
              }
            };
            CommonJSFormatter.prototype.transform = function transform(program) {
              _default2["default"].prototype.transform.apply(this, arguments);
              if (this.hasDefaultOnlyExport) {
                program.body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.identifier("module"), t.identifier("exports")), t.memberExpression(t.identifier("exports"), t.identifier("default")))));
              }
            };
            CommonJSFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes, scope) {
              var variableName = specifier.local;
              var ref = this.getExternalReference(node, nodes);
              if (t.isSpecifierDefault(specifier)) {
                if (this.isModuleType(node, "absolute")) {} else if (this.isModuleType(node, "absoluteDefault")) {
                  this.remaps.add(scope, variableName.name, ref);
                } else if (this.noInteropRequireImport) {
                  this.remaps.add(scope, variableName.name, t.memberExpression(ref, t.identifier("default")));
                } else {
                  var uid = this.scope.generateUidIdentifierBasedOnNode(node, "import");
                  nodes.push(t.variableDeclaration("var", [t.variableDeclarator(uid, t.callExpression(this.file.addHelper("interop-require-default"), [ref]))]));
                  this.remaps.add(scope, variableName.name, t.memberExpression(uid, t.identifier("default")));
                }
              } else {
                if (t.isImportNamespaceSpecifier(specifier)) {
                  if (!this.noInteropRequireImport) {
                    ref = t.callExpression(this.file.addHelper("interop-require-wildcard"), [ref]);
                  }
                  nodes.push(t.variableDeclaration("var", [t.variableDeclarator(variableName, ref)]));
                } else {
                  this.remaps.add(scope, variableName.name, t.memberExpression(ref, t.identifier(specifier.imported.name)));
                }
              }
            };
            CommonJSFormatter.prototype.importDeclaration = function importDeclaration(node, nodes) {
              nodes.push(util.template("require", {MODULE_NAME: node.source}, true));
            };
            CommonJSFormatter.prototype.exportSpecifier = function exportSpecifier(specifier) {
              if (this.doDefaultExportInterop(specifier)) {
                this.hasDefaultOnlyExport = true;
              }
              _default2["default"].prototype.exportSpecifier.apply(this, arguments);
            };
            CommonJSFormatter.prototype.exportDeclaration = function exportDeclaration(node) {
              if (this.doDefaultExportInterop(node)) {
                this.hasDefaultOnlyExport = true;
              }
              _default2["default"].prototype.exportDeclaration.apply(this, arguments);
            };
            CommonJSFormatter.prototype._getExternalReference = function _getExternalReference(node, nodes) {
              var call = t.callExpression(t.identifier("require"), [node.source]);
              var uid;
              if (this.isModuleType(node, "absolute")) {} else if (this.isModuleType(node, "absoluteDefault")) {
                call = t.memberExpression(call, t.identifier("default"));
              } else {
                uid = this.scope.generateUidIdentifierBasedOnNode(node, "import");
              }
              uid = uid || node.specifiers[0].local;
              var declar = t.variableDeclaration("var", [t.variableDeclarator(uid, call)]);
              nodes.push(declar);
              return uid;
            };
            return CommonJSFormatter;
          })(_default2["default"]);
          exports["default"] = CommonJSFormatter;
          module.exports = exports["default"];
        }, {
          "../../types": 196,
          "../../util": 199,
          "./_default": 84
        }],
        90: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }});
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _default = require("./_default");
          var _default2 = _interopRequireDefault(_default);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var IgnoreFormatter = (function(_DefaultFormatter) {
            _inherits(IgnoreFormatter, _DefaultFormatter);
            function IgnoreFormatter() {
              _classCallCheck(this, IgnoreFormatter);
              _DefaultFormatter.apply(this, arguments);
            }
            IgnoreFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
              var declar = t.toStatement(node.declaration, true);
              if (declar)
                nodes.push(t.inherits(declar, node));
            };
            IgnoreFormatter.prototype.exportAllDeclaration = function exportAllDeclaration() {};
            IgnoreFormatter.prototype.importDeclaration = function importDeclaration() {};
            IgnoreFormatter.prototype.importSpecifier = function importSpecifier() {};
            IgnoreFormatter.prototype.exportSpecifier = function exportSpecifier() {};
            IgnoreFormatter.prototype.transform = function transform() {};
            return IgnoreFormatter;
          })(_default2["default"]);
          exports["default"] = IgnoreFormatter;
          module.exports = exports["default"];
        }, {
          "../../types": 196,
          "./_default": 84
        }],
        91: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports["default"] = {
            commonStrict: require("./common-strict"),
            amdStrict: require("./amd-strict"),
            umdStrict: require("./umd-strict"),
            common: require("./common"),
            system: require("./system"),
            ignore: require("./ignore"),
            amd: require("./amd"),
            umd: require("./umd")
          };
          module.exports = exports["default"];
        }, {
          "./amd": 87,
          "./amd-strict": 86,
          "./common": 89,
          "./common-strict": 88,
          "./ignore": 90,
          "./system": 94,
          "./umd": 96,
          "./umd-strict": 95
        }],
        92: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.ExportDeclaration = ExportDeclaration;
          exports.Scope = Scope;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashObjectExtend = require("lodash/object/extend");
          var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var ModuleDeclaration = {enter: function enter(node, parent, scope, formatter) {
              if (node.source) {
                node.source.value = formatter.file.resolveModuleSource(node.source.value);
                formatter.addScope(this);
              }
            }};
          exports.ModuleDeclaration = ModuleDeclaration;
          var ImportDeclaration = {exit: function exit(node, parent, scope, formatter) {
              formatter.hasLocalImports = true;
              var specifiers = [];
              var imported = [];
              formatter.metadata.imports.push({
                source: node.source.value,
                imported: imported,
                specifiers: specifiers
              });
              var _arr = this.get("specifiers");
              for (var _i = 0; _i < _arr.length; _i++) {
                var specifier = _arr[_i];
                var ids = specifier.getBindingIdentifiers();
                _lodashObjectExtend2["default"](formatter.localImports, ids);
                var local = specifier.node.local.name;
                if (specifier.isImportDefaultSpecifier()) {
                  imported.push("default");
                  specifiers.push({
                    kind: "named",
                    imported: "default",
                    local: local
                  });
                }
                if (specifier.isImportSpecifier()) {
                  var importedName = specifier.node.imported.name;
                  imported.push(importedName);
                  specifiers.push({
                    kind: "named",
                    imported: importedName,
                    local: local
                  });
                }
                if (specifier.isImportNamespaceSpecifier()) {
                  imported.push("*");
                  specifiers.push({
                    kind: "namespace",
                    local: local
                  });
                }
              }
            }};
          exports.ImportDeclaration = ImportDeclaration;
          function ExportDeclaration(node, parent, scope, formatter) {
            formatter.hasLocalExports = true;
            var source = node.source ? node.source.value : null;
            var exports = formatter.metadata.exports;
            var declar = this.get("declaration");
            if (declar.isStatement()) {
              var bindings = declar.getBindingIdentifiers();
              for (var name in bindings) {
                var binding = bindings[name];
                formatter._addExport(name, binding);
                exports.exported.push(name);
                exports.specifiers.push({
                  kind: "local",
                  local: name,
                  exported: this.isExportDefaultDeclaration() ? "default" : name
                });
              }
            }
            if (this.isExportNamedDeclaration() && node.specifiers) {
              var _arr2 = node.specifiers;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var specifier = _arr2[_i2];
                var exported = specifier.exported.name;
                exports.exported.push(exported);
                if (t.isExportDefaultSpecifier(specifier)) {
                  exports.specifiers.push({
                    kind: "external",
                    local: exported,
                    exported: exported,
                    source: source
                  });
                }
                if (t.isExportNamespaceSpecifier(specifier)) {
                  exports.specifiers.push({
                    kind: "external-namespace",
                    exported: exported,
                    source: source
                  });
                }
                var local = specifier.local;
                if (!local)
                  continue;
                formatter._addExport(local.name, specifier.exported);
                if (source) {
                  exports.specifiers.push({
                    kind: "external",
                    local: local.name,
                    exported: exported,
                    source: source
                  });
                }
                if (!source) {
                  exports.specifiers.push({
                    kind: "local",
                    local: local.name,
                    exported: exported
                  });
                }
              }
            }
            if (this.isExportAllDeclaration()) {
              exports.specifiers.push({
                kind: "external-all",
                source: source
              });
            }
            if (!t.isExportDefaultDeclaration(node) && !declar.isTypeAlias()) {
              var onlyDefault = node.specifiers && node.specifiers.length === 1 && t.isSpecifierDefault(node.specifiers[0]);
              if (!onlyDefault) {
                formatter.hasNonDefaultExports = true;
              }
            }
          }
          function Scope(node, parent, scope, formatter) {
            if (!formatter.isLoose()) {
              this.skip();
            }
          }
        }, {
          "../../../types": 196,
          "lodash/object/extend": 528
        }],
        93: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var remapVisitor = {
            enter: function enter(node) {
              if (node._skipModulesRemap) {
                return this.skip();
              }
            },
            ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, remaps) {
              var formatter = remaps.formatter;
              var remap = remaps.get(scope, node.name);
              if (!remap || node === remap)
                return;
              if (!scope.hasBinding(node.name) || scope.bindingIdentifierEquals(node.name, formatter.localImports[node.name])) {
                if (!formatter.isLoose() && this.key === "callee" && this.parentPath.isCallExpression()) {
                  return t.sequenceExpression([t.literal(0), remap]);
                } else {
                  return remap;
                }
              }
            },
            AssignmentExpression: {exit: function exit(node, parent, scope, _ref) {
                var formatter = _ref.formatter;
                if (!node._ignoreModulesRemap) {
                  var exported = formatter.getExport(node.left, scope);
                  if (exported) {
                    return formatter.remapExportAssignment(node, exported);
                  }
                }
              }},
            UpdateExpression: function UpdateExpression(node, parent, scope, _ref2) {
              var formatter = _ref2.formatter;
              var exported = formatter.getExport(node.argument, scope);
              if (!exported)
                return;
              this.skip();
              var assign = t.assignmentExpression(node.operator[0] + "=", node.argument, t.literal(1));
              var remapped = formatter.remapExportAssignment(assign, exported);
              if (t.isExpressionStatement(parent) || node.prefix) {
                return remapped;
              }
              var nodes = [];
              nodes.push(remapped);
              var operator;
              if (node.operator === "--") {
                operator = "+";
              } else {
                operator = "-";
              }
              nodes.push(t.binaryExpression(operator, node.argument, t.literal(1)));
              return t.sequenceExpression(nodes);
            }
          };
          var Remaps = (function() {
            function Remaps(file, formatter) {
              _classCallCheck(this, Remaps);
              this.formatter = formatter;
              this.file = file;
            }
            Remaps.prototype.run = function run() {
              this.file.path.traverse(remapVisitor, this);
            };
            Remaps.prototype._getKey = function _getKey(name) {
              return name + ":moduleRemap";
            };
            Remaps.prototype.get = function get(scope, name) {
              return scope.getData(this._getKey(name));
            };
            Remaps.prototype.add = function add(scope, name, val) {
              if (this.all) {
                this.all.push({
                  name: name,
                  scope: scope,
                  node: val
                });
              }
              return scope.setData(this._getKey(name), val);
            };
            Remaps.prototype.remove = function remove(scope, name) {
              return scope.removeData(this._getKey(name));
            };
            Remaps.prototype.getAll = function getAll() {
              return this.all;
            };
            Remaps.prototype.clearAll = function clearAll() {
              if (this.all) {
                var _arr = this.all;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var remap = _arr[_i];
                  remap.scope.removeData(this._getKey(remap.name));
                }
              }
              this.all = [];
            };
            return Remaps;
          })();
          exports["default"] = Remaps;
          module.exports = exports["default"];
        }, {"../../../types": 196}],
        94: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }});
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _default = require("./_default");
          var _default2 = _interopRequireDefault(_default);
          var _amd = require("./amd");
          var _amd2 = _interopRequireDefault(_amd);
          var _util = require("../../util");
          var util = _interopRequireWildcard(_util);
          var _lodashArrayLast = require("lodash/array/last");
          var _lodashArrayLast2 = _interopRequireDefault(_lodashArrayLast);
          var _lodashCollectionMap = require("lodash/collection/map");
          var _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var hoistVariablesVisitor = {
            Function: function Function() {
              this.skip();
            },
            VariableDeclaration: function VariableDeclaration(node, parent, scope, state) {
              if (node.kind !== "var" && !t.isProgram(parent)) {
                return;
              }
              if (state.formatter._canHoist(node))
                return;
              var nodes = [];
              for (var i = 0; i < node.declarations.length; i++) {
                var declar = node.declarations[i];
                state.hoistDeclarators.push(t.variableDeclarator(declar.id));
                if (declar.init) {
                  var assign = t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init));
                  nodes.push(assign);
                }
              }
              if (t.isFor(parent) && parent.left === node) {
                return node.declarations[0].id;
              }
              return nodes;
            }
          };
          var hoistFunctionsVisitor = {
            Function: function Function() {
              this.skip();
            },
            enter: function enter(node, parent, scope, state) {
              if (t.isFunctionDeclaration(node) || state.formatter._canHoist(node)) {
                state.handlerBody.push(node);
                this.dangerouslyRemove();
              }
            }
          };
          var runnerSettersVisitor = {enter: function enter(node, parent, scope, state) {
              if (node._importSource === state.source) {
                if (t.isVariableDeclaration(node)) {
                  var _arr = node.declarations;
                  for (var _i = 0; _i < _arr.length; _i++) {
                    var declar = _arr[_i];
                    state.hoistDeclarators.push(t.variableDeclarator(declar.id));
                    state.nodes.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
                  }
                } else {
                  state.nodes.push(node);
                }
                this.dangerouslyRemove();
              }
            }};
          var SystemFormatter = (function(_AMDFormatter) {
            _inherits(SystemFormatter, _AMDFormatter);
            function SystemFormatter(file) {
              _classCallCheck(this, SystemFormatter);
              _AMDFormatter.call(this, file);
              this._setters = null;
              this.exportIdentifier = file.scope.generateUidIdentifier("export");
              this.noInteropRequireExport = true;
              this.noInteropRequireImport = true;
              this.remaps.clearAll();
            }
            SystemFormatter.prototype._addImportSource = function _addImportSource(node, exportNode) {
              if (node)
                node._importSource = exportNode.source && exportNode.source.value;
              return node;
            };
            SystemFormatter.prototype.buildExportsWildcard = function buildExportsWildcard(objectIdentifier, node) {
              var leftIdentifier = this.scope.generateUidIdentifier("key");
              var valIdentifier = t.memberExpression(objectIdentifier, leftIdentifier, true);
              var left = t.variableDeclaration("var", [t.variableDeclarator(leftIdentifier)]);
              var right = objectIdentifier;
              var block = t.blockStatement([t.ifStatement(t.binaryExpression("!==", leftIdentifier, t.literal("default")), t.expressionStatement(this._buildExportCall(leftIdentifier, valIdentifier)))]);
              return this._addImportSource(t.forInStatement(left, right, block), node);
            };
            SystemFormatter.prototype.buildExportsAssignment = function buildExportsAssignment(id, init, node) {
              var call = this._buildExportCall(t.literal(id.name), init, true);
              return this._addImportSource(call, node);
            };
            SystemFormatter.prototype.buildExportsFromAssignment = function buildExportsFromAssignment() {
              return this.buildExportsAssignment.apply(this, arguments);
            };
            SystemFormatter.prototype.remapExportAssignment = function remapExportAssignment(node, exported) {
              var assign = node;
              for (var i = 0; i < exported.length; i++) {
                assign = this._buildExportCall(t.literal(exported[i].name), assign);
              }
              return assign;
            };
            SystemFormatter.prototype._buildExportCall = function _buildExportCall(id, init, isStatement) {
              var call = t.callExpression(this.exportIdentifier, [id, init]);
              if (isStatement) {
                return t.expressionStatement(call);
              } else {
                return call;
              }
            };
            SystemFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes) {
              _amd2["default"].prototype.importSpecifier.apply(this, arguments);
              var _arr2 = this.remaps.getAll();
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var remap = _arr2[_i2];
                nodes.push(t.variableDeclaration("var", [t.variableDeclarator(t.identifier(remap.name), remap.node)]));
              }
              this.remaps.clearAll();
              this._addImportSource(_lodashArrayLast2["default"](nodes), node);
            };
            SystemFormatter.prototype._buildRunnerSetters = function _buildRunnerSetters(block, hoistDeclarators) {
              var scope = this.file.scope;
              return t.arrayExpression(_lodashCollectionMap2["default"](this.ids, function(uid, source) {
                var state = {
                  hoistDeclarators: hoistDeclarators,
                  source: source,
                  nodes: []
                };
                scope.traverse(block, runnerSettersVisitor, state);
                return t.functionExpression(null, [uid], t.blockStatement(state.nodes));
              }));
            };
            SystemFormatter.prototype._canHoist = function _canHoist(node) {
              return node._blockHoist && !this.file.dynamicImports.length;
            };
            SystemFormatter.prototype.transform = function transform(program) {
              _default2["default"].prototype.transform.apply(this, arguments);
              var hoistDeclarators = [];
              var moduleName = this.getModuleName();
              var moduleNameLiteral = t.literal(moduleName);
              var block = t.blockStatement(program.body);
              var setterListNode = this._buildRunnerSetters(block, hoistDeclarators);
              this._setters = setterListNode;
              var runner = util.template("system", {
                MODULE_DEPENDENCIES: t.arrayExpression(this.buildDependencyLiterals()),
                EXPORT_IDENTIFIER: this.exportIdentifier,
                MODULE_NAME: moduleNameLiteral,
                SETTERS: setterListNode,
                EXECUTE: t.functionExpression(null, [], block)
              }, true);
              var handlerBody = runner.expression.arguments[2].body.body;
              if (!moduleName)
                runner.expression.arguments.shift();
              var returnStatement = handlerBody.pop();
              this.file.scope.traverse(block, hoistVariablesVisitor, {
                formatter: this,
                hoistDeclarators: hoistDeclarators
              });
              if (hoistDeclarators.length) {
                var hoistDeclar = t.variableDeclaration("var", hoistDeclarators);
                hoistDeclar._blockHoist = true;
                handlerBody.unshift(hoistDeclar);
              }
              this.file.scope.traverse(block, hoistFunctionsVisitor, {
                formatter: this,
                handlerBody: handlerBody
              });
              handlerBody.push(returnStatement);
              program.body = [runner];
            };
            return SystemFormatter;
          })(_amd2["default"]);
          exports["default"] = SystemFormatter;
          module.exports = exports["default"];
        }, {
          "../../types": 196,
          "../../util": 199,
          "./_default": 84,
          "./amd": 87,
          "lodash/array/last": 424,
          "lodash/collection/map": 431
        }],
        95: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _umd = require("./umd");
          var _umd2 = _interopRequireDefault(_umd);
          var _strict = require("./_strict");
          var _strict2 = _interopRequireDefault(_strict);
          exports["default"] = _strict2["default"](_umd2["default"]);
          module.exports = exports["default"];
        }, {
          "./_strict": 85,
          "./umd": 96
        }],
        96: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }});
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _default = require("./_default");
          var _default2 = _interopRequireDefault(_default);
          var _amd = require("./amd");
          var _amd2 = _interopRequireDefault(_amd);
          var _lodashObjectValues = require("lodash/object/values");
          var _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);
          var _path = require("path");
          var _path2 = _interopRequireDefault(_path);
          var _util = require("../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var UMDFormatter = (function(_AMDFormatter) {
            _inherits(UMDFormatter, _AMDFormatter);
            function UMDFormatter() {
              _classCallCheck(this, UMDFormatter);
              _AMDFormatter.apply(this, arguments);
            }
            UMDFormatter.prototype.transform = function transform(program) {
              _default2["default"].prototype.transform.apply(this, arguments);
              var body = program.body;
              var names = [];
              for (var _name in this.ids) {
                names.push(t.literal(_name));
              }
              var ids = _lodashObjectValues2["default"](this.ids);
              var args = [t.identifier("exports")];
              if (this.passModuleArg)
                args.push(t.identifier("module"));
              args = args.concat(ids);
              var factory = t.functionExpression(null, args, t.blockStatement(body));
              var defineArgs = [t.literal("exports")];
              if (this.passModuleArg)
                defineArgs.push(t.literal("module"));
              defineArgs = defineArgs.concat(names);
              defineArgs = [t.arrayExpression(defineArgs)];
              var testExports = util.template("test-exports");
              var testModule = util.template("test-module");
              var commonTests = this.passModuleArg ? t.logicalExpression("&&", testExports, testModule) : testExports;
              var commonArgs = [t.identifier("exports")];
              if (this.passModuleArg)
                commonArgs.push(t.identifier("module"));
              commonArgs = commonArgs.concat(names.map(function(name) {
                return t.callExpression(t.identifier("require"), [name]);
              }));
              var browserArgs = [];
              if (this.passModuleArg)
                browserArgs.push(t.identifier("mod"));
              for (var _name2 in this.ids) {
                var id = this.defaultIds[_name2] || t.identifier(t.toIdentifier(_path2["default"].basename(_name2, _path2["default"].extname(_name2))));
                browserArgs.push(t.memberExpression(t.identifier("global"), id));
              }
              var moduleName = this.getModuleName();
              if (moduleName)
                defineArgs.unshift(t.literal(moduleName));
              var globalArg = this.file.opts.basename;
              if (moduleName)
                globalArg = moduleName;
              globalArg = t.identifier(t.toIdentifier(globalArg));
              var runner = util.template("umd-runner-body", {
                AMD_ARGUMENTS: defineArgs,
                COMMON_TEST: commonTests,
                COMMON_ARGUMENTS: commonArgs,
                BROWSER_ARGUMENTS: browserArgs,
                GLOBAL_ARG: globalArg
              });
              program.body = [t.expressionStatement(t.callExpression(runner, [t.thisExpression(), factory]))];
            };
            return UMDFormatter;
          })(_amd2["default"]);
          exports["default"] = UMDFormatter;
          module.exports = exports["default"];
        }, {
          "../../types": 196,
          "../../util": 199,
          "./_default": 84,
          "./amd": 87,
          "lodash/object/values": 534,
          "path": 11
        }],
        97: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _filePluginManager = require("./file/plugin-manager");
          var _filePluginManager2 = _interopRequireDefault(_filePluginManager);
          var _helpersNormalizeAst = require("../helpers/normalize-ast");
          var _helpersNormalizeAst2 = _interopRequireDefault(_helpersNormalizeAst);
          var _plugin = require("./plugin");
          var _plugin2 = _interopRequireDefault(_plugin);
          var _lodashObjectAssign = require("lodash/object/assign");
          var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
          var _helpersObject = require("../helpers/object");
          var _helpersObject2 = _interopRequireDefault(_helpersObject);
          var _file = require("./file");
          var _file2 = _interopRequireDefault(_file);
          var Pipeline = (function() {
            function Pipeline() {
              _classCallCheck(this, Pipeline);
              this.transformers = _helpersObject2["default"]();
              this.namespaces = _helpersObject2["default"]();
              this.deprecated = _helpersObject2["default"]();
              this.aliases = _helpersObject2["default"]();
              this.filters = [];
            }
            Pipeline.prototype.addTransformers = function addTransformers(transformers) {
              for (var key in transformers) {
                this.addTransformer(key, transformers[key]);
              }
              return this;
            };
            Pipeline.prototype.addTransformer = function addTransformer(key, plugin) {
              if (this.transformers[key])
                throw new Error();
              var namespace = key.split(".")[0];
              this.namespaces[namespace] = this.namespaces[namespace] || [];
              this.namespaces[namespace].push(key);
              this.namespaces[key] = namespace;
              if (typeof plugin === "function") {
                plugin = _filePluginManager2["default"].memoisePluginContainer(plugin);
                plugin.key = key;
                plugin.metadata.optional = true;
                if (key === "react.displayName") {
                  plugin.metadata.optional = false;
                }
              } else {
                plugin = new _plugin2["default"](key, plugin);
              }
              this.transformers[key] = plugin;
            };
            Pipeline.prototype.addAliases = function addAliases(names) {
              _lodashObjectAssign2["default"](this.aliases, names);
              return this;
            };
            Pipeline.prototype.addDeprecated = function addDeprecated(names) {
              _lodashObjectAssign2["default"](this.deprecated, names);
              return this;
            };
            Pipeline.prototype.addFilter = function addFilter(filter) {
              this.filters.push(filter);
              return this;
            };
            Pipeline.prototype.canTransform = function canTransform(plugin, fileOpts) {
              if (plugin.metadata.plugin) {
                return true;
              }
              var _arr = this.filters;
              for (var _i = 0; _i < _arr.length; _i++) {
                var filter = _arr[_i];
                var result = filter(plugin, fileOpts);
                if (result != null)
                  return result;
              }
              return true;
            };
            Pipeline.prototype.analyze = function analyze(code) {
              var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              opts.code = false;
              return this.transform(code, opts);
            };
            Pipeline.prototype.pretransform = function pretransform(code, opts) {
              var file = new _file2["default"](opts, this);
              return file.wrap(code, function() {
                file.addCode(code);
                file.parseCode(code);
                return file;
              });
            };
            Pipeline.prototype.transform = function transform(code, opts) {
              var file = new _file2["default"](opts, this);
              return file.wrap(code, function() {
                file.addCode(code);
                file.parseCode(code);
                return file.transform();
              });
            };
            Pipeline.prototype.transformFromAst = function transformFromAst(ast, code, opts) {
              ast = _helpersNormalizeAst2["default"](ast);
              var file = new _file2["default"](opts, this);
              return file.wrap(code, function() {
                file.addCode(code);
                file.addAst(ast);
                return file.transform();
              });
            };
            Pipeline.prototype._ensureTransformerNames = function _ensureTransformerNames(type, rawKeys) {
              var keys = [];
              for (var i = 0; i < rawKeys.length; i++) {
                var key = rawKeys[i];
                var deprecatedKey = this.deprecated[key];
                var aliasKey = this.aliases[key];
                if (aliasKey) {
                  keys.push(aliasKey);
                } else if (deprecatedKey) {
                  console.error("[BABEL] The transformer " + key + " has been renamed to " + deprecatedKey);
                  rawKeys.push(deprecatedKey);
                } else if (this.transformers[key]) {
                  keys.push(key);
                } else if (this.namespaces[key]) {
                  keys = keys.concat(this.namespaces[key]);
                } else {
                  throw new ReferenceError("Unknown transformer " + key + " specified in " + type);
                }
              }
              return keys;
            };
            return Pipeline;
          })();
          exports["default"] = Pipeline;
          module.exports = exports["default"];
        }, {
          "../helpers/normalize-ast": 57,
          "../helpers/object": 58,
          "./file": 63,
          "./file/plugin-manager": 69,
          "./plugin": 99,
          "lodash/object/assign": 526
        }],
        98: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _traversal = require("../traversal");
          var _traversal2 = _interopRequireDefault(_traversal);
          var PluginPass = (function() {
            function PluginPass(file, plugin) {
              _classCallCheck(this, PluginPass);
              this.plugin = plugin;
              this.file = file;
              this.key = plugin.key;
              if (this.canTransform() && plugin.metadata.experimental && !file.opts.experimental) {
                file.log.warn("THE TRANSFORMER " + this.key + " HAS BEEN MARKED AS EXPERIMENTAL AND IS WIP. USE AT YOUR OWN RISK. " + "THIS WILL HIGHLY LIKELY BREAK YOUR CODE SO USE WITH **EXTREME** CAUTION. ENABLE THE " + "`experimental` OPTION TO IGNORE THIS WARNING.");
              }
            }
            PluginPass.prototype.canTransform = function canTransform() {
              return this.file.transformerDependencies[this.key] || this.file.pipeline.canTransform(this.plugin, this.file.opts);
            };
            PluginPass.prototype.transform = function transform() {
              var file = this.file;
              file.log.debug("Start transformer " + this.key);
              _traversal2["default"](file.ast, this.plugin.visitor, file.scope, file);
              file.log.debug("Finish transformer " + this.key);
            };
            return PluginPass;
          })();
          exports["default"] = PluginPass;
          module.exports = exports["default"];
        }, {"../traversal": 165}],
        99: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _pluginPass = require("./plugin-pass");
          var _pluginPass2 = _interopRequireDefault(_pluginPass);
          var _messages = require("../messages");
          var messages = _interopRequireWildcard(_messages);
          var _traversal = require("../traversal");
          var _traversal2 = _interopRequireDefault(_traversal);
          var _lodashObjectAssign = require("lodash/object/assign");
          var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
          var _lodashLangClone = require("lodash/lang/clone");
          var _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);
          var _file = require("./file");
          var _file2 = _interopRequireDefault(_file);
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          var VALID_PLUGIN_PROPERTIES = ["visitor", "metadata", "manipulateOptions", "post", "pre"];
          var VALID_METADATA_PROPERTIES = ["dependencies", "optional", "stage", "group", "experimental", "secondPass"];
          var Plugin = (function() {
            function Plugin(key, plugin) {
              _classCallCheck(this, Plugin);
              Plugin.validate(key, plugin);
              plugin = _lodashObjectAssign2["default"]({}, plugin);
              var take = function take(key) {
                var val = plugin[key];
                delete plugin[key];
                return val;
              };
              this.manipulateOptions = take("manipulateOptions");
              this.metadata = take("metadata") || {};
              this.dependencies = this.metadata.dependencies || [];
              this.post = take("post");
              this.pre = take("pre");
              if (this.metadata.stage != null) {
                this.metadata.optional = true;
              }
              this.visitor = this.normalize(_lodashLangClone2["default"](take("visitor")) || {});
              this.key = key;
            }
            Plugin.validate = function validate(name, plugin) {
              for (var key in plugin) {
                if (key[0] === "_")
                  continue;
                if (VALID_PLUGIN_PROPERTIES.indexOf(key) >= 0)
                  continue;
                var msgType = "pluginInvalidProperty";
                if (t.TYPES.indexOf(key) >= 0)
                  msgType = "pluginInvalidPropertyVisitor";
                throw new Error(messages.get(msgType, name, key));
              }
              for (var key in plugin.metadata) {
                if (VALID_METADATA_PROPERTIES.indexOf(key) >= 0)
                  continue;
                throw new Error(messages.get("pluginInvalidProperty", name, "metadata." + key));
              }
            };
            Plugin.prototype.normalize = function normalize(visitor) {
              _traversal2["default"].explode(visitor);
              return visitor;
            };
            Plugin.prototype.buildPass = function buildPass(file) {
              if (!(file instanceof _file2["default"])) {
                throw new TypeError(messages.get("pluginNotFile", this.key));
              }
              return new _pluginPass2["default"](file, this);
            };
            return Plugin;
          })();
          exports["default"] = Plugin;
          module.exports = exports["default"];
        }, {
          "../messages": 60,
          "../traversal": 165,
          "../types": 196,
          "./file": 63,
          "./plugin-pass": 98,
          "lodash/lang/clone": 511,
          "lodash/object/assign": 526
        }],
        100: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _plugin = require("./plugin");
          var _plugin2 = _interopRequireDefault(_plugin);
          var Transformer = function Transformer(key, obj) {
            _classCallCheck(this, Transformer);
            var plugin = {};
            plugin.metadata = obj.metadata;
            delete obj.metadata;
            plugin.visitor = obj;
            return new _plugin2["default"](key, plugin);
          };
          exports["default"] = Transformer;
          module.exports = exports["default"];
        }, {"./plugin": 99}],
        101: [function(require, module, exports) {
          module.exports = {
            "useStrict": "strict",
            "es5.runtime": "runtime",
            "es6.runtime": "runtime",
            "minification.inlineExpressions": "minification.constantFolding"
          };
        }, {}],
        102: [function(require, module, exports) {
          module.exports = {
            "selfContained": "runtime",
            "unicode-regex": "regex.unicode",
            "spec.typeofSymbol": "es6.spec.symbols",
            "es6.symbols": "es6.spec.symbols",
            "es6.blockScopingTDZ": "es6.spec.blockScoping",
            "utility.inlineExpressions": "minification.constantFolding",
            "utility.deadCodeElimination": "minification.deadCodeElimination",
            "utility.removeConsoleCalls": "minification.removeConsole",
            "utility.removeDebugger": "minification.removeDebugger",
            "es6.parameters.rest": "es6.parameters",
            "es6.parameters.default": "es6.parameters"
          };
        }, {}],
        103: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-trailing"};
          exports.metadata = metadata;
          var visitor = {MemberExpression: {exit: function exit(node) {
                var prop = node.property;
                if (!node.computed && t.isIdentifier(prop) && !t.isValidIdentifier(prop.name)) {
                  node.property = t.literal(prop.name);
                  node.computed = true;
                }
              }}};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        104: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-trailing"};
          exports.metadata = metadata;
          var visitor = {Property: {exit: function exit(node) {
                var key = node.key;
                if (!node.computed && t.isIdentifier(key) && !t.isValidIdentifier(key.name)) {
                  node.key = t.literal(key.name);
                }
              }}};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        105: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _helpersDefineMap = require("../../helpers/define-map");
          var defineMap = _interopRequireWildcard(_helpersDefineMap);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var visitor = {ObjectExpression: function ObjectExpression(node, parent, scope, file) {
              var hasAny = false;
              var _arr = node.properties;
              for (var _i = 0; _i < _arr.length; _i++) {
                var prop = _arr[_i];
                if (prop.kind === "get" || prop.kind === "set") {
                  hasAny = true;
                  break;
                }
              }
              if (!hasAny)
                return;
              var mutatorMap = {};
              node.properties = node.properties.filter(function(prop) {
                if (prop.kind === "get" || prop.kind === "set") {
                  defineMap.push(mutatorMap, prop, prop.kind, file);
                  return false;
                } else {
                  return true;
                }
              });
              return t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("defineProperties")), [node, defineMap.toDefineObject(mutatorMap)]);
            }};
          exports.visitor = visitor;
        }, {
          "../../../types": 196,
          "../../helpers/define-map": 74
        }],
        106: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var visitor = {ArrowFunctionExpression: function ArrowFunctionExpression(node) {
              this.ensureBlock();
              node.expression = false;
              node.type = "FunctionExpression";
              node.shadow = node.shadow || true;
            }};
          exports.visitor = visitor;
        }, {}],
        107: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _traversal = require("../../../traversal");
          var _traversal2 = _interopRequireDefault(_traversal);
          var _helpersObject = require("../../../helpers/object");
          var _helpersObject2 = _interopRequireDefault(_helpersObject);
          var _util = require("../../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var _lodashObjectValues = require("lodash/object/values");
          var _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);
          var _lodashObjectExtend = require("lodash/object/extend");
          var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
          function isLet(node, parent) {
            if (!t.isVariableDeclaration(node))
              return false;
            if (node._let)
              return true;
            if (node.kind !== "let")
              return false;
            if (isLetInitable(node, parent)) {
              for (var i = 0; i < node.declarations.length; i++) {
                var declar = node.declarations[i];
                declar.init = declar.init || t.identifier("undefined");
              }
            }
            node._let = true;
            node.kind = "var";
            return true;
          }
          function isLetInitable(node, parent) {
            return !t.isFor(parent) || !t.isFor(parent, {left: node});
          }
          function isVar(node, parent) {
            return t.isVariableDeclaration(node, {kind: "var"}) && !isLet(node, parent);
          }
          function standardizeLets(declars) {
            var _arr = declars;
            for (var _i = 0; _i < _arr.length; _i++) {
              var declar = _arr[_i];
              delete declar._let;
            }
          }
          var metadata = {group: "builtin-advanced"};
          exports.metadata = metadata;
          var visitor = {
            VariableDeclaration: function VariableDeclaration(node, parent, scope, file) {
              if (!isLet(node, parent))
                return;
              if (isLetInitable(node) && file.transformers["es6.spec.blockScoping"].canTransform()) {
                var nodes = [node];
                for (var i = 0; i < node.declarations.length; i++) {
                  var decl = node.declarations[i];
                  if (decl.init) {
                    var assign = t.assignmentExpression("=", decl.id, decl.init);
                    assign._ignoreBlockScopingTDZ = true;
                    nodes.push(t.expressionStatement(assign));
                  }
                  decl.init = file.addHelper("temporal-undefined");
                }
                node._blockHoist = 2;
                return nodes;
              }
            },
            Loop: function Loop(node, parent, scope, file) {
              var init = node.left || node.init;
              if (isLet(init, node)) {
                t.ensureBlock(node);
                node.body._letDeclarators = [init];
              }
              var blockScoping = new BlockScoping(this, this.get("body"), parent, scope, file);
              return blockScoping.run();
            },
            "BlockStatement|Program": function BlockStatementProgram(block, parent, scope, file) {
              if (!t.isLoop(parent)) {
                var blockScoping = new BlockScoping(null, this, parent, scope, file);
                blockScoping.run();
              }
            }
          };
          exports.visitor = visitor;
          function replace(node, parent, scope, remaps) {
            var remap = remaps[node.name];
            if (!remap)
              return;
            var ownBinding = scope.getBindingIdentifier(node.name);
            if (ownBinding === remap.binding) {
              node.name = remap.uid;
            } else {
              if (this)
                this.skip();
            }
          }
          var replaceVisitor = {
            ReferencedIdentifier: replace,
            AssignmentExpression: function AssignmentExpression(node, parent, scope, remaps) {
              var ids = this.getBindingIdentifiers();
              for (var name in ids) {
                replace(ids[name], node, scope, remaps);
              }
            }
          };
          function traverseReplace(node, parent, scope, remaps) {
            if (t.isIdentifier(node)) {
              replace(node, parent, scope, remaps);
            }
            if (t.isAssignmentExpression(node)) {
              var ids = t.getBindingIdentifiers(node);
              for (var name in ids) {
                replace(ids[name], parent, scope, remaps);
              }
            }
            scope.traverse(node, replaceVisitor, remaps);
          }
          var letReferenceBlockVisitor = {Function: function Function(node, parent, scope, state) {
              this.traverse(letReferenceFunctionVisitor, state);
              return this.skip();
            }};
          var letReferenceFunctionVisitor = {ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              var ref = state.letReferences[node.name];
              if (!ref)
                return;
              var localBinding = scope.getBindingIdentifier(node.name);
              if (localBinding && localBinding !== ref)
                return;
              state.closurify = true;
            }};
          var hoistVarDeclarationsVisitor = {enter: function enter(node, parent, scope, self) {
              if (this.isForStatement()) {
                if (isVar(node.init, node)) {
                  var nodes = self.pushDeclar(node.init);
                  if (nodes.length === 1) {
                    node.init = nodes[0];
                  } else {
                    node.init = t.sequenceExpression(nodes);
                  }
                }
              } else if (this.isFor()) {
                if (isVar(node.left, node)) {
                  self.pushDeclar(node.left);
                  node.left = node.left.declarations[0].id;
                }
              } else if (isVar(node, parent)) {
                return self.pushDeclar(node).map(t.expressionStatement);
              } else if (this.isFunction()) {
                return this.skip();
              }
            }};
          var loopLabelVisitor = {LabeledStatement: function LabeledStatement(node, parent, scope, state) {
              state.innerLabels.push(node.label.name);
            }};
          var continuationVisitor = {enter: function enter(node, parent, scope, state) {
              if (this.isAssignmentExpression() || this.isUpdateExpression()) {
                var bindings = this.getBindingIdentifiers();
                for (var name in bindings) {
                  if (state.outsideReferences[name] !== scope.getBindingIdentifier(name))
                    continue;
                  state.reassignments[name] = true;
                }
              }
            }};
          var loopNodeTo = function loopNodeTo(node) {
            if (t.isBreakStatement(node)) {
              return "break";
            } else if (t.isContinueStatement(node)) {
              return "continue";
            }
          };
          var loopVisitor = {
            Loop: function Loop(node, parent, scope, state) {
              var oldIgnoreLabeless = state.ignoreLabeless;
              state.ignoreLabeless = true;
              this.traverse(loopVisitor, state);
              state.ignoreLabeless = oldIgnoreLabeless;
              this.skip();
            },
            Function: function Function() {
              this.skip();
            },
            SwitchCase: function SwitchCase(node, parent, scope, state) {
              var oldInSwitchCase = state.inSwitchCase;
              state.inSwitchCase = true;
              this.traverse(loopVisitor, state);
              state.inSwitchCase = oldInSwitchCase;
              this.skip();
            },
            enter: function enter(node, parent, scope, state) {
              var replace;
              var loopText = loopNodeTo(node);
              if (loopText) {
                if (node.label) {
                  if (state.innerLabels.indexOf(node.label.name) >= 0) {
                    return;
                  }
                  loopText = loopText + "|" + node.label.name;
                } else {
                  if (state.ignoreLabeless)
                    return;
                  if (state.inSwitchCase)
                    return;
                  if (t.isBreakStatement(node) && t.isSwitchCase(parent))
                    return;
                }
                state.hasBreakContinue = true;
                state.map[loopText] = node;
                replace = t.literal(loopText);
              }
              if (this.isReturnStatement()) {
                state.hasReturn = true;
                replace = t.objectExpression([t.property("init", t.identifier("v"), node.argument || t.identifier("undefined"))]);
              }
              if (replace) {
                replace = t.returnStatement(replace);
                this.skip();
                return t.inherits(replace, node);
              }
            }
          };
          var BlockScoping = (function() {
            function BlockScoping(loopPath, blockPath, parent, scope, file) {
              _classCallCheck(this, BlockScoping);
              this.parent = parent;
              this.scope = scope;
              this.file = file;
              this.blockPath = blockPath;
              this.block = blockPath.node;
              this.outsideLetReferences = _helpersObject2["default"]();
              this.hasLetReferences = false;
              this.letReferences = this.block._letReferences = _helpersObject2["default"]();
              this.body = [];
              if (loopPath) {
                this.loopParent = loopPath.parent;
                this.loopLabel = t.isLabeledStatement(this.loopParent) && this.loopParent.label;
                this.loopPath = loopPath;
                this.loop = loopPath.node;
              }
            }
            BlockScoping.prototype.run = function run() {
              var block = this.block;
              if (block._letDone)
                return;
              block._letDone = true;
              var needsClosure = this.getLetReferences();
              if (t.isFunction(this.parent) || t.isProgram(this.block))
                return;
              if (!this.hasLetReferences)
                return;
              if (needsClosure) {
                this.wrapClosure();
              } else {
                this.remap();
              }
              if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {
                return t.labeledStatement(this.loopLabel, this.loop);
              }
            };
            BlockScoping.prototype.remap = function remap() {
              var hasRemaps = false;
              var letRefs = this.letReferences;
              var scope = this.scope;
              var remaps = _helpersObject2["default"]();
              for (var key in letRefs) {
                var ref = letRefs[key];
                if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
                  var uid = scope.generateUidIdentifier(ref.name).name;
                  ref.name = uid;
                  hasRemaps = true;
                  remaps[key] = remaps[uid] = {
                    binding: ref,
                    uid: uid
                  };
                }
              }
              if (!hasRemaps)
                return;
              var loop = this.loop;
              if (loop) {
                traverseReplace(loop.right, loop, scope, remaps);
                traverseReplace(loop.test, loop, scope, remaps);
                traverseReplace(loop.update, loop, scope, remaps);
              }
              this.blockPath.traverse(replaceVisitor, remaps);
            };
            BlockScoping.prototype.wrapClosure = function wrapClosure() {
              var block = this.block;
              var outsideRefs = this.outsideLetReferences;
              if (this.loop) {
                for (var name in outsideRefs) {
                  var id = outsideRefs[name];
                  if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {
                    delete outsideRefs[id.name];
                    delete this.letReferences[id.name];
                    this.scope.rename(id.name);
                    this.letReferences[id.name] = id;
                    outsideRefs[id.name] = id;
                  }
                }
              }
              this.has = this.checkLoop();
              this.hoistVarDeclarations();
              var params = _lodashObjectValues2["default"](outsideRefs);
              var args = _lodashObjectValues2["default"](outsideRefs);
              var fn = t.functionExpression(null, params, t.blockStatement(block.body));
              fn.shadow = true;
              this.addContinuations(fn);
              block.body = this.body;
              var ref = fn;
              if (this.loop) {
                ref = this.scope.generateUidIdentifier("loop");
                this.loopPath.insertBefore(t.variableDeclaration("var", [t.variableDeclarator(ref, fn)]));
              }
              var call = t.callExpression(ref, args);
              var ret = this.scope.generateUidIdentifier("ret");
              var hasYield = _traversal2["default"].hasType(fn.body, this.scope, "YieldExpression", t.FUNCTION_TYPES);
              if (hasYield) {
                fn.generator = true;
                call = t.yieldExpression(call, true);
              }
              var hasAsync = _traversal2["default"].hasType(fn.body, this.scope, "AwaitExpression", t.FUNCTION_TYPES);
              if (hasAsync) {
                fn.async = true;
                call = t.awaitExpression(call);
              }
              this.buildClosure(ret, call);
            };
            BlockScoping.prototype.buildClosure = function buildClosure(ret, call) {
              var has = this.has;
              if (has.hasReturn || has.hasBreakContinue) {
                this.buildHas(ret, call);
              } else {
                this.body.push(t.expressionStatement(call));
              }
            };
            BlockScoping.prototype.addContinuations = function addContinuations(fn) {
              var state = {
                reassignments: {},
                outsideReferences: this.outsideLetReferences
              };
              this.scope.traverse(fn, continuationVisitor, state);
              for (var i = 0; i < fn.params.length; i++) {
                var param = fn.params[i];
                if (!state.reassignments[param.name])
                  continue;
                var newParam = this.scope.generateUidIdentifier(param.name);
                fn.params[i] = newParam;
                this.scope.rename(param.name, newParam.name, fn);
                fn.body.body.push(t.expressionStatement(t.assignmentExpression("=", param, newParam)));
              }
            };
            BlockScoping.prototype.getLetReferences = function getLetReferences() {
              var block = this.block;
              var declarators = block._letDeclarators || [];
              for (var i = 0; i < declarators.length; i++) {
                var declar = declarators[i];
                _lodashObjectExtend2["default"](this.outsideLetReferences, t.getBindingIdentifiers(declar));
              }
              if (block.body) {
                for (var i = 0; i < block.body.length; i++) {
                  var declar = block.body[i];
                  if (isLet(declar, block)) {
                    declarators = declarators.concat(declar.declarations);
                  }
                }
              }
              for (var i = 0; i < declarators.length; i++) {
                var declar = declarators[i];
                var keys = t.getBindingIdentifiers(declar);
                _lodashObjectExtend2["default"](this.letReferences, keys);
                this.hasLetReferences = true;
              }
              if (!this.hasLetReferences)
                return;
              standardizeLets(declarators);
              var state = {
                letReferences: this.letReferences,
                closurify: false
              };
              this.blockPath.traverse(letReferenceBlockVisitor, state);
              return state.closurify;
            };
            BlockScoping.prototype.checkLoop = function checkLoop() {
              var state = {
                hasBreakContinue: false,
                ignoreLabeless: false,
                inSwitchCase: false,
                innerLabels: [],
                hasReturn: false,
                isLoop: !!this.loop,
                map: {}
              };
              this.blockPath.traverse(loopLabelVisitor, state);
              this.blockPath.traverse(loopVisitor, state);
              return state;
            };
            BlockScoping.prototype.hoistVarDeclarations = function hoistVarDeclarations() {
              this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
            };
            BlockScoping.prototype.pushDeclar = function pushDeclar(node) {
              var declars = [];
              var names = t.getBindingIdentifiers(node);
              for (var name in names) {
                declars.push(t.variableDeclarator(names[name]));
              }
              this.body.push(t.variableDeclaration(node.kind, declars));
              var replace = [];
              for (var i = 0; i < node.declarations.length; i++) {
                var declar = node.declarations[i];
                if (!declar.init)
                  continue;
                var expr = t.assignmentExpression("=", declar.id, declar.init);
                replace.push(t.inherits(expr, declar));
              }
              return replace;
            };
            BlockScoping.prototype.buildHas = function buildHas(ret, call) {
              var body = this.body;
              body.push(t.variableDeclaration("var", [t.variableDeclarator(ret, call)]));
              var retCheck;
              var has = this.has;
              var cases = [];
              if (has.hasReturn) {
                retCheck = util.template("let-scoping-return", {RETURN: ret});
              }
              if (has.hasBreakContinue) {
                for (var key in has.map) {
                  cases.push(t.switchCase(t.literal(key), [has.map[key]]));
                }
                if (has.hasReturn) {
                  cases.push(t.switchCase(null, [retCheck]));
                }
                if (cases.length === 1) {
                  var single = cases[0];
                  body.push(this.file.attachAuxiliaryComment(t.ifStatement(t.binaryExpression("===", ret, single.test), single.consequent[0])));
                } else {
                  for (var i = 0; i < cases.length; i++) {
                    var caseConsequent = cases[i].consequent[0];
                    if (t.isBreakStatement(caseConsequent) && !caseConsequent.label) {
                      caseConsequent.label = this.loopLabel = this.loopLabel || this.file.scope.generateUidIdentifier("loop");
                    }
                  }
                  body.push(this.file.attachAuxiliaryComment(t.switchStatement(ret, cases)));
                }
              } else {
                if (has.hasReturn) {
                  body.push(this.file.attachAuxiliaryComment(retCheck));
                }
              }
            };
            return BlockScoping;
          })();
        }, {
          "../../../helpers/object": 58,
          "../../../traversal": 165,
          "../../../types": 196,
          "../../../util": 199,
          "lodash/object/extend": 528,
          "lodash/object/values": 534
        }],
        108: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _loose = require("./loose");
          var _loose2 = _interopRequireDefault(_loose);
          var _vanilla = require("./vanilla");
          var _vanilla2 = _interopRequireDefault(_vanilla);
          var _types = require("../../../../types");
          var t = _interopRequireWildcard(_types);
          var _helpersNameMethod = require("../../../helpers/name-method");
          var visitor = {
            ClassDeclaration: function ClassDeclaration(node) {
              return t.variableDeclaration("let", [t.variableDeclarator(node.id, t.toExpression(node))]);
            },
            ClassExpression: function ClassExpression(node, parent, scope, file) {
              var inferred = _helpersNameMethod.bare(node, parent, scope);
              if (inferred)
                return inferred;
              if (file.isLoose("es6.classes")) {
                return new _loose2["default"](this, file).run();
              } else {
                return new _vanilla2["default"](this, file).run();
              }
            }
          };
          exports.visitor = visitor;
        }, {
          "../../../../types": 196,
          "../../../helpers/name-method": 78,
          "./loose": 109,
          "./vanilla": 110
        }],
        109: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }});
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _vanilla = require("./vanilla");
          var _vanilla2 = _interopRequireDefault(_vanilla);
          var _types = require("../../../../types");
          var t = _interopRequireWildcard(_types);
          var LooseClassTransformer = (function(_VanillaTransformer) {
            _inherits(LooseClassTransformer, _VanillaTransformer);
            function LooseClassTransformer() {
              _classCallCheck(this, LooseClassTransformer);
              _VanillaTransformer.apply(this, arguments);
              this.isLoose = true;
            }
            LooseClassTransformer.prototype._processMethod = function _processMethod(node) {
              if (!node.decorators) {
                var classRef = this.classRef;
                if (!node["static"])
                  classRef = t.memberExpression(classRef, t.identifier("prototype"));
                var methodName = t.memberExpression(classRef, node.key, node.computed || t.isLiteral(node.key));
                var expr = t.expressionStatement(t.assignmentExpression("=", methodName, node.value));
                t.inheritsComments(expr, node);
                this.body.push(expr);
                return true;
              }
            };
            return LooseClassTransformer;
          })(_vanilla2["default"]);
          exports["default"] = LooseClassTransformer;
          module.exports = exports["default"];
        }, {
          "../../../../types": 196,
          "./vanilla": 110
        }],
        110: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _helpersMemoiseDecorators = require("../../../helpers/memoise-decorators");
          var _helpersMemoiseDecorators2 = _interopRequireDefault(_helpersMemoiseDecorators);
          var _helpersReplaceSupers = require("../../../helpers/replace-supers");
          var _helpersReplaceSupers2 = _interopRequireDefault(_helpersReplaceSupers);
          var _helpersNameMethod = require("../../../helpers/name-method");
          var nameMethod = _interopRequireWildcard(_helpersNameMethod);
          var _helpersDefineMap = require("../../../helpers/define-map");
          var defineMap = _interopRequireWildcard(_helpersDefineMap);
          var _messages = require("../../../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _util = require("../../../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../../../types");
          var t = _interopRequireWildcard(_types);
          var PROPERTY_COLLISION_METHOD_NAME = "__initializeProperties";
          var collectPropertyReferencesVisitor = {Identifier: {enter: function enter(node, parent, scope, state) {
                if (this.parentPath.isClassProperty({key: node})) {
                  return;
                }
                if (this.isReferenced() && scope.getBinding(node.name) === state.scope.getBinding(node.name)) {
                  state.references[node.name] = true;
                }
              }}};
          var verifyConstructorVisitor = {
            MethodDefinition: function MethodDefinition() {
              this.skip();
            },
            Property: function Property(node) {
              if (node.method)
                this.skip();
            },
            CallExpression: {exit: function exit(node, parent, scope, state) {
                if (this.get("callee").isSuper()) {
                  state.hasBareSuper = true;
                  state.bareSuper = this;
                  if (!state.isDerived) {
                    throw this.errorWithNode("super call is only allowed in derived constructor");
                  }
                }
              }},
            "FunctionDeclaration|FunctionExpression": function FunctionDeclarationFunctionExpression() {
              this.skip();
            },
            ThisExpression: function ThisExpression(node, parent, scope, state) {
              if (state.isDerived && !state.hasBareSuper) {
                if (this.inShadow()) {
                  var thisAlias = state.constructorPath.getData("this");
                  if (!thisAlias) {
                    thisAlias = state.constructorPath.setData("this", state.constructorPath.scope.generateUidIdentifier("this"));
                  }
                  return thisAlias;
                } else {
                  throw this.errorWithNode("'this' is not allowed before super()");
                }
              }
            },
            Super: function Super(node, parent, scope, state) {
              if (state.isDerived && !state.hasBareSuper && !this.parentPath.isCallExpression({callee: node})) {
                throw this.errorWithNode("'super.*' is not allowed before super()");
              }
            }
          };
          var ClassTransformer = (function() {
            function ClassTransformer(path, file) {
              _classCallCheck(this, ClassTransformer);
              this.parent = path.parent;
              this.scope = path.scope;
              this.node = path.node;
              this.path = path;
              this.file = file;
              this.clearDescriptors();
              this.instancePropBody = [];
              this.instancePropRefs = {};
              this.staticPropBody = [];
              this.body = [];
              this.pushedConstructor = false;
              this.pushedInherits = false;
              this.hasDecorators = false;
              this.isLoose = false;
              this.classId = this.node.id;
              this.classRef = this.node.id || this.scope.generateUidIdentifier("class");
              this.directRef = null;
              this.superName = this.node.superClass || t.identifier("Function");
              this.isDerived = !!this.node.superClass;
            }
            ClassTransformer.prototype.run = function run() {
              var superName = this.superName;
              var file = this.file;
              var body = this.body;
              var constructorBody = this.constructorBody = t.blockStatement([]);
              this.constructor = this.buildConstructor();
              var closureParams = [];
              var closureArgs = [];
              if (this.isDerived) {
                closureArgs.push(superName);
                superName = this.scope.generateUidIdentifierBasedOnNode(superName);
                closureParams.push(superName);
                this.superName = superName;
              }
              var decorators = this.node.decorators;
              if (decorators) {
                this.directRef = this.scope.generateUidIdentifier(this.classRef);
              } else {
                this.directRef = this.classRef;
              }
              this.buildBody();
              constructorBody.body.unshift(t.expressionStatement(t.callExpression(file.addHelper("class-call-check"), [t.thisExpression(), this.directRef])));
              this.pushDecorators();
              body = body.concat(this.staticPropBody);
              if (this.classId) {
                if (body.length === 1)
                  return t.toExpression(body[0]);
              }
              body.push(t.returnStatement(this.classRef));
              var container = t.functionExpression(null, closureParams, t.blockStatement(body));
              container.shadow = true;
              return t.callExpression(container, closureArgs);
            };
            ClassTransformer.prototype.buildConstructor = function buildConstructor() {
              var func = t.functionDeclaration(this.classRef, [], this.constructorBody);
              t.inherits(func, this.node);
              return func;
            };
            ClassTransformer.prototype.pushToMap = function pushToMap(node, enumerable) {
              var kind = arguments.length <= 2 || arguments[2] === undefined ? "value" : arguments[2];
              var mutatorMap;
              if (node["static"]) {
                this.hasStaticDescriptors = true;
                mutatorMap = this.staticMutatorMap;
              } else {
                this.hasInstanceDescriptors = true;
                mutatorMap = this.instanceMutatorMap;
              }
              var map = defineMap.push(mutatorMap, node, kind, this.file);
              if (enumerable) {
                map.enumerable = t.literal(true);
              }
              if (map.decorators) {
                this.hasDecorators = true;
              }
            };
            ClassTransformer.prototype.constructorMeMaybe = function constructorMeMaybe() {
              var hasConstructor = false;
              var paths = this.path.get("body.body");
              var _arr = paths;
              for (var _i = 0; _i < _arr.length; _i++) {
                var path = _arr[_i];
                hasConstructor = path.equals("kind", "constructor");
                if (hasConstructor)
                  break;
              }
              if (hasConstructor)
                return;
              var constructor;
              if (this.isDerived) {
                constructor = util.template("class-derived-default-constructor");
              } else {
                constructor = t.functionExpression(null, [], t.blockStatement([]));
              }
              this.path.get("body").unshiftContainer("body", t.methodDefinition(t.identifier("constructor"), constructor, "constructor"));
            };
            ClassTransformer.prototype.buildBody = function buildBody() {
              this.constructorMeMaybe();
              this.pushBody();
              this.placePropertyInitializers();
              if (this.userConstructor) {
                var constructorBody = this.constructorBody;
                constructorBody.body = constructorBody.body.concat(this.userConstructor.body.body);
                t.inherits(this.constructor, this.userConstructor);
                t.inherits(constructorBody, this.userConstructor.body);
              }
              this.pushDescriptors();
            };
            ClassTransformer.prototype.pushBody = function pushBody() {
              var classBodyPaths = this.path.get("body.body");
              var _arr2 = classBodyPaths;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var path = _arr2[_i2];
                var node = path.node;
                if (node.decorators) {
                  _helpersMemoiseDecorators2["default"](node.decorators, this.scope);
                }
                if (t.isMethodDefinition(node)) {
                  var isConstructor = node.kind === "constructor";
                  if (isConstructor)
                    this.verifyConstructor(path);
                  var replaceSupers = new _helpersReplaceSupers2["default"]({
                    methodPath: path,
                    methodNode: node,
                    objectRef: this.directRef,
                    superRef: this.superName,
                    isStatic: node["static"],
                    isLoose: this.isLoose,
                    scope: this.scope,
                    file: this.file
                  }, true);
                  replaceSupers.replace();
                  if (isConstructor) {
                    this.pushConstructor(node, path);
                  } else {
                    this.pushMethod(node, path);
                  }
                } else if (t.isClassProperty(node)) {
                  this.pushProperty(node, path);
                }
              }
            };
            ClassTransformer.prototype.clearDescriptors = function clearDescriptors() {
              this.hasInstanceDescriptors = false;
              this.hasStaticDescriptors = false;
              this.instanceMutatorMap = {};
              this.staticMutatorMap = {};
            };
            ClassTransformer.prototype.pushDescriptors = function pushDescriptors() {
              this.pushInherits();
              var body = this.body;
              var instanceProps;
              var staticProps;
              var classHelper = "create-class";
              if (this.hasDecorators)
                classHelper = "create-decorated-class";
              if (this.hasInstanceDescriptors) {
                instanceProps = defineMap.toClassObject(this.instanceMutatorMap);
              }
              if (this.hasStaticDescriptors) {
                staticProps = defineMap.toClassObject(this.staticMutatorMap);
              }
              if (instanceProps || staticProps) {
                if (instanceProps)
                  instanceProps = defineMap.toComputedObjectFromClass(instanceProps);
                if (staticProps)
                  staticProps = defineMap.toComputedObjectFromClass(staticProps);
                var nullNode = t.literal(null);
                var args = [this.classRef, nullNode, nullNode, nullNode, nullNode];
                if (instanceProps)
                  args[1] = instanceProps;
                if (staticProps)
                  args[2] = staticProps;
                if (this.instanceInitializersId) {
                  args[3] = this.instanceInitializersId;
                  body.unshift(this.buildObjectAssignment(this.instanceInitializersId));
                }
                if (this.staticInitializersId) {
                  args[4] = this.staticInitializersId;
                  body.unshift(this.buildObjectAssignment(this.staticInitializersId));
                }
                var lastNonNullIndex = 0;
                for (var i = 0; i < args.length; i++) {
                  if (args[i] !== nullNode)
                    lastNonNullIndex = i;
                }
                args = args.slice(0, lastNonNullIndex + 1);
                body.push(t.expressionStatement(t.callExpression(this.file.addHelper(classHelper), args)));
              }
              this.clearDescriptors();
            };
            ClassTransformer.prototype.buildObjectAssignment = function buildObjectAssignment(id) {
              return t.variableDeclaration("var", [t.variableDeclarator(id, t.objectExpression([]))]);
            };
            ClassTransformer.prototype.placePropertyInitializers = function placePropertyInitializers() {
              var body = this.instancePropBody;
              if (!body.length)
                return;
              if (this.hasPropertyCollision()) {
                var call = t.expressionStatement(t.callExpression(t.memberExpression(t.thisExpression(), t.identifier(PROPERTY_COLLISION_METHOD_NAME)), []));
                this.pushMethod(t.methodDefinition(t.identifier(PROPERTY_COLLISION_METHOD_NAME), t.functionExpression(null, [], t.blockStatement(body))), null, true);
                if (this.isDerived) {
                  this.bareSuper.insertAfter(call);
                } else {
                  this.constructorBody.body.unshift(call);
                }
              } else {
                if (this.isDerived) {
                  this.bareSuper.insertAfter(body);
                } else {
                  this.constructorBody.body = body.concat(this.constructorBody.body);
                }
              }
            };
            ClassTransformer.prototype.hasPropertyCollision = function hasPropertyCollision() {
              if (this.userConstructorPath) {
                for (var name in this.instancePropRefs) {
                  if (this.userConstructorPath.scope.hasOwnBinding(name)) {
                    return true;
                  }
                }
              }
              return false;
            };
            ClassTransformer.prototype.verifyConstructor = function verifyConstructor(path) {
              var state = {
                constructorPath: path.get("value"),
                hasBareSuper: false,
                bareSuper: null,
                isDerived: this.isDerived,
                file: this.file
              };
              state.constructorPath.traverse(verifyConstructorVisitor, state);
              var thisAlias = state.constructorPath.getData("this");
              if (thisAlias && state.bareSuper) {
                state.bareSuper.insertAfter(t.variableDeclaration("var", [t.variableDeclarator(thisAlias, t.thisExpression())]));
              }
              this.bareSuper = state.bareSuper;
              if (!state.hasBareSuper && this.isDerived) {
                throw path.errorWithNode("Derived constructor must call super()");
              }
            };
            ClassTransformer.prototype.pushMethod = function pushMethod(node, path, allowedIllegal) {
              if (!allowedIllegal && t.isLiteral(t.toComputedKey(node), {value: PROPERTY_COLLISION_METHOD_NAME})) {
                throw this.file.errorWithNode(node, messages.get("illegalMethodName", PROPERTY_COLLISION_METHOD_NAME));
              }
              if (node.kind === "method") {
                nameMethod.property(node, this.file, path ? path.get("value").scope : this.scope);
                if (this._processMethod(node))
                  return;
              }
              this.pushToMap(node);
            };
            ClassTransformer.prototype._processMethod = function _processMethod() {
              return false;
            };
            ClassTransformer.prototype.pushProperty = function pushProperty(node, path) {
              path.traverse(collectPropertyReferencesVisitor, {
                references: this.instancePropRefs,
                scope: this.scope
              });
              if (node.decorators) {
                var body = [];
                if (node.value) {
                  body.push(t.returnStatement(node.value));
                  node.value = t.functionExpression(null, [], t.blockStatement(body));
                } else {
                  node.value = t.literal(null);
                }
                this.pushToMap(node, true, "initializer");
                var initializers;
                var target;
                if (node["static"]) {
                  initializers = this.staticInitializersId = this.staticInitializersId || this.scope.generateUidIdentifier("staticInitializers");
                  body = this.staticPropBody;
                  target = this.classRef;
                } else {
                  initializers = this.instanceInitializersId = this.instanceInitializersId || this.scope.generateUidIdentifier("instanceInitializers");
                  body = this.instancePropBody;
                  target = t.thisExpression();
                }
                body.push(t.expressionStatement(t.callExpression(this.file.addHelper("define-decorated-property-descriptor"), [target, t.literal(node.key.name), initializers])));
              } else {
                if (!node.value && !node.decorators)
                  return;
                if (node["static"]) {
                  this.pushToMap(node, true);
                } else if (node.value) {
                  this.instancePropBody.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), node.key), node.value)));
                }
              }
            };
            ClassTransformer.prototype.pushConstructor = function pushConstructor(method, path) {
              var fnPath = path.get("value");
              if (fnPath.scope.hasOwnBinding(this.classRef.name)) {
                fnPath.scope.rename(this.classRef.name);
              }
              var construct = this.constructor;
              var fn = method.value;
              this.userConstructorPath = fnPath;
              this.userConstructor = fn;
              this.hasConstructor = true;
              t.inheritsComments(construct, method);
              construct._ignoreUserWhitespace = true;
              construct.params = fn.params;
              t.inherits(construct.body, fn.body);
              this._pushConstructor();
            };
            ClassTransformer.prototype._pushConstructor = function _pushConstructor() {
              if (this.pushedConstructor)
                return;
              this.pushedConstructor = true;
              if (this.hasInstanceDescriptors || this.hasStaticDescriptors) {
                this.pushDescriptors();
              }
              this.body.push(this.constructor);
              this.pushInherits();
            };
            ClassTransformer.prototype.pushInherits = function pushInherits() {
              if (!this.isDerived || this.pushedInherits)
                return;
              this.pushedInherits = true;
              this.body.unshift(t.expressionStatement(t.callExpression(this.file.addHelper("inherits"), [this.classRef, this.superName])));
            };
            ClassTransformer.prototype.pushDecorators = function pushDecorators() {
              var decorators = this.node.decorators;
              if (!decorators)
                return;
              this.body.push(t.variableDeclaration("var", [t.variableDeclarator(this.directRef, this.classRef)]));
              decorators = decorators.reverse();
              var _arr3 = decorators;
              for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var decorator = _arr3[_i3];
                var decoratorNode = util.template("class-decorator", {
                  DECORATOR: decorator.expression,
                  CLASS_REF: this.classRef
                }, true);
                decoratorNode.expression._ignoreModulesRemap = true;
                this.body.push(decoratorNode);
              }
            };
            return ClassTransformer;
          })();
          exports["default"] = ClassTransformer;
          module.exports = exports["default"];
        }, {
          "../../../../messages": 60,
          "../../../../types": 196,
          "../../../../util": 199,
          "../../../helpers/define-map": 74,
          "../../../helpers/memoise-decorators": 77,
          "../../../helpers/name-method": 78,
          "../../../helpers/replace-supers": 82
        }],
        111: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _messages = require("../../../messages");
          var messages = _interopRequireWildcard(_messages);
          var visitor = {
            Scope: function Scope(node, parent, scope) {
              for (var name in scope.bindings) {
                var binding = scope.bindings[name];
                if (binding.kind !== "const" && binding.kind !== "module")
                  continue;
                var _arr = binding.constantViolations;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var violation = _arr[_i];
                  throw violation.errorWithNode(messages.get("readOnly", name));
                }
              }
            },
            VariableDeclaration: function VariableDeclaration(node) {
              if (node.kind === "const")
                node.kind = "let";
            }
          };
          exports.visitor = visitor;
        }, {"../../../messages": 60}],
        112: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _messages = require("../../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-advanced"};
          exports.metadata = metadata;
          var visitor = {
            ForXStatement: function ForXStatement(node, parent, scope, file) {
              var left = node.left;
              if (t.isPattern(left)) {
                var temp = scope.generateUidIdentifier("ref");
                node.left = t.variableDeclaration("var", [t.variableDeclarator(temp)]);
                this.ensureBlock();
                node.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(left, temp)]));
                return;
              }
              if (!t.isVariableDeclaration(left))
                return;
              var pattern = left.declarations[0].id;
              if (!t.isPattern(pattern))
                return;
              var key = scope.generateUidIdentifier("ref");
              node.left = t.variableDeclaration(left.kind, [t.variableDeclarator(key, null)]);
              var nodes = [];
              var destructuring = new DestructuringTransformer({
                kind: left.kind,
                file: file,
                scope: scope,
                nodes: nodes
              });
              destructuring.init(pattern, key);
              this.ensureBlock();
              var block = node.body;
              block.body = nodes.concat(block.body);
            },
            Function: function Function(node, parent, scope, file) {
              var hasDestructuring = false;
              var _arr = node.params;
              for (var _i = 0; _i < _arr.length; _i++) {
                var pattern = _arr[_i];
                if (t.isPattern(pattern)) {
                  hasDestructuring = true;
                  break;
                }
              }
              if (!hasDestructuring)
                return;
              var nodes = [];
              for (var i = 0; i < node.params.length; i++) {
                var pattern = node.params[i];
                if (!t.isPattern(pattern))
                  continue;
                var ref = scope.generateUidIdentifier("ref");
                if (t.isAssignmentPattern(pattern)) {
                  var _pattern = pattern;
                  pattern = pattern.left;
                  _pattern.left = ref;
                } else {
                  node.params[i] = ref;
                }
                t.inherits(ref, pattern);
                var destructuring = new DestructuringTransformer({
                  blockHoist: node.params.length - i,
                  nodes: nodes,
                  scope: scope,
                  file: file,
                  kind: "let"
                });
                destructuring.init(pattern, ref);
              }
              this.ensureBlock();
              var block = node.body;
              block.body = nodes.concat(block.body);
            },
            CatchClause: function CatchClause(node, parent, scope, file) {
              var pattern = node.param;
              if (!t.isPattern(pattern))
                return;
              var ref = scope.generateUidIdentifier("ref");
              node.param = ref;
              var nodes = [];
              var destructuring = new DestructuringTransformer({
                kind: "let",
                file: file,
                scope: scope,
                nodes: nodes
              });
              destructuring.init(pattern, ref);
              node.body.body = nodes.concat(node.body.body);
            },
            AssignmentExpression: function AssignmentExpression(node, parent, scope, file) {
              if (!t.isPattern(node.left))
                return;
              var nodes = [];
              var destructuring = new DestructuringTransformer({
                operator: node.operator,
                file: file,
                scope: scope,
                nodes: nodes
              });
              var ref;
              if (this.isCompletionRecord() || !this.parentPath.isExpressionStatement()) {
                ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
                nodes.push(t.variableDeclaration("var", [t.variableDeclarator(ref, node.right)]));
                if (t.isArrayExpression(node.right)) {
                  destructuring.arrays[ref.name] = true;
                }
              }
              destructuring.init(node.left, ref || node.right);
              if (ref) {
                nodes.push(t.expressionStatement(ref));
              }
              return nodes;
            },
            VariableDeclaration: function VariableDeclaration(node, parent, scope, file) {
              if (t.isForXStatement(parent))
                return;
              if (!variableDeclarationHasPattern(node))
                return;
              var nodes = [];
              var declar;
              for (var i = 0; i < node.declarations.length; i++) {
                declar = node.declarations[i];
                var patternId = declar.init;
                var pattern = declar.id;
                var destructuring = new DestructuringTransformer({
                  nodes: nodes,
                  scope: scope,
                  kind: node.kind,
                  file: file
                });
                if (t.isPattern(pattern)) {
                  destructuring.init(pattern, patternId);
                  if (+i !== node.declarations.length - 1) {
                    t.inherits(nodes[nodes.length - 1], declar);
                  }
                } else {
                  nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar));
                }
              }
              if (!t.isProgram(parent) && !t.isBlockStatement(parent)) {
                declar = null;
                for (i = 0; i < nodes.length; i++) {
                  node = nodes[i];
                  declar = declar || t.variableDeclaration(node.kind, []);
                  if (!t.isVariableDeclaration(node) && declar.kind !== node.kind) {
                    throw file.errorWithNode(node, messages.get("invalidParentForThisNode"));
                  }
                  declar.declarations = declar.declarations.concat(node.declarations);
                }
                return declar;
              }
              return nodes;
            }
          };
          exports.visitor = visitor;
          function variableDeclarationHasPattern(node) {
            for (var i = 0; i < node.declarations.length; i++) {
              if (t.isPattern(node.declarations[i].id)) {
                return true;
              }
            }
            return false;
          }
          function hasRest(pattern) {
            for (var i = 0; i < pattern.elements.length; i++) {
              if (t.isRestElement(pattern.elements[i])) {
                return true;
              }
            }
            return false;
          }
          var arrayUnpackVisitor = {ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              if (state.bindings[node.name]) {
                state.deopt = true;
                this.stop();
              }
            }};
          var DestructuringTransformer = (function() {
            function DestructuringTransformer(opts) {
              _classCallCheck(this, DestructuringTransformer);
              this.blockHoist = opts.blockHoist;
              this.operator = opts.operator;
              this.arrays = {};
              this.nodes = opts.nodes || [];
              this.scope = opts.scope;
              this.file = opts.file;
              this.kind = opts.kind;
            }
            DestructuringTransformer.prototype.buildVariableAssignment = function buildVariableAssignment(id, init) {
              var op = this.operator;
              if (t.isMemberExpression(id))
                op = "=";
              var node;
              if (op) {
                node = t.expressionStatement(t.assignmentExpression(op, id, init));
              } else {
                node = t.variableDeclaration(this.kind, [t.variableDeclarator(id, init)]);
              }
              node._blockHoist = this.blockHoist;
              return node;
            };
            DestructuringTransformer.prototype.buildVariableDeclaration = function buildVariableDeclaration(id, init) {
              var declar = t.variableDeclaration("var", [t.variableDeclarator(id, init)]);
              declar._blockHoist = this.blockHoist;
              return declar;
            };
            DestructuringTransformer.prototype.push = function push(id, init) {
              if (t.isObjectPattern(id)) {
                this.pushObjectPattern(id, init);
              } else if (t.isArrayPattern(id)) {
                this.pushArrayPattern(id, init);
              } else if (t.isAssignmentPattern(id)) {
                this.pushAssignmentPattern(id, init);
              } else {
                this.nodes.push(this.buildVariableAssignment(id, init));
              }
            };
            DestructuringTransformer.prototype.toArray = function toArray(node, count) {
              if (this.file.isLoose("es6.destructuring") || t.isIdentifier(node) && this.arrays[node.name]) {
                return node;
              } else {
                return this.scope.toArray(node, count);
              }
            };
            DestructuringTransformer.prototype.pushAssignmentPattern = function pushAssignmentPattern(pattern, valueRef) {
              var tempValueRef = this.scope.generateUidIdentifierBasedOnNode(valueRef);
              var declar = t.variableDeclaration("var", [t.variableDeclarator(tempValueRef, valueRef)]);
              declar._blockHoist = this.blockHoist;
              this.nodes.push(declar);
              var tempConditional = t.conditionalExpression(t.binaryExpression("===", tempValueRef, t.identifier("undefined")), pattern.right, tempValueRef);
              var left = pattern.left;
              if (t.isPattern(left)) {
                var tempValueDefault = t.expressionStatement(t.assignmentExpression("=", tempValueRef, tempConditional));
                tempValueDefault._blockHoist = this.blockHoist;
                this.nodes.push(tempValueDefault);
                this.push(left, tempValueRef);
              } else {
                this.nodes.push(this.buildVariableAssignment(left, tempConditional));
              }
            };
            DestructuringTransformer.prototype.pushObjectSpread = function pushObjectSpread(pattern, objRef, spreadProp, spreadPropIndex) {
              var keys = [];
              for (var i = 0; i < pattern.properties.length; i++) {
                var prop = pattern.properties[i];
                if (i >= spreadPropIndex)
                  break;
                if (t.isSpreadProperty(prop))
                  continue;
                var key = prop.key;
                if (t.isIdentifier(key) && !prop.computed)
                  key = t.literal(prop.key.name);
                keys.push(key);
              }
              keys = t.arrayExpression(keys);
              var value = t.callExpression(this.file.addHelper("object-without-properties"), [objRef, keys]);
              this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
            };
            DestructuringTransformer.prototype.pushObjectProperty = function pushObjectProperty(prop, propRef) {
              if (t.isLiteral(prop.key))
                prop.computed = true;
              var pattern = prop.value;
              var objRef = t.memberExpression(propRef, prop.key, prop.computed);
              if (t.isPattern(pattern)) {
                this.push(pattern, objRef);
              } else {
                this.nodes.push(this.buildVariableAssignment(pattern, objRef));
              }
            };
            DestructuringTransformer.prototype.pushObjectPattern = function pushObjectPattern(pattern, objRef) {
              if (!pattern.properties.length) {
                this.nodes.push(t.expressionStatement(t.callExpression(this.file.addHelper("object-destructuring-empty"), [objRef])));
              }
              if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
                var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
                this.nodes.push(this.buildVariableDeclaration(temp, objRef));
                objRef = temp;
              }
              for (var i = 0; i < pattern.properties.length; i++) {
                var prop = pattern.properties[i];
                if (t.isSpreadProperty(prop)) {
                  this.pushObjectSpread(pattern, objRef, prop, i);
                } else {
                  this.pushObjectProperty(prop, objRef);
                }
              }
            };
            DestructuringTransformer.prototype.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {
              if (!t.isArrayExpression(arr))
                return false;
              if (pattern.elements.length > arr.elements.length)
                return;
              if (pattern.elements.length < arr.elements.length && !hasRest(pattern))
                return false;
              var _arr2 = pattern.elements;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var elem = _arr2[_i2];
                if (!elem)
                  return false;
                if (t.isMemberExpression(elem))
                  return false;
              }
              var _arr3 = arr.elements;
              for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var elem = _arr3[_i3];
                if (t.isSpreadElement(elem))
                  return false;
              }
              var bindings = t.getBindingIdentifiers(pattern);
              var state = {
                deopt: false,
                bindings: bindings
              };
              this.scope.traverse(arr, arrayUnpackVisitor, state);
              return !state.deopt;
            };
            DestructuringTransformer.prototype.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {
              for (var i = 0; i < pattern.elements.length; i++) {
                var elem = pattern.elements[i];
                if (t.isRestElement(elem)) {
                  this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));
                } else {
                  this.push(elem, arr.elements[i]);
                }
              }
            };
            DestructuringTransformer.prototype.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {
              if (!pattern.elements)
                return;
              if (this.canUnpackArrayPattern(pattern, arrayRef)) {
                return this.pushUnpackedArrayPattern(pattern, arrayRef);
              }
              var count = !hasRest(pattern) && pattern.elements.length;
              var toArray = this.toArray(arrayRef, count);
              if (t.isIdentifier(toArray)) {
                arrayRef = toArray;
              } else {
                arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
                this.arrays[arrayRef.name] = true;
                this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
              }
              for (var i = 0; i < pattern.elements.length; i++) {
                var elem = pattern.elements[i];
                if (!elem)
                  continue;
                var elemRef;
                if (t.isRestElement(elem)) {
                  elemRef = this.toArray(arrayRef);
                  if (i > 0) {
                    elemRef = t.callExpression(t.memberExpression(elemRef, t.identifier("slice")), [t.literal(i)]);
                  }
                  elem = elem.argument;
                } else {
                  elemRef = t.memberExpression(arrayRef, t.literal(i), true);
                }
                this.push(elem, elemRef);
              }
            };
            DestructuringTransformer.prototype.init = function init(pattern, ref) {
              if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {
                var memo = this.scope.maybeGenerateMemoised(ref, true);
                if (memo) {
                  this.nodes.push(this.buildVariableDeclaration(memo, ref));
                  ref = memo;
                }
              }
              this.push(pattern, ref);
              return this.nodes;
            };
            return DestructuringTransformer;
          })();
        }, {
          "../../../messages": 60,
          "../../../types": 196
        }],
        113: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports._ForOfStatementArray = _ForOfStatementArray;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _messages = require("../../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _util = require("../../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var visitor = {ForOfStatement: function ForOfStatement(node, parent, scope, file) {
              if (this.get("right").isArrayExpression()) {
                return _ForOfStatementArray.call(this, node, scope, file);
              }
              var callback = spec;
              if (file.isLoose("es6.forOf"))
                callback = loose;
              var build = callback(node, parent, scope, file);
              var declar = build.declar;
              var loop = build.loop;
              var block = loop.body;
              this.ensureBlock();
              if (declar) {
                block.body.push(declar);
              }
              block.body = block.body.concat(node.body.body);
              t.inherits(loop, node);
              t.inherits(loop.body, node.body);
              if (build.replaceParent) {
                this.parentPath.replaceWithMultiple(build.node);
                this.dangerouslyRemove();
              } else {
                return build.node;
              }
            }};
          exports.visitor = visitor;
          function _ForOfStatementArray(node, scope) {
            var nodes = [];
            var right = node.right;
            if (!t.isIdentifier(right) || !scope.hasBinding(right.name)) {
              var uid = scope.generateUidIdentifier("arr");
              nodes.push(t.variableDeclaration("var", [t.variableDeclarator(uid, right)]));
              right = uid;
            }
            var iterationKey = scope.generateUidIdentifier("i");
            var loop = util.template("for-of-array", {
              BODY: node.body,
              KEY: iterationKey,
              ARR: right
            });
            t.inherits(loop, node);
            t.ensureBlock(loop);
            var iterationValue = t.memberExpression(right, iterationKey, true);
            var left = node.left;
            if (t.isVariableDeclaration(left)) {
              left.declarations[0].init = iterationValue;
              loop.body.body.unshift(left);
            } else {
              loop.body.body.unshift(t.expressionStatement(t.assignmentExpression("=", left, iterationValue)));
            }
            if (this.parentPath.isLabeledStatement()) {
              loop = t.labeledStatement(this.parentPath.node.label, loop);
            }
            nodes.push(loop);
            return nodes;
          }
          var loose = function loose(node, parent, scope, file) {
            var left = node.left;
            var declar,
                id;
            if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {
              id = left;
            } else if (t.isVariableDeclaration(left)) {
              id = scope.generateUidIdentifier("ref");
              declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, id)]);
            } else {
              throw file.errorWithNode(left, messages.get("unknownForHead", left.type));
            }
            var iteratorKey = scope.generateUidIdentifier("iterator");
            var isArrayKey = scope.generateUidIdentifier("isArray");
            var loop = util.template("for-of-loose", {
              LOOP_OBJECT: iteratorKey,
              IS_ARRAY: isArrayKey,
              OBJECT: node.right,
              INDEX: scope.generateUidIdentifier("i"),
              ID: id
            });
            if (!declar) {
              loop.body.body.shift();
            }
            return {
              declar: declar,
              node: loop,
              loop: loop
            };
          };
          var spec = function spec(node, parent, scope, file) {
            var left = node.left;
            var declar;
            var stepKey = scope.generateUidIdentifier("step");
            var stepValue = t.memberExpression(stepKey, t.identifier("value"));
            if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {
              declar = t.expressionStatement(t.assignmentExpression("=", left, stepValue));
            } else if (t.isVariableDeclaration(left)) {
              declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, stepValue)]);
            } else {
              throw file.errorWithNode(left, messages.get("unknownForHead", left.type));
            }
            var iteratorKey = scope.generateUidIdentifier("iterator");
            var template = util.template("for-of", {
              ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
              ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
              ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
              ITERATOR_KEY: iteratorKey,
              STEP_KEY: stepKey,
              OBJECT: node.right,
              BODY: null
            });
            var isLabeledParent = t.isLabeledStatement(parent);
            var tryBody = template[3].block.body;
            var loop = tryBody[0];
            if (isLabeledParent) {
              tryBody[0] = t.labeledStatement(parent.label, loop);
            }
            return {
              replaceParent: isLabeledParent,
              declar: declar,
              loop: loop,
              node: template
            };
          };
        }, {
          "../../../messages": 60,
          "../../../types": 196,
          "../../../util": 199
        }],
        114: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var metadata = {group: "builtin-pre"};
          exports.metadata = metadata;
          var visitor = {Literal: function Literal(node) {
              if (typeof node.value === "number" && /^0[ob]/i.test(node.raw)) {
                node.raw = undefined;
              }
              if (typeof node.value === "string" && /\\[u]/gi.test(node.raw)) {
                node.raw = undefined;
              }
            }};
          exports.visitor = visitor;
        }, {}],
        115: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function keepBlockHoist(node, nodes) {
            if (node._blockHoist) {
              for (var i = 0; i < nodes.length; i++) {
                nodes[i]._blockHoist = node._blockHoist;
              }
            }
          }
          var metadata = {group: "builtin-modules"};
          exports.metadata = metadata;
          var visitor = {
            ImportDeclaration: function ImportDeclaration(node, parent, scope, file) {
              if (node.importKind === "type" || node.importKind === "typeof")
                return;
              var nodes = [];
              if (node.specifiers.length) {
                var _arr = node.specifiers;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var specifier = _arr[_i];
                  file.moduleFormatter.importSpecifier(specifier, node, nodes, scope);
                }
              } else {
                file.moduleFormatter.importDeclaration(node, nodes, scope);
              }
              if (nodes.length === 1) {
                nodes[0]._blockHoist = node._blockHoist;
              }
              return nodes;
            },
            ExportAllDeclaration: function ExportAllDeclaration(node, parent, scope, file) {
              var nodes = [];
              file.moduleFormatter.exportAllDeclaration(node, nodes, scope);
              keepBlockHoist(node, nodes);
              return nodes;
            },
            ExportDefaultDeclaration: function ExportDefaultDeclaration(node, parent, scope, file) {
              var nodes = [];
              file.moduleFormatter.exportDeclaration(node, nodes, scope);
              keepBlockHoist(node, nodes);
              return nodes;
            },
            ExportNamedDeclaration: function ExportNamedDeclaration(node, parent, scope, file) {
              if (this.get("declaration").isTypeAlias())
                return;
              var nodes = [];
              if (node.declaration) {
                if (t.isVariableDeclaration(node.declaration)) {
                  var declar = node.declaration.declarations[0];
                  declar.init = declar.init || t.identifier("undefined");
                }
                file.moduleFormatter.exportDeclaration(node, nodes, scope);
              } else if (node.specifiers) {
                for (var i = 0; i < node.specifiers.length; i++) {
                  file.moduleFormatter.exportSpecifier(node.specifiers[i], node, nodes, scope);
                }
              }
              keepBlockHoist(node, nodes);
              return nodes;
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        116: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersReplaceSupers = require("../../helpers/replace-supers");
          var _helpersReplaceSupers2 = _interopRequireDefault(_helpersReplaceSupers);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function Property(path, node, scope, getObjectRef, file) {
            if (!node.method && node.kind === "init")
              return;
            if (!t.isFunction(node.value))
              return;
            var replaceSupers = new _helpersReplaceSupers2["default"]({
              getObjectRef: getObjectRef,
              methodNode: node,
              methodPath: path,
              isStatic: true,
              scope: scope,
              file: file
            });
            replaceSupers.replace();
          }
          var visitor = {ObjectExpression: function ObjectExpression(node, parent, scope, file) {
              var objectRef;
              var getObjectRef = function getObjectRef() {
                return objectRef = objectRef || scope.generateUidIdentifier("obj");
              };
              var propPaths = this.get("properties");
              for (var i = 0; i < node.properties.length; i++) {
                Property(propPaths[i], node.properties[i], scope, getObjectRef, file);
              }
              if (objectRef) {
                scope.push({id: objectRef});
                return t.assignmentExpression("=", objectRef, node);
              }
            }};
          exports.visitor = visitor;
        }, {
          "../../../types": 196,
          "../../helpers/replace-supers": 82
        }],
        117: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersCallDelegate = require("../../../helpers/call-delegate");
          var _helpersCallDelegate2 = _interopRequireDefault(_helpersCallDelegate);
          var _helpersGetFunctionArity = require("../../../helpers/get-function-arity");
          var _helpersGetFunctionArity2 = _interopRequireDefault(_helpersGetFunctionArity);
          var _util = require("../../../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../../../types");
          var t = _interopRequireWildcard(_types);
          var hasDefaults = function hasDefaults(node) {
            for (var i = 0; i < node.params.length; i++) {
              if (!t.isIdentifier(node.params[i]))
                return true;
            }
            return false;
          };
          var iifeVisitor = {ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              if (node.name !== "eval") {
                if (!state.scope.hasOwnBinding(node.name))
                  return;
                if (state.scope.bindingIdentifierEquals(node.name, node))
                  return;
              }
              state.iife = true;
              this.stop();
            }};
          var visitor = {Function: function Function(node, parent, scope, file) {
              if (!hasDefaults(node))
                return;
              this.ensureBlock();
              var state = {
                iife: false,
                scope: scope
              };
              var body = [];
              var argsIdentifier = t.identifier("arguments");
              argsIdentifier._shadowedFunctionLiteral = this;
              function pushDefNode(left, right, i) {
                var defNode;
                if (exceedsLastNonDefault(i) || t.isPattern(left) || file.transformers["es6.spec.blockScoping"].canTransform()) {
                  defNode = util.template("default-parameter", {
                    VARIABLE_NAME: left,
                    DEFAULT_VALUE: right,
                    ARGUMENT_KEY: t.literal(i),
                    ARGUMENTS: argsIdentifier
                  }, true);
                } else {
                  defNode = util.template("default-parameter-assign", {
                    VARIABLE_NAME: left,
                    DEFAULT_VALUE: right
                  }, true);
                }
                defNode._blockHoist = node.params.length - i;
                body.push(defNode);
              }
              function exceedsLastNonDefault(i) {
                return i + 1 > lastNonDefaultParam;
              }
              var lastNonDefaultParam = _helpersGetFunctionArity2["default"](node);
              var params = this.get("params");
              for (var i = 0; i < params.length; i++) {
                var param = params[i];
                if (!param.isAssignmentPattern()) {
                  if (!param.isIdentifier()) {
                    param.traverse(iifeVisitor, state);
                  }
                  if (file.transformers["es6.spec.blockScoping"].canTransform() && param.isIdentifier()) {
                    pushDefNode(param.node, t.identifier("undefined"), i);
                  }
                  continue;
                }
                var left = param.get("left");
                var right = param.get("right");
                if (exceedsLastNonDefault(i) || left.isPattern()) {
                  var placeholder = scope.generateUidIdentifier("x");
                  placeholder._isDefaultPlaceholder = true;
                  node.params[i] = placeholder;
                } else {
                  node.params[i] = left.node;
                }
                if (!state.iife) {
                  if (right.isIdentifier() && scope.hasOwnBinding(right.node.name)) {
                    state.iife = true;
                  } else {
                    right.traverse(iifeVisitor, state);
                  }
                }
                pushDefNode(left.node, right.node, i);
              }
              node.params = node.params.slice(0, lastNonDefaultParam);
              if (state.iife) {
                body.push(_helpersCallDelegate2["default"](node, scope));
                node.body = t.blockStatement(body);
              } else {
                node.body.body = body.concat(node.body.body);
              }
            }};
          exports.visitor = visitor;
        }, {
          "../../../../types": 196,
          "../../../../util": 199,
          "../../../helpers/call-delegate": 73,
          "../../../helpers/get-function-arity": 76
        }],
        118: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _traversalVisitors = require("../../../../traversal/visitors");
          var visitors = _interopRequireWildcard(_traversalVisitors);
          var _default = require("./default");
          var def = _interopRequireWildcard(_default);
          var _rest = require("./rest");
          var rest = _interopRequireWildcard(_rest);
          var metadata = {group: "builtin-advanced"};
          exports.metadata = metadata;
          var visitor = visitors.merge([rest.visitor, def.visitor]);
          exports.visitor = visitor;
        }, {
          "../../../../traversal/visitors": 185,
          "./default": 117,
          "./rest": 119
        }],
        119: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _util = require("../../../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../../../types");
          var t = _interopRequireWildcard(_types);
          var memberExpressionOptimisationVisitor = {
            Scope: function Scope(node, parent, scope, state) {
              if (!scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
                this.skip();
              }
            },
            Flow: function Flow() {
              this.skip();
            },
            Function: function Function(node, parent, scope, state) {
              var oldNoOptimise = state.noOptimise;
              state.noOptimise = true;
              this.traverse(memberExpressionOptimisationVisitor, state);
              state.noOptimise = oldNoOptimise;
              this.skip();
            },
            ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              if (node.name === "arguments") {
                state.deopted = true;
              }
              if (node.name !== state.name)
                return;
              if (state.noOptimise) {
                state.deopted = true;
              } else {
                if (this.parentPath.isMemberExpression({
                  computed: true,
                  object: node
                })) {
                  var prop = this.parentPath.get("property");
                  if (prop.isBaseType("number")) {
                    state.candidates.push(this);
                    return;
                  }
                }
                if (this.parentPath.isSpreadElement() && state.offset === 0) {
                  var call = this.parentPath.parentPath;
                  if (call.isCallExpression() && call.node.arguments.length === 1) {
                    state.candidates.push(this);
                    return;
                  }
                }
                state.references.push(this);
              }
            },
            BindingIdentifier: function BindingIdentifier(node, parent, scope, state) {
              if (node.name === state.name) {
                state.deopted = true;
              }
            }
          };
          function optimiseMemberExpression(parent, offset) {
            if (offset === 0)
              return;
            var newExpr;
            var prop = parent.property;
            if (t.isLiteral(prop)) {
              prop.value += offset;
              prop.raw = String(prop.value);
            } else {
              newExpr = t.binaryExpression("+", prop, t.literal(offset));
              parent.property = newExpr;
            }
          }
          function hasRest(node) {
            return t.isRestElement(node.params[node.params.length - 1]);
          }
          var visitor = {Function: function Function(node, parent, scope) {
              if (!hasRest(node))
                return;
              var restParam = node.params.pop();
              var rest = restParam.argument;
              var argsId = t.identifier("arguments");
              argsId._shadowedFunctionLiteral = this;
              if (t.isPattern(rest)) {
                var pattern = rest;
                rest = scope.generateUidIdentifier("ref");
                var declar = t.variableDeclaration("let", pattern.elements.map(function(elem, index) {
                  var accessExpr = t.memberExpression(rest, t.literal(index), true);
                  return t.variableDeclarator(elem, accessExpr);
                }));
                node.body.body.unshift(declar);
              }
              var state = {
                references: [],
                offset: node.params.length,
                argumentsNode: argsId,
                outerBinding: scope.getBindingIdentifier(rest.name),
                candidates: [],
                name: rest.name,
                deopted: false
              };
              this.traverse(memberExpressionOptimisationVisitor, state);
              if (!state.deopted && !state.references.length) {
                if (state.candidates.length) {
                  var _arr = state.candidates;
                  for (var _i = 0; _i < _arr.length; _i++) {
                    var candidate = _arr[_i];
                    candidate.replaceWith(argsId);
                    if (candidate.parentPath.isMemberExpression()) {
                      optimiseMemberExpression(candidate.parent, state.offset);
                    }
                  }
                }
                return;
              } else {
                state.references = state.references.concat(state.candidates);
              }
              state.deopted = state.deopted || !!node.shadow;
              var start = t.literal(node.params.length);
              var key = scope.generateUidIdentifier("key");
              var len = scope.generateUidIdentifier("len");
              var arrKey = key;
              var arrLen = len;
              if (node.params.length) {
                arrKey = t.binaryExpression("-", key, start);
                arrLen = t.conditionalExpression(t.binaryExpression(">", len, start), t.binaryExpression("-", len, start), t.literal(0));
              }
              var loop = util.template("rest", {
                ARRAY_TYPE: restParam.typeAnnotation,
                ARGUMENTS: argsId,
                ARRAY_KEY: arrKey,
                ARRAY_LEN: arrLen,
                START: start,
                ARRAY: rest,
                KEY: key,
                LEN: len
              });
              if (state.deopted) {
                loop._blockHoist = node.params.length + 1;
                node.body.body.unshift(loop);
              } else {
                loop._blockHoist = 1;
                var target = this.getEarliestCommonAncestorFrom(state.references).getStatementParent();
                var highestLoop;
                target.findParent(function(path) {
                  if (path.isLoop()) {
                    highestLoop = path;
                  } else if (path.isFunction()) {
                    return true;
                  }
                });
                if (highestLoop)
                  target = highestLoop;
                target.insertBefore(loop);
              }
            }};
          exports.visitor = visitor;
        }, {
          "../../../../types": 196,
          "../../../../util": 199
        }],
        120: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function loose(node, body, objId) {
            var _arr = node.properties;
            for (var _i = 0; _i < _arr.length; _i++) {
              var prop = _arr[_i];
              body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(objId, prop.key, prop.computed || t.isLiteral(prop.key)), prop.value)));
            }
          }
          function spec(node, body, objId, initProps, file) {
            var _arr2 = node.properties;
            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
              var prop = _arr2[_i2];
              if (t.isLiteral(t.toComputedKey(prop), {value: "__proto__"})) {
                initProps.push(prop);
                continue;
              }
              var key = prop.key;
              if (t.isIdentifier(key) && !prop.computed) {
                key = t.literal(key.name);
              }
              var bodyNode = t.callExpression(file.addHelper("define-property"), [objId, key, prop.value]);
              body.push(t.expressionStatement(bodyNode));
            }
            if (body.length === 1) {
              var first = body[0].expression;
              if (t.isCallExpression(first)) {
                first.arguments[0] = t.objectExpression(initProps);
                return first;
              }
            }
          }
          var visitor = {ObjectExpression: {exit: function exit(node, parent, scope, file) {
                var hasComputed = false;
                var _arr3 = node.properties;
                for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                  var prop = _arr3[_i3];
                  hasComputed = t.isProperty(prop, {
                    computed: true,
                    kind: "init"
                  });
                  if (hasComputed)
                    break;
                }
                if (!hasComputed)
                  return;
                var initProps = [];
                var stopInits = false;
                node.properties = node.properties.filter(function(prop) {
                  if (prop.computed) {
                    stopInits = true;
                  }
                  if (prop.kind !== "init" || !stopInits) {
                    initProps.push(prop);
                    return false;
                  } else {
                    return true;
                  }
                });
                var objId = scope.generateUidIdentifierBasedOnNode(parent);
                var body = [];
                var callback = spec;
                if (file.isLoose("es6.properties.computed"))
                  callback = loose;
                var result = callback(node, body, objId, initProps, file);
                if (result)
                  return result;
                body.unshift(t.variableDeclaration("var", [t.variableDeclarator(objId, t.objectExpression(initProps))]));
                body.push(t.expressionStatement(objId));
                return body;
              }}};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        121: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var visitor = {Property: function Property(node) {
              if (node.method) {
                node.method = false;
              }
              if (node.shorthand) {
                node.shorthand = false;
              }
            }};
          exports.visitor = visitor;
        }, {}],
        122: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _helpersRegex = require("../../helpers/regex");
          var regex = _interopRequireWildcard(_helpersRegex);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var visitor = {Literal: function Literal(node) {
              if (!regex.is(node, "y"))
                return;
              return t.newExpression(t.identifier("RegExp"), [t.literal(node.regex.pattern), t.literal(node.regex.flags)]);
            }};
          exports.visitor = visitor;
        }, {
          "../../../types": 196,
          "../../helpers/regex": 80
        }],
        123: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _regexpuRewritePattern = require("regexpu/rewrite-pattern");
          var _regexpuRewritePattern2 = _interopRequireDefault(_regexpuRewritePattern);
          var _helpersRegex = require("../../helpers/regex");
          var regex = _interopRequireWildcard(_helpersRegex);
          var visitor = {Literal: function Literal(node) {
              if (!regex.is(node, "u"))
                return;
              node.regex.pattern = _regexpuRewritePattern2["default"](node.regex.pattern, node.regex.flags);
              regex.pullFlag(node, "u");
            }};
          exports.visitor = visitor;
        }, {
          "../../helpers/regex": 80,
          "regexpu/rewrite-pattern": 601
        }],
        124: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {
            group: "builtin-pre",
            optional: true
          };
          exports.metadata = metadata;
          var visitor = {ArrowFunctionExpression: function ArrowFunctionExpression(node, parent, scope, file) {
              if (node.shadow)
                return;
              node.shadow = {"this": false};
              var boundThis = t.thisExpression();
              boundThis._forceShadow = this;
              t.ensureBlock(node);
              this.get("body").unshiftContainer("body", t.expressionStatement(t.callExpression(file.addHelper("new-arrow-check"), [t.thisExpression(), boundThis])));
              return t.callExpression(t.memberExpression(node, t.identifier("bind")), [t.thisExpression()]);
            }};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        125: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function buildAssert(node, file) {
            return t.callExpression(file.addHelper("temporal-assert-defined"), [node, t.literal(node.name), file.addHelper("temporal-undefined")]);
          }
          function references(node, scope, state) {
            var declared = state.letRefs[node.name];
            if (!declared)
              return false;
            return scope.getBindingIdentifier(node.name) === declared;
          }
          var refVisitor = {
            ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              if (t.isFor(parent) && parent.left === node)
                return;
              if (!references(node, scope, state))
                return;
              var assert = buildAssert(node, state.file);
              this.skip();
              if (t.isUpdateExpression(parent)) {
                if (parent._ignoreBlockScopingTDZ)
                  return;
                this.parentPath.replaceWith(t.sequenceExpression([assert, parent]));
              } else {
                return t.logicalExpression("&&", assert, node);
              }
            },
            AssignmentExpression: {exit: function exit(node, parent, scope, state) {
                if (node._ignoreBlockScopingTDZ)
                  return;
                var nodes = [];
                var ids = this.getBindingIdentifiers();
                for (var name in ids) {
                  var id = ids[name];
                  if (references(id, scope, state)) {
                    nodes.push(buildAssert(id, state.file));
                  }
                }
                if (nodes.length) {
                  node._ignoreBlockScopingTDZ = true;
                  nodes.push(node);
                  return nodes.map(t.expressionStatement);
                }
              }}
          };
          var metadata = {
            optional: true,
            group: "builtin-advanced"
          };
          exports.metadata = metadata;
          var visitor = {"Program|Loop|BlockStatement": {exit: function exit(node, parent, scope, file) {
                var letRefs = node._letReferences;
                if (!letRefs)
                  return;
                this.traverse(refVisitor, {
                  letRefs: letRefs,
                  file: file
                });
              }}};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        126: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {
            group: "builtin-pre",
            optional: true
          };
          exports.metadata = metadata;
          var visitor = {Program: function Program() {
              var id = this.scope.generateUidIdentifier("null");
              this.unshiftContainer("body", [t.variableDeclaration("var", [t.variableDeclarator(id, t.literal(null))]), t.exportNamedDeclaration(null, [t.exportSpecifier(id, t.identifier("__proto__"))])]);
            }};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        127: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {optional: true};
          exports.metadata = metadata;
          var visitor = {
            UnaryExpression: function UnaryExpression(node, parent, scope, file) {
              if (node._ignoreSpecSymbols)
                return;
              if (this.parentPath.isBinaryExpression() && t.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
                var opposite = this.getOpposite();
                if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object")
                  return;
              }
              if (node.operator === "typeof") {
                var call = t.callExpression(file.addHelper("typeof"), [node.argument]);
                if (this.get("argument").isIdentifier()) {
                  var undefLiteral = t.literal("undefined");
                  var unary = t.unaryExpression("typeof", node.argument);
                  unary._ignoreSpecSymbols = true;
                  return t.conditionalExpression(t.binaryExpression("===", unary, undefLiteral), undefLiteral, call);
                } else {
                  return call;
                }
              }
            },
            BinaryExpression: function BinaryExpression(node, parent, scope, file) {
              if (node.operator === "instanceof") {
                return t.callExpression(file.addHelper("instanceof"), [node.left, node.right]);
              }
            },
            "VariableDeclaration|FunctionDeclaration": function VariableDeclarationFunctionDeclaration(node) {
              if (node._generated)
                this.skip();
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        128: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {
            optional: true,
            group: "builtin-pre"
          };
          exports.metadata = metadata;
          var visitor = {TemplateLiteral: function TemplateLiteral(node, parent) {
              if (t.isTaggedTemplateExpression(parent))
                return;
              for (var i = 0; i < node.expressions.length; i++) {
                node.expressions[i] = t.callExpression(t.identifier("String"), [node.expressions[i]]);
              }
            }};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        129: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function getSpreadLiteral(spread, scope) {
            if (scope.hub.file.isLoose("es6.spread") && !t.isIdentifier(spread.argument, {name: "arguments"})) {
              return spread.argument;
            } else {
              return scope.toArray(spread.argument, true);
            }
          }
          function hasSpread(nodes) {
            for (var i = 0; i < nodes.length; i++) {
              if (t.isSpreadElement(nodes[i])) {
                return true;
              }
            }
            return false;
          }
          function build(props, scope) {
            var nodes = [];
            var _props = [];
            var push = function push() {
              if (!_props.length)
                return;
              nodes.push(t.arrayExpression(_props));
              _props = [];
            };
            for (var i = 0; i < props.length; i++) {
              var prop = props[i];
              if (t.isSpreadElement(prop)) {
                push();
                nodes.push(getSpreadLiteral(prop, scope));
              } else {
                _props.push(prop);
              }
            }
            push();
            return nodes;
          }
          var metadata = {group: "builtin-advanced"};
          exports.metadata = metadata;
          var visitor = {
            ArrayExpression: function ArrayExpression(node, parent, scope) {
              var elements = node.elements;
              if (!hasSpread(elements))
                return;
              var nodes = build(elements, scope);
              var first = nodes.shift();
              if (!t.isArrayExpression(first)) {
                nodes.unshift(first);
                first = t.arrayExpression([]);
              }
              return t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes);
            },
            CallExpression: function CallExpression(node, parent, scope) {
              var args = node.arguments;
              if (!hasSpread(args))
                return;
              var contextLiteral = t.identifier("undefined");
              node.arguments = [];
              var nodes;
              if (args.length === 1 && args[0].argument.name === "arguments") {
                nodes = [args[0].argument];
              } else {
                nodes = build(args, scope);
              }
              var first = nodes.shift();
              if (nodes.length) {
                node.arguments.push(t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes));
              } else {
                node.arguments.push(first);
              }
              var callee = node.callee;
              if (this.get("callee").isMemberExpression()) {
                var temp = scope.maybeGenerateMemoised(callee.object);
                if (temp) {
                  callee.object = t.assignmentExpression("=", temp, callee.object);
                  contextLiteral = temp;
                } else {
                  contextLiteral = callee.object;
                }
                t.appendToMemberExpression(callee, t.identifier("apply"));
              } else {
                node.callee = t.memberExpression(node.callee, t.identifier("apply"));
              }
              node.arguments.unshift(contextLiteral);
            },
            NewExpression: function NewExpression(node, parent, scope, file) {
              var args = node.arguments;
              if (!hasSpread(args))
                return;
              var nodes = build(args, scope);
              var context = t.arrayExpression([t.literal(null)]);
              args = t.callExpression(t.memberExpression(context, t.identifier("concat")), nodes);
              return t.newExpression(t.callExpression(t.memberExpression(file.addHelper("bind"), t.identifier("apply")), [node.callee, args]), []);
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        130: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _lodashCollectionReduceRight = require("lodash/collection/reduceRight");
          var _lodashCollectionReduceRight2 = _interopRequireDefault(_lodashCollectionReduceRight);
          var _messages = require("../../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _lodashArrayFlatten = require("lodash/array/flatten");
          var _lodashArrayFlatten2 = _interopRequireDefault(_lodashArrayFlatten);
          var _util = require("../../../util");
          var util = _interopRequireWildcard(_util);
          var _lodashCollectionMap = require("lodash/collection/map");
          var _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-trailing"};
          exports.metadata = metadata;
          var visitor = {Function: function Function(node, parent, scope, file) {
              if (node.generator || node.async)
                return;
              var tailCall = new TailCallTransformer(this, scope, file);
              tailCall.run();
            }};
          exports.visitor = visitor;
          function returnBlock(expr) {
            return t.blockStatement([t.returnStatement(expr)]);
          }
          var visitor = {
            enter: function enter(node, parent) {
              if (t.isTryStatement(parent)) {
                if (node === parent.block) {
                  this.skip();
                } else if (parent.finalizer && node !== parent.finalizer) {
                  this.skip();
                }
              }
            },
            ReturnStatement: function ReturnStatement(node, parent, scope, state) {
              return state.subTransform(node.argument);
            },
            Function: function Function() {
              this.skip();
            },
            VariableDeclaration: function VariableDeclaration(node, parent, scope, state) {
              state.vars.push(node);
            },
            ThisExpression: function ThisExpression(node, parent, scope, state) {
              if (!state.isShadowed) {
                state.needsThis = true;
                state.thisPaths.push(this);
              }
            },
            ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              if (node.name === "arguments" && (!state.isShadowed || node._shadowedFunctionLiteral)) {
                state.needsArguments = true;
                state.argumentsPaths.push(this);
              }
            }
          };
          var TailCallTransformer = (function() {
            function TailCallTransformer(path, scope, file) {
              _classCallCheck(this, TailCallTransformer);
              this.hasTailRecursion = false;
              this.needsArguments = false;
              this.argumentsPaths = [];
              this.setsArguments = false;
              this.needsThis = false;
              this.thisPaths = [];
              this.isShadowed = path.isArrowFunctionExpression() || path.is("shadow");
              this.ownerId = path.node.id;
              this.vars = [];
              this.scope = scope;
              this.path = path;
              this.file = file;
              this.node = path.node;
            }
            TailCallTransformer.prototype.getArgumentsId = function getArgumentsId() {
              return this.argumentsId = this.argumentsId || this.scope.generateUidIdentifier("arguments");
            };
            TailCallTransformer.prototype.getThisId = function getThisId() {
              return this.thisId = this.thisId || this.scope.generateUidIdentifier("this");
            };
            TailCallTransformer.prototype.getLeftId = function getLeftId() {
              return this.leftId = this.leftId || this.scope.generateUidIdentifier("left");
            };
            TailCallTransformer.prototype.getFunctionId = function getFunctionId() {
              return this.functionId = this.functionId || this.scope.generateUidIdentifier("function");
            };
            TailCallTransformer.prototype.getAgainId = function getAgainId() {
              return this.againId = this.againId || this.scope.generateUidIdentifier("again");
            };
            TailCallTransformer.prototype.getParams = function getParams() {
              var params = this.params;
              if (!params) {
                params = this.node.params;
                this.paramDecls = [];
                for (var i = 0; i < params.length; i++) {
                  var param = params[i];
                  if (!param._isDefaultPlaceholder) {
                    this.paramDecls.push(t.variableDeclarator(param, params[i] = this.scope.generateUidIdentifier("x")));
                  }
                }
              }
              return this.params = params;
            };
            TailCallTransformer.prototype.hasDeopt = function hasDeopt() {
              var ownerIdInfo = this.scope.getBinding(this.ownerId.name);
              return ownerIdInfo && !ownerIdInfo.constant;
            };
            TailCallTransformer.prototype.run = function run() {
              var node = this.node;
              var ownerId = this.ownerId;
              if (!ownerId)
                return;
              this.path.traverse(visitor, this);
              if (!this.hasTailRecursion)
                return;
              if (this.hasDeopt()) {
                this.file.log.deopt(node, messages.get("tailCallReassignmentDeopt"));
                return;
              }
              var body = this.path.ensureBlock().body;
              for (var i = 0; i < body.length; i++) {
                var bodyNode = body[i];
                if (!t.isFunctionDeclaration(bodyNode))
                  continue;
                bodyNode = body[i] = t.variableDeclaration("var", [t.variableDeclarator(bodyNode.id, t.toExpression(bodyNode))]);
                bodyNode._blockHoist = 2;
              }
              if (this.vars.length > 0) {
                var declarations = _lodashArrayFlatten2["default"](_lodashCollectionMap2["default"](this.vars, function(decl) {
                  return decl.declarations;
                }));
                var assignment = _lodashCollectionReduceRight2["default"](declarations, function(expr, decl) {
                  return t.assignmentExpression("=", decl.id, expr);
                }, t.identifier("undefined"));
                var statement = t.expressionStatement(assignment);
                statement._blockHoist = Infinity;
                body.unshift(statement);
              }
              var paramDecls = this.paramDecls;
              if (paramDecls.length > 0) {
                var paramDecl = t.variableDeclaration("var", paramDecls);
                paramDecl._blockHoist = Infinity;
                body.unshift(paramDecl);
              }
              body.unshift(t.expressionStatement(t.assignmentExpression("=", this.getAgainId(), t.literal(false))));
              node.body = util.template("tail-call-body", {
                FUNCTION_ID: this.getFunctionId(),
                AGAIN_ID: this.getAgainId(),
                BLOCK: node.body
              });
              var topVars = [];
              if (this.needsThis) {
                var _arr = this.thisPaths;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var path = _arr[_i];
                  path.replaceWith(this.getThisId());
                }
                topVars.push(t.variableDeclarator(this.getThisId(), t.thisExpression()));
              }
              if (this.needsArguments || this.setsArguments) {
                var _arr2 = this.argumentsPaths;
                for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                  var _path = _arr2[_i2];
                  _path.replaceWith(this.argumentsId);
                }
                var decl = t.variableDeclarator(this.argumentsId);
                if (this.argumentsId) {
                  decl.init = t.identifier("arguments");
                  decl.init._shadowedFunctionLiteral = this.path;
                }
                topVars.push(decl);
              }
              var leftId = this.leftId;
              if (leftId) {
                topVars.push(t.variableDeclarator(leftId));
              }
              if (topVars.length > 0) {
                node.body.body.unshift(t.variableDeclaration("var", topVars));
              }
            };
            TailCallTransformer.prototype.subTransform = function subTransform(node) {
              if (!node)
                return;
              var handler = this["subTransform" + node.type];
              if (handler)
                return handler.call(this, node);
            };
            TailCallTransformer.prototype.subTransformConditionalExpression = function subTransformConditionalExpression(node) {
              var callConsequent = this.subTransform(node.consequent);
              var callAlternate = this.subTransform(node.alternate);
              if (!callConsequent && !callAlternate) {
                return;
              }
              node.type = "IfStatement";
              node.consequent = callConsequent ? t.toBlock(callConsequent) : returnBlock(node.consequent);
              if (callAlternate) {
                node.alternate = t.isIfStatement(callAlternate) ? callAlternate : t.toBlock(callAlternate);
              } else {
                node.alternate = returnBlock(node.alternate);
              }
              return [node];
            };
            TailCallTransformer.prototype.subTransformLogicalExpression = function subTransformLogicalExpression(node) {
              var callRight = this.subTransform(node.right);
              if (!callRight)
                return;
              var leftId = this.getLeftId();
              var testExpr = t.assignmentExpression("=", leftId, node.left);
              if (node.operator === "&&") {
                testExpr = t.unaryExpression("!", testExpr);
              }
              return [t.ifStatement(testExpr, returnBlock(leftId))].concat(callRight);
            };
            TailCallTransformer.prototype.subTransformSequenceExpression = function subTransformSequenceExpression(node) {
              var seq = node.expressions;
              var lastCall = this.subTransform(seq[seq.length - 1]);
              if (!lastCall) {
                return;
              }
              if (--seq.length === 1) {
                node = seq[0];
              }
              return [t.expressionStatement(node)].concat(lastCall);
            };
            TailCallTransformer.prototype.subTransformCallExpression = function subTransformCallExpression(node) {
              var callee = node.callee;
              var thisBinding,
                  args;
              if (t.isMemberExpression(callee, {computed: false}) && t.isIdentifier(callee.property)) {
                switch (callee.property.name) {
                  case "call":
                    args = t.arrayExpression(node.arguments.slice(1));
                    break;
                  case "apply":
                    args = node.arguments[1] || t.identifier("undefined");
                    this.needsArguments = true;
                    break;
                  default:
                    return;
                }
                thisBinding = node.arguments[0];
                callee = callee.object;
              }
              if (!t.isIdentifier(callee) || !this.scope.bindingIdentifierEquals(callee.name, this.ownerId)) {
                return;
              }
              this.hasTailRecursion = true;
              if (this.hasDeopt())
                return;
              var body = [];
              if (this.needsThis && !t.isThisExpression(thisBinding)) {
                body.push(t.expressionStatement(t.assignmentExpression("=", this.getThisId(), thisBinding || t.identifier("undefined"))));
              }
              if (!args) {
                args = t.arrayExpression(node.arguments);
              }
              var argumentsId = this.getArgumentsId();
              var params = this.getParams();
              if (this.needsArguments) {
                body.push(t.expressionStatement(t.assignmentExpression("=", argumentsId, args)));
              }
              if (t.isArrayExpression(args)) {
                var elems = args.elements;
                while (elems.length < params.length) {
                  elems.push(t.identifier("undefined"));
                }
                for (var i = 0; i < elems.length; i++) {
                  var param = params[i];
                  var elem = elems[i];
                  if (param && !param._isDefaultPlaceholder) {
                    elems[i] = t.assignmentExpression("=", param, elem);
                  } else {}
                }
                if (!this.needsArguments) {
                  var _arr3 = elems;
                  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                    var elem = _arr3[_i3];
                    if (!this.scope.isPure(elem)) {
                      body.push(t.expressionStatement(elem));
                    }
                  }
                }
              } else {
                this.setsArguments = true;
                for (var i = 0; i < params.length; i++) {
                  var param = params[i];
                  if (!param._isDefaultPlaceholder) {
                    body.push(t.expressionStatement(t.assignmentExpression("=", param, t.memberExpression(argumentsId, t.literal(i), true))));
                  }
                }
              }
              body.push(t.expressionStatement(t.assignmentExpression("=", this.getAgainId(), t.literal(true))));
              body.push(t.continueStatement(this.getFunctionId()));
              return body;
            };
            return TailCallTransformer;
          })();
        }, {
          "../../../messages": 60,
          "../../../types": 196,
          "../../../util": 199,
          "lodash/array/flatten": 423,
          "lodash/collection/map": 431,
          "lodash/collection/reduceRight": 432
        }],
        131: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-pre"};
          exports.metadata = metadata;
          function isString(node) {
            return t.isLiteral(node) && typeof node.value === "string";
          }
          function buildBinaryExpression(left, right) {
            var node = t.binaryExpression("+", left, right);
            node._templateLiteralProduced = true;
            return node;
          }
          function crawl(path) {
            if (path.is("_templateLiteralProduced")) {
              crawl(path.get("left"));
              crawl(path.get("right"));
            } else if (!path.isBaseType("string") && !path.isBaseType("number")) {
              path.replaceWith(t.callExpression(t.identifier("String"), [path.node]));
            }
          }
          var visitor = {
            TaggedTemplateExpression: function TaggedTemplateExpression(node, parent, scope, file) {
              var quasi = node.quasi;
              var args = [];
              var strings = [];
              var raw = [];
              var _arr = quasi.quasis;
              for (var _i = 0; _i < _arr.length; _i++) {
                var elem = _arr[_i];
                strings.push(t.literal(elem.value.cooked));
                raw.push(t.literal(elem.value.raw));
              }
              strings = t.arrayExpression(strings);
              raw = t.arrayExpression(raw);
              var templateName = "tagged-template-literal";
              if (file.isLoose("es6.templateLiterals"))
                templateName += "-loose";
              var templateObject = file.addTemplateObject(templateName, strings, raw);
              args.push(templateObject);
              args = args.concat(quasi.expressions);
              return t.callExpression(node.tag, args);
            },
            TemplateLiteral: function TemplateLiteral(node, parent, scope, file) {
              var nodes = [];
              var _arr2 = node.quasis;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var elem = _arr2[_i2];
                nodes.push(t.literal(elem.value.cooked));
                var expr = node.expressions.shift();
                if (expr)
                  nodes.push(expr);
              }
              nodes = nodes.filter(function(n) {
                return !t.isLiteral(n, {value: ""});
              });
              if (!isString(nodes[0]) && !isString(nodes[1])) {
                nodes.unshift(t.literal(""));
              }
              if (nodes.length > 1) {
                var root = buildBinaryExpression(nodes.shift(), nodes.shift());
                var _arr3 = nodes;
                for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                  var _node = _arr3[_i3];
                  root = buildBinaryExpression(root, _node);
                }
                this.replaceWith(root);
              } else {
                return nodes[0];
              }
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        132: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var metadata = {stage: 2};
          exports.metadata = metadata;
        }, {}],
        133: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var metadata = {
            stage: 0,
            dependencies: ["es6.classes"]
          };
          exports.metadata = metadata;
        }, {}],
        134: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersBuildComprehension = require("../../helpers/build-comprehension");
          var _helpersBuildComprehension2 = _interopRequireDefault(_helpersBuildComprehension);
          var _traversal = require("../../../traversal");
          var _traversal2 = _interopRequireDefault(_traversal);
          var _util = require("../../../util");
          var util = _interopRequireWildcard(_util);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {stage: 0};
          exports.metadata = metadata;
          var visitor = {ComprehensionExpression: function ComprehensionExpression(node, parent, scope) {
              var callback = array;
              if (node.generator)
                callback = generator;
              return callback(node, parent, scope);
            }};
          exports.visitor = visitor;
          function generator(node) {
            var body = [];
            var container = t.functionExpression(null, [], t.blockStatement(body), true);
            container.shadow = true;
            body.push(_helpersBuildComprehension2["default"](node, function() {
              return t.expressionStatement(t.yieldExpression(node.body));
            }));
            return t.callExpression(container, []);
          }
          function array(node, parent, scope) {
            var uid = scope.generateUidIdentifierBasedOnNode(parent);
            var container = util.template("array-comprehension-container", {KEY: uid});
            container.callee.shadow = true;
            var block = container.callee.body;
            var body = block.body;
            if (_traversal2["default"].hasType(node, scope, "YieldExpression", t.FUNCTION_TYPES)) {
              container.callee.generator = true;
              container = t.yieldExpression(container, true);
            }
            var returnStatement = body.pop();
            body.push(_helpersBuildComprehension2["default"](node, function() {
              return util.template("array-push", {
                STATEMENT: node.body,
                KEY: uid
              }, true);
            }));
            body.push(returnStatement);
            return container;
          }
        }, {
          "../../../traversal": 165,
          "../../../types": 196,
          "../../../util": 199,
          "../../helpers/build-comprehension": 71
        }],
        135: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersMemoiseDecorators = require("../../helpers/memoise-decorators");
          var _helpersMemoiseDecorators2 = _interopRequireDefault(_helpersMemoiseDecorators);
          var _helpersDefineMap = require("../../helpers/define-map");
          var defineMap = _interopRequireWildcard(_helpersDefineMap);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {
            dependencies: ["es6.classes"],
            optional: true,
            stage: 1
          };
          exports.metadata = metadata;
          var visitor = {ObjectExpression: function ObjectExpression(node, parent, scope, file) {
              var hasDecorators = false;
              for (var i = 0; i < node.properties.length; i++) {
                var prop = node.properties[i];
                if (prop.decorators) {
                  hasDecorators = true;
                  break;
                }
              }
              if (!hasDecorators)
                return;
              var mutatorMap = {};
              for (var i = 0; i < node.properties.length; i++) {
                var prop = node.properties[i];
                if (prop.decorators)
                  _helpersMemoiseDecorators2["default"](prop.decorators, scope);
                if (prop.kind === "init" && !prop.method) {
                  prop.kind = "";
                  prop.value = t.functionExpression(null, [], t.blockStatement([t.returnStatement(prop.value)]));
                }
                defineMap.push(mutatorMap, prop, "initializer", file);
              }
              var obj = defineMap.toClassObject(mutatorMap);
              obj = defineMap.toComputedObjectFromClass(obj);
              return t.callExpression(file.addHelper("create-decorated-object"), [obj]);
            }};
          exports.visitor = visitor;
        }, {
          "../../../types": 196,
          "../../helpers/define-map": 74,
          "../../helpers/memoise-decorators": 77
        }],
        136: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {
            optional: true,
            stage: 0
          };
          exports.metadata = metadata;
          var visitor = {DoExpression: function DoExpression(node) {
              var body = node.body.body;
              if (body.length) {
                return body;
              } else {
                return t.identifier("undefined");
              }
            }};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        137: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersBuildBinaryAssignmentOperatorTransformer = require("../../helpers/build-binary-assignment-operator-transformer");
          var _helpersBuildBinaryAssignmentOperatorTransformer2 = _interopRequireDefault(_helpersBuildBinaryAssignmentOperatorTransformer);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {stage: 2};
          exports.metadata = metadata;
          var MATH_POW = t.memberExpression(t.identifier("Math"), t.identifier("pow"));
          var visitor = _helpersBuildBinaryAssignmentOperatorTransformer2["default"]({
            operator: "**",
            build: function build(left, right) {
              return t.callExpression(MATH_POW, [left, right]);
            }
          });
          exports.visitor = visitor;
        }, {
          "../../../types": 196,
          "../../helpers/build-binary-assignment-operator-transformer": 70
        }],
        138: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {stage: 1};
          exports.metadata = metadata;
          function build(node, nodes, scope) {
            var first = node.specifiers[0];
            if (!t.isExportNamespaceSpecifier(first) && !t.isExportDefaultSpecifier(first))
              return;
            var specifier = node.specifiers.shift();
            var uid = scope.generateUidIdentifier(specifier.exported.name);
            var newSpecifier;
            if (t.isExportNamespaceSpecifier(specifier)) {
              newSpecifier = t.importNamespaceSpecifier(uid);
            } else {
              newSpecifier = t.importDefaultSpecifier(uid);
            }
            nodes.push(t.importDeclaration([newSpecifier], node.source));
            nodes.push(t.exportNamedDeclaration(null, [t.exportSpecifier(uid, specifier.exported)]));
            build(node, nodes, scope);
          }
          var visitor = {ExportNamedDeclaration: function ExportNamedDeclaration(node, parent, scope) {
              var nodes = [];
              build(node, nodes, scope);
              if (!nodes.length)
                return;
              if (node.specifiers.length >= 1) {
                nodes.push(node);
              }
              return nodes;
            }};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        139: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {
            optional: true,
            stage: 0
          };
          exports.metadata = metadata;
          function getTempId(scope) {
            var id = scope.path.getData("functionBind");
            if (id)
              return id;
            id = scope.generateDeclaredUidIdentifier("context");
            return scope.path.setData("functionBind", id);
          }
          function getStaticContext(bind, scope) {
            var object = bind.object || bind.callee.object;
            return scope.isStatic(object) && object;
          }
          function inferBindContext(bind, scope) {
            var staticContext = getStaticContext(bind, scope);
            if (staticContext)
              return staticContext;
            var tempId = getTempId(scope);
            if (bind.object) {
              bind.callee = t.sequenceExpression([t.assignmentExpression("=", tempId, bind.object), bind.callee]);
            } else {
              bind.callee.object = t.assignmentExpression("=", tempId, bind.callee.object);
            }
            return tempId;
          }
          var visitor = {
            CallExpression: function CallExpression(node, parent, scope) {
              var bind = node.callee;
              if (!t.isBindExpression(bind))
                return;
              var context = inferBindContext(bind, scope);
              node.callee = t.memberExpression(bind.callee, t.identifier("call"));
              node.arguments.unshift(context);
            },
            BindExpression: function BindExpression(node, parent, scope) {
              var context = inferBindContext(node, scope);
              return t.callExpression(t.memberExpression(node.callee, t.identifier("bind")), [context]);
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        140: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {
            stage: 2,
            dependencies: ["es6.destructuring"]
          };
          exports.metadata = metadata;
          var hasSpread = function hasSpread(node) {
            for (var i = 0; i < node.properties.length; i++) {
              if (t.isSpreadProperty(node.properties[i])) {
                return true;
              }
            }
            return false;
          };
          var visitor = {ObjectExpression: function ObjectExpression(node, parent, scope, file) {
              if (!hasSpread(node))
                return;
              var args = [];
              var props = [];
              var push = function push() {
                if (!props.length)
                  return;
                args.push(t.objectExpression(props));
                props = [];
              };
              for (var i = 0; i < node.properties.length; i++) {
                var prop = node.properties[i];
                if (t.isSpreadProperty(prop)) {
                  push();
                  args.push(prop.argument);
                } else {
                  props.push(prop);
                }
              }
              push();
              if (!t.isObjectExpression(args[0])) {
                args.unshift(t.objectExpression([]));
              }
              return t.callExpression(file.addHelper("extends"), args);
            }};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        141: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var metadata = {stage: 1};
          exports.metadata = metadata;
        }, {}],
        142: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.internal = internal;
          exports.blacklist = blacklist;
          exports.whitelist = whitelist;
          exports.stage = stage;
          exports.optional = optional;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashCollectionIncludes = require("lodash/collection/includes");
          var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
          function internal(transformer) {
            if (transformer.key[0] === "_")
              return true;
          }
          function blacklist(transformer, opts) {
            var blacklist = opts.blacklist;
            if (blacklist.length && _lodashCollectionIncludes2["default"](blacklist, transformer.key))
              return false;
          }
          function whitelist(transformer, opts) {
            var whitelist = opts.whitelist;
            if (whitelist)
              return _lodashCollectionIncludes2["default"](whitelist, transformer.key);
          }
          function stage(transformer, opts) {
            var stage = transformer.metadata.stage;
            if (stage != null && stage >= opts.stage)
              return true;
          }
          function optional(transformer, opts) {
            if (transformer.metadata.optional && !_lodashCollectionIncludes2["default"](opts.optional, transformer.key))
              return false;
          }
        }, {"lodash/collection/includes": 430}],
        143: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports["default"] = {
            "minification.constantFolding": require("babel-plugin-constant-folding"),
            strict: require("./other/strict"),
            eval: require("babel-plugin-eval"),
            _validation: require("./internal/validation"),
            _hoistDirectives: require("./internal/hoist-directives"),
            "minification.removeDebugger": require("babel-plugin-remove-debugger"),
            "minification.removeConsole": require("babel-plugin-remove-console"),
            "utility.inlineEnvironmentVariables": require("babel-plugin-inline-environment-variables"),
            "minification.deadCodeElimination": require("babel-plugin-dead-code-elimination"),
            _modules: require("./internal/modules"),
            "react.displayName": require("babel-plugin-react-display-name"),
            "es6.spec.modules": require("./es6/spec.modules"),
            "es6.spec.arrowFunctions": require("./es6/spec.arrow-functions"),
            "es6.spec.templateLiterals": require("./es6/spec.template-literals"),
            "es6.templateLiterals": require("./es6/template-literals"),
            "es6.literals": require("./es6/literals"),
            "validation.undeclaredVariableCheck": require("babel-plugin-undeclared-variables-check"),
            "spec.functionName": require("./spec/function-name"),
            "es7.classProperties": require("./es7/class-properties"),
            "es7.trailingFunctionCommas": require("./es7/trailing-function-commas"),
            "es7.asyncFunctions": require("./es7/async-functions"),
            "es7.decorators": require("./es7/decorators"),
            "validation.react": require("./validation/react"),
            "es6.arrowFunctions": require("./es6/arrow-functions"),
            "spec.blockScopedFunctions": require("./spec/block-scoped-functions"),
            "optimisation.react.constantElements": require("babel-plugin-react-constant-elements"),
            "optimisation.react.inlineElements": require("./optimisation/react.inline-elements"),
            "es7.comprehensions": require("./es7/comprehensions"),
            "es6.classes": require("./es6/classes"),
            asyncToGenerator: require("./other/async-to-generator"),
            bluebirdCoroutines: require("./other/bluebird-coroutines"),
            "es6.objectSuper": require("./es6/object-super"),
            "es7.objectRestSpread": require("./es7/object-rest-spread"),
            "es7.exponentiationOperator": require("./es7/exponentiation-operator"),
            "es5.properties.mutators": require("./es5/properties.mutators"),
            "es6.properties.shorthand": require("./es6/properties.shorthand"),
            "es6.properties.computed": require("./es6/properties.computed"),
            "optimisation.flow.forOf": require("./optimisation/flow.for-of"),
            "es6.forOf": require("./es6/for-of"),
            "es6.regex.sticky": require("./es6/regex.sticky"),
            "es6.regex.unicode": require("./es6/regex.unicode"),
            "es6.constants": require("./es6/constants"),
            "es7.exportExtensions": require("./es7/export-extensions"),
            "spec.protoToAssign": require("babel-plugin-proto-to-assign"),
            "es7.doExpressions": require("./es7/do-expressions"),
            "es6.spec.symbols": require("./es6/spec.symbols"),
            "es7.functionBind": require("./es7/function-bind"),
            "spec.undefinedToVoid": require("babel-plugin-undefined-to-void"),
            "es6.spread": require("./es6/spread"),
            "es6.parameters": require("./es6/parameters"),
            "es6.destructuring": require("./es6/destructuring"),
            "es6.blockScoping": require("./es6/block-scoping"),
            "es6.spec.blockScoping": require("./es6/spec.block-scoping"),
            reactCompat: require("./other/react-compat"),
            react: require("./other/react"),
            regenerator: require("./other/regenerator"),
            runtime: require("babel-plugin-runtime"),
            "es6.modules": require("./es6/modules"),
            _moduleFormatter: require("./internal/module-formatter"),
            "es6.tailCall": require("./es6/tail-call"),
            _shadowFunctions: require("./internal/shadow-functions"),
            "es3.propertyLiterals": require("./es3/property-literals"),
            "es3.memberExpressionLiterals": require("./es3/member-expression-literals"),
            "minification.memberExpressionLiterals": require("babel-plugin-member-expression-literals"),
            "minification.propertyLiterals": require("babel-plugin-property-literals"),
            _blockHoist: require("./internal/block-hoist"),
            jscript: require("babel-plugin-jscript"),
            flow: require("./other/flow"),
            "optimisation.modules.system": require("./optimisation/modules.system")
          };
          module.exports = exports["default"];
        }, {
          "./es3/member-expression-literals": 103,
          "./es3/property-literals": 104,
          "./es5/properties.mutators": 105,
          "./es6/arrow-functions": 106,
          "./es6/block-scoping": 107,
          "./es6/classes": 108,
          "./es6/constants": 111,
          "./es6/destructuring": 112,
          "./es6/for-of": 113,
          "./es6/literals": 114,
          "./es6/modules": 115,
          "./es6/object-super": 116,
          "./es6/parameters": 118,
          "./es6/properties.computed": 120,
          "./es6/properties.shorthand": 121,
          "./es6/regex.sticky": 122,
          "./es6/regex.unicode": 123,
          "./es6/spec.arrow-functions": 124,
          "./es6/spec.block-scoping": 125,
          "./es6/spec.modules": 126,
          "./es6/spec.symbols": 127,
          "./es6/spec.template-literals": 128,
          "./es6/spread": 129,
          "./es6/tail-call": 130,
          "./es6/template-literals": 131,
          "./es7/async-functions": 132,
          "./es7/class-properties": 133,
          "./es7/comprehensions": 134,
          "./es7/decorators": 135,
          "./es7/do-expressions": 136,
          "./es7/exponentiation-operator": 137,
          "./es7/export-extensions": 138,
          "./es7/function-bind": 139,
          "./es7/object-rest-spread": 140,
          "./es7/trailing-function-commas": 141,
          "./internal/block-hoist": 144,
          "./internal/hoist-directives": 145,
          "./internal/module-formatter": 146,
          "./internal/modules": 147,
          "./internal/shadow-functions": 148,
          "./internal/validation": 149,
          "./optimisation/flow.for-of": 150,
          "./optimisation/modules.system": 151,
          "./optimisation/react.inline-elements": 152,
          "./other/async-to-generator": 153,
          "./other/bluebird-coroutines": 154,
          "./other/flow": 155,
          "./other/react": 157,
          "./other/react-compat": 156,
          "./other/regenerator": 158,
          "./other/strict": 159,
          "./spec/block-scoped-functions": 160,
          "./spec/function-name": 161,
          "./validation/react": 162,
          "babel-plugin-constant-folding": 200,
          "babel-plugin-dead-code-elimination": 201,
          "babel-plugin-eval": 202,
          "babel-plugin-inline-environment-variables": 203,
          "babel-plugin-jscript": 204,
          "babel-plugin-member-expression-literals": 205,
          "babel-plugin-property-literals": 206,
          "babel-plugin-proto-to-assign": 207,
          "babel-plugin-react-constant-elements": 208,
          "babel-plugin-react-display-name": 209,
          "babel-plugin-remove-console": 210,
          "babel-plugin-remove-debugger": 211,
          "babel-plugin-runtime": 213,
          "babel-plugin-undeclared-variables-check": 214,
          "babel-plugin-undefined-to-void": 216
        }],
        144: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashCollectionSortBy = require("lodash/collection/sortBy");
          var _lodashCollectionSortBy2 = _interopRequireDefault(_lodashCollectionSortBy);
          var metadata = {group: "builtin-trailing"};
          exports.metadata = metadata;
          var visitor = {Block: {exit: function exit(node) {
                var hasChange = false;
                for (var i = 0; i < node.body.length; i++) {
                  var bodyNode = node.body[i];
                  if (bodyNode && bodyNode._blockHoist != null) {
                    hasChange = true;
                    break;
                  }
                }
                if (!hasChange)
                  return;
                node.body = _lodashCollectionSortBy2["default"](node.body, function(bodyNode) {
                  var priority = bodyNode && bodyNode._blockHoist;
                  if (priority == null)
                    priority = 1;
                  if (priority === true)
                    priority = 2;
                  return -1 * priority;
                });
              }}};
          exports.visitor = visitor;
        }, {"lodash/collection/sortBy": 434}],
        145: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-pre"};
          exports.metadata = metadata;
          var visitor = {Block: {exit: function exit(node) {
                for (var i = 0; i < node.body.length; i++) {
                  var bodyNode = node.body[i];
                  if (t.isExpressionStatement(bodyNode) && t.isLiteral(bodyNode.expression)) {
                    bodyNode._blockHoist = Infinity;
                  } else {
                    return;
                  }
                }
              }}};
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        146: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var metadata = {group: "builtin-modules"};
          exports.metadata = metadata;
          var visitor = {Program: {exit: function exit(program, parent, scope, file) {
                var _arr = file.dynamicImports;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var node = _arr[_i];
                  node._blockHoist = 3;
                }
                program.body = file.dynamicImports.concat(program.body);
                if (!file.transformers["es6.modules"].canTransform())
                  return;
                if (file.moduleFormatter.transform) {
                  file.moduleFormatter.transform(program);
                }
              }}};
          exports.visitor = visitor;
        }, {}],
        147: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function getDeclar(node) {
            var declar = node.declaration;
            t.inheritsComments(declar, node);
            t.removeComments(node);
            declar._ignoreUserWhitespace = true;
            return declar;
          }
          function buildExportSpecifier(id) {
            return t.exportSpecifier(cloneIdentifier(id), cloneIdentifier(id));
          }
          function cloneIdentifier(_ref) {
            var name = _ref.name;
            var loc = _ref.loc;
            var id = t.identifier(name);
            id._loc = loc;
            return id;
          }
          var metadata = {group: "builtin-pre"};
          exports.metadata = metadata;
          var visitor = {
            ExportDefaultDeclaration: function ExportDefaultDeclaration(node, parent, scope) {
              var declar = node.declaration;
              if (t.isClassDeclaration(declar)) {
                var nodes = [getDeclar(node), node];
                node.declaration = declar.id;
                return nodes;
              } else if (t.isClassExpression(declar)) {
                var temp = scope.generateUidIdentifier("default");
                node.declaration = t.variableDeclaration("var", [t.variableDeclarator(temp, declar)]);
                var nodes = [getDeclar(node), node];
                node.declaration = temp;
                return nodes;
              } else if (t.isFunctionDeclaration(declar)) {
                node._blockHoist = 2;
                var nodes = [getDeclar(node), node];
                node.declaration = declar.id;
                return nodes;
              }
            },
            ExportNamedDeclaration: function ExportNamedDeclaration(node) {
              var declar = node.declaration;
              if (t.isClassDeclaration(declar)) {
                node.specifiers = [buildExportSpecifier(declar.id)];
                var nodes = [getDeclar(node), node];
                node.declaration = null;
                return nodes;
              } else if (t.isFunctionDeclaration(declar)) {
                var newExport = t.exportNamedDeclaration(null, [buildExportSpecifier(declar.id)]);
                newExport._blockHoist = 2;
                return [getDeclar(node), newExport];
              } else if (t.isVariableDeclaration(declar)) {
                var specifiers = [];
                var bindings = this.get("declaration").getBindingIdentifiers();
                for (var key in bindings) {
                  specifiers.push(buildExportSpecifier(bindings[key]));
                }
                return [declar, t.exportNamedDeclaration(null, specifiers)];
              }
            },
            Program: {
              enter: function enter(node) {
                var imports = [];
                var rest = [];
                for (var i = 0; i < node.body.length; i++) {
                  var bodyNode = node.body[i];
                  if (t.isImportDeclaration(bodyNode)) {
                    imports.push(bodyNode);
                  } else {
                    rest.push(bodyNode);
                  }
                }
                node.body = imports.concat(rest);
              },
              exit: function exit(node, parent, scope, file) {
                if (!file.transformers["es6.modules"].canTransform())
                  return;
                if (file.moduleFormatter.setup) {
                  file.moduleFormatter.setup();
                }
              }
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        148: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-trailing"};
          exports.metadata = metadata;
          function shouldShadow(path, shadowPath) {
            if (path.is("_forceShadow")) {
              return true;
            } else {
              return shadowPath && !shadowPath.isArrowFunctionExpression();
            }
          }
          function remap(path, key, create) {
            var shadowPath = path.inShadow(key);
            if (!shouldShadow(path, shadowPath))
              return;
            var shadowFunction = path.node._shadowedFunctionLiteral;
            var currentFunction;
            var fnPath = path.findParent(function(path) {
              if (path.isProgram() || path.isFunction()) {
                currentFunction = currentFunction || path;
              }
              if (path.isProgram()) {
                return true;
              } else if (path.isFunction()) {
                if (shadowFunction) {
                  return path === shadowFunction || path.node === shadowFunction.node;
                } else {
                  return !path.is("shadow");
                }
              }
              return false;
            });
            if (fnPath === currentFunction)
              return;
            var cached = fnPath.getData(key);
            if (cached)
              return cached;
            var init = create();
            var id = path.scope.generateUidIdentifier(key);
            fnPath.setData(key, id);
            fnPath.scope.push({
              id: id,
              init: init
            });
            return id;
          }
          var visitor = {
            ThisExpression: function ThisExpression() {
              return remap(this, "this", function() {
                return t.thisExpression();
              });
            },
            ReferencedIdentifier: function ReferencedIdentifier(node) {
              if (node.name === "arguments") {
                return remap(this, "arguments", function() {
                  return t.identifier("arguments");
                });
              }
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        149: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _messages = require("../../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-pre"};
          exports.metadata = metadata;
          var visitor = {
            ForXStatement: function ForXStatement(node, parent, scope, file) {
              var left = node.left;
              if (t.isVariableDeclaration(left)) {
                var declar = left.declarations[0];
                if (declar.init)
                  throw file.errorWithNode(declar, messages.get("noAssignmentsInForHead"));
              }
            },
            Property: function Property(node, parent, scope, file) {
              if (node.kind === "set") {
                var first = node.value.params[0];
                if (t.isRestElement(first)) {
                  throw file.errorWithNode(first, messages.get("settersNoRest"));
                }
              }
            }
          };
          exports.visitor = visitor;
        }, {
          "../../../messages": 60,
          "../../../types": 196
        }],
        150: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var _es6ForOf = require("../es6/for-of");
          var metadata = {optional: true};
          exports.metadata = metadata;
          var visitor = {ForOfStatement: function ForOfStatement(node, parent, scope, file) {
              if (this.get("right").isGenericType("Array")) {
                return _es6ForOf._ForOfStatementArray.call(this, node, scope, file);
              }
            }};
          exports.visitor = visitor;
        }, {"../es6/for-of": 113}],
        151: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {
            optional: true,
            group: "builtin-trailing"
          };
          exports.metadata = metadata;
          var visitor = {Program: function Program(node, parent, scope, file) {
              if (file.moduleFormatter._setters) {
                scope.traverse(file.moduleFormatter._setters, optimizeSettersVisitor, {exportFunctionIdentifier: file.moduleFormatter.exportIdentifier});
              }
            }};
          exports.visitor = visitor;
          var optimizeSettersVisitor = {
            FunctionExpression: {
              enter: function enter(node, parent, scope, state) {
                state.hasExports = false;
                state.exportObjectIdentifier = scope.generateUidIdentifier("exportObj");
              },
              exit: function exit(node, parent, scope, state) {
                if (!state.hasExports)
                  return;
                node.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(t.cloneDeep(state.exportObjectIdentifier), t.objectExpression([]))]));
                node.body.body.push(t.expressionStatement(t.callExpression(t.cloneDeep(state.exportFunctionIdentifier), [t.cloneDeep(state.exportObjectIdentifier)])));
              }
            },
            CallExpression: function CallExpression(node, parent, scope, state) {
              if (!t.isIdentifier(node.callee, {name: state.exportFunctionIdentifier.name}))
                return;
              state.hasExports = true;
              var memberNode = t.memberExpression(t.cloneDeep(state.exportObjectIdentifier), node.arguments[0], true);
              return t.assignmentExpression("=", memberNode, node.arguments[1]);
            }
          };
        }, {"../../../types": 196}],
        152: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _helpersReact = require("../../helpers/react");
          var react = _interopRequireWildcard(_helpersReact);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {optional: true};
          exports.metadata = metadata;
          function hasRefOrSpread(attrs) {
            for (var i = 0; i < attrs.length; i++) {
              var attr = attrs[i];
              if (t.isJSXSpreadAttribute(attr))
                return true;
              if (isJSXAttributeOfName(attr, "ref"))
                return true;
            }
            return false;
          }
          function isJSXAttributeOfName(attr, name) {
            return t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name, {name: name});
          }
          var visitor = {JSXElement: function JSXElement(node, parent, scope, file) {
              var open = node.openingElement;
              if (hasRefOrSpread(open.attributes))
                return;
              var isComponent = true;
              var props = t.objectExpression([]);
              var obj = t.objectExpression([]);
              var key = t.literal(null);
              var type = open.name;
              if (t.isJSXIdentifier(type) && react.isCompatTag(type.name)) {
                type = t.literal(type.name);
                isComponent = false;
              }
              function pushElemProp(key, value) {
                pushProp(obj.properties, t.identifier(key), value);
              }
              function pushProp(objProps, key, value) {
                objProps.push(t.property("init", key, value));
              }
              if (node.children.length) {
                var children = react.buildChildren(node);
                children = children.length === 1 ? children[0] : t.arrayExpression(children);
                pushProp(props.properties, t.identifier("children"), children);
              }
              for (var i = 0; i < open.attributes.length; i++) {
                var attr = open.attributes[i];
                if (isJSXAttributeOfName(attr, "key")) {
                  key = attr.value;
                } else {
                  pushProp(props.properties, attr.name, attr.value || t.identifier("true"));
                }
              }
              if (isComponent) {
                props = t.callExpression(file.addHelper("default-props"), [t.memberExpression(type, t.identifier("defaultProps")), props]);
              }
              pushElemProp("$$typeof", file.addHelper("typeof-react-element"));
              pushElemProp("type", type);
              pushElemProp("key", key);
              pushElemProp("ref", t.literal(null));
              pushElemProp("props", props);
              pushElemProp("_owner", t.literal(null));
              return obj;
            }};
          exports.visitor = visitor;
        }, {
          "../../../types": 196,
          "../../helpers/react": 79
        }],
        153: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersRemapAsyncToGenerator = require("../../helpers/remap-async-to-generator");
          var _helpersRemapAsyncToGenerator2 = _interopRequireDefault(_helpersRemapAsyncToGenerator);
          var _bluebirdCoroutines = require("./bluebird-coroutines");
          exports.manipulateOptions = _bluebirdCoroutines.manipulateOptions;
          var metadata = {
            optional: true,
            dependencies: ["es7.asyncFunctions", "es6.classes"]
          };
          exports.metadata = metadata;
          var visitor = {Function: function Function(node, parent, scope, file) {
              if (!node.async || node.generator)
                return;
              return _helpersRemapAsyncToGenerator2["default"](this, file.addHelper("async-to-generator"));
            }};
          exports.visitor = visitor;
        }, {
          "../../helpers/remap-async-to-generator": 81,
          "./bluebird-coroutines": 154
        }],
        154: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.manipulateOptions = manipulateOptions;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersRemapAsyncToGenerator = require("../../helpers/remap-async-to-generator");
          var _helpersRemapAsyncToGenerator2 = _interopRequireDefault(_helpersRemapAsyncToGenerator);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function manipulateOptions(opts) {
            opts.blacklist.push("regenerator");
          }
          var metadata = {
            optional: true,
            dependencies: ["es7.asyncFunctions", "es6.classes"]
          };
          exports.metadata = metadata;
          var visitor = {Function: function Function(node, parent, scope, file) {
              if (!node.async || node.generator)
                return;
              return _helpersRemapAsyncToGenerator2["default"](this, t.memberExpression(file.addImport("bluebird", null, "absolute"), t.identifier("coroutine")));
            }};
          exports.visitor = visitor;
        }, {
          "../../../types": 196,
          "../../helpers/remap-async-to-generator": 81
        }],
        155: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-trailing"};
          exports.metadata = metadata;
          var FLOW_DIRECTIVE = "@flow";
          var visitor = {
            Program: function Program(node, parent, scope, file) {
              var _arr = file.ast.comments;
              for (var _i = 0; _i < _arr.length; _i++) {
                var comment = _arr[_i];
                if (comment.value.indexOf(FLOW_DIRECTIVE) >= 0) {
                  comment.value = comment.value.replace(FLOW_DIRECTIVE, "");
                  if (!comment.value.replace(/\*/g, "").trim())
                    comment._displayed = true;
                }
              }
            },
            Flow: function Flow() {
              this.dangerouslyRemove();
            },
            ClassProperty: function ClassProperty(node) {
              node.typeAnnotation = null;
              if (!node.value)
                this.dangerouslyRemove();
            },
            Class: function Class(node) {
              node["implements"] = null;
            },
            Function: function Function(node) {
              for (var i = 0; i < node.params.length; i++) {
                var param = node.params[i];
                param.optional = false;
              }
            },
            TypeCastExpression: function TypeCastExpression(node) {
              do {
                node = node.expression;
              } while (t.isTypeCastExpression(node));
              return node;
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        156: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.manipulateOptions = manipulateOptions;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _helpersReact = require("../../helpers/react");
          var react = _interopRequireWildcard(_helpersReact);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function manipulateOptions(opts) {
            opts.blacklist.push("react");
          }
          var metadata = {
            optional: true,
            group: "builtin-advanced"
          };
          exports.metadata = metadata;
          var visitor = require("../../helpers/build-react-transformer")({
            pre: function pre(state) {
              state.callee = state.tagExpr;
            },
            post: function post(state) {
              if (react.isCompatTag(state.tagName)) {
                state.call = t.callExpression(t.memberExpression(t.memberExpression(t.identifier("React"), t.identifier("DOM")), state.tagExpr, t.isLiteral(state.tagExpr)), state.args);
              }
            }
          });
          exports.visitor = visitor;
        }, {
          "../../../types": 196,
          "../../helpers/build-react-transformer": 72,
          "../../helpers/react": 79
        }],
        157: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _helpersReact = require("../../helpers/react");
          var react = _interopRequireWildcard(_helpersReact);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var JSX_ANNOTATION_REGEX = /^\*\s*@jsx\s+([^\s]+)/;
          var metadata = {group: "builtin-advanced"};
          exports.metadata = metadata;
          var visitor = require("../../helpers/build-react-transformer")({
            pre: function pre(state) {
              var tagName = state.tagName;
              var args = state.args;
              if (react.isCompatTag(tagName)) {
                args.push(t.literal(tagName));
              } else {
                args.push(state.tagExpr);
              }
            },
            post: function post(state, file) {
              state.callee = file.get("jsxIdentifier");
            }
          });
          exports.visitor = visitor;
          visitor.Program = function(node, parent, scope, file) {
            var id = file.opts.jsxPragma;
            for (var i = 0; i < file.ast.comments.length; i++) {
              var comment = file.ast.comments[i];
              var matches = JSX_ANNOTATION_REGEX.exec(comment.value);
              if (matches) {
                id = matches[1];
                if (id === "React.DOM") {
                  throw file.errorWithNode(comment, "The @jsx React.DOM pragma has been deprecated as of React 0.12");
                } else {
                  break;
                }
              }
            }
            file.set("jsxIdentifier", id.split(".").map(t.identifier).reduce(function(object, property) {
              return t.memberExpression(object, property);
            }));
          };
        }, {
          "../../../types": 196,
          "../../helpers/build-react-transformer": 72,
          "../../helpers/react": 79
        }],
        158: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _regenerator = require("regenerator");
          var _regenerator2 = _interopRequireDefault(_regenerator);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var NodePath = _regenerator2["default"].types.NodePath;
          var metadata = {group: "builtin-advanced"};
          exports.metadata = metadata;
          var visitor = {Function: {exit: function exit(node) {
                if (node.async || node.generator) {
                  _regenerator2["default"].transform(convertNodePath(this));
                }
              }}};
          exports.visitor = visitor;
          function convertNodePath(path) {
            var programNode;
            var keysAlongPath = [];
            while (path) {
              var pp = path.parentPath;
              var parentNode = pp && pp.node;
              if (parentNode) {
                keysAlongPath.push(path.key);
                if (parentNode !== path.container) {
                  var found = Object.keys(parentNode).some(function(listKey) {
                    if (parentNode[listKey] === path.container) {
                      keysAlongPath.push(listKey);
                      return true;
                    }
                  });
                  if (!found) {
                    throw new Error("Failed to find container object in parent node");
                  }
                }
                if (t.isProgram(parentNode)) {
                  programNode = parentNode;
                  break;
                }
              }
              path = pp;
            }
            if (!programNode) {
              throw new Error("Failed to find root Program node");
            }
            var nodePath = new NodePath(programNode);
            while (keysAlongPath.length > 0) {
              nodePath = nodePath.get(keysAlongPath.pop());
            }
            return nodePath;
          }
        }, {
          "../../../types": 196,
          "regenerator": 552
        }],
        159: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var metadata = {group: "builtin-pre"};
          exports.metadata = metadata;
          var THIS_BREAK_KEYS = ["FunctionExpression", "FunctionDeclaration", "ClassProperty"];
          function isUseStrict(node) {
            if (!t.isLiteral(node))
              return false;
            if (node.raw && node.rawValue === node.value) {
              return node.rawValue === "use strict";
            } else {
              return node.value === "use strict";
            }
          }
          var visitor = {
            Program: {enter: function enter(program) {
                var first = program.body[0];
                var directive;
                if (t.isExpressionStatement(first) && isUseStrict(first.expression)) {
                  directive = first;
                } else {
                  directive = t.expressionStatement(t.literal("use strict"));
                  this.unshiftContainer("body", directive);
                  if (first) {
                    directive.leadingComments = first.leadingComments;
                    first.leadingComments = [];
                  }
                }
                directive._blockHoist = Infinity;
              }},
            ThisExpression: function ThisExpression() {
              if (!this.findParent(function(path) {
                return !path.is("shadow") && THIS_BREAK_KEYS.indexOf(path.type) >= 0;
              })) {
                return t.identifier("undefined");
              }
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        160: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function statementList(key, path) {
            var paths = path.get(key);
            for (var i = 0; i < paths.length; i++) {
              var _path = paths[i];
              var func = _path.node;
              if (!t.isFunctionDeclaration(func))
                continue;
              var declar = t.variableDeclaration("let", [t.variableDeclarator(func.id, t.toExpression(func))]);
              declar._blockHoist = 2;
              func.id = null;
              _path.replaceWith(declar);
            }
          }
          var visitor = {
            BlockStatement: function BlockStatement(node, parent) {
              if (t.isFunction(parent) && parent.body === node || t.isExportDeclaration(parent)) {
                return;
              }
              statementList("body", this);
            },
            SwitchCase: function SwitchCase() {
              statementList("consequent", this);
            }
          };
          exports.visitor = visitor;
        }, {"../../../types": 196}],
        161: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var _helpersNameMethod = require("../../helpers/name-method");
          var metadata = {group: "builtin-basic"};
          exports.metadata = metadata;
          var visitor = {
            "ArrowFunctionExpression|FunctionExpression": {exit: function exit() {
                if (!this.parentPath.isProperty()) {
                  return _helpersNameMethod.bare.apply(this, arguments);
                }
              }},
            ObjectExpression: function ObjectExpression() {
              var props = this.get("properties");
              var _arr = props;
              for (var _i = 0; _i < _arr.length; _i++) {
                var prop = _arr[_i];
                var value = prop.get("value");
                if (value.isFunction()) {
                  var newNode = _helpersNameMethod.bare(value.node, prop.node, value.scope);
                  if (newNode)
                    value.replaceWith(newNode);
                }
              }
            }
          };
          exports.visitor = visitor;
        }, {"../../helpers/name-method": 78}],
        162: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _messages = require("../../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function check(source, file) {
            if (t.isLiteral(source)) {
              var name = source.value;
              var lower = name.toLowerCase();
              if (lower === "react" && name !== lower) {
                throw file.errorWithNode(source, messages.get("didYouMean", "react"));
              }
            }
          }
          var visitor = {
            CallExpression: function CallExpression(node, parent, scope, file) {
              if (this.get("callee").isIdentifier({name: "require"}) && node.arguments.length === 1) {
                check(node.arguments[0], file);
              }
            },
            ModuleDeclaration: function ModuleDeclaration(node, parent, scope, file) {
              check(node.source, file);
            }
          };
          exports.visitor = visitor;
        }, {
          "../../../messages": 60,
          "../../../types": 196
        }],
        163: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _path = require("./path");
          var _path2 = _interopRequireDefault(_path);
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          var TraversalContext = (function() {
            function TraversalContext(scope, opts, state, parentPath) {
              _classCallCheck(this, TraversalContext);
              this.queue = null;
              this.parentPath = parentPath;
              this.scope = scope;
              this.state = state;
              this.opts = opts;
            }
            TraversalContext.prototype.shouldVisit = function shouldVisit(node) {
              var opts = this.opts;
              if (opts.enter || opts.exit)
                return true;
              if (opts[node.type])
                return true;
              var keys = t.VISITOR_KEYS[node.type];
              if (!keys || !keys.length)
                return false;
              var _arr = keys;
              for (var _i = 0; _i < _arr.length; _i++) {
                var key = _arr[_i];
                if (node[key])
                  return true;
              }
              return false;
            };
            TraversalContext.prototype.create = function create(node, obj, key, listKey) {
              var path = _path2["default"].get({
                parentPath: this.parentPath,
                parent: node,
                container: obj,
                key: key,
                listKey: listKey
              });
              path.unshiftContext(this);
              return path;
            };
            TraversalContext.prototype.visitMultiple = function visitMultiple(container, parent, listKey) {
              if (container.length === 0)
                return false;
              var visited = [];
              var queue = this.queue = [];
              var stop = false;
              for (var key = 0; key < container.length; key++) {
                var self = container[key];
                if (self && this.shouldVisit(self)) {
                  queue.push(this.create(parent, container, key, listKey));
                }
              }
              var _arr2 = queue;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var path = _arr2[_i2];
                path.resync();
                if (visited.indexOf(path.node) >= 0)
                  continue;
                visited.push(path.node);
                if (path.visit()) {
                  stop = true;
                  break;
                }
              }
              var _arr3 = queue;
              for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var path = _arr3[_i3];
                path.shiftContext();
              }
              this.queue = null;
              return stop;
            };
            TraversalContext.prototype.visitSingle = function visitSingle(node, key) {
              if (this.shouldVisit(node[key])) {
                var path = this.create(node, node, key);
                path.visit();
                path.shiftContext();
              }
            };
            TraversalContext.prototype.visit = function visit(node, key) {
              var nodes = node[key];
              if (!nodes)
                return;
              if (Array.isArray(nodes)) {
                return this.visitMultiple(nodes, node, key);
              } else {
                return this.visitSingle(node, key);
              }
            };
            return TraversalContext;
          })();
          exports["default"] = TraversalContext;
          module.exports = exports["default"];
        }, {
          "../types": 196,
          "./path": 172
        }],
        164: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Hub = function Hub(file) {
            _classCallCheck(this, Hub);
            this.file = file;
          };
          exports["default"] = Hub;
          module.exports = exports["default"];
        }, {}],
        165: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports["default"] = traverse;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _context = require("./context");
          var _context2 = _interopRequireDefault(_context);
          var _visitors = require("./visitors");
          var visitors = _interopRequireWildcard(_visitors);
          var _messages = require("../messages");
          var messages = _interopRequireWildcard(_messages);
          var _lodashCollectionIncludes = require("lodash/collection/includes");
          var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          function traverse(parent, opts, scope, state, parentPath) {
            if (!parent)
              return;
            if (!opts)
              opts = {};
            if (!opts.noScope && !scope) {
              if (parent.type !== "Program" && parent.type !== "File") {
                throw new Error(messages.get("traverseNeedsParent", parent.type));
              }
            }
            visitors.explode(opts);
            if (Array.isArray(parent)) {
              for (var i = 0; i < parent.length; i++) {
                traverse.node(parent[i], opts, scope, state, parentPath);
              }
            } else {
              traverse.node(parent, opts, scope, state, parentPath);
            }
          }
          traverse.visitors = visitors;
          traverse.verify = visitors.verify;
          traverse.explode = visitors.explode;
          traverse.node = function(node, opts, scope, state, parentPath, skipKeys) {
            var keys = t.VISITOR_KEYS[node.type];
            if (!keys)
              return;
            var context = new _context2["default"](scope, opts, state, parentPath);
            var _arr = keys;
            for (var _i = 0; _i < _arr.length; _i++) {
              var key = _arr[_i];
              if (skipKeys && skipKeys[key])
                continue;
              if (context.visit(node, key))
                return;
            }
          };
          var CLEAR_KEYS = t.COMMENT_KEYS.concat(["_scopeInfo", "_paths", "tokens", "comments", "start", "end", "loc", "raw", "rawValue"]);
          traverse.clearNode = function(node) {
            for (var i = 0; i < CLEAR_KEYS.length; i++) {
              var key = CLEAR_KEYS[i];
              if (node[key] != null)
                node[key] = undefined;
            }
          };
          var clearVisitor = {
            noScope: true,
            exit: traverse.clearNode
          };
          traverse.removeProperties = function(tree) {
            traverse(tree, clearVisitor);
            traverse.clearNode(tree);
            return tree;
          };
          function hasBlacklistedType(node, parent, scope, state) {
            if (node.type === state.type) {
              state.has = true;
              this.skip();
            }
          }
          traverse.hasType = function(tree, scope, type, blacklistTypes) {
            if (_lodashCollectionIncludes2["default"](blacklistTypes, tree.type))
              return false;
            if (tree.type === type)
              return true;
            var state = {
              has: false,
              type: type
            };
            traverse(tree, {
              blacklist: blacklistTypes,
              enter: hasBlacklistedType
            }, scope, state);
            return state.has;
          };
          module.exports = exports["default"];
        }, {
          "../messages": 60,
          "../types": 196,
          "./context": 163,
          "./visitors": 185,
          "lodash/collection/includes": 430
        }],
        166: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.findParent = findParent;
          exports.getFunctionParent = getFunctionParent;
          exports.getStatementParent = getStatementParent;
          exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
          exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
          exports.getAncestry = getAncestry;
          exports.inType = inType;
          exports.inShadow = inShadow;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          function findParent(callback) {
            var path = this;
            while (path = path.parentPath) {
              if (callback(path))
                return path;
            }
            return null;
          }
          function getFunctionParent() {
            return this.findParent(function(path) {
              return path.isFunction() || path.isProgram();
            });
          }
          function getStatementParent() {
            var path = this;
            do {
              if (Array.isArray(path.container)) {
                return path;
              }
            } while (path = path.parentPath);
          }
          function getEarliestCommonAncestorFrom(paths) {
            return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
              var earliest;
              var keys = t.VISITOR_KEYS[deepest.type];
              var _arr = ancestries;
              for (var _i = 0; _i < _arr.length; _i++) {
                var ancestry = _arr[_i];
                var path = ancestry[i + 1];
                if (!earliest) {
                  earliest = path;
                  continue;
                }
                if (path.listKey && earliest.listKey === path.listKey) {
                  if (path.key < earliest.key) {
                    earliest = path;
                    continue;
                  }
                }
                var earliestKeyIndex = keys.indexOf(earliest.parentKey);
                var currentKeyIndex = keys.indexOf(path.parentKey);
                if (earliestKeyIndex > currentKeyIndex) {
                  earliest = path;
                }
              }
              return earliest;
            });
          }
          function getDeepestCommonAncestorFrom(paths, filter) {
            var _this = this;
            if (!paths.length) {
              return this;
            }
            if (paths.length === 1) {
              return paths[0];
            }
            var minDepth = Infinity;
            var lastCommonIndex,
                lastCommon;
            var ancestries = paths.map(function(path) {
              var ancestry = [];
              do {
                ancestry.unshift(path);
              } while ((path = path.parentPath) && path !== _this);
              if (ancestry.length < minDepth) {
                minDepth = ancestry.length;
              }
              return ancestry;
            });
            var first = ancestries[0];
            depthLoop: for (var i = 0; i < minDepth; i++) {
              var shouldMatch = first[i];
              var _arr2 = ancestries;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var ancestry = _arr2[_i2];
                if (ancestry[i] !== shouldMatch) {
                  break depthLoop;
                }
              }
              lastCommonIndex = i;
              lastCommon = shouldMatch;
            }
            if (lastCommon) {
              if (filter) {
                return filter(lastCommon, lastCommonIndex, ancestries);
              } else {
                return lastCommon;
              }
            } else {
              throw new Error("Couldn't find intersection");
            }
          }
          function getAncestry() {
            var path = this;
            var paths = [];
            do {
              paths.push(path);
            } while (path = path.parentPath);
            return paths;
          }
          function inType() {
            var path = this;
            while (path) {
              var _arr3 = arguments;
              for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var type = _arr3[_i3];
                if (path.node.type === type)
                  return true;
              }
              path = path.parentPath;
            }
            return false;
          }
          function inShadow(key) {
            var path = this;
            do {
              if (path.isFunction()) {
                var shadow = path.node.shadow;
                if (shadow) {
                  if (!key || shadow[key] !== false) {
                    return path;
                  }
                } else if (path.isArrowFunctionExpression()) {
                  return path;
                }
                return null;
              }
            } while (path = path.parentPath);
            return null;
          }
        }, {
          "../../types": 196,
          "./index": 172
        }],
        167: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
          exports.addComment = addComment;
          exports.addComments = addComments;
          function shareCommentsWithSiblings() {
            var node = this.node;
            if (!node)
              return;
            var trailing = node.trailingComments;
            var leading = node.leadingComments;
            if (!trailing && !leading)
              return;
            var prev = this.getSibling(this.key - 1);
            var next = this.getSibling(this.key + 1);
            if (!prev.node)
              prev = next;
            if (!next.node)
              next = prev;
            prev.addComments("trailing", leading);
            next.addComments("leading", trailing);
          }
          function addComment(type, content, line) {
            this.addComments(type, [{
              type: line ? "CommentLine" : "CommentBlock",
              value: content
            }]);
          }
          function addComments(type, comments) {
            if (!comments)
              return;
            var node = this.node;
            if (!node)
              return;
            var key = type + "Comments";
            if (node[key]) {
              node[key] = node[key].concat(comments);
            } else {
              node[key] = comments;
            }
          }
        }, {}],
        168: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.call = call;
          exports.isBlacklisted = isBlacklisted;
          exports.visit = visit;
          exports.skip = skip;
          exports.skipKey = skipKey;
          exports.stop = stop;
          exports.setScope = setScope;
          exports.setContext = setContext;
          exports.resync = resync;
          exports._resyncParent = _resyncParent;
          exports._resyncKey = _resyncKey;
          exports._resyncList = _resyncList;
          exports._resyncRemoved = _resyncRemoved;
          exports.shiftContext = shiftContext;
          exports.unshiftContext = unshiftContext;
          exports.setup = setup;
          exports.setKey = setKey;
          exports.queueNode = queueNode;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("../index");
          var _index2 = _interopRequireDefault(_index);
          function call(key) {
            var node = this.node;
            if (!node)
              return;
            var opts = this.opts;
            var _arr = [opts[key], opts[node.type] && opts[node.type][key]];
            for (var _i = 0; _i < _arr.length; _i++) {
              var fns = _arr[_i];
              if (!fns)
                continue;
              var _arr2 = fns;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var fn = _arr2[_i2];
                if (!fn)
                  continue;
                var _node = this.node;
                if (!_node)
                  return;
                var previousType = this.type;
                var replacement = fn.call(this, _node, this.parent, this.scope, this.state);
                if (replacement) {
                  this.replaceWith(replacement, true);
                }
                if (this.shouldStop || this.shouldSkip || this.removed)
                  return;
                if (previousType !== this.type) {
                  this.queueNode(this);
                  return;
                }
              }
            }
          }
          function isBlacklisted() {
            var blacklist = this.opts.blacklist;
            return blacklist && blacklist.indexOf(this.node.type) > -1;
          }
          function visit() {
            if (this.isBlacklisted())
              return false;
            if (this.opts.shouldSkip && this.opts.shouldSkip(this))
              return false;
            this.call("enter");
            if (this.shouldSkip) {
              return this.shouldStop;
            }
            var node = this.node;
            var opts = this.opts;
            if (node) {
              if (Array.isArray(node)) {
                for (var i = 0; i < node.length; i++) {
                  _index2["default"].node(node[i], opts, this.scope, this.state, this, this.skipKeys);
                }
              } else {
                _index2["default"].node(node, opts, this.scope, this.state, this, this.skipKeys);
                this.call("exit");
              }
            }
            return this.shouldStop;
          }
          function skip() {
            this.shouldSkip = true;
          }
          function skipKey(key) {
            this.skipKeys[key] = true;
          }
          function stop() {
            this.shouldStop = true;
            this.shouldSkip = true;
          }
          function setScope() {
            if (this.opts && this.opts.noScope)
              return;
            var target = this.context || this.parentPath;
            this.scope = this.getScope(target && target.scope);
            if (this.scope)
              this.scope.init();
          }
          function setContext(context) {
            this.shouldSkip = false;
            this.shouldStop = false;
            this.removed = false;
            this.skipKeys = {};
            if (context) {
              this.context = context;
              this.state = context.state;
              this.opts = context.opts;
            }
            this.setScope();
            return this;
          }
          function resync() {
            if (this.removed)
              return;
            this._resyncParent();
            this._resyncList();
            this._resyncKey();
          }
          function _resyncParent() {
            if (this.parentPath) {
              this.parent = this.parentPath.node;
            }
          }
          function _resyncKey() {
            if (!this.container)
              return;
            if (this.node === this.container[this.key])
              return;
            if (Array.isArray(this.container)) {
              for (var i = 0; i < this.container.length; i++) {
                if (this.container[i] === this.node) {
                  return this.setKey(i);
                }
              }
            } else {
              for (var key in this.container) {
                if (this.container[key] === this.node) {
                  return this.setKey(key);
                }
              }
            }
            this.key = null;
          }
          function _resyncList() {
            var listKey = this.listKey;
            var parentPath = this.parentPath;
            if (!listKey || !parentPath)
              return;
            var newContainer = parentPath.node[listKey];
            if (this.container === newContainer)
              return;
            if (newContainer) {
              this.container = newContainer;
            } else {
              this.container = null;
            }
          }
          function _resyncRemoved() {
            if (this.key == null || !this.container || this.container[this.key] !== this.node) {
              this._markRemoved();
            }
          }
          function shiftContext() {
            this.contexts.shift();
            this.setContext(this.contexts[0]);
          }
          function unshiftContext(context) {
            this.contexts.unshift(context);
            this.setContext(context);
          }
          function setup(parentPath, container, listKey, key) {
            this.inList = !!listKey;
            this.listKey = listKey;
            this.parentKey = listKey || key;
            this.container = container;
            this.parentPath = parentPath || this.parentPath;
            this.setKey(key);
          }
          function setKey(key) {
            this.key = key;
            this.node = this.container[this.key];
            this.type = this.node && this.node.type;
          }
          function queueNode(path) {
            var _arr3 = this.contexts;
            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
              var context = _arr3[_i3];
              if (context.queue) {
                context.queue.push(path);
              }
            }
          }
        }, {"../index": 165}],
        169: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.toComputedKey = toComputedKey;
          exports.ensureBlock = ensureBlock;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function toComputedKey() {
            var node = this.node;
            var key;
            if (this.isMemberExpression()) {
              key = node.property;
            } else if (this.isProperty()) {
              key = node.key;
            } else {
              throw new ReferenceError("todo");
            }
            if (!node.computed) {
              if (t.isIdentifier(key))
                key = t.literal(key.name);
            }
            return key;
          }
          function ensureBlock() {
            return t.ensureBlock(this.node);
          }
        }, {"../../types": 196}],
        170: [function(require, module, exports) {
          (function(global) {
            "use strict";
            exports.__esModule = true;
            exports.evaluateTruthy = evaluateTruthy;
            exports.evaluate = evaluate;
            var VALID_CALLEES = ["String", "Number", "Math"];
            function evaluateTruthy() {
              var res = this.evaluate();
              if (res.confident)
                return !!res.value;
            }
            function evaluate() {
              var confident = true;
              var value = evaluate(this);
              if (!confident)
                value = undefined;
              return {
                confident: confident,
                value: value
              };
              function evaluate(path) {
                if (!confident)
                  return;
                var node = path.node;
                if (path.isSequenceExpression()) {
                  var exprs = path.get("expressions");
                  return evaluate(exprs[exprs.length - 1]);
                }
                if (path.isLiteral()) {
                  if (node.regex) {} else {
                    return node.value;
                  }
                }
                if (path.isConditionalExpression()) {
                  if (evaluate(path.get("test"))) {
                    return evaluate(path.get("consequent"));
                  } else {
                    return evaluate(path.get("alternate"));
                  }
                }
                if (path.isTypeCastExpression()) {
                  return evaluate(path.get("expression"));
                }
                if (path.isIdentifier() && !path.scope.hasBinding(node.name, true)) {
                  if (node.name === "undefined") {
                    return undefined;
                  } else if (node.name === "Infinity") {
                    return Infinity;
                  } else if (node.name === "NaN") {
                    return NaN;
                  }
                }
                if (path.isMemberExpression() && !path.parentPath.isCallExpression({callee: node})) {
                  var _property = path.get("property");
                  var object = path.get("object");
                  if (object.isLiteral() && _property.isIdentifier()) {
                    var _value = object.node.value;
                    var type = typeof _value;
                    if (type === "number" || type === "string") {
                      return _value[_property.node.name];
                    }
                  }
                }
                if (path.isReferencedIdentifier()) {
                  var binding = path.scope.getBinding(node.name);
                  if (binding && binding.hasValue) {
                    return binding.value;
                  } else {
                    var resolved = path.resolve();
                    if (resolved === path) {
                      return confident = false;
                    } else {
                      return evaluate(resolved);
                    }
                  }
                }
                if (path.isUnaryExpression({prefix: true})) {
                  var argument = path.get("argument");
                  var arg = evaluate(argument);
                  switch (node.operator) {
                    case "void":
                      return undefined;
                    case "!":
                      return !arg;
                    case "+":
                      return +arg;
                    case "-":
                      return -arg;
                    case "~":
                      return ~arg;
                    case "typeof":
                      if (argument.isFunction()) {
                        return "function";
                      } else {
                        return typeof arg;
                      }
                  }
                }
                if (path.isArrayExpression() || path.isObjectExpression()) {}
                if (path.isLogicalExpression()) {
                  var wasConfident = confident;
                  var left = evaluate(path.get("left"));
                  var leftConfident = confident;
                  confident = wasConfident;
                  var right = evaluate(path.get("right"));
                  var rightConfident = confident;
                  var uncertain = leftConfident !== rightConfident;
                  confident = leftConfident && rightConfident;
                  switch (node.operator) {
                    case "||":
                      if ((left || right) && uncertain) {
                        confident = true;
                      }
                      return left || right;
                    case "&&":
                      if (!left && leftConfident || !right && rightConfident) {
                        confident = true;
                      }
                      return left && right;
                  }
                }
                if (path.isBinaryExpression()) {
                  var left = evaluate(path.get("left"));
                  var right = evaluate(path.get("right"));
                  switch (node.operator) {
                    case "-":
                      return left - right;
                    case "+":
                      return left + right;
                    case "/":
                      return left / right;
                    case "*":
                      return left * right;
                    case "%":
                      return left % right;
                    case "**":
                      return Math.pow(left, right);
                    case "<":
                      return left < right;
                    case ">":
                      return left > right;
                    case "<=":
                      return left <= right;
                    case ">=":
                      return left >= right;
                    case "==":
                      return left == right;
                    case "!=":
                      return left != right;
                    case "===":
                      return left === right;
                    case "!==":
                      return left !== right;
                    case "|":
                      return left | right;
                    case "&":
                      return left & right;
                    case "^":
                      return left ^ right;
                    case "<<":
                      return left << right;
                    case ">>":
                      return left >> right;
                    case ">>>":
                      return left >>> right;
                  }
                }
                if (path.isCallExpression()) {
                  var callee = path.get("callee");
                  var context;
                  var func;
                  if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
                    func = global[node.callee.name];
                  }
                  if (callee.isMemberExpression()) {
                    var object = callee.get("object");
                    var property = callee.get("property");
                    if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0) {
                      context = global[object.node.name];
                      func = context[property.node.name];
                    }
                    if (object.isLiteral() && property.isIdentifier()) {
                      var type = typeof object.node.value;
                      if (type === "string" || type === "number") {
                        context = object.node.value;
                        func = context[property.node.name];
                      }
                    }
                  }
                  if (func) {
                    var args = path.get("arguments").map(evaluate);
                    if (!confident)
                      return;
                    return func.apply(context, args);
                  }
                }
                confident = false;
              }
            }
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        171: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.getStatementParent = getStatementParent;
          exports.getOpposite = getOpposite;
          exports.getCompletionRecords = getCompletionRecords;
          exports.getSibling = getSibling;
          exports.get = get;
          exports._getKey = _getKey;
          exports._getPattern = _getPattern;
          exports.getBindingIdentifiers = getBindingIdentifiers;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function getStatementParent() {
            var path = this;
            do {
              if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
                break;
              } else {
                path = path.parentPath;
              }
            } while (path);
            if (path && (path.isProgram() || path.isFile())) {
              throw new Error("File/Program node, we can't possibly find a statement parent to this");
            }
            return path;
          }
          function getOpposite() {
            if (this.key === "left") {
              return this.getSibling("right");
            } else if (this.key === "right") {
              return this.getSibling("left");
            }
          }
          function getCompletionRecords() {
            var paths = [];
            var add = function add(path) {
              if (path)
                paths = paths.concat(path.getCompletionRecords());
            };
            if (this.isIfStatement()) {
              add(this.get("consequent"));
              add(this.get("alternate"));
            } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
              add(this.get("body"));
            } else if (this.isProgram() || this.isBlockStatement()) {
              add(this.get("body").pop());
            } else if (this.isFunction()) {
              return this.get("body").getCompletionRecords();
            } else if (this.isTryStatement()) {
              add(this.get("block"));
              add(this.get("handler"));
              add(this.get("finalizer"));
            } else {
              paths.push(this);
            }
            return paths;
          }
          function getSibling(key) {
            return _index2["default"].get({
              parentPath: this.parentPath,
              parent: this.parent,
              container: this.container,
              listKey: this.listKey,
              key: key
            });
          }
          function get(key, context) {
            if (context === true)
              context = this.context;
            var parts = key.split(".");
            if (parts.length === 1) {
              return this._getKey(key, context);
            } else {
              return this._getPattern(parts, context);
            }
          }
          function _getKey(key, context) {
            var _this = this;
            var node = this.node;
            var container = node[key];
            if (Array.isArray(container)) {
              return container.map(function(_, i) {
                return _index2["default"].get({
                  listKey: key,
                  parentPath: _this,
                  parent: node,
                  container: container,
                  key: i
                }).setContext(context);
              });
            } else {
              return _index2["default"].get({
                parentPath: this,
                parent: node,
                container: node,
                key: key
              }).setContext(context);
            }
          }
          function _getPattern(parts, context) {
            var path = this;
            var _arr = parts;
            for (var _i = 0; _i < _arr.length; _i++) {
              var part = _arr[_i];
              if (part === ".") {
                path = path.parentPath;
              } else {
                if (Array.isArray(path)) {
                  path = path[part];
                } else {
                  path = path.get(part, context);
                }
              }
            }
            return path;
          }
          function getBindingIdentifiers(duplicates) {
            return t.getBindingIdentifiers(this.node, duplicates);
          }
        }, {
          "../../types": 196,
          "./index": 172
        }],
        172: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _libVirtualTypes = require("./lib/virtual-types");
          var virtualTypes = _interopRequireWildcard(_libVirtualTypes);
          var _index = require("../index");
          var _index2 = _interopRequireDefault(_index);
          var _lodashObjectAssign = require("lodash/object/assign");
          var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
          var _scope = require("../scope");
          var _scope2 = _interopRequireDefault(_scope);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var NodePath = (function() {
            function NodePath(hub, parent) {
              _classCallCheck(this, NodePath);
              this.contexts = [];
              this.parent = parent;
              this.data = {};
              this.hub = hub;
              this.shouldSkip = false;
              this.shouldStop = false;
              this.removed = false;
              this.state = null;
              this.opts = null;
              this.skipKeys = null;
              this.parentPath = null;
              this.context = null;
              this.container = null;
              this.listKey = null;
              this.inList = false;
              this.parentKey = null;
              this.key = null;
              this.node = null;
              this.scope = null;
              this.type = null;
              this.typeAnnotation = null;
            }
            NodePath.get = function get(_ref) {
              var hub = _ref.hub;
              var parentPath = _ref.parentPath;
              var parent = _ref.parent;
              var container = _ref.container;
              var listKey = _ref.listKey;
              var key = _ref.key;
              if (!hub && parentPath) {
                hub = parentPath.hub;
              }
              var targetNode = container[key];
              var paths = parent._paths = parent._paths || [];
              var path;
              for (var i = 0; i < paths.length; i++) {
                var pathCheck = paths[i];
                if (pathCheck.node === targetNode) {
                  path = pathCheck;
                  break;
                }
              }
              if (!path) {
                path = new NodePath(hub, parent);
                paths.push(path);
              }
              path.setup(parentPath, container, listKey, key);
              return path;
            };
            NodePath.prototype.getScope = function getScope(scope) {
              var ourScope = scope;
              if (this.isScope()) {
                ourScope = new _scope2["default"](this, scope);
              }
              return ourScope;
            };
            NodePath.prototype.setData = function setData(key, val) {
              return this.data[key] = val;
            };
            NodePath.prototype.getData = function getData(key, def) {
              var val = this.data[key];
              if (!val && def)
                val = this.data[key] = def;
              return val;
            };
            NodePath.prototype.errorWithNode = function errorWithNode(msg) {
              var Error = arguments.length <= 1 || arguments[1] === undefined ? SyntaxError : arguments[1];
              return this.hub.file.errorWithNode(this.node, msg, Error);
            };
            NodePath.prototype.traverse = function traverse(visitor, state) {
              _index2["default"](this.node, visitor, this.scope, state, this);
            };
            return NodePath;
          })();
          exports["default"] = NodePath;
          _lodashObjectAssign2["default"](NodePath.prototype, require("./ancestry"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./inference"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./replacement"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./evaluation"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./conversion"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./introspection"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./context"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./removal"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./modification"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./family"));
          _lodashObjectAssign2["default"](NodePath.prototype, require("./comments"));
          var _arr = t.TYPES;
          var _loop = function() {
            var type = _arr[_i];
            var typeKey = "is" + type;
            NodePath.prototype[typeKey] = function(opts) {
              return t[typeKey](this.node, opts);
            };
          };
          for (var _i = 0; _i < _arr.length; _i++) {
            _loop();
          }
          var _loop2 = function(type) {
            if (type[0] === "_")
              return "continue";
            if (t.TYPES.indexOf(type) < 0)
              t.TYPES.push(type);
            NodePath.prototype["is" + type] = function(opts) {
              return virtualTypes[type].checkPath(this, opts);
            };
          };
          for (var type in virtualTypes) {
            var _ret2 = _loop2(type);
            if (_ret2 === "continue")
              continue;
          }
          module.exports = exports["default"];
        }, {
          "../../types": 196,
          "../index": 165,
          "../scope": 184,
          "./ancestry": 166,
          "./comments": 167,
          "./context": 168,
          "./conversion": 169,
          "./evaluation": 170,
          "./family": 171,
          "./inference": 173,
          "./introspection": 176,
          "./lib/virtual-types": 179,
          "./modification": 180,
          "./removal": 181,
          "./replacement": 182,
          "lodash/object/assign": 526
        }],
        173: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.getTypeAnnotation = getTypeAnnotation;
          exports._getTypeAnnotation = _getTypeAnnotation;
          exports.isBaseType = isBaseType;
          exports.couldBeBaseType = couldBeBaseType;
          exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
          exports.isGenericType = isGenericType;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _inferers = require("./inferers");
          var inferers = _interopRequireWildcard(_inferers);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          function getTypeAnnotation() {
            if (this.typeAnnotation)
              return this.typeAnnotation;
            var type = this._getTypeAnnotation() || t.anyTypeAnnotation();
            if (t.isTypeAnnotation(type))
              type = type.typeAnnotation;
            return this.typeAnnotation = type;
          }
          function _getTypeAnnotation() {
            var node = this.node;
            if (!node) {
              if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
                var declar = this.parentPath.parentPath;
                var declarParent = declar.parentPath;
                if (declar.key === "left" && declarParent.isForInStatement()) {
                  return t.stringTypeAnnotation();
                }
                if (declar.key === "left" && declarParent.isForOfStatement()) {
                  return t.anyTypeAnnotation();
                }
                return t.voidTypeAnnotation();
              } else {
                return;
              }
            }
            if (node.typeAnnotation) {
              return node.typeAnnotation;
            }
            var inferer = inferers[node.type];
            if (inferer) {
              return inferer.call(this, node);
            }
            inferer = inferers[this.parentPath.type];
            if (inferer && inferer.validParent) {
              return this.parentPath.getTypeAnnotation();
            }
          }
          function isBaseType(baseName, soft) {
            return _isBaseType(baseName, this.getTypeAnnotation(), soft);
          }
          function _isBaseType(baseName, type, soft) {
            if (baseName === "string") {
              return t.isStringTypeAnnotation(type);
            } else if (baseName === "number") {
              return t.isNumberTypeAnnotation(type);
            } else if (baseName === "boolean") {
              return t.isBooleanTypeAnnotation(type);
            } else if (baseName === "any") {
              return t.isAnyTypeAnnotation(type);
            } else if (baseName === "mixed") {
              return t.isMixedTypeAnnotation(type);
            } else if (baseName === "void") {
              return t.isVoidTypeAnnotation(type);
            } else {
              if (soft) {
                return false;
              } else {
                throw new Error("Unknown base type " + baseName);
              }
            }
          }
          function couldBeBaseType(name) {
            var type = this.getTypeAnnotation();
            if (t.isAnyTypeAnnotation(type))
              return true;
            if (t.isUnionTypeAnnotation(type)) {
              var _arr = type.types;
              for (var _i = 0; _i < _arr.length; _i++) {
                var type2 = _arr[_i];
                if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
                  return true;
                }
              }
              return false;
            } else {
              return _isBaseType(name, type, true);
            }
          }
          function baseTypeStrictlyMatches(right) {
            var left = this.getTypeAnnotation();
            right = right.getTypeAnnotation();
            if (!t.isAnyTypeAnnotation() && t.isFlowBaseAnnotation(left)) {
              return right.type === left.type;
            }
          }
          function isGenericType(genericName) {
            var type = this.getTypeAnnotation();
            return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {name: genericName});
          }
        }, {
          "../../../types": 196,
          "./inferers": 175
        }],
        174: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          exports["default"] = function(node) {
            if (!this.isReferenced())
              return;
            var binding = this.scope.getBinding(node.name);
            if (binding) {
              if (binding.identifier.typeAnnotation) {
                return binding.identifier.typeAnnotation;
              } else {
                return getTypeAnnotationBindingConstantViolations(this, node.name);
              }
            }
            if (node.name === "undefined") {
              return t.voidTypeAnnotation();
            } else if (node.name === "NaN" || node.name === "Infinity") {
              return t.numberTypeAnnotation();
            } else if (node.name === "arguments") {}
          };
          function getTypeAnnotationBindingConstantViolations(path, name) {
            var binding = path.scope.getBinding(name);
            var types = [];
            path.typeAnnotation = t.unionTypeAnnotation(types);
            var functionConstantViolations = [];
            var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
            var testType = getConditionalAnnotation(path, name);
            if (testType) {
              var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
              constantViolations = constantViolations.filter(function(path) {
                return testConstantViolations.indexOf(path) < 0;
              });
              types.push(testType.typeAnnotation);
            }
            if (constantViolations.length) {
              var rawConstantViolations = constantViolations.reverse();
              var visitedScopes = [];
              constantViolations = [];
              var _arr = rawConstantViolations;
              for (var _i = 0; _i < _arr.length; _i++) {
                var violation = _arr[_i];
                var violationScope = violation.scope;
                if (visitedScopes.indexOf(violationScope) >= 0)
                  continue;
                visitedScopes.push(violationScope);
                constantViolations.push(violation);
                if (violationScope === path.scope) {
                  constantViolations = [violation];
                  break;
                }
              }
              constantViolations = constantViolations.concat(functionConstantViolations);
              var _arr2 = constantViolations;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var violation = _arr2[_i2];
                types.push(violation.getTypeAnnotation());
              }
            }
            if (types.length) {
              return t.createUnionTypeAnnotation(types);
            }
          }
          function getConstantViolationsBefore(binding, path, functions) {
            var violations = binding.constantViolations.slice();
            violations.unshift(binding.path);
            return violations.filter(function(violation) {
              violation = violation.resolve();
              var status = violation._guessExecutionStatusRelativeTo(path);
              if (functions && status === "function")
                functions.push(violation);
              return status === "before";
            });
          }
          function inferAnnotationFromBinaryExpression(name, path) {
            var operator = path.node.operator;
            var right = path.get("right").resolve();
            var left = path.get("left").resolve();
            var target;
            if (left.isIdentifier({name: name})) {
              target = right;
            } else if (right.isIdentifier({name: name})) {
              target = left;
            }
            if (target) {
              if (operator === "===") {
                return target.getTypeAnnotation();
              } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
                return t.numberTypeAnnotation();
              } else {
                return;
              }
            } else {
              if (operator !== "===")
                return;
            }
            var typeofPath;
            var typePath;
            if (left.isUnaryExpression({operator: "typeof"})) {
              typeofPath = left;
              typePath = right;
            } else if (right.isUnaryExpression({operator: "typeof"})) {
              typeofPath = right;
              typePath = left;
            }
            if (!typePath && !typeofPath)
              return;
            typePath = typePath.resolve();
            if (!typePath.isLiteral())
              return;
            var typeValue = typePath.node.value;
            if (typeof typeValue !== "string")
              return;
            if (!typeofPath.get("argument").isIdentifier({name: name}))
              return;
            return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);
          }
          function getParentConditionalPath(path) {
            var parentPath;
            while (parentPath = path.parentPath) {
              if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
                if (path.key === "test") {
                  return;
                } else {
                  return parentPath;
                }
              } else {
                path = parentPath;
              }
            }
          }
          function getConditionalAnnotation(path, name) {
            var ifStatement = getParentConditionalPath(path);
            if (!ifStatement)
              return;
            var test = ifStatement.get("test");
            var paths = [test];
            var types = [];
            do {
              var _path = paths.shift().resolve();
              if (_path.isLogicalExpression()) {
                paths.push(_path.get("left"));
                paths.push(_path.get("right"));
              }
              if (_path.isBinaryExpression()) {
                var type = inferAnnotationFromBinaryExpression(name, _path);
                if (type)
                  types.push(type);
              }
            } while (paths.length);
            if (types.length) {
              return {
                typeAnnotation: t.createUnionTypeAnnotation(types),
                ifStatement: ifStatement
              };
            } else {
              return getConditionalAnnotation(ifStatement, name);
            }
          }
          module.exports = exports["default"];
        }, {"../../../types": 196}],
        175: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.VariableDeclarator = VariableDeclarator;
          exports.TypeCastExpression = TypeCastExpression;
          exports.NewExpression = NewExpression;
          exports.TemplateLiteral = TemplateLiteral;
          exports.UnaryExpression = UnaryExpression;
          exports.BinaryExpression = BinaryExpression;
          exports.LogicalExpression = LogicalExpression;
          exports.ConditionalExpression = ConditionalExpression;
          exports.SequenceExpression = SequenceExpression;
          exports.AssignmentExpression = AssignmentExpression;
          exports.UpdateExpression = UpdateExpression;
          exports.Literal = Literal;
          exports.ObjectExpression = ObjectExpression;
          exports.ArrayExpression = ArrayExpression;
          exports.RestElement = RestElement;
          exports.CallExpression = CallExpression;
          exports.TaggedTemplateExpression = TaggedTemplateExpression;
          function _interopRequire(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var _infererReference = require("./inferer-reference");
          exports.Identifier = _interopRequire(_infererReference);
          function VariableDeclarator() {
            var id = this.get("id");
            if (id.isIdentifier()) {
              return this.get("init").getTypeAnnotation();
            } else {
              return;
            }
          }
          function TypeCastExpression(node) {
            return node.typeAnnotation;
          }
          TypeCastExpression.validParent = true;
          function NewExpression(node) {
            if (this.get("callee").isIdentifier()) {
              return t.genericTypeAnnotation(node.callee);
            }
          }
          function TemplateLiteral() {
            return t.stringTypeAnnotation();
          }
          function UnaryExpression(node) {
            var operator = node.operator;
            if (operator === "void") {
              return t.voidTypeAnnotation();
            } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t.numberTypeAnnotation();
            } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t.stringTypeAnnotation();
            } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t.booleanTypeAnnotation();
            }
          }
          function BinaryExpression(node) {
            var operator = node.operator;
            if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
              return t.numberTypeAnnotation();
            } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
              return t.booleanTypeAnnotation();
            } else if (operator === "+") {
              var right = this.get("right");
              var left = this.get("left");
              if (left.isBaseType("number") && right.isBaseType("number")) {
                return t.numberTypeAnnotation();
              } else if (left.isBaseType("string") || right.isBaseType("string")) {
                return t.stringTypeAnnotation();
              }
              return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);
            }
          }
          function LogicalExpression() {
            return t.createUnionTypeAnnotation([this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()]);
          }
          function ConditionalExpression() {
            return t.createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()]);
          }
          function SequenceExpression() {
            return this.get("expressions").pop().getTypeAnnotation();
          }
          function AssignmentExpression() {
            return this.get("right").getTypeAnnotation();
          }
          function UpdateExpression(node) {
            var operator = node.operator;
            if (operator === "++" || operator === "--") {
              return t.numberTypeAnnotation();
            }
          }
          function Literal(node) {
            var value = node.value;
            if (typeof value === "string")
              return t.stringTypeAnnotation();
            if (typeof value === "number")
              return t.numberTypeAnnotation();
            if (typeof value === "boolean")
              return t.booleanTypeAnnotation();
            if (value === null)
              return t.voidTypeAnnotation();
            if (node.regex)
              return t.genericTypeAnnotation(t.identifier("RegExp"));
          }
          function ObjectExpression() {
            return t.genericTypeAnnotation(t.identifier("Object"));
          }
          function ArrayExpression() {
            return t.genericTypeAnnotation(t.identifier("Array"));
          }
          function RestElement() {
            return ArrayExpression();
          }
          RestElement.validParent = true;
          function Func() {
            return t.genericTypeAnnotation(t.identifier("Function"));
          }
          exports.Function = Func;
          exports.Class = Func;
          function CallExpression() {
            return resolveCall(this.get("callee"));
          }
          function TaggedTemplateExpression() {
            return resolveCall(this.get("tag"));
          }
          function resolveCall(callee) {
            callee = callee.resolve();
            if (callee.isFunction()) {
              if (callee.is("async")) {
                if (callee.is("generator")) {
                  return t.genericTypeAnnotation(t.identifier("AsyncIterator"));
                } else {
                  return t.genericTypeAnnotation(t.identifier("Promise"));
                }
              } else {
                if (callee.node.returnType) {
                  return callee.node.returnType;
                } else {}
              }
            }
          }
        }, {
          "../../../types": 196,
          "./inferer-reference": 174
        }],
        176: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.matchesPattern = matchesPattern;
          exports.has = has;
          exports.isnt = isnt;
          exports.equals = equals;
          exports.isNodeType = isNodeType;
          exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
          exports.isCompletionRecord = isCompletionRecord;
          exports.isStatementOrBlock = isStatementOrBlock;
          exports.referencesImport = referencesImport;
          exports.getSource = getSource;
          exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
          exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
          exports.resolve = resolve;
          exports._resolve = _resolve;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashCollectionIncludes = require("lodash/collection/includes");
          var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function matchesPattern(pattern, allowPartial) {
            if (!this.isMemberExpression())
              return false;
            var parts = pattern.split(".");
            var search = [this.node];
            var i = 0;
            function matches(name) {
              var part = parts[i];
              return part === "*" || name === part;
            }
            while (search.length) {
              var node = search.shift();
              if (allowPartial && i === parts.length) {
                return true;
              }
              if (t.isIdentifier(node)) {
                if (!matches(node.name))
                  return false;
              } else if (t.isLiteral(node)) {
                if (!matches(node.value))
                  return false;
              } else if (t.isMemberExpression(node)) {
                if (node.computed && !t.isLiteral(node.property)) {
                  return false;
                } else {
                  search.unshift(node.property);
                  search.unshift(node.object);
                  continue;
                }
              } else if (t.isThisExpression(node)) {
                if (!matches("this"))
                  return false;
              } else {
                return false;
              }
              if (++i > parts.length) {
                return false;
              }
            }
            return i === parts.length;
          }
          function has(key) {
            var val = this.node[key];
            if (val && Array.isArray(val)) {
              return !!val.length;
            } else {
              return !!val;
            }
          }
          var is = has;
          exports.is = is;
          function isnt(key) {
            return !this.has(key);
          }
          function equals(key, value) {
            return this.node[key] === value;
          }
          function isNodeType(type) {
            return t.isType(this.type, type);
          }
          function canHaveVariableDeclarationOrExpression() {
            return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
          }
          function isCompletionRecord(allowInsideFunction) {
            var path = this;
            var first = true;
            do {
              var container = path.container;
              if (path.isFunction() && !first) {
                return !!allowInsideFunction;
              }
              first = false;
              if (Array.isArray(container) && path.key !== container.length - 1) {
                return false;
              }
            } while ((path = path.parentPath) && !path.isProgram());
            return true;
          }
          function isStatementOrBlock() {
            if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {
              return false;
            } else {
              return _lodashCollectionIncludes2["default"](t.STATEMENT_OR_BLOCK_KEYS, this.key);
            }
          }
          function referencesImport(moduleSource, importName) {
            if (!this.isReferencedIdentifier())
              return false;
            var binding = this.scope.getBinding(this.node.name);
            if (!binding || binding.kind !== "module")
              return false;
            var path = binding.path;
            var parent = path.parentPath;
            if (!parent.isImportDeclaration())
              return false;
            if (parent.node.source.value === moduleSource) {
              if (!importName)
                return true;
            } else {
              return false;
            }
            if (path.isImportDefaultSpecifier() && importName === "default") {
              return true;
            }
            if (path.isImportNamespaceSpecifier() && importName === "*") {
              return true;
            }
            if (path.isImportSpecifier() && path.node.imported.name === importName) {
              return true;
            }
            return false;
          }
          function getSource() {
            var node = this.node;
            if (node.end) {
              return this.hub.file.code.slice(node.start, node.end);
            } else {
              return "";
            }
          }
          function willIMaybeExecuteBefore(target) {
            return this._guessExecutionStatusRelativeTo(target) !== "after";
          }
          function _guessExecutionStatusRelativeTo(target) {
            var targetFuncParent = target.scope.getFunctionParent();
            var selfFuncParent = this.scope.getFunctionParent();
            if (targetFuncParent !== selfFuncParent) {
              return "function";
            }
            var targetPaths = target.getAncestry();
            var selfPaths = this.getAncestry();
            var commonPath;
            var targetIndex;
            var selfIndex;
            for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
              var selfPath = selfPaths[selfIndex];
              targetIndex = targetPaths.indexOf(selfPath);
              if (targetIndex >= 0) {
                commonPath = selfPath;
                break;
              }
            }
            if (!commonPath) {
              return "before";
            }
            var targetRelationship = targetPaths[targetIndex - 1];
            var selfRelationship = selfPaths[selfIndex - 1];
            if (!targetRelationship || !selfRelationship) {
              return "before";
            }
            if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {
              return targetRelationship.key > selfRelationship.key ? "before" : "after";
            }
            var targetKeyPosition = t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);
            var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);
            return targetKeyPosition > selfKeyPosition ? "before" : "after";
          }
          function resolve(dangerous, resolved) {
            return this._resolve(dangerous, resolved) || this;
          }
          function _resolve(dangerous, resolved) {
            if (resolved && resolved.indexOf(this) >= 0)
              return;
            resolved = resolved || [];
            resolved.push(this);
            if (this.isVariableDeclarator()) {
              if (this.get("id").isIdentifier()) {
                return this.get("init").resolve(dangerous, resolved);
              } else {}
            } else if (this.isReferencedIdentifier()) {
              var binding = this.scope.getBinding(this.node.name);
              if (!binding)
                return;
              if (!binding.constant)
                return;
              if (binding.kind === "module")
                return;
              if (binding.path !== this) {
                return binding.path.resolve(dangerous, resolved);
              }
            } else if (this.isTypeCastExpression()) {
              return this.get("expression").resolve(dangerous, resolved);
            } else if (dangerous && this.isMemberExpression()) {
              var targetKey = this.toComputedKey();
              if (!t.isLiteral(targetKey))
                return;
              var targetName = targetKey.value;
              var target = this.get("object").resolve(dangerous, resolved);
              if (target.isObjectExpression()) {
                var props = target.get("properties");
                var _arr = props;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var prop = _arr[_i];
                  if (!prop.isProperty())
                    continue;
                  var key = prop.get("key");
                  var match = prop.isnt("computed") && key.isIdentifier({name: targetName});
                  match = match || key.isLiteral({value: targetName});
                  if (match)
                    return prop.get("value").resolve(dangerous, resolved);
                }
              } else if (target.isArrayExpression() && !isNaN(+targetName)) {
                var elems = target.get("elements");
                var elem = elems[targetName];
                if (elem)
                  return elem.resolve(dangerous, resolved);
              }
            }
          }
        }, {
          "../../types": 196,
          "lodash/collection/includes": 430
        }],
        177: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _transformationHelpersReact = require("../../../transformation/helpers/react");
          var react = _interopRequireWildcard(_transformationHelpersReact);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var referenceVisitor = {ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              if (this.isJSXIdentifier() && react.isCompatTag(node.name)) {
                return;
              }
              var binding = scope.getBinding(node.name);
              if (!binding)
                return;
              if (binding !== state.scope.getBinding(node.name))
                return;
              if (binding.constant) {
                state.bindings[node.name] = binding;
              } else {
                var _arr = binding.constantViolations;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var violationPath = _arr[_i];
                  state.breakOnScopePaths = state.breakOnScopePaths.concat(violationPath.getAncestry());
                }
              }
            }};
          var PathHoister = (function() {
            function PathHoister(path, scope) {
              _classCallCheck(this, PathHoister);
              this.breakOnScopePaths = [];
              this.bindings = {};
              this.scopes = [];
              this.scope = scope;
              this.path = path;
            }
            PathHoister.prototype.isCompatibleScope = function isCompatibleScope(scope) {
              for (var key in this.bindings) {
                var binding = this.bindings[key];
                if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
                  return false;
                }
              }
              return true;
            };
            PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {
              var scope = this.path.scope;
              do {
                if (this.isCompatibleScope(scope)) {
                  this.scopes.push(scope);
                } else {
                  break;
                }
                if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
                  break;
                }
              } while (scope = scope.parent);
            };
            PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {
              var scopes = this.scopes;
              var scope = scopes.pop();
              if (!scope)
                return;
              if (scope.path.isFunction()) {
                if (this.hasOwnParamBindings(scope)) {
                  if (this.scope === scope)
                    return;
                  return scope.path.get("body").get("body")[0];
                } else {
                  return this.getNextScopeStatementParent();
                }
              } else if (scope.path.isProgram()) {
                return this.getNextScopeStatementParent();
              }
            };
            PathHoister.prototype.getNextScopeStatementParent = function getNextScopeStatementParent() {
              var scope = this.scopes.pop();
              if (scope)
                return scope.path.getStatementParent();
            };
            PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(scope) {
              for (var name in this.bindings) {
                if (!scope.hasOwnBinding(name))
                  continue;
                var binding = this.bindings[name];
                if (binding.kind === "param")
                  return true;
              }
              return false;
            };
            PathHoister.prototype.run = function run() {
              var node = this.path.node;
              if (node._hoisted)
                return;
              node._hoisted = true;
              this.path.traverse(referenceVisitor, this);
              this.getCompatibleScopes();
              var attachTo = this.getAttachmentPath();
              if (!attachTo)
                return;
              if (attachTo.getFunctionParent() === this.path.getFunctionParent())
                return;
              var uid = attachTo.scope.generateUidIdentifier("ref");
              attachTo.insertBefore([t.variableDeclaration("var", [t.variableDeclarator(uid, this.path.node)])]);
              var parent = this.path.parentPath;
              if (parent.isJSXElement() && this.path.container === parent.node.children) {
                uid = t.JSXExpressionContainer(uid);
              }
              this.path.replaceWith(uid);
            };
            return PathHoister;
          })();
          exports["default"] = PathHoister;
          module.exports = exports["default"];
        }, {
          "../../../transformation/helpers/react": 79,
          "../../../types": 196
        }],
        178: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var pre = [function(self) {
            if (self.key === "body" && (self.isBlockStatement() || self.isClassBody())) {
              self.node.body = [];
              return true;
            }
          }, function(self, parent) {
            var replace = false;
            replace = replace || self.key === "body" && parent.isArrowFunctionExpression();
            replace = replace || self.key === "argument" && parent.isThrowStatement();
            if (replace) {
              self.replaceWith(t.identifier("undefined"));
              return true;
            }
          }];
          exports.pre = pre;
          var post = [function(self, parent) {
            var removeParent = false;
            removeParent = removeParent || self.key === "test" && (parent.isWhile() || parent.isSwitchCase());
            removeParent = removeParent || self.key === "declaration" && parent.isExportDeclaration();
            removeParent = removeParent || self.key === "body" && parent.isLabeledStatement();
            removeParent = removeParent || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 0;
            removeParent = removeParent || self.key === "expression" && parent.isExpressionStatement();
            removeParent = removeParent || self.key === "test" && parent.isIfStatement();
            if (removeParent) {
              parent.dangerouslyRemove();
              return true;
            }
          }, function(self, parent) {
            if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
              parent.replaceWith(parent.node.expressions[0]);
              return true;
            }
          }, function(self, parent) {
            if (parent.isBinary()) {
              if (self.key === "left") {
                parent.replaceWith(parent.node.right);
              } else {
                parent.replaceWith(parent.node.left);
              }
              return true;
            }
          }];
          exports.post = post;
        }, {"../../../types": 196}],
        179: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _transformationHelpersReact = require("../../../transformation/helpers/react");
          var react = _interopRequireWildcard(_transformationHelpersReact);
          var _types = require("../../../types");
          var t = _interopRequireWildcard(_types);
          var ReferencedIdentifier = {
            types: ["Identifier", "JSXIdentifier"],
            checkPath: function checkPath(_ref, opts) {
              var node = _ref.node;
              var parent = _ref.parent;
              if (!t.isIdentifier(node, opts)) {
                if (t.isJSXIdentifier(node, opts)) {
                  if (react.isCompatTag(node.name))
                    return false;
                } else {
                  return false;
                }
              }
              return t.isReferenced(node, parent);
            }
          };
          exports.ReferencedIdentifier = ReferencedIdentifier;
          var BindingIdentifier = {
            types: ["Identifier"],
            checkPath: function checkPath(_ref2) {
              var node = _ref2.node;
              var parent = _ref2.parent;
              return t.isBinding(node, parent);
            }
          };
          exports.BindingIdentifier = BindingIdentifier;
          var Statement = {
            types: ["Statement"],
            checkPath: function checkPath(_ref3) {
              var node = _ref3.node;
              var parent = _ref3.parent;
              if (t.isStatement(node)) {
                if (t.isVariableDeclaration(node)) {
                  if (t.isForXStatement(parent, {left: node}))
                    return false;
                  if (t.isForStatement(parent, {init: node}))
                    return false;
                }
                return true;
              } else {
                return false;
              }
            }
          };
          exports.Statement = Statement;
          var Expression = {
            types: ["Expression"],
            checkPath: function checkPath(path) {
              if (path.isIdentifier()) {
                return path.isReferencedIdentifier();
              } else {
                return t.isExpression(path.node);
              }
            }
          };
          exports.Expression = Expression;
          var Scope = {
            types: ["Scopable"],
            checkPath: function checkPath(path) {
              return t.isScope(path.node, path.parent);
            }
          };
          exports.Scope = Scope;
          var Referenced = {checkPath: function checkPath(path) {
              return t.isReferenced(path.node, path.parent);
            }};
          exports.Referenced = Referenced;
          var BlockScoped = {checkPath: function checkPath(path) {
              return t.isBlockScoped(path.node);
            }};
          exports.BlockScoped = BlockScoped;
          var Var = {
            types: ["VariableDeclaration"],
            checkPath: function checkPath(path) {
              return t.isVar(path.node);
            }
          };
          exports.Var = Var;
          var DirectiveLiteral = {
            types: ["Literal"],
            checkPath: function checkPath(path) {
              return path.isLiteral() && path.parentPath.isExpressionStatement();
            }
          };
          exports.DirectiveLiteral = DirectiveLiteral;
          var Directive = {
            types: ["ExpressionStatement"],
            checkPath: function checkPath(path) {
              return path.get("expression").isLiteral();
            }
          };
          exports.Directive = Directive;
          var User = {checkPath: function checkPath(path) {
              return path.node && !!path.node.loc;
            }};
          exports.User = User;
          var Generated = {checkPath: function checkPath(path) {
              return !path.isUser();
            }};
          exports.Generated = Generated;
          var Flow = {
            types: ["Flow", "ImportDeclaration", "ExportDeclaration"],
            checkPath: function checkPath(_ref4) {
              var node = _ref4.node;
              if (t.isFlow(node)) {
                return true;
              } else if (t.isImportDeclaration(node)) {
                return node.importKind === "type" || node.importKind === "typeof";
              } else if (t.isExportDeclaration(node)) {
                return node.exportKind === "type";
              } else {
                return false;
              }
            }
          };
          exports.Flow = Flow;
        }, {
          "../../../transformation/helpers/react": 79,
          "../../../types": 196
        }],
        180: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.insertBefore = insertBefore;
          exports._containerInsert = _containerInsert;
          exports._containerInsertBefore = _containerInsertBefore;
          exports._containerInsertAfter = _containerInsertAfter;
          exports._maybePopFromStatements = _maybePopFromStatements;
          exports.insertAfter = insertAfter;
          exports.updateSiblingKeys = updateSiblingKeys;
          exports._verifyNodeList = _verifyNodeList;
          exports.unshiftContainer = unshiftContainer;
          exports.pushContainer = pushContainer;
          exports.hoist = hoist;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _libHoister = require("./lib/hoister");
          var _libHoister2 = _interopRequireDefault(_libHoister);
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          function insertBefore(nodes) {
            this._assertUnremoved();
            nodes = this._verifyNodeList(nodes);
            if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
              return this.parentPath.insertBefore(nodes);
            } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
              if (this.node)
                nodes.push(this.node);
              this.replaceExpressionWithStatements(nodes);
            } else {
              this._maybePopFromStatements(nodes);
              if (Array.isArray(this.container)) {
                return this._containerInsertBefore(nodes);
              } else if (this.isStatementOrBlock()) {
                if (this.node)
                  nodes.push(this.node);
                this.node = this.container[this.key] = t.blockStatement(nodes);
              } else {
                throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
              }
            }
            return [this];
          }
          function _containerInsert(from, nodes) {
            this.updateSiblingKeys(from, nodes.length);
            var paths = [];
            for (var i = 0; i < nodes.length; i++) {
              var to = from + i;
              var node = nodes[i];
              this.container.splice(to, 0, node);
              if (this.context) {
                var path = this.context.create(this.parent, this.container, to, this.listKey);
                paths.push(path);
                this.queueNode(path);
              } else {
                paths.push(_index2["default"].get({
                  parentPath: this,
                  parent: node,
                  container: this.container,
                  listKey: this.listKey,
                  key: to
                }));
              }
            }
            return paths;
          }
          function _containerInsertBefore(nodes) {
            return this._containerInsert(this.key, nodes);
          }
          function _containerInsertAfter(nodes) {
            return this._containerInsert(this.key + 1, nodes);
          }
          function _maybePopFromStatements(nodes) {
            var last = nodes[nodes.length - 1];
            if (t.isExpressionStatement(last) && t.isIdentifier(last.expression) && !this.isCompletionRecord()) {
              nodes.pop();
            }
          }
          function insertAfter(nodes) {
            this._assertUnremoved();
            nodes = this._verifyNodeList(nodes);
            if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
              return this.parentPath.insertAfter(nodes);
            } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
              if (this.node) {
                var temp = this.scope.generateDeclaredUidIdentifier();
                nodes.unshift(t.expressionStatement(t.assignmentExpression("=", temp, this.node)));
                nodes.push(t.expressionStatement(temp));
              }
              this.replaceExpressionWithStatements(nodes);
            } else {
              this._maybePopFromStatements(nodes);
              if (Array.isArray(this.container)) {
                return this._containerInsertAfter(nodes);
              } else if (this.isStatementOrBlock()) {
                if (this.node)
                  nodes.unshift(this.node);
                this.node = this.container[this.key] = t.blockStatement(nodes);
              } else {
                throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
              }
            }
            return [this];
          }
          function updateSiblingKeys(fromIndex, incrementBy) {
            var paths = this.parent._paths;
            for (var i = 0; i < paths.length; i++) {
              var path = paths[i];
              if (path.key >= fromIndex) {
                path.key += incrementBy;
              }
            }
          }
          function _verifyNodeList(nodes) {
            if (nodes.constructor !== Array) {
              nodes = [nodes];
            }
            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if (!node) {
                throw new Error("Node list has falsy node with the index of " + i);
              } else if (typeof node !== "object") {
                throw new Error("Node list contains a non-object node with the index of " + i);
              } else if (!node.type) {
                throw new Error("Node list contains a node without a type with the index of " + i);
              } else if (node instanceof _index2["default"]) {
                nodes[i] = node.node;
              }
            }
            return nodes;
          }
          function unshiftContainer(listKey, nodes) {
            this._assertUnremoved();
            nodes = this._verifyNodeList(nodes);
            var container = this.node[listKey];
            var path = _index2["default"].get({
              parentPath: this,
              parent: this.node,
              container: container,
              listKey: listKey,
              key: 0
            });
            return path.insertBefore(nodes);
          }
          function pushContainer(listKey, nodes) {
            this._assertUnremoved();
            nodes = this._verifyNodeList(nodes);
            var container = this.node[listKey];
            var i = container.length;
            var path = _index2["default"].get({
              parentPath: this,
              parent: this.node,
              container: container,
              listKey: listKey,
              key: i
            });
            return path.replaceWith(nodes, true);
          }
          function hoist() {
            var scope = arguments.length <= 0 || arguments[0] === undefined ? this.scope : arguments[0];
            var hoister = new _libHoister2["default"](this, scope);
            return hoister.run();
          }
        }, {
          "../../types": 196,
          "./index": 172,
          "./lib/hoister": 177
        }],
        181: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.remove = remove;
          exports.dangerouslyRemove = dangerouslyRemove;
          exports._callRemovalHooks = _callRemovalHooks;
          exports._remove = _remove;
          exports._markRemoved = _markRemoved;
          exports._assertUnremoved = _assertUnremoved;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _libRemovalHooks = require("./lib/removal-hooks");
          var removalHooks = _interopRequireWildcard(_libRemovalHooks);
          function remove() {
            console.trace("Path#remove has been renamed to Path#dangerouslyRemove, removing a node is extremely dangerous so please refrain using it.");
            return this.dangerouslyRemove();
          }
          function dangerouslyRemove() {
            this._assertUnremoved();
            this.resync();
            if (this._callRemovalHooks("pre")) {
              this._markRemoved();
              return;
            }
            this.shareCommentsWithSiblings();
            this._remove();
            this._markRemoved();
            this._callRemovalHooks("post");
          }
          function _callRemovalHooks(position) {
            var _arr = removalHooks[position];
            for (var _i = 0; _i < _arr.length; _i++) {
              var fn = _arr[_i];
              if (fn(this, this.parentPath))
                return true;
            }
          }
          function _remove() {
            if (Array.isArray(this.container)) {
              this.container.splice(this.key, 1);
              this.updateSiblingKeys(this.key, -1);
            } else {
              this.container[this.key] = null;
            }
          }
          function _markRemoved() {
            this.shouldSkip = true;
            this.removed = true;
            this.node = null;
          }
          function _assertUnremoved() {
            if (this.removed) {
              throw this.errorWithNode("NodePath has been removed so is read-only.");
            }
          }
        }, {"./lib/removal-hooks": 178}],
        182: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.replaceWithMultiple = replaceWithMultiple;
          exports.replaceWithSourceString = replaceWithSourceString;
          exports.replaceWith = replaceWith;
          exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
          exports.replaceInline = replaceInline;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersCodeFrame = require("../../helpers/code-frame");
          var _helpersCodeFrame2 = _interopRequireDefault(_helpersCodeFrame);
          var _index = require("../index");
          var _index2 = _interopRequireDefault(_index);
          var _index3 = require("./index");
          var _index4 = _interopRequireDefault(_index3);
          var _helpersParse = require("../../helpers/parse");
          var _helpersParse2 = _interopRequireDefault(_helpersParse);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var hoistVariablesVisitor = {
            Function: function Function() {
              this.skip();
            },
            VariableDeclaration: function VariableDeclaration(node, parent, scope) {
              if (node.kind !== "var")
                return;
              var bindings = this.getBindingIdentifiers();
              for (var key in bindings) {
                scope.push({id: bindings[key]});
              }
              var exprs = [];
              var _arr = node.declarations;
              for (var _i = 0; _i < _arr.length; _i++) {
                var declar = _arr[_i];
                if (declar.init) {
                  exprs.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
                }
              }
              return exprs;
            }
          };
          function replaceWithMultiple(nodes) {
            this.resync();
            nodes = this._verifyNodeList(nodes);
            t.inheritLeadingComments(nodes[0], this.node);
            t.inheritTrailingComments(nodes[nodes.length - 1], this.node);
            this.node = this.container[this.key] = null;
            this.insertAfter(nodes);
            if (!this.node)
              this.dangerouslyRemove();
          }
          function replaceWithSourceString(replacement) {
            this.resync();
            try {
              replacement = "(" + replacement + ")";
              replacement = _helpersParse2["default"](replacement);
            } catch (err) {
              var loc = err.loc;
              if (loc) {
                err.message += " - make sure this is an expression.";
                err.message += "\n" + _helpersCodeFrame2["default"](replacement, loc.line, loc.column + 1);
              }
              throw err;
            }
            replacement = replacement.program.body[0].expression;
            _index2["default"].removeProperties(replacement);
            return this.replaceWith(replacement);
          }
          function replaceWith(replacement, whateverAllowed) {
            this.resync();
            if (this.removed) {
              throw new Error("You can't replace this node, we've already removed it");
            }
            if (replacement instanceof _index4["default"]) {
              replacement = replacement.node;
            }
            if (!replacement) {
              throw new Error("You passed `path.replaceWith()` a falsy node, use `path.dangerouslyRemove()` instead");
            }
            if (this.node === replacement) {
              return;
            }
            if (this.isProgram() && !t.isProgram(replacement)) {
              throw new Error("You can only replace a Program root node with another Program node");
            }
            if (t.isProgram(replacement) && !this.isProgram()) {
              replacement = replacement.body;
              whateverAllowed = true;
            }
            if (Array.isArray(replacement)) {
              if (whateverAllowed) {
                return this.replaceWithMultiple(replacement);
              } else {
                throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
              }
            }
            if (typeof replacement === "string") {
              return this.replaceWithSourceString();
            }
            if (this.isNodeType("Statement") && t.isExpression(replacement) && !this.canHaveVariableDeclarationOrExpression()) {
              replacement = t.expressionStatement(replacement);
            }
            if (this.isNodeType("Expression") && t.isStatement(replacement)) {
              return this.replaceExpressionWithStatements([replacement]);
            }
            var oldNode = this.node;
            if (oldNode)
              t.inheritsComments(replacement, oldNode);
            this.node = this.container[this.key] = replacement;
            this.type = replacement.type;
            this.setScope();
          }
          function replaceExpressionWithStatements(nodes) {
            this.resync();
            var toSequenceExpression = t.toSequenceExpression(nodes, this.scope);
            if (toSequenceExpression) {
              return this.replaceWith(toSequenceExpression);
            } else {
              var container = t.functionExpression(null, [], t.blockStatement(nodes));
              container.shadow = true;
              this.replaceWith(t.callExpression(container, []));
              this.traverse(hoistVariablesVisitor);
              var last = this.get("callee").getCompletionRecords();
              var _arr2 = last;
              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var lastNode = _arr2[_i2];
                if (!lastNode.isExpressionStatement())
                  continue;
                var loop = lastNode.findParent(function(path) {
                  return path.isLoop();
                });
                if (loop) {
                  var uid = this.get("callee").scope.generateDeclaredUidIdentifier("ret");
                  this.get("callee.body").pushContainer("body", t.returnStatement(uid));
                  lastNode.get("expression").replaceWith(t.assignmentExpression("=", uid, lastNode.node.expression));
                } else {
                  lastNode.replaceWith(t.returnStatement(lastNode.node.expression));
                }
              }
              return this.node;
            }
          }
          function replaceInline(nodes) {
            this.resync();
            if (Array.isArray(nodes)) {
              if (Array.isArray(this.container)) {
                nodes = this._verifyNodeList(nodes);
                this._containerInsertAfter(nodes);
                return this.dangerouslyRemove();
              } else {
                return this.replaceWithMultiple(nodes);
              }
            } else {
              return this.replaceWith(nodes);
            }
          }
        }, {
          "../../helpers/code-frame": 55,
          "../../helpers/parse": 59,
          "../../types": 196,
          "../index": 165,
          "./index": 172
        }],
        183: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Binding = (function() {
            function Binding(_ref) {
              var existing = _ref.existing;
              var identifier = _ref.identifier;
              var scope = _ref.scope;
              var path = _ref.path;
              var kind = _ref.kind;
              _classCallCheck(this, Binding);
              this.constantViolations = [];
              this.constant = true;
              this.identifier = identifier;
              this.references = 0;
              this.referenced = false;
              this.scope = scope;
              this.path = path;
              this.kind = kind;
              this.hasValue = false;
              this.hasDeoptedValue = false;
              this.value = null;
              this.clearValue();
              if (existing) {
                this.constantViolations = [].concat(existing.path, existing.constantViolations, this.constantViolations);
              }
            }
            Binding.prototype.deoptValue = function deoptValue() {
              this.clearValue();
              this.hasDeoptedValue = true;
            };
            Binding.prototype.setValue = function setValue(value) {
              if (this.hasDeoptedValue)
                return;
              this.hasValue = true;
              this.value = value;
            };
            Binding.prototype.clearValue = function clearValue() {
              this.hasDeoptedValue = false;
              this.hasValue = false;
              this.value = null;
            };
            Binding.prototype.reassign = function reassign(path) {
              this.constant = false;
              this.constantViolations.push(path);
            };
            Binding.prototype.reference = function reference() {
              this.referenced = true;
              this.references++;
            };
            Binding.prototype.dereference = function dereference() {
              this.references--;
              this.referenced = !!this.references;
            };
            return Binding;
          })();
          exports["default"] = Binding;
          module.exports = exports["default"];
        }, {}],
        184: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _lodashCollectionIncludes = require("lodash/collection/includes");
          var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
          var _repeating = require("repeating");
          var _repeating2 = _interopRequireDefault(_repeating);
          var _index = require("../index");
          var _index2 = _interopRequireDefault(_index);
          var _lodashObjectDefaults = require("lodash/object/defaults");
          var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
          var _messages = require("../../messages");
          var messages = _interopRequireWildcard(_messages);
          var _binding = require("./binding");
          var _binding2 = _interopRequireDefault(_binding);
          var _globals = require("globals");
          var _globals2 = _interopRequireDefault(_globals);
          var _lodashArrayFlatten = require("lodash/array/flatten");
          var _lodashArrayFlatten2 = _interopRequireDefault(_lodashArrayFlatten);
          var _lodashObjectExtend = require("lodash/object/extend");
          var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
          var _helpersObject = require("../../helpers/object");
          var _helpersObject2 = _interopRequireDefault(_helpersObject);
          var _types = require("../../types");
          var t = _interopRequireWildcard(_types);
          var collectorVisitor = {
            For: function For(node, parent, scope) {
              var _arr = t.FOR_INIT_KEYS;
              for (var _i = 0; _i < _arr.length; _i++) {
                var key = _arr[_i];
                var declar = this.get(key);
                if (declar.isVar())
                  scope.getFunctionParent().registerBinding("var", declar);
              }
            },
            Declaration: function Declaration(node, parent, scope) {
              if (this.isBlockScoped())
                return;
              if (this.isExportDeclaration() && this.get("declaration").isDeclaration())
                return;
              scope.getFunctionParent().registerDeclaration(this);
            },
            ReferencedIdentifier: function ReferencedIdentifier(node) {
              var binding = this.scope.getBinding(node.name);
              if (binding) {
                binding.reference(this);
              } else {
                this.scope.getProgramParent().addGlobal(node);
              }
            },
            ForXStatement: function ForXStatement() {
              var left = this.get("left");
              if (left.isPattern() || left.isIdentifier()) {
                this.scope.registerConstantViolation(left, left);
              }
            },
            ExportDeclaration: {exit: function exit(node) {
                var declar = node.declaration;
                if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
                  this.scope.getBinding(declar.id.name).reference();
                } else if (t.isVariableDeclaration(declar)) {
                  var _arr2 = declar.declarations;
                  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                    var decl = _arr2[_i2];
                    var ids = t.getBindingIdentifiers(decl);
                    for (var name in ids) {
                      this.scope.getBinding(name).reference();
                    }
                  }
                }
              }},
            LabeledStatement: function LabeledStatement(node) {
              this.scope.getProgramParent().addGlobal(node);
              this.scope.getBlockParent().registerDeclaration(this);
            },
            AssignmentExpression: function AssignmentExpression() {
              var ids = this.getBindingIdentifiers();
              var programParent;
              for (var name in ids) {
                if (this.scope.getBinding(name))
                  continue;
                programParent = programParent || this.scope.getProgramParent();
                programParent.addGlobal(ids[name]);
              }
              this.scope.registerConstantViolation(this, this.get("left"), this.get("right"));
            },
            UpdateExpression: function UpdateExpression(node, parent, scope) {
              scope.registerConstantViolation(this, this.get("argument"), null);
            },
            UnaryExpression: function UnaryExpression(node, parent, scope) {
              if (node.operator === "delete")
                scope.registerConstantViolation(this, this.get("left"), null);
            },
            BlockScoped: function BlockScoped(node, parent, scope) {
              if (scope.path === this)
                scope = scope.parent;
              scope.getBlockParent().registerDeclaration(this);
            },
            ClassDeclaration: function ClassDeclaration(node, parent, scope) {
              var name = node.id.name;
              scope.bindings[name] = scope.getBinding(name);
            },
            Block: function Block(node, parent, scope) {
              var paths = this.get("body");
              var _arr3 = paths;
              for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var path = _arr3[_i3];
                if (path.isFunctionDeclaration()) {
                  scope.getBlockParent().registerDeclaration(path);
                }
              }
            }
          };
          var renameVisitor = {
            ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
              if (node.name === state.oldName) {
                node.name = state.newName;
              }
            },
            Scope: function Scope(node, parent, scope, state) {
              if (!scope.bindingIdentifierEquals(state.oldName, state.binding)) {
                this.skip();
              }
            },
            "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(node, parent, scope, state) {
              var ids = this.getBindingIdentifiers();
              for (var name in ids) {
                if (name === state.oldName)
                  ids[name].name = state.newName;
              }
            }
          };
          var Scope = (function() {
            function Scope(path, parent) {
              _classCallCheck(this, Scope);
              if (parent && parent.block === path.node) {
                return parent;
              }
              var cached = path.getData("scope");
              if (cached && cached.parent === parent && cached.block === path.node) {
                return cached;
              } else {
                path.setData("scope", this);
              }
              this.parent = parent;
              this.hub = path.hub;
              this.parentBlock = path.parent;
              this.block = path.node;
              this.path = path;
            }
            Scope.prototype.traverse = function traverse(node, opts, state) {
              _index2["default"](node, opts, this, state, this.path);
            };
            Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() {
              var name = arguments.length <= 0 || arguments[0] === undefined ? "temp" : arguments[0];
              var id = this.generateUidIdentifier(name);
              this.push({id: id});
              return id;
            };
            Scope.prototype.generateUidIdentifier = function generateUidIdentifier(name) {
              return t.identifier(this.generateUid(name));
            };
            Scope.prototype.generateUid = function generateUid(name) {
              name = t.toIdentifier(name).replace(/^_+/, "");
              var uid;
              var i = 0;
              do {
                uid = this._generateUid(name, i);
                i++;
              } while (this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));
              var program = this.getProgramParent();
              program.references[uid] = true;
              program.uids[uid] = true;
              return uid;
            };
            Scope.prototype._generateUid = function _generateUid(name, i) {
              var id = name;
              if (i > 1)
                id += i;
              return "_" + id;
            };
            Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) {
              var node = parent;
              if (t.isAssignmentExpression(parent)) {
                node = parent.left;
              } else if (t.isVariableDeclarator(parent)) {
                node = parent.id;
              } else if (t.isProperty(node)) {
                node = node.key;
              }
              var parts = [];
              var add = function add(node) {
                if (t.isModuleDeclaration(node)) {
                  if (node.source) {
                    add(node.source);
                  } else if (node.specifiers && node.specifiers.length) {
                    var _arr4 = node.specifiers;
                    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
                      var specifier = _arr4[_i4];
                      add(specifier);
                    }
                  } else if (node.declaration) {
                    add(node.declaration);
                  }
                } else if (t.isModuleSpecifier(node)) {
                  add(node.local);
                } else if (t.isMemberExpression(node)) {
                  add(node.object);
                  add(node.property);
                } else if (t.isIdentifier(node)) {
                  parts.push(node.name);
                } else if (t.isLiteral(node)) {
                  parts.push(node.value);
                } else if (t.isCallExpression(node)) {
                  add(node.callee);
                } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {
                  var _arr5 = node.properties;
                  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
                    var prop = _arr5[_i5];
                    add(prop.key || prop.argument);
                  }
                }
              };
              add(node);
              var id = parts.join("$");
              id = id.replace(/^_/, "") || defaultName || "ref";
              return this.generateUidIdentifier(id);
            };
            Scope.prototype.isStatic = function isStatic(node) {
              if (t.isThisExpression(node) || t.isSuper(node)) {
                return true;
              }
              if (t.isIdentifier(node)) {
                var binding = this.getBinding(node.name);
                if (binding) {
                  return binding.constant;
                } else {
                  return this.hasBinding(node.name);
                }
              }
              return false;
            };
            Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
              if (this.isStatic(node)) {
                return null;
              } else {
                var id = this.generateUidIdentifierBasedOnNode(node);
                if (!dontPush)
                  this.push({id: id});
                return id;
              }
            };
            Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
              if (kind === "param")
                return;
              if (kind === "hoisted" && local.kind === "let")
                return;
              var duplicate = false;
              if (!duplicate)
                duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module";
              if (!duplicate)
                duplicate = local.kind === "param" && (kind === "let" || kind === "const");
              if (duplicate) {
                throw this.hub.file.errorWithNode(id, messages.get("scopeDuplicateDeclaration", name), TypeError);
              }
            };
            Scope.prototype.rename = function rename(oldName, newName, block) {
              newName = newName || this.generateUidIdentifier(oldName).name;
              var info = this.getBinding(oldName);
              if (!info)
                return;
              var state = {
                newName: newName,
                oldName: oldName,
                binding: info.identifier,
                info: info
              };
              var scope = info.scope;
              scope.traverse(block || scope.block, renameVisitor, state);
              if (!block) {
                scope.removeOwnBinding(oldName);
                scope.bindings[newName] = info;
                state.binding.name = newName;
              }
              var file = this.hub.file;
              if (file) {
                this._renameFromMap(file.moduleFormatter.localImports, oldName, newName, state.binding);
              }
            };
            Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
              if (map[oldName]) {
                map[newName] = value;
                map[oldName] = null;
              }
            };
            Scope.prototype.dump = function dump() {
              var sep = _repeating2["default"]("-", 60);
              console.log(sep);
              var scope = this;
              do {
                console.log("#", scope.block.type);
                for (var name in scope.bindings) {
                  var binding = scope.bindings[name];
                  console.log(" -", name, {
                    constant: binding.constant,
                    references: binding.references,
                    kind: binding.kind
                  });
                }
              } while (scope = scope.parent);
              console.log(sep);
            };
            Scope.prototype.toArray = function toArray(node, i) {
              var file = this.hub.file;
              if (t.isIdentifier(node)) {
                var binding = this.getBinding(node.name);
                if (binding && binding.constant && binding.path.isGenericType("Array"))
                  return node;
              }
              if (t.isArrayExpression(node)) {
                return node;
              }
              if (t.isIdentifier(node, {name: "arguments"})) {
                return t.callExpression(t.memberExpression(file.addHelper("slice"), t.identifier("call")), [node]);
              }
              var helperName = "to-array";
              var args = [node];
              if (i === true) {
                helperName = "to-consumable-array";
              } else if (i) {
                args.push(t.literal(i));
                helperName = "sliced-to-array";
                if (this.hub.file.isLoose("es6.forOf"))
                  helperName += "-loose";
              }
              return t.callExpression(file.addHelper(helperName), args);
            };
            Scope.prototype.registerDeclaration = function registerDeclaration(path) {
              if (path.isLabeledStatement()) {
                this.registerBinding("label", path);
              } else if (path.isFunctionDeclaration()) {
                this.registerBinding("hoisted", path);
              } else if (path.isVariableDeclaration()) {
                var declarations = path.get("declarations");
                var _arr6 = declarations;
                for (var _i6 = 0; _i6 < _arr6.length; _i6++) {
                  var declar = _arr6[_i6];
                  this.registerBinding(path.node.kind, declar);
                }
              } else if (path.isClassDeclaration()) {
                this.registerBinding("let", path);
              } else if (path.isImportDeclaration()) {
                var specifiers = path.get("specifiers");
                var _arr7 = specifiers;
                for (var _i7 = 0; _i7 < _arr7.length; _i7++) {
                  var specifier = _arr7[_i7];
                  this.registerBinding("module", specifier);
                }
              } else if (path.isExportDeclaration()) {
                var declar = path.get("declaration");
                if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
                  this.registerDeclaration(declar);
                }
              } else {
                this.registerBinding("unknown", path);
              }
            };
            Scope.prototype.registerConstantViolation = function registerConstantViolation(root, left, right) {
              var ids = left.getBindingIdentifiers();
              for (var name in ids) {
                var binding = this.getBinding(name);
                if (binding)
                  binding.reassign(root, left, right);
              }
            };
            Scope.prototype.registerBinding = function registerBinding(kind, path) {
              if (!kind)
                throw new ReferenceError("no `kind`");
              if (path.isVariableDeclaration()) {
                var declarators = path.get("declarations");
                var _arr8 = declarators;
                for (var _i8 = 0; _i8 < _arr8.length; _i8++) {
                  var declar = _arr8[_i8];
                  this.registerBinding(kind, declar);
                }
                return;
              }
              var parent = this.getProgramParent();
              var ids = path.getBindingIdentifiers(true);
              for (var name in ids) {
                var _arr9 = ids[name];
                for (var _i9 = 0; _i9 < _arr9.length; _i9++) {
                  var id = _arr9[_i9];
                  var local = this.getOwnBinding(name);
                  if (local) {
                    if (local.identifier === id)
                      continue;
                    this.checkBlockScopedCollisions(local, kind, name, id);
                  }
                  parent.references[name] = true;
                  this.bindings[name] = new _binding2["default"]({
                    identifier: id,
                    existing: local,
                    scope: this,
                    path: path,
                    kind: kind
                  });
                }
              }
            };
            Scope.prototype.addGlobal = function addGlobal(node) {
              this.globals[node.name] = node;
            };
            Scope.prototype.hasUid = function hasUid(name) {
              var scope = this;
              do {
                if (scope.uids[name])
                  return true;
              } while (scope = scope.parent);
              return false;
            };
            Scope.prototype.hasGlobal = function hasGlobal(name) {
              var scope = this;
              do {
                if (scope.globals[name])
                  return true;
              } while (scope = scope.parent);
              return false;
            };
            Scope.prototype.hasReference = function hasReference(name) {
              var scope = this;
              do {
                if (scope.references[name])
                  return true;
              } while (scope = scope.parent);
              return false;
            };
            Scope.prototype.isPure = function isPure(node, constantsOnly) {
              if (t.isIdentifier(node)) {
                var binding = this.getBinding(node.name);
                if (!binding)
                  return false;
                if (constantsOnly)
                  return binding.constant;
                return true;
              } else if (t.isClass(node)) {
                return !node.superClass || this.isPure(node.superClass, constantsOnly);
              } else if (t.isBinary(node)) {
                return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
              } else if (t.isArrayExpression(node)) {
                var _arr10 = node.elements;
                for (var _i10 = 0; _i10 < _arr10.length; _i10++) {
                  var elem = _arr10[_i10];
                  if (!this.isPure(elem, constantsOnly))
                    return false;
                }
                return true;
              } else if (t.isObjectExpression(node)) {
                var _arr11 = node.properties;
                for (var _i11 = 0; _i11 < _arr11.length; _i11++) {
                  var prop = _arr11[_i11];
                  if (!this.isPure(prop, constantsOnly))
                    return false;
                }
                return true;
              } else if (t.isProperty(node)) {
                if (node.computed && !this.isPure(node.key, constantsOnly))
                  return false;
                return this.isPure(node.value, constantsOnly);
              } else {
                return t.isPure(node);
              }
            };
            Scope.prototype.setData = function setData(key, val) {
              return this.data[key] = val;
            };
            Scope.prototype.getData = function getData(key) {
              var scope = this;
              do {
                var data = scope.data[key];
                if (data != null)
                  return data;
              } while (scope = scope.parent);
            };
            Scope.prototype.removeData = function removeData(key) {
              var scope = this;
              do {
                var data = scope.data[key];
                if (data != null)
                  scope.data[key] = null;
              } while (scope = scope.parent);
            };
            Scope.prototype.init = function init() {
              if (!this.references)
                this.crawl();
            };
            Scope.prototype.crawl = function crawl() {
              var path = this.path;
              var info = this.block._scopeInfo;
              if (info)
                return _lodashObjectExtend2["default"](this, info);
              info = this.block._scopeInfo = {
                references: _helpersObject2["default"](),
                bindings: _helpersObject2["default"](),
                globals: _helpersObject2["default"](),
                uids: _helpersObject2["default"](),
                data: _helpersObject2["default"]()
              };
              _lodashObjectExtend2["default"](this, info);
              if (path.isLoop()) {
                var _arr12 = t.FOR_INIT_KEYS;
                for (var _i12 = 0; _i12 < _arr12.length; _i12++) {
                  var key = _arr12[_i12];
                  var node = path.get(key);
                  if (node.isBlockScoped())
                    this.registerBinding(node.node.kind, node);
                }
              }
              if (path.isFunctionExpression() && path.has("id")) {
                if (!t.isProperty(path.parent, {method: true})) {
                  this.registerBinding("var", path);
                }
              }
              if (path.isClassExpression() && path.has("id")) {
                this.registerBinding("var", path);
              }
              if (path.isFunction()) {
                var params = path.get("params");
                var _arr13 = params;
                for (var _i13 = 0; _i13 < _arr13.length; _i13++) {
                  var param = _arr13[_i13];
                  this.registerBinding("param", param);
                }
              }
              if (path.isCatchClause()) {
                this.registerBinding("let", path);
              }
              if (path.isComprehensionExpression()) {
                this.registerBinding("let", path);
              }
              var parent = this.getProgramParent();
              if (parent.crawling)
                return;
              this.crawling = true;
              path.traverse(collectorVisitor);
              this.crawling = false;
            };
            Scope.prototype.push = function push(opts) {
              var path = this.path;
              if (path.isSwitchStatement()) {
                path = this.getFunctionParent().path;
              }
              if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
                t.ensureBlock(path.node);
                path = path.get("body");
              }
              if (!path.isBlockStatement() && !path.isProgram()) {
                path = this.getBlockParent().path;
              }
              var unique = opts.unique;
              var kind = opts.kind || "var";
              var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
              var dataKey = "declaration:" + kind + ":" + blockHoist;
              var declarPath = !unique && path.getData(dataKey);
              if (!declarPath) {
                var declar = t.variableDeclaration(kind, []);
                declar._generated = true;
                declar._blockHoist = blockHoist;
                this.hub.file.attachAuxiliaryComment(declar);
                var _path$unshiftContainer = path.unshiftContainer("body", [declar]);
                declarPath = _path$unshiftContainer[0];
                if (!unique)
                  path.setData(dataKey, declarPath);
              }
              var declarator = t.variableDeclarator(opts.id, opts.init);
              declarPath.node.declarations.push(declarator);
              this.registerBinding(kind, declarPath.get("declarations").pop());
            };
            Scope.prototype.getProgramParent = function getProgramParent() {
              var scope = this;
              do {
                if (scope.path.isProgram()) {
                  return scope;
                }
              } while (scope = scope.parent);
              throw new Error("We couldn't find a Function or Program...");
            };
            Scope.prototype.getFunctionParent = function getFunctionParent() {
              var scope = this;
              do {
                if (scope.path.isFunctionParent()) {
                  return scope;
                }
              } while (scope = scope.parent);
              throw new Error("We couldn't find a Function or Program...");
            };
            Scope.prototype.getBlockParent = function getBlockParent() {
              var scope = this;
              do {
                if (scope.path.isBlockParent()) {
                  return scope;
                }
              } while (scope = scope.parent);
              throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
            };
            Scope.prototype.getAllBindings = function getAllBindings() {
              var ids = _helpersObject2["default"]();
              var scope = this;
              do {
                _lodashObjectDefaults2["default"](ids, scope.bindings);
                scope = scope.parent;
              } while (scope);
              return ids;
            };
            Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
              var ids = _helpersObject2["default"]();
              var _arr14 = arguments;
              for (var _i14 = 0; _i14 < _arr14.length; _i14++) {
                var kind = _arr14[_i14];
                var scope = this;
                do {
                  for (var name in scope.bindings) {
                    var binding = scope.bindings[name];
                    if (binding.kind === kind)
                      ids[name] = binding;
                  }
                  scope = scope.parent;
                } while (scope);
              }
              return ids;
            };
            Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
              return this.getBindingIdentifier(name) === node;
            };
            Scope.prototype.getBinding = function getBinding(name) {
              var scope = this;
              do {
                var binding = scope.getOwnBinding(name);
                if (binding)
                  return binding;
              } while (scope = scope.parent);
            };
            Scope.prototype.getOwnBinding = function getOwnBinding(name) {
              return this.bindings[name];
            };
            Scope.prototype.getBindingIdentifier = function getBindingIdentifier(name) {
              var info = this.getBinding(name);
              return info && info.identifier;
            };
            Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
              var binding = this.bindings[name];
              return binding && binding.identifier;
            };
            Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
              return !!this.getOwnBinding(name);
            };
            Scope.prototype.hasBinding = function hasBinding(name, noGlobals) {
              if (!name)
                return false;
              if (this.hasOwnBinding(name))
                return true;
              if (this.parentHasBinding(name, noGlobals))
                return true;
              if (this.hasUid(name))
                return true;
              if (!noGlobals && _lodashCollectionIncludes2["default"](Scope.globals, name))
                return true;
              if (!noGlobals && _lodashCollectionIncludes2["default"](Scope.contextVariables, name))
                return true;
              return false;
            };
            Scope.prototype.parentHasBinding = function parentHasBinding(name, noGlobals) {
              return this.parent && this.parent.hasBinding(name, noGlobals);
            };
            Scope.prototype.moveBindingTo = function moveBindingTo(name, scope) {
              var info = this.getBinding(name);
              if (info) {
                info.scope.removeOwnBinding(name);
                info.scope = scope;
                scope.bindings[name] = info;
              }
            };
            Scope.prototype.removeOwnBinding = function removeOwnBinding(name) {
              delete this.bindings[name];
            };
            Scope.prototype.removeBinding = function removeBinding(name) {
              var info = this.getBinding(name);
              if (info) {
                info.scope.removeOwnBinding(name);
              }
              var scope = this;
              do {
                if (scope.uids[name]) {
                  scope.uids[name] = false;
                }
              } while (scope = scope.parent);
            };
            _createClass(Scope, null, [{
              key: "globals",
              value: _lodashArrayFlatten2["default"]([_globals2["default"].builtin, _globals2["default"].browser, _globals2["default"].node].map(Object.keys)),
              enumerable: true
            }, {
              key: "contextVariables",
              value: ["arguments", "undefined", "Infinity", "NaN"],
              enumerable: true
            }]);
            return Scope;
          })();
          exports["default"] = Scope;
          module.exports = exports["default"];
        }, {
          "../../helpers/object": 58,
          "../../messages": 60,
          "../../types": 196,
          "../index": 165,
          "./binding": 183,
          "globals": 414,
          "lodash/array/flatten": 423,
          "lodash/collection/includes": 430,
          "lodash/object/defaults": 527,
          "lodash/object/extend": 528,
          "repeating": 602
        }],
        185: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.explode = explode;
          exports.verify = verify;
          exports.merge = merge;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _pathLibVirtualTypes = require("./path/lib/virtual-types");
          var virtualTypes = _interopRequireWildcard(_pathLibVirtualTypes);
          var _messages = require("../messages");
          var messages = _interopRequireWildcard(_messages);
          var _types = require("../types");
          var t = _interopRequireWildcard(_types);
          var _lodashLangClone = require("lodash/lang/clone");
          var _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);
          function explode(visitor) {
            if (visitor._exploded)
              return visitor;
            visitor._exploded = true;
            for (var nodeType in visitor) {
              if (shouldIgnoreKey(nodeType))
                continue;
              var parts = nodeType.split("|");
              if (parts.length === 1)
                continue;
              var fns = visitor[nodeType];
              delete visitor[nodeType];
              var _arr = parts;
              for (var _i = 0; _i < _arr.length; _i++) {
                var part = _arr[_i];
                visitor[part] = fns;
              }
            }
            verify(visitor);
            delete visitor.__esModule;
            ensureEntranceObjects(visitor);
            ensureCallbackArrays(visitor);
            var _arr2 = Object.keys(visitor);
            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
              var nodeType = _arr2[_i2];
              if (shouldIgnoreKey(nodeType))
                continue;
              var wrapper = virtualTypes[nodeType];
              if (!wrapper)
                continue;
              var fns = visitor[nodeType];
              for (var type in fns) {
                fns[type] = wrapCheck(wrapper, fns[type]);
              }
              delete visitor[nodeType];
              if (wrapper.types) {
                var _arr4 = wrapper.types;
                for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
                  var type = _arr4[_i4];
                  if (visitor[type]) {
                    mergePair(visitor[type], fns);
                  } else {
                    visitor[type] = fns;
                  }
                }
              } else {
                mergePair(visitor, fns);
              }
            }
            for (var nodeType in visitor) {
              if (shouldIgnoreKey(nodeType))
                continue;
              var fns = visitor[nodeType];
              var aliases = t.FLIPPED_ALIAS_KEYS[nodeType];
              if (!aliases)
                continue;
              delete visitor[nodeType];
              var _arr3 = aliases;
              for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var alias = _arr3[_i3];
                var existing = visitor[alias];
                if (existing) {
                  mergePair(existing, fns);
                } else {
                  visitor[alias] = _lodashLangClone2["default"](fns);
                }
              }
            }
            for (var nodeType in visitor) {
              if (shouldIgnoreKey(nodeType))
                continue;
              ensureCallbackArrays(visitor[nodeType]);
            }
            return visitor;
          }
          function verify(visitor) {
            if (visitor._verified)
              return;
            if (typeof visitor === "function") {
              throw new Error(messages.get("traverseVerifyRootFunction"));
            }
            for (var nodeType in visitor) {
              if (shouldIgnoreKey(nodeType))
                continue;
              if (t.TYPES.indexOf(nodeType) < 0) {
                throw new Error(messages.get("traverseVerifyNodeType", nodeType));
              }
              var visitors = visitor[nodeType];
              if (typeof visitors === "object") {
                for (var visitorKey in visitors) {
                  if (visitorKey === "enter" || visitorKey === "exit")
                    continue;
                  throw new Error(messages.get("traverseVerifyVisitorProperty", nodeType, visitorKey));
                }
              }
            }
            visitor._verified = true;
          }
          function merge(visitors) {
            var rootVisitor = {};
            var _arr5 = visitors;
            for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
              var visitor = _arr5[_i5];
              explode(visitor);
              for (var type in visitor) {
                var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
                mergePair(nodeVisitor, visitor[type]);
              }
            }
            return rootVisitor;
          }
          function ensureEntranceObjects(obj) {
            for (var key in obj) {
              if (shouldIgnoreKey(key))
                continue;
              var fns = obj[key];
              if (typeof fns === "function") {
                obj[key] = {enter: fns};
              }
            }
          }
          function ensureCallbackArrays(obj) {
            if (obj.enter && !Array.isArray(obj.enter))
              obj.enter = [obj.enter];
            if (obj.exit && !Array.isArray(obj.exit))
              obj.exit = [obj.exit];
          }
          function wrapCheck(wrapper, fn) {
            return function() {
              if (wrapper.checkPath(this)) {
                return fn.apply(this, arguments);
              }
            };
          }
          function shouldIgnoreKey(key) {
            if (key[0] === "_")
              return true;
            if (key === "enter" || key === "exit" || key === "shouldSkip")
              return true;
            if (key === "blacklist" || key === "noScope" || key === "skipKeys")
              return true;
            return false;
          }
          function mergePair(dest, src) {
            for (var key in src) {
              dest[key] = [].concat(dest[key] || [], src[key]);
            }
          }
        }, {
          "../messages": 60,
          "../types": 196,
          "./path/lib/virtual-types": 179,
          "lodash/lang/clone": 511
        }],
        186: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.toComputedKey = toComputedKey;
          exports.toSequenceExpression = toSequenceExpression;
          exports.toKeyAlias = toKeyAlias;
          exports.toIdentifier = toIdentifier;
          exports.toBindingIdentifierName = toBindingIdentifierName;
          exports.toStatement = toStatement;
          exports.toExpression = toExpression;
          exports.toBlock = toBlock;
          exports.valueToNode = valueToNode;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashLangIsPlainObject = require("lodash/lang/isPlainObject");
          var _lodashLangIsPlainObject2 = _interopRequireDefault(_lodashLangIsPlainObject);
          var _lodashLangIsNumber = require("lodash/lang/isNumber");
          var _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);
          var _lodashLangIsRegExp = require("lodash/lang/isRegExp");
          var _lodashLangIsRegExp2 = _interopRequireDefault(_lodashLangIsRegExp);
          var _lodashLangIsString = require("lodash/lang/isString");
          var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
          var _traversal = require("../traversal");
          var _traversal2 = _interopRequireDefault(_traversal);
          var _index = require("./index");
          var t = _interopRequireWildcard(_index);
          function toComputedKey(node) {
            var key = arguments.length <= 1 || arguments[1] === undefined ? node.key || node.property : arguments[1];
            return (function() {
              if (!node.computed) {
                if (t.isIdentifier(key))
                  key = t.literal(key.name);
              }
              return key;
            })();
          }
          function toSequenceExpression(nodes, scope) {
            var declars = [];
            var bailed = false;
            var result = convert(nodes);
            if (bailed)
              return;
            for (var i = 0; i < declars.length; i++) {
              scope.push(declars[i]);
            }
            return result;
            function convert(nodes) {
              var ensureLastUndefined = false;
              var exprs = [];
              var _arr = nodes;
              for (var _i = 0; _i < _arr.length; _i++) {
                var node = _arr[_i];
                if (t.isExpression(node)) {
                  exprs.push(node);
                } else if (t.isExpressionStatement(node)) {
                  exprs.push(node.expression);
                } else if (t.isVariableDeclaration(node)) {
                  if (node.kind !== "var")
                    return bailed = true;
                  var _arr2 = node.declarations;
                  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                    var declar = _arr2[_i2];
                    var bindings = t.getBindingIdentifiers(declar);
                    for (var key in bindings) {
                      declars.push({
                        kind: node.kind,
                        id: bindings[key]
                      });
                    }
                    if (declar.init) {
                      exprs.push(t.assignmentExpression("=", declar.id, declar.init));
                    }
                  }
                  ensureLastUndefined = true;
                  continue;
                } else if (t.isIfStatement(node)) {
                  var consequent = node.consequent ? convert([node.consequent]) : t.identifier("undefined");
                  var alternate = node.alternate ? convert([node.alternate]) : t.identifier("undefined");
                  if (!consequent || !alternate)
                    return bailed = true;
                  exprs.push(t.conditionalExpression(node.test, consequent, alternate));
                } else if (t.isBlockStatement(node)) {
                  exprs.push(convert(node.body));
                } else if (t.isEmptyStatement(node)) {
                  ensureLastUndefined = true;
                  continue;
                } else {
                  return bailed = true;
                }
                ensureLastUndefined = false;
              }
              if (ensureLastUndefined) {
                exprs.push(t.identifier("undefined"));
              }
              if (exprs.length === 1) {
                return exprs[0];
              } else {
                return t.sequenceExpression(exprs);
              }
            }
          }
          function toKeyAlias(node) {
            var key = arguments.length <= 1 || arguments[1] === undefined ? node.key : arguments[1];
            return (function() {
              var alias;
              if (node.kind === "method") {
                return toKeyAlias.uid++;
              } else if (t.isIdentifier(key)) {
                alias = key.name;
              } else if (t.isLiteral(key)) {
                alias = JSON.stringify(key.value);
              } else {
                alias = JSON.stringify(_traversal2["default"].removeProperties(t.cloneDeep(key)));
              }
              if (node.computed) {
                alias = "[" + alias + "]";
              }
              return alias;
            })();
          }
          toKeyAlias.uid = 0;
          function toIdentifier(name) {
            if (t.isIdentifier(name))
              return name.name;
            name = name + "";
            name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
            name = name.replace(/^[-0-9]+/, "");
            name = name.replace(/[-\s]+(.)?/g, function(match, c) {
              return c ? c.toUpperCase() : "";
            });
            if (!t.isValidIdentifier(name)) {
              name = "_" + name;
            }
            return name || "_";
          }
          function toBindingIdentifierName(name) {
            name = toIdentifier(name);
            if (name === "eval" || name === "arguments")
              name = "_" + name;
            return name;
          }
          function toStatement(node, ignore) {
            if (t.isStatement(node)) {
              return node;
            }
            var mustHaveId = false;
            var newType;
            if (t.isClass(node)) {
              mustHaveId = true;
              newType = "ClassDeclaration";
            } else if (t.isFunction(node)) {
              mustHaveId = true;
              newType = "FunctionDeclaration";
            } else if (t.isAssignmentExpression(node)) {
              return t.expressionStatement(node);
            }
            if (mustHaveId && !node.id) {
              newType = false;
            }
            if (!newType) {
              if (ignore) {
                return false;
              } else {
                throw new Error("cannot turn " + node.type + " to a statement");
              }
            }
            node.type = newType;
            return node;
          }
          function toExpression(node) {
            if (t.isExpressionStatement(node)) {
              node = node.expression;
            }
            if (t.isClass(node)) {
              node.type = "ClassExpression";
            } else if (t.isFunction(node)) {
              node.type = "FunctionExpression";
            }
            if (t.isExpression(node)) {
              return node;
            } else {
              throw new Error("cannot turn " + node.type + " to an expression");
            }
          }
          function toBlock(node, parent) {
            if (t.isBlockStatement(node)) {
              return node;
            }
            if (t.isEmptyStatement(node)) {
              node = [];
            }
            if (!Array.isArray(node)) {
              if (!t.isStatement(node)) {
                if (t.isFunction(parent)) {
                  node = t.returnStatement(node);
                } else {
                  node = t.expressionStatement(node);
                }
              }
              node = [node];
            }
            return t.blockStatement(node);
          }
          function valueToNode(value) {
            if (value === undefined) {
              return t.identifier("undefined");
            }
            if (value === true || value === false || value === null || _lodashLangIsString2["default"](value) || _lodashLangIsNumber2["default"](value) || _lodashLangIsRegExp2["default"](value)) {
              return t.literal(value);
            }
            if (Array.isArray(value)) {
              return t.arrayExpression(value.map(t.valueToNode));
            }
            if (_lodashLangIsPlainObject2["default"](value)) {
              var props = [];
              for (var key in value) {
                var nodeKey;
                if (t.isValidIdentifier(key)) {
                  nodeKey = t.identifier(key);
                } else {
                  nodeKey = t.literal(key);
                }
                props.push(t.property("init", nodeKey, t.valueToNode(value[key])));
              }
              return t.objectExpression(props);
            }
            throw new Error("don't know how to turn this value into a node");
          }
        }, {
          "../traversal": 165,
          "./index": 196,
          "lodash/lang/isNumber": 519,
          "lodash/lang/isPlainObject": 521,
          "lodash/lang/isRegExp": 522,
          "lodash/lang/isString": 523
        }],
        187: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          _index2["default"]("ArrayExpression", {
            visitor: ["elements"],
            aliases: ["Expression"]
          });
          _index2["default"]("AssignmentExpression", {
            builder: ["operator", "left", "right"],
            visitor: ["left", "right"],
            aliases: ["Expression"]
          });
          _index2["default"]("BinaryExpression", {
            builder: ["operator", "left", "right"],
            visitor: ["left", "right"],
            aliases: ["Binary", "Expression"]
          });
          _index2["default"]("BlockStatement", {
            visitor: ["body"],
            aliases: ["Scopable", "BlockParent", "Block", "Statement"]
          });
          _index2["default"]("BreakStatement", {
            visitor: ["label"],
            aliases: ["Statement", "Terminatorless", "CompletionStatement"]
          });
          _index2["default"]("CallExpression", {
            visitor: ["callee", "arguments"],
            aliases: ["Expression"]
          });
          _index2["default"]("CatchClause", {
            visitor: ["param", "body"],
            aliases: ["Scopable"]
          });
          _index2["default"]("ConditionalExpression", {
            visitor: ["test", "consequent", "alternate"],
            aliases: ["Expression"]
          });
          _index2["default"]("ContinueStatement", {
            visitor: ["label"],
            aliases: ["Statement", "Terminatorless", "CompletionStatement"]
          });
          _index2["default"]("DebuggerStatement", {aliases: ["Statement"]});
          _index2["default"]("DoWhileStatement", {
            visitor: ["body", "test"],
            aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
          });
          _index2["default"]("EmptyStatement", {aliases: ["Statement"]});
          _index2["default"]("ExpressionStatement", {
            visitor: ["expression"],
            aliases: ["Statement"]
          });
          _index2["default"]("File", {
            builder: ["program", "comments", "tokens"],
            visitor: ["program"]
          });
          _index2["default"]("ForInStatement", {
            visitor: ["left", "right", "body"],
            aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"]
          });
          _index2["default"]("ForStatement", {
            visitor: ["init", "test", "update", "body"],
            aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"]
          });
          _index2["default"]("FunctionDeclaration", {
            builder: {
              id: null,
              params: null,
              body: null,
              generator: false,
              async: false
            },
            visitor: ["id", "params", "body", "returnType", "typeParameters"],
            aliases: ["Scopable", "Function", "Func", "BlockParent", "FunctionParent", "Statement", "Pure", "Declaration"]
          });
          _index2["default"]("FunctionExpression", {
            builder: {
              id: null,
              params: null,
              body: null,
              generator: false,
              async: false
            },
            visitor: ["id", "params", "body", "returnType", "typeParameters"],
            aliases: ["Scopable", "Function", "Func", "BlockParent", "FunctionParent", "Expression", "Pure"]
          });
          _index2["default"]("Identifier", {
            builder: ["name"],
            visitor: ["typeAnnotation"],
            aliases: ["Expression"]
          });
          _index2["default"]("IfStatement", {
            visitor: ["test", "consequent", "alternate"],
            aliases: ["Statement"]
          });
          _index2["default"]("LabeledStatement", {
            visitor: ["label", "body"],
            aliases: ["Statement"]
          });
          _index2["default"]("Literal", {
            builder: ["value"],
            aliases: ["Expression", "Pure"]
          });
          _index2["default"]("LogicalExpression", {
            builder: ["operator", "left", "right"],
            visitor: ["left", "right"],
            aliases: ["Binary", "Expression"]
          });
          _index2["default"]("MemberExpression", {
            builder: {
              object: null,
              property: null,
              computed: false
            },
            visitor: ["object", "property"],
            aliases: ["Expression"]
          });
          _index2["default"]("NewExpression", {
            visitor: ["callee", "arguments"],
            aliases: ["Expression"]
          });
          _index2["default"]("ObjectExpression", {
            visitor: ["properties"],
            aliases: ["Expression"]
          });
          _index2["default"]("Program", {
            visitor: ["body"],
            aliases: ["Scopable", "BlockParent", "Block", "FunctionParent"]
          });
          _index2["default"]("Property", {
            builder: {
              kind: "init",
              key: null,
              value: null,
              computed: false
            },
            visitor: ["key", "value", "decorators"],
            aliases: ["UserWhitespacable"]
          });
          _index2["default"]("RestElement", {visitor: ["argument", "typeAnnotation"]});
          _index2["default"]("ReturnStatement", {
            visitor: ["argument"],
            aliases: ["Statement", "Terminatorless", "CompletionStatement"]
          });
          _index2["default"]("SequenceExpression", {
            visitor: ["expressions"],
            aliases: ["Expression"]
          });
          _index2["default"]("SwitchCase", {visitor: ["test", "consequent"]});
          _index2["default"]("SwitchStatement", {
            visitor: ["discriminant", "cases"],
            aliases: ["Statement", "BlockParent", "Scopable"]
          });
          _index2["default"]("ThisExpression", {aliases: ["Expression"]});
          _index2["default"]("ThrowStatement", {
            visitor: ["argument"],
            aliases: ["Statement", "Terminatorless", "CompletionStatement"]
          });
          _index2["default"]("TryStatement", {
            builder: ["block", "handler", "finalizer"],
            visitor: ["block", "handlers", "handler", "guardedHandlers", "finalizer"],
            aliases: ["Statement"]
          });
          _index2["default"]("UnaryExpression", {
            builder: {
              operator: null,
              argument: null,
              prefix: false
            },
            visitor: ["argument"],
            aliases: ["UnaryLike", "Expression"]
          });
          _index2["default"]("UpdateExpression", {
            builder: {
              operator: null,
              argument: null,
              prefix: false
            },
            visitor: ["argument"],
            aliases: ["Expression"]
          });
          _index2["default"]("VariableDeclaration", {
            builder: ["kind", "declarations"],
            visitor: ["declarations"],
            aliases: ["Statement", "Declaration"]
          });
          _index2["default"]("VariableDeclarator", {visitor: ["id", "init"]});
          _index2["default"]("WhileStatement", {
            visitor: ["test", "body"],
            aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
          });
          _index2["default"]("WithStatement", {
            visitor: ["object", "body"],
            aliases: ["Statement"]
          });
        }, {"./index": 191}],
        188: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          _index2["default"]("AssignmentPattern", {
            visitor: ["left", "right"],
            aliases: ["Pattern"]
          });
          _index2["default"]("ArrayPattern", {
            visitor: ["elements", "typeAnnotation"],
            aliases: ["Pattern"]
          });
          _index2["default"]("ArrowFunctionExpression", {
            builder: ["params", "body", "async"],
            visitor: ["params", "body", "returnType"],
            aliases: ["Scopable", "Function", "Func", "BlockParent", "FunctionParent", "Expression", "Pure"]
          });
          _index2["default"]("ClassBody", {visitor: ["body"]});
          _index2["default"]("ClassDeclaration", {
            visitor: ["id", "body", "superClass", "typeParameters", "superTypeParameters", "implements", "decorators"],
            aliases: ["Scopable", "Class", "Statement", "Declaration"]
          });
          _index2["default"]("ClassExpression", {
            visitor: ["id", "body", "superClass", "typeParameters", "superTypeParameters", "implements", "decorators"],
            aliases: ["Scopable", "Class", "Expression"]
          });
          _index2["default"]("ExportAllDeclaration", {
            visitor: ["source", "exported"],
            aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"]
          });
          _index2["default"]("ExportDefaultDeclaration", {
            visitor: ["declaration"],
            aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"]
          });
          _index2["default"]("ExportNamedDeclaration", {
            visitor: ["declaration", "specifiers", "source"],
            aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"]
          });
          _index2["default"]("ExportDefaultSpecifier", {
            visitor: ["exported"],
            aliases: ["ModuleSpecifier"]
          });
          _index2["default"]("ExportNamespaceSpecifier", {
            visitor: ["exported"],
            aliases: ["ModuleSpecifier"]
          });
          _index2["default"]("ExportSpecifier", {
            visitor: ["local", "exported"],
            aliases: ["ModuleSpecifier"]
          });
          _index2["default"]("ForOfStatement", {
            visitor: ["left", "right", "body"],
            aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"]
          });
          _index2["default"]("ImportDeclaration", {
            visitor: ["specifiers", "source"],
            aliases: ["Statement", "Declaration", "ModuleDeclaration"]
          });
          _index2["default"]("ImportDefaultSpecifier", {
            visitor: ["local"],
            aliases: ["ModuleSpecifier"]
          });
          _index2["default"]("ImportNamespaceSpecifier", {
            visitor: ["local"],
            aliases: ["ModuleSpecifier"]
          });
          _index2["default"]("ImportSpecifier", {
            visitor: ["local", "imported"],
            aliases: ["ModuleSpecifier"]
          });
          _index2["default"]("MetaProperty", {
            visitor: ["meta", "property"],
            aliases: ["Expression"]
          });
          _index2["default"]("MethodDefinition", {
            builder: {
              key: null,
              value: null,
              kind: "method",
              computed: false,
              "static": false
            },
            visitor: ["key", "value", "decorators"]
          });
          _index2["default"]("ObjectPattern", {
            visitor: ["properties", "typeAnnotation"],
            aliases: ["Pattern"]
          });
          _index2["default"]("SpreadElement", {
            visitor: ["argument"],
            aliases: ["UnaryLike"]
          });
          _index2["default"]("Super", {aliases: ["Expression"]});
          _index2["default"]("TaggedTemplateExpression", {
            visitor: ["tag", "quasi"],
            aliases: ["Expression"]
          });
          _index2["default"]("TemplateElement");
          _index2["default"]("TemplateLiteral", {
            visitor: ["quasis", "expressions"],
            aliases: ["Expression"]
          });
          _index2["default"]("YieldExpression", {
            builder: ["argument", "delegate"],
            visitor: ["argument"],
            aliases: ["Expression", "Terminatorless"]
          });
        }, {"./index": 191}],
        189: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          _index2["default"]("AwaitExpression", {
            builder: ["argument", "all"],
            visitor: ["argument"],
            aliases: ["Expression", "Terminatorless"]
          });
          _index2["default"]("BindExpression", {visitor: ["object", "callee"]});
          _index2["default"]("ComprehensionBlock", {visitor: ["left", "right"]});
          _index2["default"]("ComprehensionExpression", {
            visitor: ["filter", "blocks", "body"],
            aliases: ["Expression", "Scopable"]
          });
          _index2["default"]("Decorator", {visitor: ["expression"]});
          _index2["default"]("DoExpression", {
            visitor: ["body"],
            aliases: ["Expression"]
          });
          _index2["default"]("SpreadProperty", {
            visitor: ["argument"],
            aliases: ["UnaryLike"]
          });
        }, {"./index": 191}],
        190: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          _index2["default"]("AnyTypeAnnotation", {aliases: ["Flow", "FlowBaseAnnotation"]});
          _index2["default"]("ArrayTypeAnnotation", {
            visitor: ["elementType"],
            aliases: ["Flow"]
          });
          _index2["default"]("BooleanTypeAnnotation", {aliases: ["Flow", "FlowBaseAnnotation"]});
          _index2["default"]("BooleanLiteralTypeAnnotation", {aliases: ["Flow"]});
          _index2["default"]("ClassImplements", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow"]
          });
          _index2["default"]("ClassProperty", {
            visitor: ["key", "value", "typeAnnotation", "decorators"],
            aliases: ["Flow"]
          });
          _index2["default"]("DeclareClass", {
            visitor: ["id", "typeParameters", "extends", "body"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"]
          });
          _index2["default"]("DeclareFunction", {
            visitor: ["id"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"]
          });
          _index2["default"]("DeclareModule", {
            visitor: ["id", "body"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"]
          });
          _index2["default"]("DeclareVariable", {
            visitor: ["id"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"]
          });
          _index2["default"]("FunctionTypeAnnotation", {
            visitor: ["typeParameters", "params", "rest", "returnType"],
            aliases: ["Flow"]
          });
          _index2["default"]("FunctionTypeParam", {
            visitor: ["name", "typeAnnotation"],
            aliases: ["Flow"]
          });
          _index2["default"]("GenericTypeAnnotation", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow"]
          });
          _index2["default"]("InterfaceExtends", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow"]
          });
          _index2["default"]("InterfaceDeclaration", {
            visitor: ["id", "typeParameters", "extends", "body"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"]
          });
          _index2["default"]("IntersectionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow"]
          });
          _index2["default"]("MixedTypeAnnotation", {aliases: ["Flow", "FlowBaseAnnotation"]});
          _index2["default"]("NullableTypeAnnotation", {
            visitor: ["typeAnnotation"],
            aliases: ["Flow"]
          });
          _index2["default"]("NumberLiteralTypeAnnotation", {aliases: ["Flow"]});
          _index2["default"]("NumberTypeAnnotation", {aliases: ["Flow", "FlowBaseAnnotation"]});
          _index2["default"]("StringLiteralTypeAnnotation", {aliases: ["Flow"]});
          _index2["default"]("StringTypeAnnotation", {aliases: ["Flow", "FlowBaseAnnotation"]});
          _index2["default"]("TupleTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow"]
          });
          _index2["default"]("TypeofTypeAnnotation", {
            visitor: ["argument"],
            aliases: ["Flow"]
          });
          _index2["default"]("TypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"]
          });
          _index2["default"]("TypeAnnotation", {
            visitor: ["typeAnnotation"],
            aliases: ["Flow"]
          });
          _index2["default"]("TypeCastExpression", {
            visitor: ["expression", "typeAnnotation"],
            aliases: ["Flow"]
          });
          _index2["default"]("TypeParameterDeclaration", {
            visitor: ["params"],
            aliases: ["Flow"]
          });
          _index2["default"]("TypeParameterInstantiation", {
            visitor: ["params"],
            aliases: ["Flow"]
          });
          _index2["default"]("ObjectTypeAnnotation", {
            visitor: ["properties", "indexers", "callProperties"],
            aliases: ["Flow"]
          });
          _index2["default"]("ObjectTypeCallProperty", {
            visitor: ["value"],
            aliases: ["Flow", "UserWhitespacable"]
          });
          _index2["default"]("ObjectTypeIndexer", {
            visitor: ["id", "key", "value"],
            aliases: ["Flow", "UserWhitespacable"]
          });
          _index2["default"]("ObjectTypeProperty", {
            visitor: ["key", "value"],
            aliases: ["Flow", "UserWhitespacable"]
          });
          _index2["default"]("QualifiedTypeIdentifier", {
            visitor: ["id", "qualification"],
            aliases: ["Flow"]
          });
          _index2["default"]("UnionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow"]
          });
          _index2["default"]("VoidTypeAnnotation", {aliases: ["Flow", "FlowBaseAnnotation"]});
        }, {"./index": 191}],
        191: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports["default"] = defineType;
          var VISITOR_KEYS = {};
          exports.VISITOR_KEYS = VISITOR_KEYS;
          var ALIAS_KEYS = {};
          exports.ALIAS_KEYS = ALIAS_KEYS;
          var BUILDER_KEYS = {};
          exports.BUILDER_KEYS = BUILDER_KEYS;
          function builderFromArray(arr) {
            var builder = {};
            var _arr = arr;
            for (var _i = 0; _i < _arr.length; _i++) {
              var key = _arr[_i];
              builder[key] = null;
            }
            return builder;
          }
          function defineType(type) {
            var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            opts.visitor = opts.visitor || [];
            opts.aliases = opts.aliases || [];
            if (!opts.builder)
              opts.builder = builderFromArray(opts.visitor);
            if (Array.isArray(opts.builder))
              opts.builder = builderFromArray(opts.builder);
            VISITOR_KEYS[type] = opts.visitor;
            ALIAS_KEYS[type] = opts.aliases;
            BUILDER_KEYS[type] = opts.builder;
          }
        }, {}],
        192: [function(require, module, exports) {
          "use strict";
          require("./index");
          require("./core");
          require("./es2015");
          require("./flow");
          require("./jsx");
          require("./misc");
          require("./experimental");
        }, {
          "./core": 187,
          "./es2015": 188,
          "./experimental": 189,
          "./flow": 190,
          "./index": 191,
          "./jsx": 193,
          "./misc": 194
        }],
        193: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          _index2["default"]("JSXAttribute", {
            visitor: ["name", "value"],
            aliases: ["JSX", "Immutable"]
          });
          _index2["default"]("JSXClosingElement", {
            visitor: ["name"],
            aliases: ["JSX", "Immutable"]
          });
          _index2["default"]("JSXElement", {
            visitor: ["openingElement", "closingElement", "children"],
            aliases: ["JSX", "Immutable", "Expression"]
          });
          _index2["default"]("JSXEmptyExpression", {aliases: ["JSX", "Expression"]});
          _index2["default"]("JSXExpressionContainer", {
            visitor: ["expression"],
            aliases: ["JSX", "Immutable"]
          });
          _index2["default"]("JSXIdentifier", {aliases: ["JSX", "Expression"]});
          _index2["default"]("JSXMemberExpression", {
            visitor: ["object", "property"],
            aliases: ["JSX", "Expression"]
          });
          _index2["default"]("JSXNamespacedName", {
            visitor: ["namespace", "name"],
            aliases: ["JSX"]
          });
          _index2["default"]("JSXOpeningElement", {
            visitor: ["name", "attributes"],
            aliases: ["JSX", "Immutable"]
          });
          _index2["default"]("JSXSpreadAttribute", {
            visitor: ["argument"],
            aliases: ["JSX"]
          });
        }, {"./index": 191}],
        194: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          _index2["default"]("Noop", {visitor: []});
          _index2["default"]("ParenthesizedExpression", {
            visitor: ["expression"],
            aliases: ["Expression"]
          });
        }, {"./index": 191}],
        195: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.createUnionTypeAnnotation = createUnionTypeAnnotation;
          exports.removeTypeDuplicates = removeTypeDuplicates;
          exports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          var _index = require("./index");
          var t = _interopRequireWildcard(_index);
          function createUnionTypeAnnotation(types) {
            var flattened = removeTypeDuplicates(types);
            if (flattened.length === 1) {
              return flattened[0];
            } else {
              return t.unionTypeAnnotation(flattened);
            }
          }
          function removeTypeDuplicates(nodes) {
            var generics = {};
            var bases = {};
            var typeGroups = [];
            var types = [];
            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if (!node)
                continue;
              if (types.indexOf(node) >= 0) {
                continue;
              }
              if (t.isAnyTypeAnnotation(node)) {
                return [node];
              }
              if (t.isFlowBaseAnnotation(node)) {
                bases[node.type] = node;
                continue;
              }
              if (t.isUnionTypeAnnotation(node)) {
                if (typeGroups.indexOf(node.types) < 0) {
                  nodes = nodes.concat(node.types);
                  typeGroups.push(node.types);
                }
                continue;
              }
              if (t.isGenericTypeAnnotation(node)) {
                var _name = node.id.name;
                if (generics[_name]) {
                  var existing = generics[_name];
                  if (existing.typeParameters) {
                    if (node.typeParameters) {
                      existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
                    }
                  } else {
                    existing = node.typeParameters;
                  }
                } else {
                  generics[_name] = node;
                }
                continue;
              }
              types.push(node);
            }
            for (var type in bases) {
              types.push(bases[type]);
            }
            for (var _name2 in generics) {
              types.push(generics[_name2]);
            }
            return types;
          }
          function createTypeAnnotationBasedOnTypeof(type) {
            if (type === "string") {
              return t.stringTypeAnnotation();
            } else if (type === "number") {
              return t.numberTypeAnnotation();
            } else if (type === "undefined") {
              return t.voidTypeAnnotation();
            } else if (type === "boolean") {
              return t.booleanTypeAnnotation();
            } else if (type === "function") {
              return t.genericTypeAnnotation(t.identifier("Function"));
            } else if (type === "object") {
              return t.genericTypeAnnotation(t.identifier("Object"));
            } else if (type === "symbol") {
              return t.genericTypeAnnotation(t.identifier("Symbol"));
            } else {
              throw new Error("Invalid typeof value");
            }
          }
        }, {"./index": 196}],
        196: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.is = is;
          exports.isType = isType;
          exports.shallowEqual = shallowEqual;
          exports.appendToMemberExpression = appendToMemberExpression;
          exports.prependToMemberExpression = prependToMemberExpression;
          exports.ensureBlock = ensureBlock;
          exports.clone = clone;
          exports.cloneDeep = cloneDeep;
          exports.buildMatchMemberExpression = buildMatchMemberExpression;
          exports.removeComments = removeComments;
          exports.inheritsComments = inheritsComments;
          exports.inheritTrailingComments = inheritTrailingComments;
          exports.inheritLeadingComments = inheritLeadingComments;
          exports.inheritInnerComments = inheritInnerComments;
          exports.inherits = inherits;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _toFastProperties = require("to-fast-properties");
          var _toFastProperties2 = _interopRequireDefault(_toFastProperties);
          var _lodashArrayCompact = require("lodash/array/compact");
          var _lodashArrayCompact2 = _interopRequireDefault(_lodashArrayCompact);
          var _lodashObjectAssign = require("lodash/object/assign");
          var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
          var _lodashCollectionEach = require("lodash/collection/each");
          var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
          var _lodashArrayUniq = require("lodash/array/uniq");
          var _lodashArrayUniq2 = _interopRequireDefault(_lodashArrayUniq);
          require("./definitions/init");
          var _definitions = require("./definitions");
          var t = exports;
          function registerType(type, skipAliasCheck) {
            var is = t["is" + type] = function(node, opts) {
              return t.is(type, node, opts, skipAliasCheck);
            };
            t["assert" + type] = function(node, opts) {
              opts = opts || {};
              if (!is(node, opts)) {
                throw new Error("Expected type " + JSON.stringify(type) + " with option " + JSON.stringify(opts));
              }
            };
          }
          var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
          exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
          var FLATTENABLE_KEYS = ["body", "expressions"];
          exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
          var FOR_INIT_KEYS = ["left", "init"];
          exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
          var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
          exports.COMMENT_KEYS = COMMENT_KEYS;
          var INHERIT_KEYS = {
            optional: ["typeAnnotation", "typeParameters", "returnType"],
            force: ["_scopeInfo", "_paths", "start", "loc", "end"]
          };
          exports.INHERIT_KEYS = INHERIT_KEYS;
          var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
          exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
          var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
          exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
          var COMPARISON_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS.concat(["in", "instanceof"]);
          exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
          var BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);
          exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
          var NUMBER_BINARY_OPERATORS = ["-", "/", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
          exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
          var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
          exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
          var NUMBER_UNARY_OPERATORS = ["+", "-", "++", "--", "~"];
          exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
          var STRING_UNARY_OPERATORS = ["typeof"];
          exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
          exports.VISITOR_KEYS = _definitions.VISITOR_KEYS;
          exports.BUILDER_KEYS = _definitions.BUILDER_KEYS;
          exports.ALIAS_KEYS = _definitions.ALIAS_KEYS;
          _lodashCollectionEach2["default"](t.VISITOR_KEYS, function(keys, type) {
            registerType(type, true);
          });
          t.FLIPPED_ALIAS_KEYS = {};
          _lodashCollectionEach2["default"](t.ALIAS_KEYS, function(aliases, type) {
            _lodashCollectionEach2["default"](aliases, function(alias) {
              var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];
              types.push(type);
            });
          });
          _lodashCollectionEach2["default"](t.FLIPPED_ALIAS_KEYS, function(types, type) {
            t[type.toUpperCase() + "_TYPES"] = types;
            registerType(type, false);
          });
          var TYPES = Object.keys(t.VISITOR_KEYS).concat(Object.keys(t.FLIPPED_ALIAS_KEYS));
          exports.TYPES = TYPES;
          function is(type, node, opts, skipAliasCheck) {
            if (!node)
              return false;
            var matches = isType(node.type, type);
            if (!matches)
              return false;
            if (typeof opts === "undefined") {
              return true;
            } else {
              return t.shallowEqual(node, opts);
            }
          }
          function isType(nodeType, targetType) {
            if (nodeType === targetType)
              return true;
            var aliases = t.FLIPPED_ALIAS_KEYS[targetType];
            if (aliases) {
              if (aliases[0] === nodeType)
                return true;
              var _arr = aliases;
              for (var _i = 0; _i < _arr.length; _i++) {
                var alias = _arr[_i];
                if (nodeType === alias)
                  return true;
              }
            }
            return false;
          }
          _lodashCollectionEach2["default"](t.VISITOR_KEYS, function(keys, type) {
            if (t.BUILDER_KEYS[type])
              return;
            var defs = {};
            _lodashCollectionEach2["default"](keys, function(key) {
              defs[key] = null;
            });
            t.BUILDER_KEYS[type] = defs;
          });
          _lodashCollectionEach2["default"](t.BUILDER_KEYS, function(keys, type) {
            var builder = function builder() {
              var node = {};
              node.type = type;
              var i = 0;
              for (var key in keys) {
                var arg = arguments[i++];
                if (arg === undefined)
                  arg = keys[key];
                node[key] = arg;
              }
              return node;
            };
            t[type] = builder;
            t[type[0].toLowerCase() + type.slice(1)] = builder;
          });
          function shallowEqual(actual, expected) {
            var keys = Object.keys(expected);
            var _arr2 = keys;
            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
              var key = _arr2[_i2];
              if (actual[key] !== expected[key]) {
                return false;
              }
            }
            return true;
          }
          function appendToMemberExpression(member, append, computed) {
            member.object = t.memberExpression(member.object, member.property, member.computed);
            member.property = append;
            member.computed = !!computed;
            return member;
          }
          function prependToMemberExpression(member, prepend) {
            member.object = t.memberExpression(prepend, member.object);
            return member;
          }
          function ensureBlock(node) {
            var key = arguments.length <= 1 || arguments[1] === undefined ? "body" : arguments[1];
            return node[key] = t.toBlock(node[key], node);
          }
          function clone(node) {
            var newNode = {};
            for (var key in node) {
              if (key[0] === "_")
                continue;
              newNode[key] = node[key];
            }
            return newNode;
          }
          function cloneDeep(node) {
            var newNode = {};
            for (var key in node) {
              if (key[0] === "_")
                continue;
              var val = node[key];
              if (val) {
                if (val.type) {
                  val = t.cloneDeep(val);
                } else if (Array.isArray(val)) {
                  val = val.map(t.cloneDeep);
                }
              }
              newNode[key] = val;
            }
            return newNode;
          }
          function buildMatchMemberExpression(match, allowPartial) {
            var parts = match.split(".");
            return function(member) {
              if (!t.isMemberExpression(member))
                return false;
              var search = [member];
              var i = 0;
              while (search.length) {
                var node = search.shift();
                if (allowPartial && i === parts.length) {
                  return true;
                }
                if (t.isIdentifier(node)) {
                  if (parts[i] !== node.name)
                    return false;
                } else if (t.isLiteral(node)) {
                  if (parts[i] !== node.value)
                    return false;
                } else if (t.isMemberExpression(node)) {
                  if (node.computed && !t.isLiteral(node.property)) {
                    return false;
                  } else {
                    search.push(node.object);
                    search.push(node.property);
                    continue;
                  }
                } else {
                  return false;
                }
                if (++i > parts.length) {
                  return false;
                }
              }
              return true;
            };
          }
          function removeComments(node) {
            var _arr3 = COMMENT_KEYS;
            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
              var key = _arr3[_i3];
              delete node[key];
            }
            return node;
          }
          function inheritsComments(child, parent) {
            inheritTrailingComments(child, parent);
            inheritLeadingComments(child, parent);
            inheritInnerComments(child, parent);
            return child;
          }
          function inheritTrailingComments(child, parent) {
            _inheritComments("trailingComments", child, parent);
          }
          function inheritLeadingComments(child, parent) {
            _inheritComments("leadingComments", child, parent);
          }
          function inheritInnerComments(child, parent) {
            _inheritComments("innerComments", child, parent);
          }
          function _inheritComments(key, child, parent) {
            if (child && parent) {
              child[key] = _lodashArrayUniq2["default"](_lodashArrayCompact2["default"]([].concat(child[key], parent[key])));
            }
          }
          function inherits(child, parent) {
            if (!child || !parent)
              return child;
            var _arr4 = t.INHERIT_KEYS.optional;
            for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
              var key = _arr4[_i4];
              if (child[key] == null) {
                child[key] = parent[key];
              }
            }
            var _arr5 = t.INHERIT_KEYS.force;
            for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
              var key = _arr5[_i5];
              child[key] = parent[key];
            }
            t.inheritsComments(child, parent);
            return child;
          }
          _toFastProperties2["default"](t);
          _toFastProperties2["default"](t.VISITOR_KEYS);
          _lodashObjectAssign2["default"](t, require("./retrievers"));
          _lodashObjectAssign2["default"](t, require("./validators"));
          _lodashObjectAssign2["default"](t, require("./converters"));
          _lodashObjectAssign2["default"](t, require("./flow"));
        }, {
          "./converters": 186,
          "./definitions": 191,
          "./definitions/init": 192,
          "./flow": 195,
          "./retrievers": 197,
          "./validators": 198,
          "lodash/array/compact": 422,
          "lodash/array/uniq": 426,
          "lodash/collection/each": 428,
          "lodash/object/assign": 526,
          "to-fast-properties": 619
        }],
        197: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.getBindingIdentifiers = getBindingIdentifiers;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _helpersObject = require("../helpers/object");
          var _helpersObject2 = _interopRequireDefault(_helpersObject);
          var _index = require("./index");
          var t = _interopRequireWildcard(_index);
          function getBindingIdentifiers(node, duplicates) {
            var search = [].concat(node);
            var ids = _helpersObject2["default"]();
            while (search.length) {
              var id = search.shift();
              if (!id)
                continue;
              var key = t.getBindingIdentifiers.keys[id.type];
              if (t.isIdentifier(id)) {
                if (duplicates) {
                  var _ids = ids[id.name] = ids[id.name] || [];
                  _ids.push(id);
                } else {
                  ids[id.name] = id;
                }
              } else if (t.isExportDeclaration(id)) {
                if (t.isDeclaration(node.declaration)) {
                  search.push(node.declaration);
                }
              } else if (key && id[key]) {
                search = search.concat(id[key]);
              }
            }
            return ids;
          }
          getBindingIdentifiers.keys = {
            DeclareClass: "id",
            DeclareFunction: "id",
            DeclareModule: "id",
            DeclareVariable: "id",
            InterfaceDeclaration: "id",
            TypeAlias: "id",
            ComprehensionExpression: "blocks",
            ComprehensionBlock: "left",
            CatchClause: "param",
            LabeledStatement: "label",
            UnaryExpression: "argument",
            AssignmentExpression: "left",
            ImportSpecifier: "local",
            ImportNamespaceSpecifier: "local",
            ImportDefaultSpecifier: "local",
            ImportDeclaration: "specifiers",
            FunctionDeclaration: "id",
            FunctionExpression: "id",
            ClassDeclaration: "id",
            ClassExpression: "id",
            RestElement: "argument",
            UpdateExpression: "argument",
            SpreadProperty: "argument",
            Property: "value",
            AssignmentPattern: "left",
            ArrayPattern: "elements",
            ObjectPattern: "properties",
            VariableDeclaration: "declarations",
            VariableDeclarator: "id"
          };
        }, {
          "../helpers/object": 58,
          "./index": 196
        }],
        198: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.isBinding = isBinding;
          exports.isReferenced = isReferenced;
          exports.isValidIdentifier = isValidIdentifier;
          exports.isLet = isLet;
          exports.isBlockScoped = isBlockScoped;
          exports.isVar = isVar;
          exports.isSpecifierDefault = isSpecifierDefault;
          exports.isScope = isScope;
          exports.isImmutable = isImmutable;
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj["default"] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _retrievers = require("./retrievers");
          var _esutils = require("esutils");
          var _esutils2 = _interopRequireDefault(_esutils);
          var _index = require("./index");
          var t = _interopRequireWildcard(_index);
          function isBinding(node, parent) {
            var bindingKey = _retrievers.getBindingIdentifiers.keys[parent.type];
            if (bindingKey) {
              return parent[bindingKey] === node;
            } else {
              return false;
            }
          }
          function isReferenced(node, parent) {
            switch (parent.type) {
              case "MemberExpression":
              case "JSXMemberExpression":
                if (parent.property === node && parent.computed) {
                  return true;
                } else if (parent.object === node) {
                  return true;
                } else {
                  return false;
                }
              case "MetaProperty":
                return false;
              case "Property":
                if (parent.key === node) {
                  return parent.computed;
                }
              case "VariableDeclarator":
                return parent.id !== node;
              case "ArrowFunctionExpression":
              case "FunctionDeclaration":
              case "FunctionExpression":
                var _arr = parent.params;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var param = _arr[_i];
                  if (param === node)
                    return false;
                }
                return parent.id !== node;
              case "ExportSpecifier":
                if (parent.source) {
                  return false;
                } else {
                  return parent.local === node;
                }
              case "JSXAttribute":
                return parent.name !== node;
              case "ClassProperty":
                return parent.value === node;
              case "ImportDefaultSpecifier":
              case "ImportNamespaceSpecifier":
              case "ImportSpecifier":
                return false;
              case "ClassDeclaration":
              case "ClassExpression":
                return parent.id !== node;
              case "MethodDefinition":
                return parent.key === node && parent.computed;
              case "LabeledStatement":
                return false;
              case "CatchClause":
                return parent.param !== node;
              case "RestElement":
                return false;
              case "AssignmentExpression":
                return parent.right === node;
              case "AssignmentPattern":
                return parent.right === node;
              case "ObjectPattern":
              case "ArrayPattern":
                return false;
            }
            return true;
          }
          function isValidIdentifier(name) {
            if (typeof name !== "string" || _esutils2["default"].keyword.isReservedWordES6(name, true)) {
              return false;
            } else {
              return _esutils2["default"].keyword.isIdentifierNameES6(name);
            }
          }
          function isLet(node) {
            return t.isVariableDeclaration(node) && (node.kind !== "var" || node._let);
          }
          function isBlockScoped(node) {
            return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);
          }
          function isVar(node) {
            return t.isVariableDeclaration(node, {kind: "var"}) && !node._let;
          }
          function isSpecifierDefault(specifier) {
            return t.isImportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, {name: "default"});
          }
          function isScope(node, parent) {
            if (t.isBlockStatement(node) && t.isFunction(parent, {body: node})) {
              return false;
            }
            return t.isScopable(node);
          }
          function isImmutable(node) {
            if (t.isType(node.type, "Immutable"))
              return true;
            if (t.isLiteral(node)) {
              if (node.regex) {
                return false;
              } else {
                return true;
              }
            } else if (t.isIdentifier(node)) {
              if (node.name === "undefined") {
                return true;
              } else {
                return false;
              }
            }
            return false;
          }
        }, {
          "./index": 196,
          "./retrievers": 197,
          "esutils": 412
        }],
        199: [function(require, module, exports) {
          (function(__dirname) {
            "use strict";
            exports.__esModule = true;
            exports.canCompile = canCompile;
            exports.list = list;
            exports.regexify = regexify;
            exports.arrayify = arrayify;
            exports.booleanify = booleanify;
            exports.shouldIgnore = shouldIgnore;
            exports.template = template;
            exports.parseTemplate = parseTemplate;
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj;
              } else {
                var newObj = {};
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                      newObj[key] = obj[key];
                  }
                }
                newObj["default"] = obj;
                return newObj;
              }
            }
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {"default": obj};
            }
            var _lodashStringEscapeRegExp = require("lodash/string/escapeRegExp");
            var _lodashStringEscapeRegExp2 = _interopRequireDefault(_lodashStringEscapeRegExp);
            var _lodashStringStartsWith = require("lodash/string/startsWith");
            var _lodashStringStartsWith2 = _interopRequireDefault(_lodashStringStartsWith);
            var _lodashLangCloneDeep = require("lodash/lang/cloneDeep");
            var _lodashLangCloneDeep2 = _interopRequireDefault(_lodashLangCloneDeep);
            var _lodashLangIsBoolean = require("lodash/lang/isBoolean");
            var _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);
            var _messages = require("./messages");
            var messages = _interopRequireWildcard(_messages);
            var _minimatch = require("minimatch");
            var _minimatch2 = _interopRequireDefault(_minimatch);
            var _lodashCollectionContains = require("lodash/collection/contains");
            var _lodashCollectionContains2 = _interopRequireDefault(_lodashCollectionContains);
            var _traversal = require("./traversal");
            var _traversal2 = _interopRequireDefault(_traversal);
            var _lodashLangIsString = require("lodash/lang/isString");
            var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
            var _lodashLangIsRegExp = require("lodash/lang/isRegExp");
            var _lodashLangIsRegExp2 = _interopRequireDefault(_lodashLangIsRegExp);
            var _lodashLangIsEmpty = require("lodash/lang/isEmpty");
            var _lodashLangIsEmpty2 = _interopRequireDefault(_lodashLangIsEmpty);
            var _helpersParse = require("./helpers/parse");
            var _helpersParse2 = _interopRequireDefault(_helpersParse);
            var _path = require("path");
            var _path2 = _interopRequireDefault(_path);
            var _lodashObjectHas = require("lodash/object/has");
            var _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);
            var _fs = require("fs");
            var _fs2 = _interopRequireDefault(_fs);
            var _types = require("./types");
            var t = _interopRequireWildcard(_types);
            var _slash = require("slash");
            var _slash2 = _interopRequireDefault(_slash);
            var _pathExists = require("path-exists");
            var _pathExists2 = _interopRequireDefault(_pathExists);
            var _util = require("util");
            exports.inherits = _util.inherits;
            exports.inspect = _util.inspect;
            function canCompile(filename, altExts) {
              var exts = altExts || canCompile.EXTENSIONS;
              var ext = _path2["default"].extname(filename);
              return _lodashCollectionContains2["default"](exts, ext);
            }
            canCompile.EXTENSIONS = [".js", ".jsx", ".es6", ".es"];
            function list(val) {
              if (!val) {
                return [];
              } else if (Array.isArray(val)) {
                return val;
              } else if (typeof val === "string") {
                return val.split(",");
              } else {
                return [val];
              }
            }
            function regexify(val) {
              if (!val)
                return new RegExp(/.^/);
              if (Array.isArray(val))
                val = new RegExp(val.map(_lodashStringEscapeRegExp2["default"]).join("|"), "i");
              if (_lodashLangIsString2["default"](val)) {
                val = _slash2["default"](val);
                if (_lodashStringStartsWith2["default"](val, "./") || _lodashStringStartsWith2["default"](val, "*/"))
                  val = val.slice(2);
                if (_lodashStringStartsWith2["default"](val, "**/"))
                  val = val.slice(3);
                var regex = _minimatch2["default"].makeRe(val, {nocase: true});
                return new RegExp(regex.source.slice(1, -1), "i");
              }
              if (_lodashLangIsRegExp2["default"](val))
                return val;
              throw new TypeError("illegal type for regexify");
            }
            function arrayify(val, mapFn) {
              if (!val)
                return [];
              if (_lodashLangIsBoolean2["default"](val))
                return arrayify([val], mapFn);
              if (_lodashLangIsString2["default"](val))
                return arrayify(list(val), mapFn);
              if (Array.isArray(val)) {
                if (mapFn)
                  val = val.map(mapFn);
                return val;
              }
              return [val];
            }
            function booleanify(val) {
              if (val === "true")
                return true;
              if (val === "false")
                return false;
              return val;
            }
            function shouldIgnore(filename, ignore, only) {
              filename = _slash2["default"](filename);
              if (only) {
                var _arr = only;
                for (var _i = 0; _i < _arr.length; _i++) {
                  var pattern = _arr[_i];
                  if (_shouldIgnore(pattern, filename))
                    return false;
                }
                return true;
              } else if (ignore.length) {
                var _arr2 = ignore;
                for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                  var pattern = _arr2[_i2];
                  if (_shouldIgnore(pattern, filename))
                    return true;
                }
              }
              return false;
            }
            function _shouldIgnore(pattern, filename) {
              if (typeof pattern === "function") {
                return pattern(filename);
              } else {
                return pattern.test(filename);
              }
            }
            var templateVisitor = {
              noScope: true,
              enter: function enter(node, parent, scope, nodes) {
                if (t.isExpressionStatement(node)) {
                  node = node.expression;
                }
                if (t.isIdentifier(node) && _lodashObjectHas2["default"](nodes, node.name)) {
                  this.skip();
                  this.replaceInline(nodes[node.name]);
                }
              },
              exit: function exit(node) {
                _traversal2["default"].clearNode(node);
              }
            };
            function template(name, nodes, keepExpression) {
              var ast = exports.templates[name];
              if (!ast)
                throw new ReferenceError("unknown template " + name);
              if (nodes === true) {
                keepExpression = true;
                nodes = null;
              }
              ast = _lodashLangCloneDeep2["default"](ast);
              if (!_lodashLangIsEmpty2["default"](nodes)) {
                _traversal2["default"](ast, templateVisitor, null, nodes);
              }
              if (ast.body.length > 1)
                return ast.body;
              var node = ast.body[0];
              if (!keepExpression && t.isExpressionStatement(node)) {
                return node.expression;
              } else {
                return node;
              }
            }
            function parseTemplate(loc, code) {
              var ast = _helpersParse2["default"](code, {
                filename: loc,
                looseModules: true
              }).program;
              ast = _traversal2["default"].removeProperties(ast);
              return ast;
            }
            function loadTemplates() {
              var templates = {};
              var templatesLoc = _path2["default"].join(__dirname, "transformation/templates");
              if (!_pathExists2["default"].sync(templatesLoc)) {
                throw new ReferenceError(messages.get("missingTemplatesDirectory"));
              }
              var _arr3 = _fs2["default"].readdirSync(templatesLoc);
              for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                var name = _arr3[_i3];
                if (name[0] === ".")
                  return;
                var key = _path2["default"].basename(name, _path2["default"].extname(name));
                var loc = _path2["default"].join(templatesLoc, name);
                var code = _fs2["default"].readFileSync(loc, "utf8");
                templates[key] = parseTemplate(loc, code);
              }
              return templates;
            }
            try {
              exports.templates = require("../templates.json");
            } catch (err) {
              if (err.code !== "MODULE_NOT_FOUND")
                throw err;
              exports.templates = loadTemplates();
            }
          }).call(this, "/lib");
        }, {
          "../templates.json": 623,
          "./helpers/parse": 59,
          "./messages": 60,
          "./traversal": 165,
          "./types": 196,
          "fs": 1,
          "lodash/collection/contains": 427,
          "lodash/lang/cloneDeep": 512,
          "lodash/lang/isBoolean": 515,
          "lodash/lang/isEmpty": 516,
          "lodash/lang/isRegExp": 522,
          "lodash/lang/isString": 523,
          "lodash/object/has": 529,
          "lodash/string/escapeRegExp": 535,
          "lodash/string/startsWith": 536,
          "minimatch": 539,
          "path": 11,
          "path-exists": 543,
          "slash": 606,
          "util": 30
        }],
        200: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            return new Plugin("constant-folding", {
              metadata: {
                group: "builtin-prepass",
                experimental: true
              },
              visitor: {
                AssignmentExpression: function AssignmentExpression() {
                  var left = this.get("left");
                  if (!left.isIdentifier())
                    return;
                  var binding = this.scope.getBinding(left.node.name);
                  if (!binding || binding.hasDeoptValue)
                    return;
                  var evaluated = this.get("right").evaluate();
                  if (evaluated.confident) {
                    binding.setValue(evaluated.value);
                  } else {
                    binding.deoptValue();
                  }
                },
                IfStatement: function IfStatement() {
                  var evaluated = this.get("test").evaluate();
                  if (!evaluated.confident) {
                    return this.skip();
                  }
                  if (evaluated.value) {
                    this.skipKey("alternate");
                  } else {
                    this.skipKey("consequent");
                  }
                },
                Scopable: {
                  enter: function enter() {
                    var funcScope = this.scope.getFunctionParent();
                    for (var name in this.scope.bindings) {
                      var binding = this.scope.bindings[name];
                      var deopt = false;
                      var _iteratorNormalCompletion = true;
                      var _didIteratorError = false;
                      var _iteratorError = undefined;
                      try {
                        for (var _iterator = binding.constantViolations[Symbol.iterator](),
                            _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                          var path = _step.value;
                          var funcViolationScope = path.scope.getFunctionParent();
                          if (funcViolationScope !== funcScope) {
                            deopt = true;
                            break;
                          }
                        }
                      } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                          }
                        } finally {
                          if (_didIteratorError) {
                            throw _iteratorError;
                          }
                        }
                      }
                      if (deopt)
                        binding.deoptValue();
                    }
                  },
                  exit: function exit() {
                    for (var name in this.scope.bindings) {
                      var binding = this.scope.bindings[name];
                      binding.clearValue();
                    }
                  }
                },
                Expression: {exit: function exit() {
                    var res = this.evaluate();
                    if (res.confident)
                      return t.valueToNode(res.value);
                  }}
              }
            });
          };
          module.exports = exports["default"];
        }, {}],
        201: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            function toStatements(node) {
              if (t.isBlockStatement(node)) {
                var hasBlockScoped = false;
                for (var i = 0; i < node.body.length; i++) {
                  var bodyNode = node.body[i];
                  if (t.isBlockScoped(bodyNode))
                    hasBlockScoped = true;
                }
                if (!hasBlockScoped) {
                  return node.body;
                }
              }
              return node;
            }
            var visitor = {
              ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope) {
                var binding = scope.getBinding(node.name);
                if (!binding || binding.references > 1 || !binding.constant)
                  return;
                if (binding.kind === "param" || binding.kind === "module")
                  return;
                var replacement = binding.path.node;
                if (t.isVariableDeclarator(replacement)) {
                  replacement = replacement.init;
                }
                if (!replacement)
                  return;
                if (!scope.isPure(replacement, true))
                  return;
                if (t.isClass(replacement) || t.isFunction(replacement)) {
                  if (binding.path.scope.parent !== scope)
                    return;
                }
                if (this.findParent(function(path) {
                  return path.node === replacement;
                })) {
                  return;
                }
                t.toExpression(replacement);
                scope.removeBinding(node.name);
                binding.path.dangerouslyRemove();
                return replacement;
              },
              "ClassDeclaration|FunctionDeclaration": function ClassDeclarationFunctionDeclaration(node, parent, scope) {
                var binding = scope.getBinding(node.id.name);
                if (binding && !binding.referenced) {
                  this.dangerouslyRemove();
                }
              },
              VariableDeclarator: function VariableDeclarator(node, parent, scope) {
                if (!t.isIdentifier(node.id) || !scope.isPure(node.init, true))
                  return;
                visitor["ClassDeclaration|FunctionDeclaration"].apply(this, arguments);
              },
              ConditionalExpression: function ConditionalExpression(node) {
                var evaluateTest = this.get("test").evaluateTruthy();
                if (evaluateTest === true) {
                  return node.consequent;
                } else if (evaluateTest === false) {
                  return node.alternate;
                }
              },
              BlockStatement: function BlockStatement() {
                var paths = this.get("body");
                var purge = false;
                for (var i = 0; i < paths.length; i++) {
                  var path = paths[i];
                  if (!purge && path.isCompletionStatement()) {
                    purge = true;
                    continue;
                  }
                  if (purge && !path.isFunctionDeclaration()) {
                    path.dangerouslyRemove();
                  }
                }
              },
              IfStatement: {exit: function exit(node) {
                  var consequent = node.consequent;
                  var alternate = node.alternate;
                  var test = node.test;
                  var evaluateTest = this.get("test").evaluateTruthy();
                  if (evaluateTest === true) {
                    return toStatements(consequent);
                  }
                  if (evaluateTest === false) {
                    if (alternate) {
                      return toStatements(alternate);
                    } else {
                      return this.dangerouslyRemove();
                    }
                  }
                  if (t.isBlockStatement(alternate) && !alternate.body.length) {
                    alternate = node.alternate = null;
                  }
                  if (t.isBlockStatement(consequent) && !consequent.body.length && t.isBlockStatement(alternate) && alternate.body.length) {
                    node.consequent = node.alternate;
                    node.alternate = null;
                    node.test = t.unaryExpression("!", test, true);
                  }
                }}
            };
            return new Plugin("dead-code-elimination", {
              metadata: {
                group: "builtin-pre",
                experimental: true
              },
              visitor: visitor
            });
          };
          module.exports = exports["default"];
        }, {}],
        202: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var parse = _ref.parse;
            var traverse = _ref.traverse;
            return new Plugin("eval", {
              metadata: {group: "builtin-pre"},
              visitor: {CallExpression: function CallExpression(node) {
                  if (this.get("callee").isIdentifier({name: "eval"}) && node.arguments.length === 1) {
                    var evaluate = this.get("arguments")[0].evaluate();
                    if (!evaluate.confident)
                      return;
                    var code = evaluate.value;
                    if (typeof code !== "string")
                      return;
                    var ast = parse(code);
                    traverse.removeProperties(ast);
                    return ast.program;
                  }
                }}
            });
          };
          module.exports = exports["default"];
        }, {}],
        203: [function(require, module, exports) {
          (function(process) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            exports["default"] = function(_ref) {
              var Plugin = _ref.Plugin;
              var t = _ref.types;
              return new Plugin("inline-environment-variables", {
                metadata: {group: "builtin-pre"},
                visitor: {MemberExpression: function MemberExpression(node) {
                    if (this.get("object").matchesPattern("process.env")) {
                      var key = this.toComputedKey();
                      if (t.isLiteral(key)) {
                        return t.valueToNode(process.env[key.value]);
                      }
                    }
                  }}
              });
            };
            module.exports = exports["default"];
          }).call(this, require('_process'));
        }, {"_process": 12}],
        204: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            return new Plugin("jscript", {
              metadata: {group: "builtin-trailing"},
              visitor: {FunctionExpression: {exit: function exit(node) {
                    if (!node.id)
                      return;
                    node._ignoreUserWhitespace = true;
                    return t.callExpression(t.functionExpression(null, [], t.blockStatement([t.toStatement(node), t.returnStatement(node.id)])), []);
                  }}}
            });
          };
          module.exports = exports["default"];
        }, {}],
        205: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            return new Plugin("member-expression-literals", {
              metadata: {group: "builtin-trailing"},
              visitor: {MemberExpression: {exit: function exit(node) {
                    var prop = node.property;
                    if (node.computed && t.isLiteral(prop) && t.isValidIdentifier(prop.value)) {
                      node.property = t.identifier(prop.value);
                      node.computed = false;
                    }
                  }}}
            });
          };
          module.exports = exports["default"];
        }, {}],
        206: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            return new Plugin("property-literals", {
              metadata: {group: "builtin-trailing"},
              visitor: {Property: {exit: function exit(node) {
                    var key = node.key;
                    if (t.isLiteral(key) && t.isValidIdentifier(key.value)) {
                      node.key = t.identifier(key.value);
                      node.computed = false;
                    }
                  }}}
            });
          };
          module.exports = exports["default"];
        }, {}],
        207: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _lodashArrayPull = require("lodash/array/pull");
          var _lodashArrayPull2 = _interopRequireDefault(_lodashArrayPull);
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            function isProtoKey(node) {
              return t.isLiteral(t.toComputedKey(node, node.key), {value: "__proto__"});
            }
            function isProtoAssignmentExpression(node) {
              var left = node.left;
              return t.isMemberExpression(left) && t.isLiteral(t.toComputedKey(left, left.property), {value: "__proto__"});
            }
            function buildDefaultsCallExpression(expr, ref, file) {
              return t.expressionStatement(t.callExpression(file.addHelper("defaults"), [ref, expr.right]));
            }
            return new Plugin("proto-to-assign", {
              metadata: {secondPass: true},
              visitor: {
                AssignmentExpression: function AssignmentExpression(node, parent, scope, file) {
                  if (!isProtoAssignmentExpression(node))
                    return;
                  var nodes = [];
                  var left = node.left.object;
                  var temp = scope.maybeGenerateMemoised(left);
                  if (temp)
                    nodes.push(t.expressionStatement(t.assignmentExpression("=", temp, left)));
                  nodes.push(buildDefaultsCallExpression(node, temp || left, file));
                  if (temp)
                    nodes.push(temp);
                  return nodes;
                },
                ExpressionStatement: function ExpressionStatement(node, parent, scope, file) {
                  var expr = node.expression;
                  if (!t.isAssignmentExpression(expr, {operator: "="}))
                    return;
                  if (isProtoAssignmentExpression(expr)) {
                    return buildDefaultsCallExpression(expr, expr.left.object, file);
                  }
                },
                ObjectExpression: function ObjectExpression(node, parent, scope, file) {
                  var proto;
                  for (var i = 0; i < node.properties.length; i++) {
                    var prop = node.properties[i];
                    if (isProtoKey(prop)) {
                      proto = prop.value;
                      (0, _lodashArrayPull2["default"])(node.properties, prop);
                    }
                  }
                  if (proto) {
                    var args = [t.objectExpression([]), proto];
                    if (node.properties.length)
                      args.push(node);
                    return t.callExpression(file.addHelper("extends"), args);
                  }
                }
              }
            });
          };
          module.exports = exports["default"];
        }, {"lodash/array/pull": 425}],
        208: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var immutabilityVisitor = {enter: function enter(node, parent, scope, state) {
                var _this = this;
                var stop = function stop() {
                  state.isImmutable = false;
                  _this.stop();
                };
                if (this.isJSXClosingElement()) {
                  this.skip();
                  return;
                }
                if (this.isJSXIdentifier({name: "ref"}) && this.parentPath.isJSXAttribute({name: node})) {
                  return stop();
                }
                if (this.isJSXIdentifier() || this.isIdentifier() || this.isJSXMemberExpression()) {
                  return;
                }
                if (!this.isImmutable())
                  stop();
              }};
            return new Plugin("react-constant-elements", {
              metadata: {group: "builtin-basic"},
              visitor: {JSXElement: function JSXElement(node) {
                  if (node._hoisted)
                    return;
                  var state = {isImmutable: true};
                  this.traverse(immutabilityVisitor, state);
                  if (state.isImmutable) {
                    this.hoist();
                  } else {
                    node._hoisted = true;
                  }
                }}
            });
          };
          module.exports = exports["default"];
        }, {}],
        209: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            function addDisplayName(id, call) {
              var props = call.arguments[0].properties;
              var safe = true;
              for (var i = 0; i < props.length; i++) {
                var prop = props[i];
                var key = t.toComputedKey(prop);
                if (t.isLiteral(key, {value: "displayName"})) {
                  safe = false;
                  break;
                }
              }
              if (safe) {
                props.unshift(t.property("init", t.identifier("displayName"), t.literal(id)));
              }
            }
            var isCreateClassCallExpression = t.buildMatchMemberExpression("React.createClass");
            function isCreateClass(node) {
              if (!node || !t.isCallExpression(node))
                return false;
              if (!isCreateClassCallExpression(node.callee))
                return false;
              var args = node.arguments;
              if (args.length !== 1)
                return false;
              var first = args[0];
              if (!t.isObjectExpression(first))
                return false;
              return true;
            }
            return new Plugin("react-display-name", {
              metadata: {group: "builtin-pre"},
              visitor: {
                ExportDefaultDeclaration: function ExportDefaultDeclaration(node, parent, scope, file) {
                  if (isCreateClass(node.declaration)) {
                    addDisplayName(file.opts.basename, node.declaration);
                  }
                },
                "AssignmentExpression|Property|VariableDeclarator": function AssignmentExpressionPropertyVariableDeclarator(node) {
                  var left,
                      right;
                  if (t.isAssignmentExpression(node)) {
                    left = node.left;
                    right = node.right;
                  } else if (t.isProperty(node)) {
                    left = node.key;
                    right = node.value;
                  } else if (t.isVariableDeclarator(node)) {
                    left = node.id;
                    right = node.init;
                  }
                  if (t.isMemberExpression(left)) {
                    left = left.property;
                  }
                  if (t.isIdentifier(left) && isCreateClass(right)) {
                    addDisplayName(left.name, right);
                  }
                }
              }
            });
          };
          module.exports = exports["default"];
        }, {}],
        210: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            return new Plugin("remove-console", {
              metadata: {group: "builtin-pre"},
              visitor: {CallExpression: function CallExpression() {
                  if (this.get("callee").matchesPattern("console", true)) {
                    this.dangerouslyRemove();
                  }
                }}
            });
          };
          module.exports = exports["default"];
        }, {}],
        211: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            return new Plugin("remove-debugger", {
              metadata: {group: "builtin-pre"},
              visitor: {DebuggerStatement: function DebuggerStatement() {
                  this.dangerouslyRemove();
                }}
            });
          };
          module.exports = exports["default"];
        }, {}],
        212: [function(require, module, exports) {
          module.exports = {
            "builtins": {
              "Symbol": "symbol",
              "Promise": "promise",
              "Map": "map",
              "WeakMap": "weak-map",
              "Set": "set",
              "WeakSet": "weak-set"
            },
            "methods": {
              "Array": {
                "concat": "array/concat",
                "copyWithin": "array/copy-within",
                "entries": "array/entries",
                "every": "array/every",
                "fill": "array/fill",
                "filter": "array/filter",
                "findIndex": "array/find-index",
                "find": "array/find",
                "forEach": "array/for-each",
                "from": "array/from",
                "includes": "array/includes",
                "indexOf": "array/index-of",
                "join": "array/join",
                "keys": "array/keys",
                "lastIndexOf": "array/last-index-of",
                "map": "array/map",
                "of": "array/of",
                "pop": "array/pop",
                "push": "array/push",
                "reduceRight": "array/reduce-right",
                "reduce": "array/reduce",
                "reverse": "array/reverse",
                "shift": "array/shift",
                "slice": "array/slice",
                "some": "array/some",
                "sort": "array/sort",
                "splice": "array/splice",
                "turn": "array/turn",
                "unshift": "array/unshift",
                "values": "array/values"
              },
              "Object": {
                "assign": "object/assign",
                "classof": "object/classof",
                "create": "object/create",
                "define": "object/define",
                "defineProperties": "object/define-properties",
                "defineProperty": "object/define-property",
                "entries": "object/entries",
                "freeze": "object/freeze",
                "getOwnPropertyDescriptor": "object/get-own-property-descriptor",
                "getOwnPropertyDescriptors": "object/get-own-property-descriptors",
                "getOwnPropertyNames": "object/get-own-property-names",
                "getOwnPropertySymbols": "object/get-own-property-symbols",
                "getPrototypePf": "object/get-prototype-of",
                "index": "object/index",
                "isExtensible": "object/is-extensible",
                "isFrozen": "object/is-frozen",
                "isObject": "object/is-object",
                "isSealed": "object/is-sealed",
                "is": "object/is",
                "keys": "object/keys",
                "make": "object/make",
                "preventExtensions": "object/prevent-extensions",
                "seal": "object/seal",
                "setPrototypeOf": "object/set-prototype-of",
                "values": "object/values"
              },
              "RegExp": {"escape": "regexp/escape"},
              "Function": {
                "only": "function/only",
                "part": "function/part"
              },
              "Math": {
                "acosh": "math/acosh",
                "asinh": "math/asinh",
                "atanh": "math/atanh",
                "cbrt": "math/cbrt",
                "clz32": "math/clz32",
                "cosh": "math/cosh",
                "expm1": "math/expm1",
                "fround": "math/fround",
                "hypot": "math/hypot",
                "pot": "math/pot",
                "imul": "math/imul",
                "log10": "math/log10",
                "log1p": "math/log1p",
                "log2": "math/log2",
                "sign": "math/sign",
                "sinh": "math/sinh",
                "tanh": "math/tanh",
                "trunc": "math/trunc"
              },
              "Date": {
                "addLocale": "date/add-locale",
                "formatUTC": "date/format-utc",
                "format": "date/format"
              },
              "Symbol": {
                "for": "symbol/for",
                "hasInstance": "symbol/has-instance",
                "is-concat-spreadable": "symbol/is-concat-spreadable",
                "iterator": "symbol/iterator",
                "keyFor": "symbol/key-for",
                "match": "symbol/match",
                "replace": "symbol/replace",
                "search": "symbol/search",
                "species": "symbol/species",
                "split": "symbol/split",
                "toPrimitive": "symbol/to-primitive",
                "toStringTag": "symbol/to-string-tag",
                "unscopables": "symbol/unscopables"
              },
              "String": {
                "at": "string/at",
                "codePointAt": "string/code-point-at",
                "endsWith": "string/ends-with",
                "escapeHTML": "string/escape-html",
                "fromCodePoint": "string/from-code-point",
                "includes": "string/includes",
                "raw": "string/raw",
                "repeat": "string/repeat",
                "startsWith": "string/starts-with",
                "unescapeHTML": "string/unescape-html"
              },
              "Number": {
                "EPSILON": "number/epsilon",
                "isFinite": "number/is-finite",
                "isInteger": "number/is-integer",
                "isNaN": "number/is-nan",
                "isSafeInteger": "number/is-safe-integer",
                "MAX_SAFE_INTEGER": "number/max-safe-integer",
                "MIN_SAFE_INTEGER": "number/min-safe-integer",
                "parseFloat": "number/parse-float",
                "parseInt": "number/parse-int",
                "random": "number/random"
              },
              "Reflect": {
                "apply": "reflect/apply",
                "construct": "reflect/construct",
                "defineProperty": "reflect/define-property",
                "deleteProperty": "reflect/delete-property",
                "enumerate": "reflect/enumerate",
                "getOwnPropertyDescriptor": "reflect/get-own-property-descriptor",
                "getPrototypeOf": "reflect/get-prototype-of",
                "get": "reflect/get",
                "has": "reflect/has",
                "isExtensible": "reflect/is-extensible",
                "ownKeys": "reflect/own-keys",
                "preventExtensions": "reflect/prevent-extensions",
                "setPrototypeOf": "reflect/set-prototype-of",
                "set": "reflect/set"
              }
            }
          };
        }, {}],
        213: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _definitions = require("./definitions");
          var _definitions2 = _interopRequireDefault(_definitions);
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            var RUNTIME_MODULE_NAME = "babel-runtime";
            function has(obj, key) {
              return Object.prototype.hasOwnProperty.call(obj, key);
            }
            return new Plugin("runtime", {
              metadata: {group: "builtin-post-modules"},
              pre: function pre(file) {
                file.set("helperGenerator", function(name) {
                  return file.addImport(RUNTIME_MODULE_NAME + "/helpers/" + name, name, "absoluteDefault");
                });
                file.setDynamic("regeneratorIdentifier", function() {
                  return file.addImport(RUNTIME_MODULE_NAME + "/regenerator", "regeneratorRuntime", "absoluteDefault");
                });
              },
              visitor: {
                ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, file) {
                  if (node.name === "regeneratorRuntime") {
                    return file.get("regeneratorIdentifier");
                  }
                  if (t.isMemberExpression(parent))
                    return;
                  if (!has(_definitions2["default"].builtins, node.name))
                    return;
                  if (scope.getBindingIdentifier(node.name))
                    return;
                  var modulePath = _definitions2["default"].builtins[node.name];
                  return file.addImport(RUNTIME_MODULE_NAME + "/core-js/" + modulePath, node.name, "absoluteDefault");
                },
                CallExpression: function CallExpression(node, parent, scope, file) {
                  if (node.arguments.length)
                    return;
                  var callee = node.callee;
                  if (!t.isMemberExpression(callee))
                    return;
                  if (!callee.computed)
                    return;
                  if (!this.get("callee.property").matchesPattern("Symbol.iterator"))
                    return;
                  return t.callExpression(file.addImport(RUNTIME_MODULE_NAME + "/core-js/get-iterator", "getIterator", "absoluteDefault"), [callee.object]);
                },
                BinaryExpression: function BinaryExpression(node, parent, scope, file) {
                  if (node.operator !== "in")
                    return;
                  if (!this.get("left").matchesPattern("Symbol.iterator"))
                    return;
                  return t.callExpression(file.addImport(RUNTIME_MODULE_NAME + "/core-js/is-iterable", "isIterable", "absoluteDefault"), [node.right]);
                },
                MemberExpression: {
                  enter: function enter(node, parent, scope, file) {
                    if (!this.isReferenced())
                      return;
                    var obj = node.object;
                    var prop = node.property;
                    if (!t.isReferenced(obj, node))
                      return;
                    if (node.computed)
                      return;
                    if (!has(_definitions2["default"].methods, obj.name))
                      return;
                    var methods = _definitions2["default"].methods[obj.name];
                    if (!has(methods, prop.name))
                      return;
                    if (scope.getBindingIdentifier(obj.name))
                      return;
                    if (obj.name === "Object" && prop.name === "defineProperty" && this.parentPath.isCallExpression()) {
                      var call = this.parentPath.node;
                      if (call.arguments.length === 3 && t.isLiteral(call.arguments[1]))
                        return;
                    }
                    var modulePath = methods[prop.name];
                    return file.addImport(RUNTIME_MODULE_NAME + "/core-js/" + modulePath, obj.name + "$" + prop.name, "absoluteDefault");
                  },
                  exit: function exit(node, parent, scope, file) {
                    if (!this.isReferenced())
                      return;
                    var prop = node.property;
                    var obj = node.object;
                    if (!has(_definitions2["default"].builtins, obj.name))
                      return;
                    if (scope.getBindingIdentifier(obj.name))
                      return;
                    var modulePath = _definitions2["default"].builtins[obj.name];
                    return t.memberExpression(file.addImport(RUNTIME_MODULE_NAME + "/core-js/" + modulePath, "" + obj.name, "absoluteDefault"), prop);
                  }
                }
              }
            });
          };
          module.exports = exports["default"];
        }, {"./definitions": 212}],
        214: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _leven = require("leven");
          var _leven2 = _interopRequireDefault(_leven);
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            var messages = _ref.messages;
            return new Plugin("undeclared-variables-check", {
              metadata: {group: "builtin-pre"},
              visitor: {ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope) {
                  var binding = scope.getBinding(node.name);
                  if (binding && binding.kind === "type" && !this.parentPath.isFlow()) {
                    throw this.errorWithNode(messages.get("undeclaredVariableType", node.name), ReferenceError);
                  }
                  if (scope.hasBinding(node.name))
                    return;
                  var bindings = scope.getAllBindings();
                  var closest;
                  var shortest = -1;
                  for (var name in bindings) {
                    var distance = (0, _leven2["default"])(node.name, name);
                    if (distance <= 0 || distance > 3)
                      continue;
                    if (distance <= shortest)
                      continue;
                    closest = name;
                    shortest = distance;
                  }
                  var msg;
                  if (closest) {
                    msg = messages.get("undeclaredVariableSuggestion", node.name, closest);
                  } else {
                    msg = messages.get("undeclaredVariable", node.name);
                  }
                  throw this.errorWithNode(msg, ReferenceError);
                }}
            });
          };
          module.exports = exports["default"];
        }, {"leven": 215}],
        215: [function(require, module, exports) {
          'use strict';
          var arr = [];
          var charCodeCache = [];
          module.exports = function(a, b) {
            if (a === b) {
              return 0;
            }
            var aLen = a.length;
            var bLen = b.length;
            if (aLen === 0) {
              return bLen;
            }
            if (bLen === 0) {
              return aLen;
            }
            var bCharCode;
            var ret;
            var tmp;
            var tmp2;
            var i = 0;
            var j = 0;
            while (i < aLen) {
              charCodeCache[i] = a.charCodeAt(i);
              arr[i] = ++i;
            }
            while (j < bLen) {
              bCharCode = b.charCodeAt(j);
              tmp = j++;
              ret = j;
              for (i = 0; i < aLen; i++) {
                tmp2 = bCharCode === charCodeCache[i] ? tmp : tmp + 1;
                tmp = arr[i];
                ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;
              }
            }
            return ret;
          };
        }, {}],
        216: [function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", {value: true});
          exports["default"] = function(_ref) {
            var Plugin = _ref.Plugin;
            var t = _ref.types;
            return new Plugin("undefined-to-void", {
              metadata: {group: "builtin-basic"},
              visitor: {ReferencedIdentifier: function ReferencedIdentifier(node, parent) {
                  if (node.name === "undefined") {
                    return t.unaryExpression("void", t.literal(0), true);
                  }
                }}
            });
          };
          module.exports = exports["default"];
        }, {}],
        217: [function(require, module, exports) {
          (function(process) {
            'use strict';
            var escapeStringRegexp = require('escape-string-regexp');
            var ansiStyles = require('ansi-styles');
            var stripAnsi = require('strip-ansi');
            var hasAnsi = require('has-ansi');
            var supportsColor = require('supports-color');
            var defineProps = Object.defineProperties;
            var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);
            function Chalk(options) {
              this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
            }
            if (isSimpleWindowsTerm) {
              ansiStyles.blue.open = '\u001b[94m';
            }
            var styles = (function() {
              var ret = {};
              Object.keys(ansiStyles).forEach(function(key) {
                ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
                ret[key] = {get: function() {
                    return build.call(this, this._styles.concat(key));
                  }};
              });
              return ret;
            })();
            var proto = defineProps(function chalk() {}, styles);
            function build(_styles) {
              var builder = function() {
                return applyStyle.apply(builder, arguments);
              };
              builder._styles = _styles;
              builder.enabled = this.enabled;
              builder.__proto__ = proto;
              return builder;
            }
            function applyStyle() {
              var args = arguments;
              var argsLen = args.length;
              var str = argsLen !== 0 && String(arguments[0]);
              if (argsLen > 1) {
                for (var a = 1; a < argsLen; a++) {
                  str += ' ' + args[a];
                }
              }
              if (!this.enabled || !str) {
                return str;
              }
              var nestedStyles = this._styles;
              var i = nestedStyles.length;
              var originalDim = ansiStyles.dim.open;
              if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
                ansiStyles.dim.open = '';
              }
              while (i--) {
                var code = ansiStyles[nestedStyles[i]];
                str = code.open + str.replace(code.closeRe, code.open) + code.close;
              }
              ansiStyles.dim.open = originalDim;
              return str;
            }
            function init() {
              var ret = {};
              Object.keys(styles).forEach(function(name) {
                ret[name] = {get: function() {
                    return build.call(this, [name]);
                  }};
              });
              return ret;
            }
            defineProps(Chalk.prototype, init());
            module.exports = new Chalk();
            module.exports.styles = ansiStyles;
            module.exports.hasColor = hasAnsi;
            module.exports.stripColor = stripAnsi;
            module.exports.supportsColor = supportsColor;
          }).call(this, require('_process'));
        }, {
          "_process": 12,
          "ansi-styles": 218,
          "escape-string-regexp": 219,
          "has-ansi": 220,
          "strip-ansi": 222,
          "supports-color": 224
        }],
        218: [function(require, module, exports) {
          'use strict';
          function assembleStyles() {
            var styles = {
              modifiers: {
                reset: [0, 0],
                bold: [1, 22],
                dim: [2, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                hidden: [8, 28],
                strikethrough: [9, 29]
              },
              colors: {
                black: [30, 39],
                red: [31, 39],
                green: [32, 39],
                yellow: [33, 39],
                blue: [34, 39],
                magenta: [35, 39],
                cyan: [36, 39],
                white: [37, 39],
                gray: [90, 39]
              },
              bgColors: {
                bgBlack: [40, 49],
                bgRed: [41, 49],
                bgGreen: [42, 49],
                bgYellow: [43, 49],
                bgBlue: [44, 49],
                bgMagenta: [45, 49],
                bgCyan: [46, 49],
                bgWhite: [47, 49]
              }
            };
            styles.colors.grey = styles.colors.gray;
            Object.keys(styles).forEach(function(groupName) {
              var group = styles[groupName];
              Object.keys(group).forEach(function(styleName) {
                var style = group[styleName];
                styles[styleName] = group[styleName] = {
                  open: '\u001b[' + style[0] + 'm',
                  close: '\u001b[' + style[1] + 'm'
                };
              });
              Object.defineProperty(styles, groupName, {
                value: group,
                enumerable: false
              });
            });
            return styles;
          }
          Object.defineProperty(module, 'exports', {
            enumerable: true,
            get: assembleStyles
          });
        }, {}],
        219: [function(require, module, exports) {
          'use strict';
          var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
          module.exports = function(str) {
            if (typeof str !== 'string') {
              throw new TypeError('Expected a string');
            }
            return str.replace(matchOperatorsRe, '\\$&');
          };
        }, {}],
        220: [function(require, module, exports) {
          'use strict';
          var ansiRegex = require('ansi-regex');
          var re = new RegExp(ansiRegex().source);
          module.exports = re.test.bind(re);
        }, {"ansi-regex": 221}],
        221: [function(require, module, exports) {
          'use strict';
          module.exports = function() {
            return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
          };
        }, {}],
        222: [function(require, module, exports) {
          'use strict';
          var ansiRegex = require('ansi-regex')();
          module.exports = function(str) {
            return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
          };
        }, {"ansi-regex": 223}],
        223: [function(require, module, exports) {
          arguments[4][221][0].apply(exports, arguments);
        }, {"dup": 221}],
        224: [function(require, module, exports) {
          (function(process) {
            'use strict';
            var argv = process.argv;
            var terminator = argv.indexOf('--');
            var hasFlag = function(flag) {
              flag = '--' + flag;
              var pos = argv.indexOf(flag);
              return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
            };
            module.exports = (function() {
              if ('FORCE_COLOR' in process.env) {
                return true;
              }
              if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
                return false;
              }
              if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
                return true;
              }
              if (process.stdout && !process.stdout.isTTY) {
                return false;
              }
              if (process.platform === 'win32') {
                return true;
              }
              if ('COLORTERM' in process.env) {
                return true;
              }
              if (process.env.TERM === 'dumb') {
                return false;
              }
              if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
                return true;
              }
              return false;
            })();
          }).call(this, require('_process'));
        }, {"_process": 12}],
        225: [function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            var fs = require('fs');
            var path = require('path');
            var commentRx = /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+;)?base64,(.*)$/mg;
            var mapFileCommentRx = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
            function decodeBase64(base64) {
              return new Buffer(base64, 'base64').toString();
            }
            function stripComment(sm) {
              return sm.split(',').pop();
            }
            function readFromFileMap(sm, dir) {
              var r = mapFileCommentRx.exec(sm);
              mapFileCommentRx.lastIndex = 0;
              var filename = r[1] || r[2];
              var filepath = path.join(dir, filename);
              try {
                return fs.readFileSync(filepath, 'utf8');
              } catch (e) {
                throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
              }
            }
            function Converter(sm, opts) {
              opts = opts || {};
              if (opts.isFileComment)
                sm = readFromFileMap(sm, opts.commentFileDir);
              if (opts.hasComment)
                sm = stripComment(sm);
              if (opts.isEncoded)
                sm = decodeBase64(sm);
              if (opts.isJSON || opts.isEncoded)
                sm = JSON.parse(sm);
              this.sourcemap = sm;
            }
            function convertFromLargeSource(content) {
              var lines = content.split('\n');
              var line;
              for (var i = lines.length - 1; i > 0; i--) {
                line = lines[i];
                if (~line.indexOf('sourceMappingURL=data:'))
                  return exports.fromComment(line);
              }
            }
            Converter.prototype.toJSON = function(space) {
              return JSON.stringify(this.sourcemap, null, space);
            };
            Converter.prototype.toBase64 = function() {
              var json = this.toJSON();
              return new Buffer(json).toString('base64');
            };
            Converter.prototype.toComment = function(options) {
              var base64 = this.toBase64();
              var data = 'sourceMappingURL=data:application/json;base64,' + base64;
              return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
            };
            Converter.prototype.toObject = function() {
              return JSON.parse(this.toJSON());
            };
            Converter.prototype.addProperty = function(key, value) {
              if (this.sourcemap.hasOwnProperty(key))
                throw new Error('property %s already exists on the sourcemap, use set property instead');
              return this.setProperty(key, value);
            };
            Converter.prototype.setProperty = function(key, value) {
              this.sourcemap[key] = value;
              return this;
            };
            Converter.prototype.getProperty = function(key) {
              return this.sourcemap[key];
            };
            exports.fromObject = function(obj) {
              return new Converter(obj);
            };
            exports.fromJSON = function(json) {
              return new Converter(json, {isJSON: true});
            };
            exports.fromBase64 = function(base64) {
              return new Converter(base64, {isEncoded: true});
            };
            exports.fromComment = function(comment) {
              comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '');
              return new Converter(comment, {
                isEncoded: true,
                hasComment: true
              });
            };
            exports.fromMapFileComment = function(comment, dir) {
              return new Converter(comment, {
                commentFileDir: dir,
                isFileComment: true,
                isJSON: true
              });
            };
            exports.fromSource = function(content, largeSource) {
              if (largeSource)
                return convertFromLargeSource(content);
              var m = content.match(commentRx);
              commentRx.lastIndex = 0;
              return m ? exports.fromComment(m.pop()) : null;
            };
            exports.fromMapFileSource = function(content, dir) {
              var m = content.match(mapFileCommentRx);
              mapFileCommentRx.lastIndex = 0;
              return m ? exports.fromMapFileComment(m.pop(), dir) : null;
            };
            exports.removeComments = function(src) {
              commentRx.lastIndex = 0;
              return src.replace(commentRx, '');
            };
            exports.removeMapFileComments = function(src) {
              mapFileCommentRx.lastIndex = 0;
              return src.replace(mapFileCommentRx, '');
            };
            Object.defineProperty(exports, 'commentRegex', {get: function getCommentRegex() {
                commentRx.lastIndex = 0;
                return commentRx;
              }});
            Object.defineProperty(exports, 'mapFileCommentRegex', {get: function getMapFileCommentRegex() {
                mapFileCommentRx.lastIndex = 0;
                return mapFileCommentRx;
              }});
          }).call(this, require("buffer").Buffer);
        }, {
          "buffer": 4,
          "fs": 1,
          "path": 11
        }],
        226: [function(require, module, exports) {
          module.exports = function(it) {
            if (typeof it != 'function')
              throw TypeError(it + ' is not a function!');
            return it;
          };
        }, {}],
        227: [function(require, module, exports) {
          var isObject = require('./$.is-object');
          module.exports = function(it) {
            if (!isObject(it))
              throw TypeError(it + ' is not an object!');
            return it;
          };
        }, {"./$.is-object": 257}],
        228: [function(require, module, exports) {
          var toIObject = require('./$.to-iobject'),
              toLength = require('./$.to-length'),
              toIndex = require('./$.to-index');
          module.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIObject($this),
                  length = toLength(O.length),
                  index = toIndex(fromIndex, length),
                  value;
              if (IS_INCLUDES && el != el)
                while (length > index) {
                  value = O[index++];
                  if (value != value)
                    return true;
                }
              else
                for (; length > index; index++)
                  if (IS_INCLUDES || index in O) {
                    if (O[index] === el)
                      return IS_INCLUDES || index;
                  }
              return !IS_INCLUDES && -1;
            };
          };
        }, {
          "./$.to-index": 292,
          "./$.to-iobject": 294,
          "./$.to-length": 295
        }],
        229: [function(require, module, exports) {
          var ctx = require('./$.ctx'),
              IObject = require('./$.iobject'),
              toObject = require('./$.to-object'),
              toLength = require('./$.to-length');
          module.exports = function(TYPE) {
            var IS_MAP = TYPE == 1,
                IS_FILTER = TYPE == 2,
                IS_SOME = TYPE == 3,
                IS_EVERY = TYPE == 4,
                IS_FIND_INDEX = TYPE == 6,
                NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
            return function($this, callbackfn, that) {
              var O = toObject($this),
                  self = IObject(O),
                  f = ctx(callbackfn, that, 3),
                  length = toLength(self.length),
                  index = 0,
                  result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined,
                  val,
                  res;
              for (; length > index; index++)
                if (NO_HOLES || index in self) {
                  val = self[index];
                  res = f(val, index, O);
                  if (TYPE) {
                    if (IS_MAP)
                      result[index] = res;
                    else if (res)
                      switch (TYPE) {
                        case 3:
                          return true;
                        case 5:
                          return val;
                        case 6:
                          return index;
                        case 2:
                          result.push(val);
                      }
                    else if (IS_EVERY)
                      return false;
                  }
                }
              return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
            };
          };
        }, {
          "./$.ctx": 238,
          "./$.iobject": 254,
          "./$.to-length": 295,
          "./$.to-object": 296
        }],
        230: [function(require, module, exports) {
          var toObject = require('./$.to-object'),
              IObject = require('./$.iobject'),
              enumKeys = require('./$.enum-keys');
          module.exports = require('./$.fails')(function() {
            return Symbol() in Object.assign({});
          }) ? function assign(target, source) {
            var T = toObject(target),
                l = arguments.length,
                i = 1;
            while (l > i) {
              var S = IObject(arguments[i++]),
                  keys = enumKeys(S),
                  length = keys.length,
                  j = 0,
                  key;
              while (length > j)
                T[key = keys[j++]] = S[key];
            }
            return T;
          } : Object.assign;
        }, {
          "./$.enum-keys": 242,
          "./$.fails": 244,
          "./$.iobject": 254,
          "./$.to-object": 296
        }],
        231: [function(require, module, exports) {
          var cof = require('./$.cof'),
              TAG = require('./$.wks')('toStringTag'),
              ARG = cof(function() {
                return arguments;
              }()) == 'Arguments';
          module.exports = function(it) {
            var O,
                T,
                B;
            return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
          };
        }, {
          "./$.cof": 232,
          "./$.wks": 299
        }],
        232: [function(require, module, exports) {
          var toString = {}.toString;
          module.exports = function(it) {
            return toString.call(it).slice(8, -1);
          };
        }, {}],
        233: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              hide = require('./$.hide'),
              ctx = require('./$.ctx'),
              species = require('./$.species'),
              strictNew = require('./$.strict-new'),
              defined = require('./$.defined'),
              forOf = require('./$.for-of'),
              step = require('./$.iter-step'),
              ID = require('./$.uid')('id'),
              $has = require('./$.has'),
              isObject = require('./$.is-object'),
              isExtensible = Object.isExtensible || isObject,
              SUPPORT_DESC = require('./$.support-desc'),
              SIZE = SUPPORT_DESC ? '_s' : 'size',
              id = 0;
          var fastKey = function(it, create) {
            if (!isObject(it))
              return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
            if (!$has(it, ID)) {
              if (!isExtensible(it))
                return 'F';
              if (!create)
                return 'E';
              hide(it, ID, ++id);
            }
            return 'O' + it[ID];
          };
          var getEntry = function(that, key) {
            var index = fastKey(key),
                entry;
            if (index !== 'F')
              return that._i[index];
            for (entry = that._f; entry; entry = entry.n) {
              if (entry.k == key)
                return entry;
            }
          };
          module.exports = {
            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
              var C = wrapper(function(that, iterable) {
                strictNew(that, C, NAME);
                that._i = $.create(null);
                that._f = undefined;
                that._l = undefined;
                that[SIZE] = 0;
                if (iterable != undefined)
                  forOf(iterable, IS_MAP, that[ADDER], that);
              });
              require('./$.mix')(C.prototype, {
                clear: function clear() {
                  for (var that = this,
                      data = that._i,
                      entry = that._f; entry; entry = entry.n) {
                    entry.r = true;
                    if (entry.p)
                      entry.p = entry.p.n = undefined;
                    delete data[entry.i];
                  }
                  that._f = that._l = undefined;
                  that[SIZE] = 0;
                },
                'delete': function(key) {
                  var that = this,
                      entry = getEntry(that, key);
                  if (entry) {
                    var next = entry.n,
                        prev = entry.p;
                    delete that._i[entry.i];
                    entry.r = true;
                    if (prev)
                      prev.n = next;
                    if (next)
                      next.p = prev;
                    if (that._f == entry)
                      that._f = next;
                    if (that._l == entry)
                      that._l = prev;
                    that[SIZE]--;
                  }
                  return !!entry;
                },
                forEach: function forEach(callbackfn) {
                  var f = ctx(callbackfn, arguments[1], 3),
                      entry;
                  while (entry = entry ? entry.n : this._f) {
                    f(entry.v, entry.k, this);
                    while (entry && entry.r)
                      entry = entry.p;
                  }
                },
                has: function has(key) {
                  return !!getEntry(this, key);
                }
              });
              if (SUPPORT_DESC)
                $.setDesc(C.prototype, 'size', {get: function() {
                    return defined(this[SIZE]);
                  }});
              return C;
            },
            def: function(that, key, value) {
              var entry = getEntry(that, key),
                  prev,
                  index;
              if (entry) {
                entry.v = value;
              } else {
                that._l = entry = {
                  i: index = fastKey(key, true),
                  k: key,
                  v: value,
                  p: prev = that._l,
                  n: undefined,
                  r: false
                };
                if (!that._f)
                  that._f = entry;
                if (prev)
                  prev.n = entry;
                that[SIZE]++;
                if (index !== 'F')
                  that._i[index] = entry;
              }
              return that;
            },
            getEntry: getEntry,
            setStrong: function(C, NAME, IS_MAP) {
              require('./$.iter-define')(C, NAME, function(iterated, kind) {
                this._t = iterated;
                this._k = kind;
                this._l = undefined;
              }, function() {
                var that = this,
                    kind = that._k,
                    entry = that._l;
                while (entry && entry.r)
                  entry = entry.p;
                if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
                  that._t = undefined;
                  return step(1);
                }
                if (kind == 'keys')
                  return step(0, entry.k);
                if (kind == 'values')
                  return step(0, entry.v);
                return step(0, [entry.k, entry.v]);
              }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
              species(C);
              species(require('./$.core')[NAME]);
            }
          };
        }, {
          "./$": 264,
          "./$.core": 237,
          "./$.ctx": 238,
          "./$.defined": 240,
          "./$.for-of": 247,
          "./$.has": 250,
          "./$.hide": 251,
          "./$.is-object": 257,
          "./$.iter-define": 260,
          "./$.iter-step": 262,
          "./$.mix": 269,
          "./$.species": 282,
          "./$.strict-new": 283,
          "./$.support-desc": 289,
          "./$.uid": 297
        }],
        234: [function(require, module, exports) {
          var forOf = require('./$.for-of'),
              classof = require('./$.classof');
          module.exports = function(NAME) {
            return function toJSON() {
              if (classof(this) != NAME)
                throw TypeError(NAME + "#toJSON isn't generic");
              var arr = [];
              forOf(this, false, arr.push, arr);
              return arr;
            };
          };
        }, {
          "./$.classof": 231,
          "./$.for-of": 247
        }],
        235: [function(require, module, exports) {
          'use strict';
          var hide = require('./$.hide'),
              anObject = require('./$.an-object'),
              strictNew = require('./$.strict-new'),
              forOf = require('./$.for-of'),
              method = require('./$.array-methods'),
              WEAK = require('./$.uid')('weak'),
              isObject = require('./$.is-object'),
              $has = require('./$.has'),
              isExtensible = Object.isExtensible || isObject,
              find = method(5),
              findIndex = method(6),
              id = 0;
          var frozenStore = function(that) {
            return that._l || (that._l = new FrozenStore);
          };
          var FrozenStore = function() {
            this.a = [];
          };
          var findFrozen = function(store, key) {
            return find(store.a, function(it) {
              return it[0] === key;
            });
          };
          FrozenStore.prototype = {
            get: function(key) {
              var entry = findFrozen(this, key);
              if (entry)
                return entry[1];
            },
            has: function(key) {
              return !!findFrozen(this, key);
            },
            set: function(key, value) {
              var entry = findFrozen(this, key);
              if (entry)
                entry[1] = value;
              else
                this.a.push([key, value]);
            },
            'delete': function(key) {
              var index = findIndex(this.a, function(it) {
                return it[0] === key;
              });
              if (~index)
                this.a.splice(index, 1);
              return !!~index;
            }
          };
          module.exports = {
            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
              var C = wrapper(function(that, iterable) {
                strictNew(that, C, NAME);
                that._i = id++;
                that._l = undefined;
                if (iterable != undefined)
                  forOf(iterable, IS_MAP, that[ADDER], that);
              });
              require('./$.mix')(C.prototype, {
                'delete': function(key) {
                  if (!isObject(key))
                    return false;
                  if (!isExtensible(key))
                    return frozenStore(this)['delete'](key);
                  return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
                },
                has: function has(key) {
                  if (!isObject(key))
                    return false;
                  if (!isExtensible(key))
                    return frozenStore(this).has(key);
                  return $has(key, WEAK) && $has(key[WEAK], this._i);
                }
              });
              return C;
            },
            def: function(that, key, value) {
              if (!isExtensible(anObject(key))) {
                frozenStore(that).set(key, value);
              } else {
                $has(key, WEAK) || hide(key, WEAK, {});
                key[WEAK][that._i] = value;
              }
              return that;
            },
            frozenStore: frozenStore,
            WEAK: WEAK
          };
        }, {
          "./$.an-object": 227,
          "./$.array-methods": 229,
          "./$.for-of": 247,
          "./$.has": 250,
          "./$.hide": 251,
          "./$.is-object": 257,
          "./$.mix": 269,
          "./$.strict-new": 283,
          "./$.uid": 297
        }],
        236: [function(require, module, exports) {
          'use strict';
          var global = require('./$.global'),
              $def = require('./$.def'),
              forOf = require('./$.for-of'),
              strictNew = require('./$.strict-new');
          module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
            var Base = global[NAME],
                C = Base,
                ADDER = IS_MAP ? 'set' : 'add',
                proto = C && C.prototype,
                O = {};
            var fixMethod = function(KEY) {
              var fn = proto[KEY];
              require('./$.redef')(proto, KEY, KEY == 'delete' ? function(a) {
                return fn.call(this, a === 0 ? 0 : a);
              } : KEY == 'has' ? function has(a) {
                return fn.call(this, a === 0 ? 0 : a);
              } : KEY == 'get' ? function get(a) {
                return fn.call(this, a === 0 ? 0 : a);
              } : KEY == 'add' ? function add(a) {
                fn.call(this, a === 0 ? 0 : a);
                return this;
              } : function set(a, b) {
                fn.call(this, a === 0 ? 0 : a, b);
                return this;
              });
            };
            if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !require('./$.fails')(function() {
              new C().entries().next();
            }))) {
              C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
              require('./$.mix')(C.prototype, methods);
            } else {
              var inst = new C,
                  chain = inst[ADDER](IS_WEAK ? {} : -0, 1),
                  buggyZero;
              if (!require('./$.iter-detect')(function(iter) {
                new C(iter);
              })) {
                C = wrapper(function(target, iterable) {
                  strictNew(target, C, NAME);
                  var that = new Base;
                  if (iterable != undefined)
                    forOf(iterable, IS_MAP, that[ADDER], that);
                  return that;
                });
                C.prototype = proto;
                proto.constructor = C;
              }
              IS_WEAK || inst.forEach(function(val, key) {
                buggyZero = 1 / key === -Infinity;
              });
              if (buggyZero) {
                fixMethod('delete');
                fixMethod('has');
                IS_MAP && fixMethod('get');
              }
              if (buggyZero || chain !== inst)
                fixMethod(ADDER);
              if (IS_WEAK && proto.clear)
                delete proto.clear;
            }
            require('./$.tag')(C, NAME);
            O[NAME] = C;
            $def($def.G + $def.W + $def.F * (C != Base), O);
            if (!IS_WEAK)
              common.setStrong(C, NAME, IS_MAP);
            return C;
          };
        }, {
          "./$.def": 239,
          "./$.fails": 244,
          "./$.for-of": 247,
          "./$.global": 249,
          "./$.iter-detect": 261,
          "./$.mix": 269,
          "./$.redef": 276,
          "./$.strict-new": 283,
          "./$.tag": 290
        }],
        237: [function(require, module, exports) {
          var core = module.exports = {};
          if (typeof __e == 'number')
            __e = core;
        }, {}],
        238: [function(require, module, exports) {
          var aFunction = require('./$.a-function');
          module.exports = function(fn, that, length) {
            aFunction(fn);
            if (that === undefined)
              return fn;
            switch (length) {
              case 1:
                return function(a) {
                  return fn.call(that, a);
                };
              case 2:
                return function(a, b) {
                  return fn.call(that, a, b);
                };
              case 3:
                return function(a, b, c) {
                  return fn.call(that, a, b, c);
                };
            }
            return function() {
              return fn.apply(that, arguments);
            };
          };
        }, {"./$.a-function": 226}],
        239: [function(require, module, exports) {
          var global = require('./$.global'),
              core = require('./$.core'),
              hide = require('./$.hide'),
              $redef = require('./$.redef'),
              PROTOTYPE = 'prototype';
          var ctx = function(fn, that) {
            return function() {
              return fn.apply(that, arguments);
            };
          };
          var $def = function(type, name, source) {
            var key,
                own,
                out,
                exp,
                isGlobal = type & $def.G,
                isProto = type & $def.P,
                target = isGlobal ? global : type & $def.S ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
                exports = isGlobal ? core : core[name] || (core[name] = {});
            if (isGlobal)
              source = name;
            for (key in source) {
              own = !(type & $def.F) && target && key in target;
              out = (own ? target : source)[key];
              if (type & $def.B && own)
                exp = ctx(out, global);
              else
                exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
              if (target && !own)
                $redef(target, key, out);
              if (exports[key] != out)
                hide(exports, key, exp);
              if (isProto)
                (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
            }
          };
          global.core = core;
          $def.F = 1;
          $def.G = 2;
          $def.S = 4;
          $def.P = 8;
          $def.B = 16;
          $def.W = 32;
          module.exports = $def;
        }, {
          "./$.core": 237,
          "./$.global": 249,
          "./$.hide": 251,
          "./$.redef": 276
        }],
        240: [function(require, module, exports) {
          module.exports = function(it) {
            if (it == undefined)
              throw TypeError("Can't call method on  " + it);
            return it;
          };
        }, {}],
        241: [function(require, module, exports) {
          var isObject = require('./$.is-object'),
              document = require('./$.global').document,
              is = isObject(document) && isObject(document.createElement);
          module.exports = function(it) {
            return is ? document.createElement(it) : {};
          };
        }, {
          "./$.global": 249,
          "./$.is-object": 257
        }],
        242: [function(require, module, exports) {
          var $ = require('./$');
          module.exports = function(it) {
            var keys = $.getKeys(it),
                getSymbols = $.getSymbols;
            if (getSymbols) {
              var symbols = getSymbols(it),
                  isEnum = $.isEnum,
                  i = 0,
                  key;
              while (symbols.length > i)
                if (isEnum.call(it, key = symbols[i++]))
                  keys.push(key);
            }
            return keys;
          };
        }, {"./$": 264}],
        243: [function(require, module, exports) {
          module.exports = Math.expm1 || function expm1(x) {
            return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
          };
        }, {}],
        244: [function(require, module, exports) {
          module.exports = function(exec) {
            try {
              return !!exec();
            } catch (e) {
              return true;
            }
          };
        }, {}],
        245: [function(require, module, exports) {
          'use strict';
          module.exports = function(KEY, length, exec) {
            var defined = require('./$.defined'),
                SYMBOL = require('./$.wks')(KEY),
                original = ''[KEY];
            if (require('./$.fails')(function() {
              var O = {};
              O[SYMBOL] = function() {
                return 7;
              };
              return ''[KEY](O) != 7;
            })) {
              require('./$.redef')(String.prototype, KEY, exec(defined, SYMBOL, original));
              require('./$.hide')(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
                return original.call(string, this, arg);
              } : function(string) {
                return original.call(string, this);
              });
            }
          };
        }, {
          "./$.defined": 240,
          "./$.fails": 244,
          "./$.hide": 251,
          "./$.redef": 276,
          "./$.wks": 299
        }],
        246: [function(require, module, exports) {
          'use strict';
          var anObject = require('./$.an-object');
          module.exports = function() {
            var that = anObject(this),
                result = '';
            if (that.global)
              result += 'g';
            if (that.ignoreCase)
              result += 'i';
            if (that.multiline)
              result += 'm';
            if (that.unicode)
              result += 'u';
            if (that.sticky)
              result += 'y';
            return result;
          };
        }, {"./$.an-object": 227}],
        247: [function(require, module, exports) {
          var ctx = require('./$.ctx'),
              call = require('./$.iter-call'),
              isArrayIter = require('./$.is-array-iter'),
              anObject = require('./$.an-object'),
              toLength = require('./$.to-length'),
              getIterFn = require('./core.get-iterator-method');
          module.exports = function(iterable, entries, fn, that) {
            var iterFn = getIterFn(iterable),
                f = ctx(fn, that, entries ? 2 : 1),
                index = 0,
                length,
                step,
                iterator;
            if (typeof iterFn != 'function')
              throw TypeError(iterable + ' is not iterable!');
            if (isArrayIter(iterFn))
              for (length = toLength(iterable.length); length > index; index++) {
                entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
              }
            else
              for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
                call(iterator, f, step.value, entries);
              }
          };
        }, {
          "./$.an-object": 227,
          "./$.ctx": 238,
          "./$.is-array-iter": 255,
          "./$.iter-call": 258,
          "./$.to-length": 295,
          "./core.get-iterator-method": 300
        }],
        248: [function(require, module, exports) {
          var toString = {}.toString,
              toIObject = require('./$.to-iobject'),
              getNames = require('./$').getNames;
          var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
          var getWindowNames = function(it) {
            try {
              return getNames(it);
            } catch (e) {
              return windowNames.slice();
            }
          };
          module.exports.get = function getOwnPropertyNames(it) {
            if (windowNames && toString.call(it) == '[object Window]')
              return getWindowNames(it);
            return getNames(toIObject(it));
          };
        }, {
          "./$": 264,
          "./$.to-iobject": 294
        }],
        249: [function(require, module, exports) {
          var UNDEFINED = 'undefined';
          var global = module.exports = typeof window != UNDEFINED && window.Math == Math ? window : typeof self != UNDEFINED && self.Math == Math ? self : Function('return this')();
          if (typeof __g == 'number')
            __g = global;
        }, {}],
        250: [function(require, module, exports) {
          var hasOwnProperty = {}.hasOwnProperty;
          module.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
          };
        }, {}],
        251: [function(require, module, exports) {
          var $ = require('./$'),
              createDesc = require('./$.property-desc');
          module.exports = require('./$.support-desc') ? function(object, key, value) {
            return $.setDesc(object, key, createDesc(1, value));
          } : function(object, key, value) {
            object[key] = value;
            return object;
          };
        }, {
          "./$": 264,
          "./$.property-desc": 275,
          "./$.support-desc": 289
        }],
        252: [function(require, module, exports) {
          module.exports = require('./$.global').document && document.documentElement;
        }, {"./$.global": 249}],
        253: [function(require, module, exports) {
          module.exports = function(fn, args, that) {
            var un = that === undefined;
            switch (args.length) {
              case 0:
                return un ? fn() : fn.call(that);
              case 1:
                return un ? fn(args[0]) : fn.call(that, args[0]);
              case 2:
                return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
              case 3:
                return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
              case 4:
                return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
            }
            return fn.apply(that, args);
          };
        }, {}],
        254: [function(require, module, exports) {
          var cof = require('./$.cof');
          module.exports = 0 in Object('z') ? Object : function(it) {
            return cof(it) == 'String' ? it.split('') : Object(it);
          };
        }, {"./$.cof": 232}],
        255: [function(require, module, exports) {
          var Iterators = require('./$.iterators'),
              ITERATOR = require('./$.wks')('iterator');
          module.exports = function(it) {
            return (Iterators.Array || Array.prototype[ITERATOR]) === it;
          };
        }, {
          "./$.iterators": 263,
          "./$.wks": 299
        }],
        256: [function(require, module, exports) {
          var isObject = require('./$.is-object'),
              floor = Math.floor;
          module.exports = function isInteger(it) {
            return !isObject(it) && isFinite(it) && floor(it) === it;
          };
        }, {"./$.is-object": 257}],
        257: [function(require, module, exports) {
          module.exports = function(it) {
            return it !== null && (typeof it == 'object' || typeof it == 'function');
          };
        }, {}],
        258: [function(require, module, exports) {
          var anObject = require('./$.an-object');
          module.exports = function(iterator, fn, value, entries) {
            try {
              return entries ? fn(anObject(value)[0], value[1]) : fn(value);
            } catch (e) {
              var ret = iterator['return'];
              if (ret !== undefined)
                anObject(ret.call(iterator));
              throw e;
            }
          };
        }, {"./$.an-object": 227}],
        259: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              IteratorPrototype = {};
          require('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function() {
            return this;
          });
          module.exports = function(Constructor, NAME, next) {
            Constructor.prototype = $.create(IteratorPrototype, {next: require('./$.property-desc')(1, next)});
            require('./$.tag')(Constructor, NAME + ' Iterator');
          };
        }, {
          "./$": 264,
          "./$.hide": 251,
          "./$.property-desc": 275,
          "./$.tag": 290,
          "./$.wks": 299
        }],
        260: [function(require, module, exports) {
          'use strict';
          var LIBRARY = require('./$.library'),
              $def = require('./$.def'),
              $redef = require('./$.redef'),
              hide = require('./$.hide'),
              has = require('./$.has'),
              SYMBOL_ITERATOR = require('./$.wks')('iterator'),
              Iterators = require('./$.iterators'),
              BUGGY = !([].keys && 'next' in [].keys()),
              FF_ITERATOR = '@@iterator',
              KEYS = 'keys',
              VALUES = 'values';
          var returnThis = function() {
            return this;
          };
          module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE) {
            require('./$.iter-create')(Constructor, NAME, next);
            var createMethod = function(kind) {
              switch (kind) {
                case KEYS:
                  return function keys() {
                    return new Constructor(this, kind);
                  };
                case VALUES:
                  return function values() {
                    return new Constructor(this, kind);
                  };
              }
              return function entries() {
                return new Constructor(this, kind);
              };
            };
            var TAG = NAME + ' Iterator',
                proto = Base.prototype,
                _native = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
                _default = _native || createMethod(DEFAULT),
                methods,
                key;
            if (_native) {
              var IteratorPrototype = require('./$').getProto(_default.call(new Base));
              require('./$.tag')(IteratorPrototype, TAG, true);
              if (!LIBRARY && has(proto, FF_ITERATOR))
                hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
            }
            if (!LIBRARY || FORCE)
              hide(proto, SYMBOL_ITERATOR, _default);
            Iterators[NAME] = _default;
            Iterators[TAG] = returnThis;
            if (DEFAULT) {
              methods = {
                keys: IS_SET ? _default : createMethod(KEYS),
                values: DEFAULT == VALUES ? _default : createMethod(VALUES),
                entries: DEFAULT != VALUES ? _default : createMethod('entries')
              };
              if (FORCE)
                for (key in methods) {
                  if (!(key in proto))
                    $redef(proto, key, methods[key]);
                }
              else
                $def($def.P + $def.F * BUGGY, NAME, methods);
            }
          };
        }, {
          "./$": 264,
          "./$.def": 239,
          "./$.has": 250,
          "./$.hide": 251,
          "./$.iter-create": 259,
          "./$.iterators": 263,
          "./$.library": 266,
          "./$.redef": 276,
          "./$.tag": 290,
          "./$.wks": 299
        }],
        261: [function(require, module, exports) {
          var SYMBOL_ITERATOR = require('./$.wks')('iterator'),
              SAFE_CLOSING = false;
          try {
            var riter = [7][SYMBOL_ITERATOR]();
            riter['return'] = function() {
              SAFE_CLOSING = true;
            };
            Array.from(riter, function() {
              throw 2;
            });
          } catch (e) {}
          module.exports = function(exec) {
            if (!SAFE_CLOSING)
              return false;
            var safe = false;
            try {
              var arr = [7],
                  iter = arr[SYMBOL_ITERATOR]();
              iter.next = function() {
                safe = true;
              };
              arr[SYMBOL_ITERATOR] = function() {
                return iter;
              };
              exec(arr);
            } catch (e) {}
            return safe;
          };
        }, {"./$.wks": 299}],
        262: [function(require, module, exports) {
          module.exports = function(done, value) {
            return {
              value: value,
              done: !!done
            };
          };
        }, {}],
        263: [function(require, module, exports) {
          module.exports = {};
        }, {}],
        264: [function(require, module, exports) {
          var $Object = Object;
          module.exports = {
            create: $Object.create,
            getProto: $Object.getPrototypeOf,
            isEnum: {}.propertyIsEnumerable,
            getDesc: $Object.getOwnPropertyDescriptor,
            setDesc: $Object.defineProperty,
            setDescs: $Object.defineProperties,
            getKeys: $Object.keys,
            getNames: $Object.getOwnPropertyNames,
            getSymbols: $Object.getOwnPropertySymbols,
            each: [].forEach
          };
        }, {}],
        265: [function(require, module, exports) {
          var $ = require('./$'),
              toIObject = require('./$.to-iobject');
          module.exports = function(object, el) {
            var O = toIObject(object),
                keys = $.getKeys(O),
                length = keys.length,
                index = 0,
                key;
            while (length > index)
              if (O[key = keys[index++]] === el)
                return key;
          };
        }, {
          "./$": 264,
          "./$.to-iobject": 294
        }],
        266: [function(require, module, exports) {
          module.exports = false;
        }, {}],
        267: [function(require, module, exports) {
          module.exports = Math.log1p || function log1p(x) {
            return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
          };
        }, {}],
        268: [function(require, module, exports) {
          var global = require('./$.global'),
              macrotask = require('./$.task').set,
              Observer = global.MutationObserver || global.WebKitMutationObserver,
              process = global.process,
              isNode = require('./$.cof')(process) == 'process',
              head,
              last,
              notify;
          var flush = function() {
            var parent,
                domain;
            if (isNode && (parent = process.domain)) {
              process.domain = null;
              parent.exit();
            }
            while (head) {
              domain = head.domain;
              if (domain)
                domain.enter();
              head.fn.call();
              if (domain)
                domain.exit();
              head = head.next;
            }
            last = undefined;
            if (parent)
              parent.enter();
          };
          if (isNode) {
            notify = function() {
              process.nextTick(flush);
            };
          } else if (Observer) {
            var toggle = 1,
                node = document.createTextNode('');
            new Observer(flush).observe(node, {characterData: true});
            notify = function() {
              node.data = toggle = -toggle;
            };
          } else {
            notify = function() {
              macrotask.call(global, flush);
            };
          }
          module.exports = function asap(fn) {
            var task = {
              fn: fn,
              next: undefined,
              domain: isNode && process.domain
            };
            if (last)
              last.next = task;
            if (!head) {
              head = task;
              notify();
            }
            last = task;
          };
        }, {
          "./$.cof": 232,
          "./$.global": 249,
          "./$.task": 291
        }],
        269: [function(require, module, exports) {
          var $redef = require('./$.redef');
          module.exports = function(target, src) {
            for (var key in src)
              $redef(target, key, src[key]);
            return target;
          };
        }, {"./$.redef": 276}],
        270: [function(require, module, exports) {
          module.exports = function(KEY, exec) {
            var $def = require('./$.def'),
                fn = (require('./$.core').Object || {})[KEY] || Object[KEY],
                exp = {};
            exp[KEY] = exec(fn);
            $def($def.S + $def.F * require('./$.fails')(function() {
              fn(1);
            }), 'Object', exp);
          };
        }, {
          "./$.core": 237,
          "./$.def": 239,
          "./$.fails": 244
        }],
        271: [function(require, module, exports) {
          var $ = require('./$'),
              toIObject = require('./$.to-iobject');
          module.exports = function(isEntries) {
            return function(it) {
              var O = toIObject(it),
                  keys = $.getKeys(O),
                  length = keys.length,
                  i = 0,
                  result = Array(length),
                  key;
              if (isEntries)
                while (length > i)
                  result[i] = [key = keys[i++], O[key]];
              else
                while (length > i)
                  result[i] = O[keys[i++]];
              return result;
            };
          };
        }, {
          "./$": 264,
          "./$.to-iobject": 294
        }],
        272: [function(require, module, exports) {
          var $ = require('./$'),
              anObject = require('./$.an-object'),
              Reflect = require('./$.global').Reflect;
          module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
            var keys = $.getNames(anObject(it)),
                getSymbols = $.getSymbols;
            return getSymbols ? keys.concat(getSymbols(it)) : keys;
          };
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.global": 249
        }],
        273: [function(require, module, exports) {
          'use strict';
          var path = require('./$.path'),
              invoke = require('./$.invoke'),
              aFunction = require('./$.a-function');
          module.exports = function() {
            var fn = aFunction(this),
                length = arguments.length,
                pargs = Array(length),
                i = 0,
                _ = path._,
                holder = false;
            while (length > i)
              if ((pargs[i] = arguments[i++]) === _)
                holder = true;
            return function() {
              var that = this,
                  _length = arguments.length,
                  j = 0,
                  k = 0,
                  args;
              if (!holder && !_length)
                return invoke(fn, pargs, that);
              args = pargs.slice();
              if (holder)
                for (; length > j; j++)
                  if (args[j] === _)
                    args[j] = arguments[k++];
              while (_length > k)
                args.push(arguments[k++]);
              return invoke(fn, args, that);
            };
          };
        }, {
          "./$.a-function": 226,
          "./$.invoke": 253,
          "./$.path": 274
        }],
        274: [function(require, module, exports) {
          module.exports = require('./$.global');
        }, {"./$.global": 249}],
        275: [function(require, module, exports) {
          module.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value: value
            };
          };
        }, {}],
        276: [function(require, module, exports) {
          var global = require('./$.global'),
              hide = require('./$.hide'),
              SRC = require('./$.uid')('src'),
              TO_STRING = 'toString',
              $toString = Function[TO_STRING],
              TPL = ('' + $toString).split(TO_STRING);
          require('./$.core').inspectSource = function(it) {
            return $toString.call(it);
          };
          (module.exports = function(O, key, val, safe) {
            if (typeof val == 'function') {
              hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
              if (!('name' in val))
                val.name = key;
            }
            if (O === global) {
              O[key] = val;
            } else {
              if (!safe)
                delete O[key];
              hide(O, key, val);
            }
          })(Function.prototype, TO_STRING, function toString() {
            return typeof this == 'function' && this[SRC] || $toString.call(this);
          });
        }, {
          "./$.core": 237,
          "./$.global": 249,
          "./$.hide": 251,
          "./$.uid": 297
        }],
        277: [function(require, module, exports) {
          module.exports = function(regExp, replace) {
            var replacer = replace === Object(replace) ? function(part) {
              return replace[part];
            } : replace;
            return function(it) {
              return String(it).replace(regExp, replacer);
            };
          };
        }, {}],
        278: [function(require, module, exports) {
          module.exports = Object.is || function is(x, y) {
            return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
          };
        }, {}],
        279: [function(require, module, exports) {
          var getDesc = require('./$').getDesc,
              isObject = require('./$.is-object'),
              anObject = require('./$.an-object');
          var check = function(O, proto) {
            anObject(O);
            if (!isObject(proto) && proto !== null)
              throw TypeError(proto + ": can't set as prototype!");
          };
          module.exports = {
            set: Object.setPrototypeOf || ('__proto__' in {} ? function(buggy, set) {
              try {
                set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
                set({}, []);
              } catch (e) {
                buggy = true;
              }
              return function setPrototypeOf(O, proto) {
                check(O, proto);
                if (buggy)
                  O.__proto__ = proto;
                else
                  set(O, proto);
                return O;
              };
            }() : undefined),
            check: check
          };
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.ctx": 238,
          "./$.is-object": 257
        }],
        280: [function(require, module, exports) {
          var global = require('./$.global'),
              SHARED = '__core-js_shared__',
              store = global[SHARED] || (global[SHARED] = {});
          module.exports = function(key) {
            return store[key] || (store[key] = {});
          };
        }, {"./$.global": 249}],
        281: [function(require, module, exports) {
          module.exports = Math.sign || function sign(x) {
            return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
          };
        }, {}],
        282: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              SPECIES = require('./$.wks')('species');
          module.exports = function(C) {
            if (require('./$.support-desc') && !(SPECIES in C))
              $.setDesc(C, SPECIES, {
                configurable: true,
                get: function() {
                  return this;
                }
              });
          };
        }, {
          "./$": 264,
          "./$.support-desc": 289,
          "./$.wks": 299
        }],
        283: [function(require, module, exports) {
          module.exports = function(it, Constructor, name) {
            if (!(it instanceof Constructor))
              throw TypeError(name + ": use the 'new' operator!");
            return it;
          };
        }, {}],
        284: [function(require, module, exports) {
          var toInteger = require('./$.to-integer'),
              defined = require('./$.defined');
          module.exports = function(TO_STRING) {
            return function(that, pos) {
              var s = String(defined(that)),
                  i = toInteger(pos),
                  l = s.length,
                  a,
                  b;
              if (i < 0 || i >= l)
                return TO_STRING ? '' : undefined;
              a = s.charCodeAt(i);
              return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
            };
          };
        }, {
          "./$.defined": 240,
          "./$.to-integer": 293
        }],
        285: [function(require, module, exports) {
          var defined = require('./$.defined'),
              cof = require('./$.cof');
          module.exports = function(that, searchString, NAME) {
            if (cof(searchString) == 'RegExp')
              throw TypeError('String#' + NAME + " doesn't accept regex!");
            return String(defined(that));
          };
        }, {
          "./$.cof": 232,
          "./$.defined": 240
        }],
        286: [function(require, module, exports) {
          var toLength = require('./$.to-length'),
              repeat = require('./$.string-repeat'),
              defined = require('./$.defined');
          module.exports = function(that, maxLength, fillString, left) {
            var S = String(defined(that)),
                stringLength = S.length,
                fillStr = fillString === undefined ? ' ' : String(fillString),
                intMaxLength = toLength(maxLength);
            if (intMaxLength <= stringLength)
              return S;
            if (fillStr == '')
              fillStr = ' ';
            var fillLen = intMaxLength - stringLength,
                stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
            if (stringFiller.length > fillLen)
              stringFiller = left ? stringFiller.slice(stringFiller.length - fillLen) : stringFiller.slice(0, fillLen);
            return left ? stringFiller + S : S + stringFiller;
          };
        }, {
          "./$.defined": 240,
          "./$.string-repeat": 287,
          "./$.to-length": 295
        }],
        287: [function(require, module, exports) {
          'use strict';
          var toInteger = require('./$.to-integer'),
              defined = require('./$.defined');
          module.exports = function repeat(count) {
            var str = String(defined(this)),
                res = '',
                n = toInteger(count);
            if (n < 0 || n == Infinity)
              throw RangeError("Count can't be negative");
            for (; n > 0; (n >>>= 1) && (str += str))
              if (n & 1)
                res += str;
            return res;
          };
        }, {
          "./$.defined": 240,
          "./$.to-integer": 293
        }],
        288: [function(require, module, exports) {
          var trim = function(string, TYPE) {
            string = String(defined(string));
            if (TYPE & 1)
              string = string.replace(ltrim, '');
            if (TYPE & 2)
              string = string.replace(rtrim, '');
            return string;
          };
          var $def = require('./$.def'),
              defined = require('./$.defined'),
              spaces = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF',
              space = '[' + spaces + ']',
              non = '\u200b\u0085',
              ltrim = RegExp('^' + space + space + '*'),
              rtrim = RegExp(space + space + '*$');
          module.exports = function(KEY, exec) {
            var exp = {};
            exp[KEY] = exec(trim);
            $def($def.P + $def.F * require('./$.fails')(function() {
              return !!spaces[KEY]() || non[KEY]() != non;
            }), 'String', exp);
          };
        }, {
          "./$.def": 239,
          "./$.defined": 240,
          "./$.fails": 244
        }],
        289: [function(require, module, exports) {
          module.exports = !require('./$.fails')(function() {
            return Object.defineProperty({}, 'a', {get: function() {
                return 7;
              }}).a != 7;
          });
        }, {"./$.fails": 244}],
        290: [function(require, module, exports) {
          var has = require('./$.has'),
              hide = require('./$.hide'),
              TAG = require('./$.wks')('toStringTag');
          module.exports = function(it, tag, stat) {
            if (it && !has(it = stat ? it : it.prototype, TAG))
              hide(it, TAG, tag);
          };
        }, {
          "./$.has": 250,
          "./$.hide": 251,
          "./$.wks": 299
        }],
        291: [function(require, module, exports) {
          'use strict';
          var ctx = require('./$.ctx'),
              invoke = require('./$.invoke'),
              html = require('./$.html'),
              cel = require('./$.dom-create'),
              global = require('./$.global'),
              process = global.process,
              setTask = global.setImmediate,
              clearTask = global.clearImmediate,
              MessageChannel = global.MessageChannel,
              counter = 0,
              queue = {},
              ONREADYSTATECHANGE = 'onreadystatechange',
              defer,
              channel,
              port;
          var run = function() {
            var id = +this;
            if (queue.hasOwnProperty(id)) {
              var fn = queue[id];
              delete queue[id];
              fn();
            }
          };
          var listner = function(event) {
            run.call(event.data);
          };
          if (!setTask || !clearTask) {
            setTask = function setImmediate(fn) {
              var args = [],
                  i = 1;
              while (arguments.length > i)
                args.push(arguments[i++]);
              queue[++counter] = function() {
                invoke(typeof fn == 'function' ? fn : Function(fn), args);
              };
              defer(counter);
              return counter;
            };
            clearTask = function clearImmediate(id) {
              delete queue[id];
            };
            if (require('./$.cof')(process) == 'process') {
              defer = function(id) {
                process.nextTick(ctx(run, id, 1));
              };
            } else if (MessageChannel) {
              channel = new MessageChannel;
              port = channel.port2;
              channel.port1.onmessage = listner;
              defer = ctx(port.postMessage, port, 1);
            } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScript) {
              defer = function(id) {
                global.postMessage(id + '', '*');
              };
              global.addEventListener('message', listner, false);
            } else if (ONREADYSTATECHANGE in cel('script')) {
              defer = function(id) {
                html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
                  html.removeChild(this);
                  run.call(id);
                };
              };
            } else {
              defer = function(id) {
                setTimeout(ctx(run, id, 1), 0);
              };
            }
          }
          module.exports = {
            set: setTask,
            clear: clearTask
          };
        }, {
          "./$.cof": 232,
          "./$.ctx": 238,
          "./$.dom-create": 241,
          "./$.global": 249,
          "./$.html": 252,
          "./$.invoke": 253
        }],
        292: [function(require, module, exports) {
          var toInteger = require('./$.to-integer'),
              max = Math.max,
              min = Math.min;
          module.exports = function(index, length) {
            index = toInteger(index);
            return index < 0 ? max(index + length, 0) : min(index, length);
          };
        }, {"./$.to-integer": 293}],
        293: [function(require, module, exports) {
          var ceil = Math.ceil,
              floor = Math.floor;
          module.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
          };
        }, {}],
        294: [function(require, module, exports) {
          var IObject = require('./$.iobject'),
              defined = require('./$.defined');
          module.exports = function(it) {
            return IObject(defined(it));
          };
        }, {
          "./$.defined": 240,
          "./$.iobject": 254
        }],
        295: [function(require, module, exports) {
          var toInteger = require('./$.to-integer'),
              min = Math.min;
          module.exports = function(it) {
            return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
          };
        }, {"./$.to-integer": 293}],
        296: [function(require, module, exports) {
          var defined = require('./$.defined');
          module.exports = function(it) {
            return Object(defined(it));
          };
        }, {"./$.defined": 240}],
        297: [function(require, module, exports) {
          var id = 0,
              px = Math.random();
          module.exports = function(key) {
            return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
          };
        }, {}],
        298: [function(require, module, exports) {
          var UNSCOPABLES = require('./$.wks')('unscopables');
          if (!(UNSCOPABLES in []))
            require('./$.hide')(Array.prototype, UNSCOPABLES, {});
          module.exports = function(key) {
            [][UNSCOPABLES][key] = true;
          };
        }, {
          "./$.hide": 251,
          "./$.wks": 299
        }],
        299: [function(require, module, exports) {
          var store = require('./$.shared')('wks'),
              Symbol = require('./$.global').Symbol;
          module.exports = function(name) {
            return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || require('./$.uid'))('Symbol.' + name));
          };
        }, {
          "./$.global": 249,
          "./$.shared": 280,
          "./$.uid": 297
        }],
        300: [function(require, module, exports) {
          var classof = require('./$.classof'),
              ITERATOR = require('./$.wks')('iterator'),
              Iterators = require('./$.iterators');
          module.exports = require('./$.core').getIteratorMethod = function(it) {
            if (it != undefined)
              return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
          };
        }, {
          "./$.classof": 231,
          "./$.core": 237,
          "./$.iterators": 263,
          "./$.wks": 299
        }],
        301: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              SUPPORT_DESC = require('./$.support-desc'),
              createDesc = require('./$.property-desc'),
              html = require('./$.html'),
              cel = require('./$.dom-create'),
              has = require('./$.has'),
              cof = require('./$.cof'),
              $def = require('./$.def'),
              invoke = require('./$.invoke'),
              arrayMethod = require('./$.array-methods'),
              IE_PROTO = require('./$.uid')('__proto__'),
              isObject = require('./$.is-object'),
              anObject = require('./$.an-object'),
              aFunction = require('./$.a-function'),
              toObject = require('./$.to-object'),
              toIObject = require('./$.to-iobject'),
              toInteger = require('./$.to-integer'),
              toIndex = require('./$.to-index'),
              toLength = require('./$.to-length'),
              IObject = require('./$.iobject'),
              fails = require('./$.fails'),
              ObjectProto = Object.prototype,
              A = [],
              _slice = A.slice,
              _join = A.join,
              defineProperty = $.setDesc,
              getOwnDescriptor = $.getDesc,
              defineProperties = $.setDescs,
              $indexOf = require('./$.array-includes')(false),
              factories = {},
              IE8_DOM_DEFINE;
          if (!SUPPORT_DESC) {
            IE8_DOM_DEFINE = !fails(function() {
              return defineProperty(cel('div'), 'a', {get: function() {
                  return 7;
                }}).a != 7;
            });
            $.setDesc = function(O, P, Attributes) {
              if (IE8_DOM_DEFINE)
                try {
                  return defineProperty(O, P, Attributes);
                } catch (e) {}
              if ('get' in Attributes || 'set' in Attributes)
                throw TypeError('Accessors not supported!');
              if ('value' in Attributes)
                anObject(O)[P] = Attributes.value;
              return O;
            };
            $.getDesc = function(O, P) {
              if (IE8_DOM_DEFINE)
                try {
                  return getOwnDescriptor(O, P);
                } catch (e) {}
              if (has(O, P))
                return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
            };
            $.setDescs = defineProperties = function(O, Properties) {
              anObject(O);
              var keys = $.getKeys(Properties),
                  length = keys.length,
                  i = 0,
                  P;
              while (length > i)
                $.setDesc(O, P = keys[i++], Properties[P]);
              return O;
            };
          }
          $def($def.S + $def.F * !SUPPORT_DESC, 'Object', {
            getOwnPropertyDescriptor: $.getDesc,
            defineProperty: $.setDesc,
            defineProperties: defineProperties
          });
          var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' + 'toLocaleString,toString,valueOf').split(','),
              keys2 = keys1.concat('length', 'prototype'),
              keysLen1 = keys1.length;
          var createDict = function() {
            var iframe = cel('iframe'),
                i = keysLen1,
                gt = '>',
                iframeDocument;
            iframe.style.display = 'none';
            html.appendChild(iframe);
            iframe.src = 'javascript:';
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write('<script>document.F=Object</script' + gt);
            iframeDocument.close();
            createDict = iframeDocument.F;
            while (i--)
              delete createDict.prototype[keys1[i]];
            return createDict();
          };
          var createGetKeys = function(names, length) {
            return function(object) {
              var O = toIObject(object),
                  i = 0,
                  result = [],
                  key;
              for (key in O)
                if (key != IE_PROTO)
                  has(O, key) && result.push(key);
              while (length > i)
                if (has(O, key = names[i++])) {
                  ~$indexOf(result, key) || result.push(key);
                }
              return result;
            };
          };
          var Empty = function() {};
          $def($def.S, 'Object', {
            getPrototypeOf: $.getProto = $.getProto || function(O) {
              O = toObject(O);
              if (has(O, IE_PROTO))
                return O[IE_PROTO];
              if (typeof O.constructor == 'function' && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectProto : null;
            },
            getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
            create: $.create = $.create || function(O, Properties) {
              var result;
              if (O !== null) {
                Empty.prototype = anObject(O);
                result = new Empty();
                Empty.prototype = null;
                result[IE_PROTO] = O;
              } else
                result = createDict();
              return Properties === undefined ? result : defineProperties(result, Properties);
            },
            keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
          });
          var construct = function(F, len, args) {
            if (!(len in factories)) {
              for (var n = [],
                  i = 0; i < len; i++)
                n[i] = 'a[' + i + ']';
              factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
            }
            return factories[len](F, args);
          };
          $def($def.P, 'Function', {bind: function bind(that) {
              var fn = aFunction(this),
                  partArgs = _slice.call(arguments, 1);
              var bound = function() {
                var args = partArgs.concat(_slice.call(arguments));
                return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
              };
              if (isObject(fn.prototype))
                bound.prototype = fn.prototype;
              return bound;
            }});
          var buggySlice = fails(function() {
            if (html)
              _slice.call(html);
          });
          $def($def.P + $def.F * buggySlice, 'Array', {slice: function(begin, end) {
              var len = toLength(this.length),
                  klass = cof(this);
              end = end === undefined ? len : end;
              if (klass == 'Array')
                return _slice.call(this, begin, end);
              var start = toIndex(begin, len),
                  upTo = toIndex(end, len),
                  size = toLength(upTo - start),
                  cloned = Array(size),
                  i = 0;
              for (; i < size; i++)
                cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
              return cloned;
            }});
          $def($def.P + $def.F * (IObject != Object), 'Array', {join: function() {
              return _join.apply(IObject(this), arguments);
            }});
          $def($def.S, 'Array', {isArray: function(arg) {
              return cof(arg) == 'Array';
            }});
          var createArrayReduce = function(isRight) {
            return function(callbackfn, memo) {
              aFunction(callbackfn);
              var O = IObject(this),
                  length = toLength(O.length),
                  index = isRight ? length - 1 : 0,
                  i = isRight ? -1 : 1;
              if (arguments.length < 2)
                for (; ; ) {
                  if (index in O) {
                    memo = O[index];
                    index += i;
                    break;
                  }
                  index += i;
                  if (isRight ? index < 0 : length <= index) {
                    throw TypeError('Reduce of empty array with no initial value');
                  }
                }
              for (; isRight ? index >= 0 : length > index; index += i)
                if (index in O) {
                  memo = callbackfn(memo, O[index], index, this);
                }
              return memo;
            };
          };
          var methodize = function($fn) {
            return function(arg1) {
              return $fn(this, arg1, arguments[1]);
            };
          };
          $def($def.P, 'Array', {
            forEach: $.each = $.each || methodize(arrayMethod(0)),
            map: methodize(arrayMethod(1)),
            filter: methodize(arrayMethod(2)),
            some: methodize(arrayMethod(3)),
            every: methodize(arrayMethod(4)),
            reduce: createArrayReduce(false),
            reduceRight: createArrayReduce(true),
            indexOf: methodize($indexOf),
            lastIndexOf: function(el, fromIndex) {
              var O = toIObject(this),
                  length = toLength(O.length),
                  index = length - 1;
              if (arguments.length > 1)
                index = Math.min(index, toInteger(fromIndex));
              if (index < 0)
                index = toLength(length + index);
              for (; index >= 0; index--)
                if (index in O)
                  if (O[index] === el)
                    return index;
              return -1;
            }
          });
          $def($def.S, 'Date', {now: function() {
              return +new Date;
            }});
          var lz = function(num) {
            return num > 9 ? num : '0' + num;
          };
          var date = new Date(-5e13 - 1),
              brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z' && fails(function() {
                new Date(NaN).toISOString();
              }));
          $def($def.P + $def.F * brokenDate, 'Date', {toISOString: function toISOString() {
              if (!isFinite(this))
                throw RangeError('Invalid time value');
              var d = this,
                  y = d.getUTCFullYear(),
                  m = d.getUTCMilliseconds(),
                  s = y < 0 ? '-' : y > 9999 ? '+' : '';
              return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
            }});
        }, {
          "./$": 264,
          "./$.a-function": 226,
          "./$.an-object": 227,
          "./$.array-includes": 228,
          "./$.array-methods": 229,
          "./$.cof": 232,
          "./$.def": 239,
          "./$.dom-create": 241,
          "./$.fails": 244,
          "./$.has": 250,
          "./$.html": 252,
          "./$.invoke": 253,
          "./$.iobject": 254,
          "./$.is-object": 257,
          "./$.property-desc": 275,
          "./$.support-desc": 289,
          "./$.to-index": 292,
          "./$.to-integer": 293,
          "./$.to-iobject": 294,
          "./$.to-length": 295,
          "./$.to-object": 296,
          "./$.uid": 297
        }],
        302: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              toObject = require('./$.to-object'),
              toIndex = require('./$.to-index'),
              toLength = require('./$.to-length');
          $def($def.P, 'Array', {copyWithin: function copyWithin(target, start) {
              var O = toObject(this),
                  len = toLength(O.length),
                  to = toIndex(target, len),
                  from = toIndex(start, len),
                  end = arguments[2],
                  fin = end === undefined ? len : toIndex(end, len),
                  count = Math.min(fin - from, len - to),
                  inc = 1;
              if (from < to && to < from + count) {
                inc = -1;
                from = from + count - 1;
                to = to + count - 1;
              }
              while (count-- > 0) {
                if (from in O)
                  O[to] = O[from];
                else
                  delete O[to];
                to += inc;
                from += inc;
              }
              return O;
            }});
          require('./$.unscope')('copyWithin');
        }, {
          "./$.def": 239,
          "./$.to-index": 292,
          "./$.to-length": 295,
          "./$.to-object": 296,
          "./$.unscope": 298
        }],
        303: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              toObject = require('./$.to-object'),
              toIndex = require('./$.to-index'),
              toLength = require('./$.to-length');
          $def($def.P, 'Array', {fill: function fill(value) {
              var O = toObject(this, true),
                  length = toLength(O.length),
                  index = toIndex(arguments[1], length),
                  end = arguments[2],
                  endPos = end === undefined ? length : toIndex(end, length);
              while (endPos > index)
                O[index++] = value;
              return O;
            }});
          require('./$.unscope')('fill');
        }, {
          "./$.def": 239,
          "./$.to-index": 292,
          "./$.to-length": 295,
          "./$.to-object": 296,
          "./$.unscope": 298
        }],
        304: [function(require, module, exports) {
          'use strict';
          var KEY = 'findIndex',
              $def = require('./$.def'),
              forced = true,
              $find = require('./$.array-methods')(6);
          if (KEY in [])
            Array(1)[KEY](function() {
              forced = false;
            });
          $def($def.P + $def.F * forced, 'Array', {findIndex: function findIndex(callbackfn) {
              return $find(this, callbackfn, arguments[1]);
            }});
          require('./$.unscope')(KEY);
        }, {
          "./$.array-methods": 229,
          "./$.def": 239,
          "./$.unscope": 298
        }],
        305: [function(require, module, exports) {
          'use strict';
          var KEY = 'find',
              $def = require('./$.def'),
              forced = true,
              $find = require('./$.array-methods')(5);
          if (KEY in [])
            Array(1)[KEY](function() {
              forced = false;
            });
          $def($def.P + $def.F * forced, 'Array', {find: function find(callbackfn) {
              return $find(this, callbackfn, arguments[1]);
            }});
          require('./$.unscope')(KEY);
        }, {
          "./$.array-methods": 229,
          "./$.def": 239,
          "./$.unscope": 298
        }],
        306: [function(require, module, exports) {
          'use strict';
          var ctx = require('./$.ctx'),
              $def = require('./$.def'),
              toObject = require('./$.to-object'),
              call = require('./$.iter-call'),
              isArrayIter = require('./$.is-array-iter'),
              toLength = require('./$.to-length'),
              getIterFn = require('./core.get-iterator-method');
          $def($def.S + $def.F * !require('./$.iter-detect')(function(iter) {
            Array.from(iter);
          }), 'Array', {from: function from(arrayLike) {
              var O = toObject(arrayLike),
                  C = typeof this == 'function' ? this : Array,
                  mapfn = arguments[1],
                  mapping = mapfn !== undefined,
                  index = 0,
                  iterFn = getIterFn(O),
                  length,
                  result,
                  step,
                  iterator;
              if (mapping)
                mapfn = ctx(mapfn, arguments[2], 2);
              if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
                for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
                  result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
                }
              } else {
                for (result = new C(length = toLength(O.length)); length > index; index++) {
                  result[index] = mapping ? mapfn(O[index], index) : O[index];
                }
              }
              result.length = index;
              return result;
            }});
        }, {
          "./$.ctx": 238,
          "./$.def": 239,
          "./$.is-array-iter": 255,
          "./$.iter-call": 258,
          "./$.iter-detect": 261,
          "./$.to-length": 295,
          "./$.to-object": 296,
          "./core.get-iterator-method": 300
        }],
        307: [function(require, module, exports) {
          'use strict';
          var setUnscope = require('./$.unscope'),
              step = require('./$.iter-step'),
              Iterators = require('./$.iterators'),
              toIObject = require('./$.to-iobject');
          require('./$.iter-define')(Array, 'Array', function(iterated, kind) {
            this._t = toIObject(iterated);
            this._i = 0;
            this._k = kind;
          }, function() {
            var O = this._t,
                kind = this._k,
                index = this._i++;
            if (!O || index >= O.length) {
              this._t = undefined;
              return step(1);
            }
            if (kind == 'keys')
              return step(0, index);
            if (kind == 'values')
              return step(0, O[index]);
            return step(0, [index, O[index]]);
          }, 'values');
          Iterators.Arguments = Iterators.Array;
          setUnscope('keys');
          setUnscope('values');
          setUnscope('entries');
        }, {
          "./$.iter-define": 260,
          "./$.iter-step": 262,
          "./$.iterators": 263,
          "./$.to-iobject": 294,
          "./$.unscope": 298
        }],
        308: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def');
          $def($def.S + $def.F * require('./$.fails')(function() {
            function F() {}
            return !(Array.of.call(F) instanceof F);
          }), 'Array', {of: function of() {
              var index = 0,
                  length = arguments.length,
                  result = new (typeof this == 'function' ? this : Array)(length);
              while (length > index)
                result[index] = arguments[index++];
              result.length = length;
              return result;
            }});
        }, {
          "./$.def": 239,
          "./$.fails": 244
        }],
        309: [function(require, module, exports) {
          require('./$.species')(Array);
        }, {"./$.species": 282}],
        310: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              isObject = require('./$.is-object'),
              HAS_INSTANCE = require('./$.wks')('hasInstance'),
              FunctionProto = Function.prototype;
          if (!(HAS_INSTANCE in FunctionProto))
            $.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O) {
                if (typeof this != 'function' || !isObject(O))
                  return false;
                if (!isObject(this.prototype))
                  return O instanceof this;
                while (O = $.getProto(O))
                  if (this.prototype === O)
                    return true;
                return false;
              }});
        }, {
          "./$": 264,
          "./$.is-object": 257,
          "./$.wks": 299
        }],
        311: [function(require, module, exports) {
          var setDesc = require('./$').setDesc,
              createDesc = require('./$.property-desc'),
              has = require('./$.has'),
              FProto = Function.prototype,
              nameRE = /^\s*function ([^ (]*)/,
              NAME = 'name';
          NAME in FProto || require('./$.support-desc') && setDesc(FProto, NAME, {
            configurable: true,
            get: function() {
              var match = ('' + this).match(nameRE),
                  name = match ? match[1] : '';
              has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
              return name;
            }
          });
        }, {
          "./$": 264,
          "./$.has": 250,
          "./$.property-desc": 275,
          "./$.support-desc": 289
        }],
        312: [function(require, module, exports) {
          'use strict';
          var strong = require('./$.collection-strong');
          require('./$.collection')('Map', function(get) {
            return function Map() {
              return get(this, arguments[0]);
            };
          }, {
            get: function get(key) {
              var entry = strong.getEntry(this, key);
              return entry && entry.v;
            },
            set: function set(key, value) {
              return strong.def(this, key === 0 ? 0 : key, value);
            }
          }, strong, true);
        }, {
          "./$.collection": 236,
          "./$.collection-strong": 233
        }],
        313: [function(require, module, exports) {
          var $def = require('./$.def'),
              log1p = require('./$.log1p'),
              sqrt = Math.sqrt,
              $acosh = Math.acosh;
          $def($def.S + $def.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {acosh: function acosh(x) {
              return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
            }});
        }, {
          "./$.def": 239,
          "./$.log1p": 267
        }],
        314: [function(require, module, exports) {
          var $def = require('./$.def');
          function asinh(x) {
            return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
          }
          $def($def.S, 'Math', {asinh: asinh});
        }, {"./$.def": 239}],
        315: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Math', {atanh: function atanh(x) {
              return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
            }});
        }, {"./$.def": 239}],
        316: [function(require, module, exports) {
          var $def = require('./$.def'),
              sign = require('./$.sign');
          $def($def.S, 'Math', {cbrt: function cbrt(x) {
              return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
            }});
        }, {
          "./$.def": 239,
          "./$.sign": 281
        }],
        317: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Math', {clz32: function clz32(x) {
              return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
            }});
        }, {"./$.def": 239}],
        318: [function(require, module, exports) {
          var $def = require('./$.def'),
              exp = Math.exp;
          $def($def.S, 'Math', {cosh: function cosh(x) {
              return (exp(x = +x) + exp(-x)) / 2;
            }});
        }, {"./$.def": 239}],
        319: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Math', {expm1: require('./$.expm1')});
        }, {
          "./$.def": 239,
          "./$.expm1": 243
        }],
        320: [function(require, module, exports) {
          var $def = require('./$.def'),
              sign = require('./$.sign'),
              pow = Math.pow,
              EPSILON = pow(2, -52),
              EPSILON32 = pow(2, -23),
              MAX32 = pow(2, 127) * (2 - EPSILON32),
              MIN32 = pow(2, -126);
          var roundTiesToEven = function(n) {
            return n + 1 / EPSILON - 1 / EPSILON;
          };
          $def($def.S, 'Math', {fround: function fround(x) {
              var $abs = Math.abs(x),
                  $sign = sign(x),
                  a,
                  result;
              if ($abs < MIN32)
                return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
              a = (1 + EPSILON32 / EPSILON) * $abs;
              result = a - (a - $abs);
              if (result > MAX32 || result != result)
                return $sign * Infinity;
              return $sign * result;
            }});
        }, {
          "./$.def": 239,
          "./$.sign": 281
        }],
        321: [function(require, module, exports) {
          var $def = require('./$.def'),
              abs = Math.abs;
          $def($def.S, 'Math', {hypot: function hypot(value1, value2) {
              var sum = 0,
                  i = 0,
                  len = arguments.length,
                  larg = 0,
                  arg,
                  div;
              while (i < len) {
                arg = abs(arguments[i++]);
                if (larg < arg) {
                  div = larg / arg;
                  sum = sum * div * div + 1;
                  larg = arg;
                } else if (arg > 0) {
                  div = arg / larg;
                  sum += div * div;
                } else
                  sum += arg;
              }
              return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
            }});
        }, {"./$.def": 239}],
        322: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S + $def.F * require('./$.fails')(function() {
            return Math.imul(0xffffffff, 5) != -5;
          }), 'Math', {imul: function imul(x, y) {
              var UINT16 = 0xffff,
                  xn = +x,
                  yn = +y,
                  xl = UINT16 & xn,
                  yl = UINT16 & yn;
              return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
            }});
        }, {
          "./$.def": 239,
          "./$.fails": 244
        }],
        323: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Math', {log10: function log10(x) {
              return Math.log(x) / Math.LN10;
            }});
        }, {"./$.def": 239}],
        324: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Math', {log1p: require('./$.log1p')});
        }, {
          "./$.def": 239,
          "./$.log1p": 267
        }],
        325: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Math', {log2: function log2(x) {
              return Math.log(x) / Math.LN2;
            }});
        }, {"./$.def": 239}],
        326: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Math', {sign: require('./$.sign')});
        }, {
          "./$.def": 239,
          "./$.sign": 281
        }],
        327: [function(require, module, exports) {
          var $def = require('./$.def'),
              expm1 = require('./$.expm1'),
              exp = Math.exp;
          $def($def.S, 'Math', {sinh: function sinh(x) {
              return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
            }});
        }, {
          "./$.def": 239,
          "./$.expm1": 243
        }],
        328: [function(require, module, exports) {
          var $def = require('./$.def'),
              expm1 = require('./$.expm1'),
              exp = Math.exp;
          $def($def.S, 'Math', {tanh: function tanh(x) {
              var a = expm1(x = +x),
                  b = expm1(-x);
              return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
            }});
        }, {
          "./$.def": 239,
          "./$.expm1": 243
        }],
        329: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Math', {trunc: function trunc(it) {
              return (it > 0 ? Math.floor : Math.ceil)(it);
            }});
        }, {"./$.def": 239}],
        330: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              global = require('./$.global'),
              has = require('./$.has'),
              cof = require('./$.cof'),
              isObject = require('./$.is-object'),
              fails = require('./$.fails'),
              NUMBER = 'Number',
              $Number = global[NUMBER],
              Base = $Number,
              proto = $Number.prototype,
              BROKEN_COF = cof($.create(proto)) == NUMBER;
          var toPrimitive = function(it) {
            var fn,
                val;
            if (typeof(fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))
              return val;
            if (typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
              return val;
            throw TypeError("Can't convert object to number");
          };
          var toNumber = function(it) {
            if (isObject(it))
              it = toPrimitive(it);
            if (typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48) {
              var binary = false;
              switch (it.charCodeAt(1)) {
                case 66:
                case 98:
                  binary = true;
                case 79:
                case 111:
                  return parseInt(it.slice(2), binary ? 2 : 8);
              }
            }
            return +it;
          };
          if (!($Number('0o1') && $Number('0b1'))) {
            $Number = function Number(it) {
              var that = this;
              return that instanceof $Number && (BROKEN_COF ? fails(function() {
                proto.valueOf.call(that);
              }) : cof(that) != NUMBER) ? new Base(toNumber(it)) : toNumber(it);
            };
            $.each.call(require('./$.support-desc') ? $.getNames(Base) : ('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), function(key) {
              if (has(Base, key) && !has($Number, key)) {
                $.setDesc($Number, key, $.getDesc(Base, key));
              }
            });
            $Number.prototype = proto;
            proto.constructor = $Number;
            require('./$.redef')(global, NUMBER, $Number);
          }
        }, {
          "./$": 264,
          "./$.cof": 232,
          "./$.fails": 244,
          "./$.global": 249,
          "./$.has": 250,
          "./$.is-object": 257,
          "./$.redef": 276,
          "./$.support-desc": 289
        }],
        331: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Number', {EPSILON: Math.pow(2, -52)});
        }, {"./$.def": 239}],
        332: [function(require, module, exports) {
          var $def = require('./$.def'),
              _isFinite = require('./$.global').isFinite;
          $def($def.S, 'Number', {isFinite: function isFinite(it) {
              return typeof it == 'number' && _isFinite(it);
            }});
        }, {
          "./$.def": 239,
          "./$.global": 249
        }],
        333: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Number', {isInteger: require('./$.is-integer')});
        }, {
          "./$.def": 239,
          "./$.is-integer": 256
        }],
        334: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Number', {isNaN: function isNaN(number) {
              return number != number;
            }});
        }, {"./$.def": 239}],
        335: [function(require, module, exports) {
          var $def = require('./$.def'),
              isInteger = require('./$.is-integer'),
              abs = Math.abs;
          $def($def.S, 'Number', {isSafeInteger: function isSafeInteger(number) {
              return isInteger(number) && abs(number) <= 0x1fffffffffffff;
            }});
        }, {
          "./$.def": 239,
          "./$.is-integer": 256
        }],
        336: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
        }, {"./$.def": 239}],
        337: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
        }, {"./$.def": 239}],
        338: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Number', {parseFloat: parseFloat});
        }, {"./$.def": 239}],
        339: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Number', {parseInt: parseInt});
        }, {"./$.def": 239}],
        340: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S + $def.F, 'Object', {assign: require('./$.assign')});
        }, {
          "./$.assign": 230,
          "./$.def": 239
        }],
        341: [function(require, module, exports) {
          var isObject = require('./$.is-object');
          require('./$.object-sap')('freeze', function($freeze) {
            return function freeze(it) {
              return $freeze && isObject(it) ? $freeze(it) : it;
            };
          });
        }, {
          "./$.is-object": 257,
          "./$.object-sap": 270
        }],
        342: [function(require, module, exports) {
          var toIObject = require('./$.to-iobject');
          require('./$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
            return function getOwnPropertyDescriptor(it, key) {
              return $getOwnPropertyDescriptor(toIObject(it), key);
            };
          });
        }, {
          "./$.object-sap": 270,
          "./$.to-iobject": 294
        }],
        343: [function(require, module, exports) {
          require('./$.object-sap')('getOwnPropertyNames', function() {
            return require('./$.get-names').get;
          });
        }, {
          "./$.get-names": 248,
          "./$.object-sap": 270
        }],
        344: [function(require, module, exports) {
          var toObject = require('./$.to-object');
          require('./$.object-sap')('getPrototypeOf', function($getPrototypeOf) {
            return function getPrototypeOf(it) {
              return $getPrototypeOf(toObject(it));
            };
          });
        }, {
          "./$.object-sap": 270,
          "./$.to-object": 296
        }],
        345: [function(require, module, exports) {
          var isObject = require('./$.is-object');
          require('./$.object-sap')('isExtensible', function($isExtensible) {
            return function isExtensible(it) {
              return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
            };
          });
        }, {
          "./$.is-object": 257,
          "./$.object-sap": 270
        }],
        346: [function(require, module, exports) {
          var isObject = require('./$.is-object');
          require('./$.object-sap')('isFrozen', function($isFrozen) {
            return function isFrozen(it) {
              return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
            };
          });
        }, {
          "./$.is-object": 257,
          "./$.object-sap": 270
        }],
        347: [function(require, module, exports) {
          var isObject = require('./$.is-object');
          require('./$.object-sap')('isSealed', function($isSealed) {
            return function isSealed(it) {
              return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
            };
          });
        }, {
          "./$.is-object": 257,
          "./$.object-sap": 270
        }],
        348: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Object', {is: require('./$.same')});
        }, {
          "./$.def": 239,
          "./$.same": 278
        }],
        349: [function(require, module, exports) {
          var toObject = require('./$.to-object');
          require('./$.object-sap')('keys', function($keys) {
            return function keys(it) {
              return $keys(toObject(it));
            };
          });
        }, {
          "./$.object-sap": 270,
          "./$.to-object": 296
        }],
        350: [function(require, module, exports) {
          var isObject = require('./$.is-object');
          require('./$.object-sap')('preventExtensions', function($preventExtensions) {
            return function preventExtensions(it) {
              return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
            };
          });
        }, {
          "./$.is-object": 257,
          "./$.object-sap": 270
        }],
        351: [function(require, module, exports) {
          var isObject = require('./$.is-object');
          require('./$.object-sap')('seal', function($seal) {
            return function seal(it) {
              return $seal && isObject(it) ? $seal(it) : it;
            };
          });
        }, {
          "./$.is-object": 257,
          "./$.object-sap": 270
        }],
        352: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
        }, {
          "./$.def": 239,
          "./$.set-proto": 279
        }],
        353: [function(require, module, exports) {
          'use strict';
          var classof = require('./$.classof'),
              test = {};
          test[require('./$.wks')('toStringTag')] = 'z';
          if (test + '' != '[object z]') {
            require('./$.redef')(Object.prototype, 'toString', function toString() {
              return '[object ' + classof(this) + ']';
            }, true);
          }
        }, {
          "./$.classof": 231,
          "./$.redef": 276,
          "./$.wks": 299
        }],
        354: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              LIBRARY = require('./$.library'),
              global = require('./$.global'),
              ctx = require('./$.ctx'),
              classof = require('./$.classof'),
              $def = require('./$.def'),
              isObject = require('./$.is-object'),
              anObject = require('./$.an-object'),
              aFunction = require('./$.a-function'),
              strictNew = require('./$.strict-new'),
              forOf = require('./$.for-of'),
              setProto = require('./$.set-proto').set,
              same = require('./$.same'),
              species = require('./$.species'),
              SPECIES = require('./$.wks')('species'),
              RECORD = require('./$.uid')('record'),
              asap = require('./$.microtask'),
              PROMISE = 'Promise',
              process = global.process,
              isNode = classof(process) == 'process',
              P = global[PROMISE],
              Wrapper;
          var testResolve = function(sub) {
            var test = new P(function() {});
            if (sub)
              test.constructor = Object;
            return P.resolve(test) === test;
          };
          var useNative = function() {
            var works = false;
            function P2(x) {
              var self = new P(x);
              setProto(self, P2.prototype);
              return self;
            }
            try {
              works = P && P.resolve && testResolve();
              setProto(P2, P);
              P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
              if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
                works = false;
              }
              if (works && require('./$.support-desc')) {
                var thenableThenGotten = false;
                P.resolve($.setDesc({}, 'then', {get: function() {
                    thenableThenGotten = true;
                  }}));
                works = thenableThenGotten;
              }
            } catch (e) {
              works = false;
            }
            return works;
          }();
          var isPromise = function(it) {
            return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
          };
          var sameConstructor = function(a, b) {
            if (LIBRARY && a === P && b === Wrapper)
              return true;
            return same(a, b);
          };
          var getConstructor = function(C) {
            var S = anObject(C)[SPECIES];
            return S != undefined ? S : C;
          };
          var isThenable = function(it) {
            var then;
            return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
          };
          var notify = function(record, isReject) {
            if (record.n)
              return;
            record.n = true;
            var chain = record.c;
            asap(function() {
              var value = record.v,
                  ok = record.s == 1,
                  i = 0;
              var run = function(react) {
                var cb = ok ? react.ok : react.fail,
                    ret,
                    then;
                try {
                  if (cb) {
                    if (!ok)
                      record.h = true;
                    ret = cb === true ? value : cb(value);
                    if (ret === react.P) {
                      react.rej(TypeError('Promise-chain cycle'));
                    } else if (then = isThenable(ret)) {
                      then.call(ret, react.res, react.rej);
                    } else
                      react.res(ret);
                  } else
                    react.rej(value);
                } catch (err) {
                  react.rej(err);
                }
              };
              while (chain.length > i)
                run(chain[i++]);
              chain.length = 0;
              record.n = false;
              if (isReject)
                setTimeout(function() {
                  if (isUnhandled(record.p)) {
                    if (isNode) {
                      process.emit('unhandledRejection', value, record.p);
                    } else if (global.console && console.error) {
                      console.error('Unhandled promise rejection', value);
                    }
                  }
                  record.a = undefined;
                }, 1);
            });
          };
          var isUnhandled = function(promise) {
            var record = promise[RECORD],
                chain = record.a || record.c,
                i = 0,
                react;
            if (record.h)
              return false;
            while (chain.length > i) {
              react = chain[i++];
              if (react.fail || !isUnhandled(react.P))
                return false;
            }
            return true;
          };
          var $reject = function(value) {
            var record = this;
            if (record.d)
              return;
            record.d = true;
            record = record.r || record;
            record.v = value;
            record.s = 2;
            record.a = record.c.slice();
            notify(record, true);
          };
          var $resolve = function(value) {
            var record = this,
                then;
            if (record.d)
              return;
            record.d = true;
            record = record.r || record;
            try {
              if (then = isThenable(value)) {
                asap(function() {
                  var wrapper = {
                    r: record,
                    d: false
                  };
                  try {
                    then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
                  } catch (e) {
                    $reject.call(wrapper, e);
                  }
                });
              } else {
                record.v = value;
                record.s = 1;
                notify(record, false);
              }
            } catch (e) {
              $reject.call({
                r: record,
                d: false
              }, e);
            }
          };
          if (!useNative) {
            P = function Promise(executor) {
              aFunction(executor);
              var record = {
                p: strictNew(this, P, PROMISE),
                c: [],
                a: undefined,
                s: 0,
                d: false,
                v: undefined,
                h: false,
                n: false
              };
              this[RECORD] = record;
              try {
                executor(ctx($resolve, record, 1), ctx($reject, record, 1));
              } catch (err) {
                $reject.call(record, err);
              }
            };
            require('./$.mix')(P.prototype, {
              then: function then(onFulfilled, onRejected) {
                var S = anObject(anObject(this).constructor)[SPECIES];
                var react = {
                  ok: typeof onFulfilled == 'function' ? onFulfilled : true,
                  fail: typeof onRejected == 'function' ? onRejected : false
                };
                var promise = react.P = new (S != undefined ? S : P)(function(res, rej) {
                  react.res = aFunction(res);
                  react.rej = aFunction(rej);
                });
                var record = this[RECORD];
                record.c.push(react);
                if (record.a)
                  record.a.push(react);
                if (record.s)
                  notify(record, false);
                return promise;
              },
              'catch': function(onRejected) {
                return this.then(undefined, onRejected);
              }
            });
          }
          $def($def.G + $def.W + $def.F * !useNative, {Promise: P});
          require('./$.tag')(P, PROMISE);
          species(P);
          species(Wrapper = require('./$.core')[PROMISE]);
          $def($def.S + $def.F * !useNative, PROMISE, {reject: function reject(r) {
              return new this(function(res, rej) {
                rej(r);
              });
            }});
          $def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {resolve: function resolve(x) {
              return isPromise(x) && sameConstructor(x.constructor, this) ? x : new this(function(res) {
                res(x);
              });
            }});
          $def($def.S + $def.F * !(useNative && require('./$.iter-detect')(function(iter) {
            P.all(iter)['catch'](function() {});
          })), PROMISE, {
            all: function all(iterable) {
              var C = getConstructor(this),
                  values = [];
              return new C(function(res, rej) {
                forOf(iterable, false, values.push, values);
                var remaining = values.length,
                    results = Array(remaining);
                if (remaining)
                  $.each.call(values, function(promise, index) {
                    C.resolve(promise).then(function(value) {
                      results[index] = value;
                      --remaining || res(results);
                    }, rej);
                  });
                else
                  res(results);
              });
            },
            race: function race(iterable) {
              var C = getConstructor(this);
              return new C(function(res, rej) {
                forOf(iterable, false, function(promise) {
                  C.resolve(promise).then(res, rej);
                });
              });
            }
          });
        }, {
          "./$": 264,
          "./$.a-function": 226,
          "./$.an-object": 227,
          "./$.classof": 231,
          "./$.core": 237,
          "./$.ctx": 238,
          "./$.def": 239,
          "./$.for-of": 247,
          "./$.global": 249,
          "./$.is-object": 257,
          "./$.iter-detect": 261,
          "./$.library": 266,
          "./$.microtask": 268,
          "./$.mix": 269,
          "./$.same": 278,
          "./$.set-proto": 279,
          "./$.species": 282,
          "./$.strict-new": 283,
          "./$.support-desc": 289,
          "./$.tag": 290,
          "./$.uid": 297,
          "./$.wks": 299
        }],
        355: [function(require, module, exports) {
          var $def = require('./$.def'),
              _apply = Function.apply;
          $def($def.S, 'Reflect', {apply: function apply(target, thisArgument, argumentsList) {
              return _apply.call(target, thisArgument, argumentsList);
            }});
        }, {"./$.def": 239}],
        356: [function(require, module, exports) {
          var $ = require('./$'),
              $def = require('./$.def'),
              aFunction = require('./$.a-function'),
              anObject = require('./$.an-object'),
              isObject = require('./$.is-object'),
              bind = Function.bind || require('./$.core').Function.prototype.bind;
          $def($def.S + $def.F * require('./$.fails')(function() {
            function F() {}
            return !(Reflect.construct(function() {}, [], F) instanceof F);
          }), 'Reflect', {construct: function construct(Target, args) {
              aFunction(Target);
              var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
              if (Target == newTarget) {
                if (args != undefined)
                  switch (anObject(args).length) {
                    case 0:
                      return new Target;
                    case 1:
                      return new Target(args[0]);
                    case 2:
                      return new Target(args[0], args[1]);
                    case 3:
                      return new Target(args[0], args[1], args[2]);
                    case 4:
                      return new Target(args[0], args[1], args[2], args[3]);
                  }
                var $args = [null];
                $args.push.apply($args, args);
                return new (bind.apply(Target, $args));
              }
              var proto = newTarget.prototype,
                  instance = $.create(isObject(proto) ? proto : Object.prototype),
                  result = Function.apply.call(Target, instance, args);
              return isObject(result) ? result : instance;
            }});
        }, {
          "./$": 264,
          "./$.a-function": 226,
          "./$.an-object": 227,
          "./$.core": 237,
          "./$.def": 239,
          "./$.fails": 244,
          "./$.is-object": 257
        }],
        357: [function(require, module, exports) {
          var $ = require('./$'),
              $def = require('./$.def'),
              anObject = require('./$.an-object');
          $def($def.S + $def.F * require('./$.fails')(function() {
            Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});
          }), 'Reflect', {defineProperty: function defineProperty(target, propertyKey, attributes) {
              anObject(target);
              try {
                $.setDesc(target, propertyKey, attributes);
                return true;
              } catch (e) {
                return false;
              }
            }});
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.def": 239,
          "./$.fails": 244
        }],
        358: [function(require, module, exports) {
          var $def = require('./$.def'),
              getDesc = require('./$').getDesc,
              anObject = require('./$.an-object');
          $def($def.S, 'Reflect', {deleteProperty: function deleteProperty(target, propertyKey) {
              var desc = getDesc(anObject(target), propertyKey);
              return desc && !desc.configurable ? false : delete target[propertyKey];
            }});
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.def": 239
        }],
        359: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              anObject = require('./$.an-object');
          var Enumerate = function(iterated) {
            this._t = anObject(iterated);
            this._i = 0;
            var keys = this._k = [],
                key;
            for (key in iterated)
              keys.push(key);
          };
          require('./$.iter-create')(Enumerate, 'Object', function() {
            var that = this,
                keys = that._k,
                key;
            do {
              if (that._i >= keys.length)
                return {
                  value: undefined,
                  done: true
                };
            } while (!((key = keys[that._i++]) in that._t));
            return {
              value: key,
              done: false
            };
          });
          $def($def.S, 'Reflect', {enumerate: function enumerate(target) {
              return new Enumerate(target);
            }});
        }, {
          "./$.an-object": 227,
          "./$.def": 239,
          "./$.iter-create": 259
        }],
        360: [function(require, module, exports) {
          var $ = require('./$'),
              $def = require('./$.def'),
              anObject = require('./$.an-object');
          $def($def.S, 'Reflect', {getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
              return $.getDesc(anObject(target), propertyKey);
            }});
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.def": 239
        }],
        361: [function(require, module, exports) {
          var $def = require('./$.def'),
              getProto = require('./$').getProto,
              anObject = require('./$.an-object');
          $def($def.S, 'Reflect', {getPrototypeOf: function getPrototypeOf(target) {
              return getProto(anObject(target));
            }});
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.def": 239
        }],
        362: [function(require, module, exports) {
          var $ = require('./$'),
              has = require('./$.has'),
              $def = require('./$.def'),
              isObject = require('./$.is-object'),
              anObject = require('./$.an-object');
          function get(target, propertyKey) {
            var receiver = arguments.length < 3 ? target : arguments[2],
                desc,
                proto;
            if (anObject(target) === receiver)
              return target[propertyKey];
            if (desc = $.getDesc(target, propertyKey))
              return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
            if (isObject(proto = $.getProto(target)))
              return get(proto, propertyKey, receiver);
          }
          $def($def.S, 'Reflect', {get: get});
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.def": 239,
          "./$.has": 250,
          "./$.is-object": 257
        }],
        363: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Reflect', {has: function has(target, propertyKey) {
              return propertyKey in target;
            }});
        }, {"./$.def": 239}],
        364: [function(require, module, exports) {
          var $def = require('./$.def'),
              anObject = require('./$.an-object'),
              $isExtensible = Object.isExtensible;
          $def($def.S, 'Reflect', {isExtensible: function isExtensible(target) {
              anObject(target);
              return $isExtensible ? $isExtensible(target) : true;
            }});
        }, {
          "./$.an-object": 227,
          "./$.def": 239
        }],
        365: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.S, 'Reflect', {ownKeys: require('./$.own-keys')});
        }, {
          "./$.def": 239,
          "./$.own-keys": 272
        }],
        366: [function(require, module, exports) {
          var $def = require('./$.def'),
              anObject = require('./$.an-object'),
              $preventExtensions = Object.preventExtensions;
          $def($def.S, 'Reflect', {preventExtensions: function preventExtensions(target) {
              anObject(target);
              try {
                if ($preventExtensions)
                  $preventExtensions(target);
                return true;
              } catch (e) {
                return false;
              }
            }});
        }, {
          "./$.an-object": 227,
          "./$.def": 239
        }],
        367: [function(require, module, exports) {
          var $def = require('./$.def'),
              setProto = require('./$.set-proto');
          if (setProto)
            $def($def.S, 'Reflect', {setPrototypeOf: function setPrototypeOf(target, proto) {
                setProto.check(target, proto);
                try {
                  setProto.set(target, proto);
                  return true;
                } catch (e) {
                  return false;
                }
              }});
        }, {
          "./$.def": 239,
          "./$.set-proto": 279
        }],
        368: [function(require, module, exports) {
          var $ = require('./$'),
              has = require('./$.has'),
              $def = require('./$.def'),
              createDesc = require('./$.property-desc'),
              anObject = require('./$.an-object'),
              isObject = require('./$.is-object');
          function set(target, propertyKey, V) {
            var receiver = arguments.length < 4 ? target : arguments[3],
                ownDesc = $.getDesc(anObject(target), propertyKey),
                existingDescriptor,
                proto;
            if (!ownDesc) {
              if (isObject(proto = $.getProto(target))) {
                return set(proto, propertyKey, V, receiver);
              }
              ownDesc = createDesc(0);
            }
            if (has(ownDesc, 'value')) {
              if (ownDesc.writable === false || !isObject(receiver))
                return false;
              existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
              existingDescriptor.value = V;
              $.setDesc(receiver, propertyKey, existingDescriptor);
              return true;
            }
            return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
          }
          $def($def.S, 'Reflect', {set: set});
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.def": 239,
          "./$.has": 250,
          "./$.is-object": 257,
          "./$.property-desc": 275
        }],
        369: [function(require, module, exports) {
          var $ = require('./$'),
              global = require('./$.global'),
              cof = require('./$.cof'),
              $flags = require('./$.flags'),
              $RegExp = global.RegExp,
              Base = $RegExp,
              proto = $RegExp.prototype,
              re = /a/g,
              CORRECT_NEW = new $RegExp(re) !== re,
              ALLOWS_RE_WITH_FLAGS = function() {
                try {
                  return $RegExp(re, 'i') == '/a/i';
                } catch (e) {}
              }();
          if (require('./$.support-desc')) {
            if (!CORRECT_NEW || !ALLOWS_RE_WITH_FLAGS) {
              $RegExp = function RegExp(pattern, flags) {
                var patternIsRegExp = cof(pattern) == 'RegExp',
                    flagsIsUndefined = flags === undefined;
                if (!(this instanceof $RegExp) && patternIsRegExp && flagsIsUndefined)
                  return pattern;
                return CORRECT_NEW ? new Base(patternIsRegExp && !flagsIsUndefined ? pattern.source : pattern, flags) : new Base(patternIsRegExp ? pattern.source : pattern, patternIsRegExp && flagsIsUndefined ? $flags.call(pattern) : flags);
              };
              $.each.call($.getNames(Base), function(key) {
                key in $RegExp || $.setDesc($RegExp, key, {
                  configurable: true,
                  get: function() {
                    return Base[key];
                  },
                  set: function(it) {
                    Base[key] = it;
                  }
                });
              });
              proto.constructor = $RegExp;
              $RegExp.prototype = proto;
              require('./$.redef')(global, 'RegExp', $RegExp);
            }
          }
          require('./$.species')($RegExp);
        }, {
          "./$": 264,
          "./$.cof": 232,
          "./$.flags": 246,
          "./$.global": 249,
          "./$.redef": 276,
          "./$.species": 282,
          "./$.support-desc": 289
        }],
        370: [function(require, module, exports) {
          var $ = require('./$');
          if (require('./$.support-desc') && /./g.flags != 'g')
            $.setDesc(RegExp.prototype, 'flags', {
              configurable: true,
              get: require('./$.flags')
            });
        }, {
          "./$": 264,
          "./$.flags": 246,
          "./$.support-desc": 289
        }],
        371: [function(require, module, exports) {
          require('./$.fix-re-wks')('match', 1, function(defined, MATCH) {
            return function match(regexp) {
              'use strict';
              var O = defined(this),
                  fn = regexp == undefined ? undefined : regexp[MATCH];
              return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
            };
          });
        }, {"./$.fix-re-wks": 245}],
        372: [function(require, module, exports) {
          require('./$.fix-re-wks')('replace', 2, function(defined, REPLACE, $replace) {
            return function replace(searchValue, replaceValue) {
              'use strict';
              var O = defined(this),
                  fn = searchValue == undefined ? undefined : searchValue[REPLACE];
              return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
            };
          });
        }, {"./$.fix-re-wks": 245}],
        373: [function(require, module, exports) {
          require('./$.fix-re-wks')('search', 1, function(defined, SEARCH) {
            return function search(regexp) {
              'use strict';
              var O = defined(this),
                  fn = regexp == undefined ? undefined : regexp[SEARCH];
              return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
            };
          });
        }, {"./$.fix-re-wks": 245}],
        374: [function(require, module, exports) {
          require('./$.fix-re-wks')('split', 2, function(defined, SPLIT, $split) {
            return function split(separator, limit) {
              'use strict';
              var O = defined(this),
                  fn = separator == undefined ? undefined : separator[SPLIT];
              return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
            };
          });
        }, {"./$.fix-re-wks": 245}],
        375: [function(require, module, exports) {
          'use strict';
          var strong = require('./$.collection-strong');
          require('./$.collection')('Set', function(get) {
            return function Set() {
              return get(this, arguments[0]);
            };
          }, {add: function add(value) {
              return strong.def(this, value = value === 0 ? 0 : value, value);
            }}, strong);
        }, {
          "./$.collection": 236,
          "./$.collection-strong": 233
        }],
        376: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              $at = require('./$.string-at')(false);
          $def($def.P, 'String', {codePointAt: function codePointAt(pos) {
              return $at(this, pos);
            }});
        }, {
          "./$.def": 239,
          "./$.string-at": 284
        }],
        377: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              toLength = require('./$.to-length'),
              context = require('./$.string-context');
          $def($def.P + $def.F * !require('./$.fails')(function() {
            'q'.endsWith(/./);
          }), 'String', {endsWith: function endsWith(searchString) {
              var that = context(this, searchString, 'endsWith'),
                  endPosition = arguments[1],
                  len = toLength(that.length),
                  end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
                  search = String(searchString);
              return that.slice(end - search.length, end) === search;
            }});
        }, {
          "./$.def": 239,
          "./$.fails": 244,
          "./$.string-context": 285,
          "./$.to-length": 295
        }],
        378: [function(require, module, exports) {
          var $def = require('./$.def'),
              toIndex = require('./$.to-index'),
              fromCharCode = String.fromCharCode,
              $fromCodePoint = String.fromCodePoint;
          $def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {fromCodePoint: function fromCodePoint(x) {
              var res = [],
                  len = arguments.length,
                  i = 0,
                  code;
              while (len > i) {
                code = +arguments[i++];
                if (toIndex(code, 0x10ffff) !== code)
                  throw RangeError(code + ' is not a valid code point');
                res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
              }
              return res.join('');
            }});
        }, {
          "./$.def": 239,
          "./$.to-index": 292
        }],
        379: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              context = require('./$.string-context');
          $def($def.P, 'String', {includes: function includes(searchString) {
              return !!~context(this, searchString, 'includes').indexOf(searchString, arguments[1]);
            }});
        }, {
          "./$.def": 239,
          "./$.string-context": 285
        }],
        380: [function(require, module, exports) {
          'use strict';
          var $at = require('./$.string-at')(true);
          require('./$.iter-define')(String, 'String', function(iterated) {
            this._t = String(iterated);
            this._i = 0;
          }, function() {
            var O = this._t,
                index = this._i,
                point;
            if (index >= O.length)
              return {
                value: undefined,
                done: true
              };
            point = $at(O, index);
            this._i += point.length;
            return {
              value: point,
              done: false
            };
          });
        }, {
          "./$.iter-define": 260,
          "./$.string-at": 284
        }],
        381: [function(require, module, exports) {
          var $def = require('./$.def'),
              toIObject = require('./$.to-iobject'),
              toLength = require('./$.to-length');
          $def($def.S, 'String', {raw: function raw(callSite) {
              var tpl = toIObject(callSite.raw),
                  len = toLength(tpl.length),
                  sln = arguments.length,
                  res = [],
                  i = 0;
              while (len > i) {
                res.push(String(tpl[i++]));
                if (i < sln)
                  res.push(String(arguments[i]));
              }
              return res.join('');
            }});
        }, {
          "./$.def": 239,
          "./$.to-iobject": 294,
          "./$.to-length": 295
        }],
        382: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.P, 'String', {repeat: require('./$.string-repeat')});
        }, {
          "./$.def": 239,
          "./$.string-repeat": 287
        }],
        383: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              toLength = require('./$.to-length'),
              context = require('./$.string-context');
          $def($def.P + $def.F * !require('./$.fails')(function() {
            'q'.startsWith(/./);
          }), 'String', {startsWith: function startsWith(searchString) {
              var that = context(this, searchString, 'startsWith'),
                  index = toLength(Math.min(arguments[1], that.length)),
                  search = String(searchString);
              return that.slice(index, index + search.length) === search;
            }});
        }, {
          "./$.def": 239,
          "./$.fails": 244,
          "./$.string-context": 285,
          "./$.to-length": 295
        }],
        384: [function(require, module, exports) {
          'use strict';
          require('./$.string-trim')('trim', function($trim) {
            return function trim() {
              return $trim(this, 3);
            };
          });
        }, {"./$.string-trim": 288}],
        385: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              global = require('./$.global'),
              has = require('./$.has'),
              SUPPORT_DESC = require('./$.support-desc'),
              $def = require('./$.def'),
              $redef = require('./$.redef'),
              shared = require('./$.shared'),
              setTag = require('./$.tag'),
              uid = require('./$.uid'),
              wks = require('./$.wks'),
              keyOf = require('./$.keyof'),
              $names = require('./$.get-names'),
              enumKeys = require('./$.enum-keys'),
              isObject = require('./$.is-object'),
              anObject = require('./$.an-object'),
              toIObject = require('./$.to-iobject'),
              createDesc = require('./$.property-desc'),
              getDesc = $.getDesc,
              setDesc = $.setDesc,
              _create = $.create,
              getNames = $names.get,
              $Symbol = global.Symbol,
              setter = false,
              HIDDEN = wks('_hidden'),
              isEnum = $.isEnum,
              SymbolRegistry = shared('symbol-registry'),
              AllSymbols = shared('symbols'),
              useNative = typeof $Symbol == 'function',
              ObjectProto = Object.prototype;
          var setSymbolDesc = SUPPORT_DESC ? function() {
            try {
              return _create(setDesc({}, HIDDEN, {get: function() {
                  return setDesc(this, HIDDEN, {value: false})[HIDDEN];
                }}))[HIDDEN] || setDesc;
            } catch (e) {
              return function(it, key, D) {
                var protoDesc = getDesc(ObjectProto, key);
                if (protoDesc)
                  delete ObjectProto[key];
                setDesc(it, key, D);
                if (protoDesc && it !== ObjectProto)
                  setDesc(ObjectProto, key, protoDesc);
              };
            }
          }() : setDesc;
          var wrap = function(tag) {
            var sym = AllSymbols[tag] = _create($Symbol.prototype);
            sym._k = tag;
            SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
              configurable: true,
              set: function(value) {
                if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                  this[HIDDEN][tag] = false;
                setSymbolDesc(this, tag, createDesc(1, value));
              }
            });
            return sym;
          };
          var $defineProperty = function defineProperty(it, key, D) {
            if (D && has(AllSymbols, key)) {
              if (!D.enumerable) {
                if (!has(it, HIDDEN))
                  setDesc(it, HIDDEN, createDesc(1, {}));
                it[HIDDEN][key] = true;
              } else {
                if (has(it, HIDDEN) && it[HIDDEN][key])
                  it[HIDDEN][key] = false;
                D = _create(D, {enumerable: createDesc(0, false)});
              }
              return setSymbolDesc(it, key, D);
            }
            return setDesc(it, key, D);
          };
          var $defineProperties = function defineProperties(it, P) {
            anObject(it);
            var keys = enumKeys(P = toIObject(P)),
                i = 0,
                l = keys.length,
                key;
            while (l > i)
              $defineProperty(it, key = keys[i++], P[key]);
            return it;
          };
          var $create = function create(it, P) {
            return P === undefined ? _create(it) : $defineProperties(_create(it), P);
          };
          var $propertyIsEnumerable = function propertyIsEnumerable(key) {
            var E = isEnum.call(this, key);
            return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
          };
          var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
            var D = getDesc(it = toIObject(it), key);
            if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
              D.enumerable = true;
            return D;
          };
          var $getOwnPropertyNames = function getOwnPropertyNames(it) {
            var names = getNames(toIObject(it)),
                result = [],
                i = 0,
                key;
            while (names.length > i)
              if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
                result.push(key);
            return result;
          };
          var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
            var names = getNames(toIObject(it)),
                result = [],
                i = 0,
                key;
            while (names.length > i)
              if (has(AllSymbols, key = names[i++]))
                result.push(AllSymbols[key]);
            return result;
          };
          if (!useNative) {
            $Symbol = function Symbol() {
              if (this instanceof $Symbol)
                throw TypeError('Symbol is not a constructor');
              return wrap(uid(arguments[0]));
            };
            $redef($Symbol.prototype, 'toString', function toString() {
              return this._k;
            });
            $.create = $create;
            $.isEnum = $propertyIsEnumerable;
            $.getDesc = $getOwnPropertyDescriptor;
            $.setDesc = $defineProperty;
            $.setDescs = $defineProperties;
            $.getNames = $names.get = $getOwnPropertyNames;
            $.getSymbols = $getOwnPropertySymbols;
            if (SUPPORT_DESC && !require('./$.library')) {
              $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
            }
          }
          if (!useNative || require('./$.fails')(function() {
            return JSON.stringify([{a: $Symbol()}, [$Symbol()]]) != '[{},[null]]';
          }))
            $redef($Symbol.prototype, 'toJSON', function toJSON() {
              if (useNative && isObject(this))
                return this;
            });
          var symbolStatics = {
            'for': function(key) {
              return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
            },
            keyFor: function keyFor(key) {
              return keyOf(SymbolRegistry, key);
            },
            useSetter: function() {
              setter = true;
            },
            useSimple: function() {
              setter = false;
            }
          };
          $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
            var sym = wks(it);
            symbolStatics[it] = useNative ? sym : wrap(sym);
          });
          setter = true;
          $def($def.G + $def.W, {Symbol: $Symbol});
          $def($def.S, 'Symbol', symbolStatics);
          $def($def.S + $def.F * !useNative, 'Object', {
            create: $create,
            defineProperty: $defineProperty,
            defineProperties: $defineProperties,
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
            getOwnPropertyNames: $getOwnPropertyNames,
            getOwnPropertySymbols: $getOwnPropertySymbols
          });
          setTag($Symbol, 'Symbol');
          setTag(Math, 'Math', true);
          setTag(global.JSON, 'JSON', true);
        }, {
          "./$": 264,
          "./$.an-object": 227,
          "./$.def": 239,
          "./$.enum-keys": 242,
          "./$.fails": 244,
          "./$.get-names": 248,
          "./$.global": 249,
          "./$.has": 250,
          "./$.is-object": 257,
          "./$.keyof": 265,
          "./$.library": 266,
          "./$.property-desc": 275,
          "./$.redef": 276,
          "./$.shared": 280,
          "./$.support-desc": 289,
          "./$.tag": 290,
          "./$.to-iobject": 294,
          "./$.uid": 297,
          "./$.wks": 299
        }],
        386: [function(require, module, exports) {
          'use strict';
          var $ = require('./$'),
              weak = require('./$.collection-weak'),
              isObject = require('./$.is-object'),
              has = require('./$.has'),
              frozenStore = weak.frozenStore,
              WEAK = weak.WEAK,
              isExtensible = Object.isExtensible || isObject,
              tmp = {};
          var $WeakMap = require('./$.collection')('WeakMap', function(get) {
            return function WeakMap() {
              return get(this, arguments[0]);
            };
          }, {
            get: function get(key) {
              if (isObject(key)) {
                if (!isExtensible(key))
                  return frozenStore(this).get(key);
                if (has(key, WEAK))
                  return key[WEAK][this._i];
              }
            },
            set: function set(key, value) {
              return weak.def(this, key, value);
            }
          }, weak, true, true);
          if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
            $.each.call(['delete', 'has', 'get', 'set'], function(key) {
              var proto = $WeakMap.prototype,
                  method = proto[key];
              require('./$.redef')(proto, key, function(a, b) {
                if (isObject(a) && !isExtensible(a)) {
                  var result = frozenStore(this)[key](a, b);
                  return key == 'set' ? this : result;
                }
                return method.call(this, a, b);
              });
            });
          }
        }, {
          "./$": 264,
          "./$.collection": 236,
          "./$.collection-weak": 235,
          "./$.has": 250,
          "./$.is-object": 257,
          "./$.redef": 276
        }],
        387: [function(require, module, exports) {
          'use strict';
          var weak = require('./$.collection-weak');
          require('./$.collection')('WeakSet', function(get) {
            return function WeakSet() {
              return get(this, arguments[0]);
            };
          }, {add: function add(value) {
              return weak.def(this, value, true);
            }}, weak, false, true);
        }, {
          "./$.collection": 236,
          "./$.collection-weak": 235
        }],
        388: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              $includes = require('./$.array-includes')(true);
          $def($def.P, 'Array', {includes: function includes(el) {
              return $includes(this, el, arguments[1]);
            }});
          require('./$.unscope')('includes');
        }, {
          "./$.array-includes": 228,
          "./$.def": 239,
          "./$.unscope": 298
        }],
        389: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.P, 'Map', {toJSON: require('./$.collection-to-json')('Map')});
        }, {
          "./$.collection-to-json": 234,
          "./$.def": 239
        }],
        390: [function(require, module, exports) {
          var $def = require('./$.def'),
              $entries = require('./$.object-to-array')(true);
          $def($def.S, 'Object', {entries: function entries(it) {
              return $entries(it);
            }});
        }, {
          "./$.def": 239,
          "./$.object-to-array": 271
        }],
        391: [function(require, module, exports) {
          var $ = require('./$'),
              $def = require('./$.def'),
              ownKeys = require('./$.own-keys'),
              toIObject = require('./$.to-iobject'),
              createDesc = require('./$.property-desc');
          $def($def.S, 'Object', {getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
              var O = toIObject(object),
                  setDesc = $.setDesc,
                  getDesc = $.getDesc,
                  keys = ownKeys(O),
                  result = {},
                  i = 0,
                  key,
                  D;
              while (keys.length > i) {
                D = getDesc(O, key = keys[i++]);
                if (key in result)
                  setDesc(result, key, createDesc(0, D));
                else
                  result[key] = D;
              }
              return result;
            }});
        }, {
          "./$": 264,
          "./$.def": 239,
          "./$.own-keys": 272,
          "./$.property-desc": 275,
          "./$.to-iobject": 294
        }],
        392: [function(require, module, exports) {
          var $def = require('./$.def'),
              $values = require('./$.object-to-array')(false);
          $def($def.S, 'Object', {values: function values(it) {
              return $values(it);
            }});
        }, {
          "./$.def": 239,
          "./$.object-to-array": 271
        }],
        393: [function(require, module, exports) {
          var $def = require('./$.def'),
              $re = require('./$.replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');
          $def($def.S, 'RegExp', {escape: function escape(it) {
              return $re(it);
            }});
        }, {
          "./$.def": 239,
          "./$.replacer": 277
        }],
        394: [function(require, module, exports) {
          var $def = require('./$.def');
          $def($def.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});
        }, {
          "./$.collection-to-json": 234,
          "./$.def": 239
        }],
        395: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              $at = require('./$.string-at')(true);
          $def($def.P, 'String', {at: function at(pos) {
              return $at(this, pos);
            }});
        }, {
          "./$.def": 239,
          "./$.string-at": 284
        }],
        396: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              $pad = require('./$.string-pad');
          $def($def.P, 'String', {padLeft: function padLeft(maxLength) {
              return $pad(this, maxLength, arguments[1], true);
            }});
        }, {
          "./$.def": 239,
          "./$.string-pad": 286
        }],
        397: [function(require, module, exports) {
          'use strict';
          var $def = require('./$.def'),
              $pad = require('./$.string-pad');
          $def($def.P, 'String', {padRight: function padRight(maxLength) {
              return $pad(this, maxLength, arguments[1], false);
            }});
        }, {
          "./$.def": 239,
          "./$.string-pad": 286
        }],
        398: [function(require, module, exports) {
          'use strict';
          require('./$.string-trim')('trimLeft', function($trim) {
            return function trimLeft() {
              return $trim(this, 1);
            };
          });
        }, {"./$.string-trim": 288}],
        399: [function(require, module, exports) {
          'use strict';
          require('./$.string-trim')('trimRight', function($trim) {
            return function trimRight() {
              return $trim(this, 2);
            };
          });
        }, {"./$.string-trim": 288}],
        400: [function(require, module, exports) {
          var $ = require('./$'),
              $def = require('./$.def'),
              $Array = require('./$.core').Array || Array,
              statics = {};
          var setStatics = function(keys, length) {
            $.each.call(keys.split(','), function(key) {
              if (length == undefined && key in $Array)
                statics[key] = $Array[key];
              else if (key in [])
                statics[key] = require('./$.ctx')(Function.call, [][key], length);
            });
          };
          setStatics('pop,reverse,shift,keys,values,entries', 1);
          setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
          setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' + 'reduce,reduceRight,copyWithin,fill');
          $def($def.S, 'Array', statics);
        }, {
          "./$": 264,
          "./$.core": 237,
          "./$.ctx": 238,
          "./$.def": 239
        }],
        401: [function(require, module, exports) {
          require('./es6.array.iterator');
          var global = require('./$.global'),
              hide = require('./$.hide'),
              Iterators = require('./$.iterators'),
              ITERATOR = require('./$.wks')('iterator'),
              NL = global.NodeList,
              HTC = global.HTMLCollection,
              NLProto = NL && NL.prototype,
              HTCProto = HTC && HTC.prototype,
              ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
          if (NL && !(ITERATOR in NLProto))
            hide(NLProto, ITERATOR, ArrayValues);
          if (HTC && !(ITERATOR in HTCProto))
            hide(HTCProto, ITERATOR, ArrayValues);
        }, {
          "./$.global": 249,
          "./$.hide": 251,
          "./$.iterators": 263,
          "./$.wks": 299,
          "./es6.array.iterator": 307
        }],
        402: [function(require, module, exports) {
          var $def = require('./$.def'),
              $task = require('./$.task');
          $def($def.G + $def.B, {
            setImmediate: $task.set,
            clearImmediate: $task.clear
          });
        }, {
          "./$.def": 239,
          "./$.task": 291
        }],
        403: [function(require, module, exports) {
          var global = require('./$.global'),
              $def = require('./$.def'),
              invoke = require('./$.invoke'),
              partial = require('./$.partial'),
              navigator = global.navigator,
              MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent);
          var wrap = function(set) {
            return MSIE ? function(fn, time) {
              return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
            } : set;
          };
          $def($def.G + $def.B + $def.F * MSIE, {
            setTimeout: wrap(global.setTimeout),
            setInterval: wrap(global.setInterval)
          });
        }, {
          "./$.def": 239,
          "./$.global": 249,
          "./$.invoke": 253,
          "./$.partial": 273
        }],
        404: [function(require, module, exports) {
          require('./modules/es5');
          require('./modules/es6.symbol');
          require('./modules/es6.object.assign');
          require('./modules/es6.object.is');
          require('./modules/es6.object.set-prototype-of');
          require('./modules/es6.object.to-string');
          require('./modules/es6.object.freeze');
          require('./modules/es6.object.seal');
          require('./modules/es6.object.prevent-extensions');
          require('./modules/es6.object.is-frozen');
          require('./modules/es6.object.is-sealed');
          require('./modules/es6.object.is-extensible');
          require('./modules/es6.object.get-own-property-descriptor');
          require('./modules/es6.object.get-prototype-of');
          require('./modules/es6.object.keys');
          require('./modules/es6.object.get-own-property-names');
          require('./modules/es6.function.name');
          require('./modules/es6.function.has-instance');
          require('./modules/es6.number.constructor');
          require('./modules/es6.number.epsilon');
          require('./modules/es6.number.is-finite');
          require('./modules/es6.number.is-integer');
          require('./modules/es6.number.is-nan');
          require('./modules/es6.number.is-safe-integer');
          require('./modules/es6.number.max-safe-integer');
          require('./modules/es6.number.min-safe-integer');
          require('./modules/es6.number.parse-float');
          require('./modules/es6.number.parse-int');
          require('./modules/es6.math.acosh');
          require('./modules/es6.math.asinh');
          require('./modules/es6.math.atanh');
          require('./modules/es6.math.cbrt');
          require('./modules/es6.math.clz32');
          require('./modules/es6.math.cosh');
          require('./modules/es6.math.expm1');
          require('./modules/es6.math.fround');
          require('./modules/es6.math.hypot');
          require('./modules/es6.math.imul');
          require('./modules/es6.math.log10');
          require('./modules/es6.math.log1p');
          require('./modules/es6.math.log2');
          require('./modules/es6.math.sign');
          require('./modules/es6.math.sinh');
          require('./modules/es6.math.tanh');
          require('./modules/es6.math.trunc');
          require('./modules/es6.string.from-code-point');
          require('./modules/es6.string.raw');
          require('./modules/es6.string.trim');
          require('./modules/es6.string.iterator');
          require('./modules/es6.string.code-point-at');
          require('./modules/es6.string.ends-with');
          require('./modules/es6.string.includes');
          require('./modules/es6.string.repeat');
          require('./modules/es6.string.starts-with');
          require('./modules/es6.array.from');
          require('./modules/es6.array.of');
          require('./modules/es6.array.iterator');
          require('./modules/es6.array.species');
          require('./modules/es6.array.copy-within');
          require('./modules/es6.array.fill');
          require('./modules/es6.array.find');
          require('./modules/es6.array.find-index');
          require('./modules/es6.regexp.constructor');
          require('./modules/es6.regexp.flags');
          require('./modules/es6.regexp.match');
          require('./modules/es6.regexp.replace');
          require('./modules/es6.regexp.search');
          require('./modules/es6.regexp.split');
          require('./modules/es6.promise');
          require('./modules/es6.map');
          require('./modules/es6.set');
          require('./modules/es6.weak-map');
          require('./modules/es6.weak-set');
          require('./modules/es6.reflect.apply');
          require('./modules/es6.reflect.construct');
          require('./modules/es6.reflect.define-property');
          require('./modules/es6.reflect.delete-property');
          require('./modules/es6.reflect.enumerate');
          require('./modules/es6.reflect.get');
          require('./modules/es6.reflect.get-own-property-descriptor');
          require('./modules/es6.reflect.get-prototype-of');
          require('./modules/es6.reflect.has');
          require('./modules/es6.reflect.is-extensible');
          require('./modules/es6.reflect.own-keys');
          require('./modules/es6.reflect.prevent-extensions');
          require('./modules/es6.reflect.set');
          require('./modules/es6.reflect.set-prototype-of');
          require('./modules/es7.array.includes');
          require('./modules/es7.string.at');
          require('./modules/es7.string.pad-left');
          require('./modules/es7.string.pad-right');
          require('./modules/es7.string.trim-left');
          require('./modules/es7.string.trim-right');
          require('./modules/es7.regexp.escape');
          require('./modules/es7.object.get-own-property-descriptors');
          require('./modules/es7.object.values');
          require('./modules/es7.object.entries');
          require('./modules/es7.map.to-json');
          require('./modules/es7.set.to-json');
          require('./modules/js.array.statics');
          require('./modules/web.timers');
          require('./modules/web.immediate');
          require('./modules/web.dom.iterable');
          module.exports = require('./modules/$.core');
        }, {
          "./modules/$.core": 237,
          "./modules/es5": 301,
          "./modules/es6.array.copy-within": 302,
          "./modules/es6.array.fill": 303,
          "./modules/es6.array.find": 305,
          "./modules/es6.array.find-index": 304,
          "./modules/es6.array.from": 306,
          "./modules/es6.array.iterator": 307,
          "./modules/es6.array.of": 308,
          "./modules/es6.array.species": 309,
          "./modules/es6.function.has-instance": 310,
          "./modules/es6.function.name": 311,
          "./modules/es6.map": 312,
          "./modules/es6.math.acosh": 313,
          "./modules/es6.math.asinh": 314,
          "./modules/es6.math.atanh": 315,
          "./modules/es6.math.cbrt": 316,
          "./modules/es6.math.clz32": 317,
          "./modules/es6.math.cosh": 318,
          "./modules/es6.math.expm1": 319,
          "./modules/es6.math.fround": 320,
          "./modules/es6.math.hypot": 321,
          "./modules/es6.math.imul": 322,
          "./modules/es6.math.log10": 323,
          "./modules/es6.math.log1p": 324,
          "./modules/es6.math.log2": 325,
          "./modules/es6.math.sign": 326,
          "./modules/es6.math.sinh": 327,
          "./modules/es6.math.tanh": 328,
          "./modules/es6.math.trunc": 329,
          "./modules/es6.number.constructor": 330,
          "./modules/es6.number.epsilon": 331,
          "./modules/es6.number.is-finite": 332,
          "./modules/es6.number.is-integer": 333,
          "./modules/es6.number.is-nan": 334,
          "./modules/es6.number.is-safe-integer": 335,
          "./modules/es6.number.max-safe-integer": 336,
          "./modules/es6.number.min-safe-integer": 337,
          "./modules/es6.number.parse-float": 338,
          "./modules/es6.number.parse-int": 339,
          "./modules/es6.object.assign": 340,
          "./modules/es6.object.freeze": 341,
          "./modules/es6.object.get-own-property-descriptor": 342,
          "./modules/es6.object.get-own-property-names": 343,
          "./modules/es6.object.get-prototype-of": 344,
          "./modules/es6.object.is": 348,
          "./modules/es6.object.is-extensible": 345,
          "./modules/es6.object.is-frozen": 346,
          "./modules/es6.object.is-sealed": 347,
          "./modules/es6.object.keys": 349,
          "./modules/es6.object.prevent-extensions": 350,
          "./modules/es6.object.seal": 351,
          "./modules/es6.object.set-prototype-of": 352,
          "./modules/es6.object.to-string": 353,
          "./modules/es6.promise": 354,
          "./modules/es6.reflect.apply": 355,
          "./modules/es6.reflect.construct": 356,
          "./modules/es6.reflect.define-property": 357,
          "./modules/es6.reflect.delete-property": 358,
          "./modules/es6.reflect.enumerate": 359,
          "./modules/es6.reflect.get": 362,
          "./modules/es6.reflect.get-own-property-descriptor": 360,
          "./modules/es6.reflect.get-prototype-of": 361,
          "./modules/es6.reflect.has": 363,
          "./modules/es6.reflect.is-extensible": 364,
          "./modules/es6.reflect.own-keys": 365,
          "./modules/es6.reflect.prevent-extensions": 366,
          "./modules/es6.reflect.set": 368,
          "./modules/es6.reflect.set-prototype-of": 367,
          "./modules/es6.regexp.constructor": 369,
          "./modules/es6.regexp.flags": 370,
          "./modules/es6.regexp.match": 371,
          "./modules/es6.regexp.replace": 372,
          "./modules/es6.regexp.search": 373,
          "./modules/es6.regexp.split": 374,
          "./modules/es6.set": 375,
          "./modules/es6.string.code-point-at": 376,
          "./modules/es6.string.ends-with": 377,
          "./modules/es6.string.from-code-point": 378,
          "./modules/es6.string.includes": 379,
          "./modules/es6.string.iterator": 380,
          "./modules/es6.string.raw": 381,
          "./modules/es6.string.repeat": 382,
          "./modules/es6.string.starts-with": 383,
          "./modules/es6.string.trim": 384,
          "./modules/es6.symbol": 385,
          "./modules/es6.weak-map": 386,
          "./modules/es6.weak-set": 387,
          "./modules/es7.array.includes": 388,
          "./modules/es7.map.to-json": 389,
          "./modules/es7.object.entries": 390,
          "./modules/es7.object.get-own-property-descriptors": 391,
          "./modules/es7.object.values": 392,
          "./modules/es7.regexp.escape": 393,
          "./modules/es7.set.to-json": 394,
          "./modules/es7.string.at": 395,
          "./modules/es7.string.pad-left": 396,
          "./modules/es7.string.pad-right": 397,
          "./modules/es7.string.trim-left": 398,
          "./modules/es7.string.trim-right": 399,
          "./modules/js.array.statics": 400,
          "./modules/web.dom.iterable": 401,
          "./modules/web.immediate": 402,
          "./modules/web.timers": 403
        }],
        405: [function(require, module, exports) {
          exports = module.exports = debug;
          exports.coerce = coerce;
          exports.disable = disable;
          exports.enable = enable;
          exports.enabled = enabled;
          exports.humanize = require('ms');
          exports.names = [];
          exports.skips = [];
          exports.formatters = {};
          var prevColor = 0;
          var prevTime;
          function selectColor() {
            return exports.colors[prevColor++ % exports.colors.length];
          }
          function debug(namespace) {
            function disabled() {}
            disabled.enabled = false;
            function enabled() {
              var self = enabled;
              var curr = +new Date();
              var ms = curr - (prevTime || curr);
              self.diff = ms;
              self.prev = prevTime;
              self.curr = curr;
              prevTime = curr;
              if (null == self.useColors)
                self.useColors = exports.useColors();
              if (null == self.color && self.useColors)
                self.color = selectColor();
              var args = Array.prototype.slice.call(arguments);
              args[0] = exports.coerce(args[0]);
              if ('string' !== typeof args[0]) {
                args = ['%o'].concat(args);
              }
              var index = 0;
              args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
                if (match === '%%')
                  return match;
                index++;
                var formatter = exports.formatters[format];
                if ('function' === typeof formatter) {
                  var val = args[index];
                  match = formatter.call(self, val);
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });
              if ('function' === typeof exports.formatArgs) {
                args = exports.formatArgs.apply(self, args);
              }
              var logFn = enabled.log || exports.log || console.log.bind(console);
              logFn.apply(self, args);
            }
            enabled.enabled = true;
            var fn = exports.enabled(namespace) ? enabled : disabled;
            fn.namespace = namespace;
            return fn;
          }
          function enable(namespaces) {
            exports.save(namespaces);
            var split = (namespaces || '').split(/[\s,]+/);
            var len = split.length;
            for (var i = 0; i < len; i++) {
              if (!split[i])
                continue;
              namespaces = split[i].replace(/\*/g, '.*?');
              if (namespaces[0] === '-') {
                exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
              } else {
                exports.names.push(new RegExp('^' + namespaces + '$'));
              }
            }
          }
          function disable() {
            exports.enable('');
          }
          function enabled(name) {
            var i,
                len;
            for (i = 0, len = exports.skips.length; i < len; i++) {
              if (exports.skips[i].test(name)) {
                return false;
              }
            }
            for (i = 0, len = exports.names.length; i < len; i++) {
              if (exports.names[i].test(name)) {
                return true;
              }
            }
            return false;
          }
          function coerce(val) {
            if (val instanceof Error)
              return val.stack || val.message;
            return val;
          }
        }, {"ms": 407}],
        406: [function(require, module, exports) {
          (function(process) {
            var tty = require('tty');
            var util = require('util');
            exports = module.exports = require('./debug');
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.colors = [6, 2, 3, 4, 5, 1];
            var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
            var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
            function useColors() {
              var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
              if (0 === debugColors.length) {
                return tty.isatty(fd);
              } else {
                return '0' !== debugColors && 'no' !== debugColors && 'false' !== debugColors && 'disabled' !== debugColors;
              }
            }
            var inspect = (4 === util.inspect.length ? function(v, colors) {
              return util.inspect(v, void 0, void 0, colors);
            } : function(v, colors) {
              return util.inspect(v, {colors: colors});
            });
            exports.formatters.o = function(v) {
              return inspect(v, this.useColors).replace(/\s*\n\s*/g, ' ');
            };
            function formatArgs() {
              var args = arguments;
              var useColors = this.useColors;
              var name = this.namespace;
              if (useColors) {
                var c = this.color;
                args[0] = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m' + args[0] + '\u001b[3' + c + 'm' + ' +' + exports.humanize(this.diff) + '\u001b[0m';
              } else {
                args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
              }
              return args;
            }
            function log() {
              return stream.write(util.format.apply(this, arguments) + '\n');
            }
            function save(namespaces) {
              if (null == namespaces) {
                delete process.env.DEBUG;
              } else {
                process.env.DEBUG = namespaces;
              }
            }
            function load() {
              return process.env.DEBUG;
            }
            function createWritableStdioStream(fd) {
              var stream;
              var tty_wrap = process.binding('tty_wrap');
              switch (tty_wrap.guessHandleType(fd)) {
                case 'TTY':
                  stream = new tty.WriteStream(fd);
                  stream._type = 'tty';
                  if (stream._handle && stream._handle.unref) {
                    stream._handle.unref();
                  }
                  break;
                case 'FILE':
                  var fs = require('fs');
                  stream = new fs.SyncWriteStream(fd, {autoClose: false});
                  stream._type = 'fs';
                  break;
                case 'PIPE':
                case 'TCP':
                  var net = require('net');
                  stream = new net.Socket({
                    fd: fd,
                    readable: false,
                    writable: true
                  });
                  stream.readable = false;
                  stream.read = null;
                  stream._type = 'pipe';
                  if (stream._handle && stream._handle.unref) {
                    stream._handle.unref();
                  }
                  break;
                default:
                  throw new Error('Implement me. Unknown stream file type!');
              }
              stream.fd = fd;
              stream._isStdio = true;
              return stream;
            }
            exports.enable(load());
          }).call(this, require('_process'));
        }, {
          "./debug": 405,
          "_process": 12,
          "fs": 1,
          "net": 1,
          "tty": 28,
          "util": 30
        }],
        407: [function(require, module, exports) {
          var s = 1000;
          var m = s * 60;
          var h = m * 60;
          var d = h * 24;
          var y = d * 365.25;
          module.exports = function(val, options) {
            options = options || {};
            if ('string' == typeof val)
              return parse(val);
            return options.long ? long(val) : short(val);
          };
          function parse(str) {
            str = '' + str;
            if (str.length > 10000)
              return;
            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
            if (!match)
              return;
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch (type) {
              case 'years':
              case 'year':
              case 'yrs':
              case 'yr':
              case 'y':
                return n * y;
              case 'days':
              case 'day':
              case 'd':
                return n * d;
              case 'hours':
              case 'hour':
              case 'hrs':
              case 'hr':
              case 'h':
                return n * h;
              case 'minutes':
              case 'minute':
              case 'mins':
              case 'min':
              case 'm':
                return n * m;
              case 'seconds':
              case 'second':
              case 'secs':
              case 'sec':
              case 's':
                return n * s;
              case 'milliseconds':
              case 'millisecond':
              case 'msecs':
              case 'msec':
              case 'ms':
                return n;
            }
          }
          function short(ms) {
            if (ms >= d)
              return Math.round(ms / d) + 'd';
            if (ms >= h)
              return Math.round(ms / h) + 'h';
            if (ms >= m)
              return Math.round(ms / m) + 'm';
            if (ms >= s)
              return Math.round(ms / s) + 's';
            return ms + 'ms';
          }
          function long(ms) {
            return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
          }
          function plural(ms, n, name) {
            if (ms < n)
              return;
            if (ms < n * 1.5)
              return Math.floor(ms / n) + ' ' + name;
            return Math.ceil(ms / n) + ' ' + name + 's';
          }
        }, {}],
        408: [function(require, module, exports) {
          'use strict';
          var repeating = require('repeating');
          var INDENT_RE = /^(?:( )+|\t+)/;
          function getMostUsed(indents) {
            var result = 0;
            var maxUsed = 0;
            var maxWeight = 0;
            for (var n in indents) {
              var indent = indents[n];
              var u = indent[0];
              var w = indent[1];
              if (u > maxUsed || u === maxUsed && w > maxWeight) {
                maxUsed = u;
                maxWeight = w;
                result = +n;
              }
            }
            return result;
          }
          module.exports = function(str) {
            if (typeof str !== 'string') {
              throw new TypeError('Expected a string');
            }
            var tabs = 0;
            var spaces = 0;
            var prev = 0;
            var indents = {};
            var current;
            var isIndent;
            str.split(/\n/g).forEach(function(line) {
              if (!line) {
                return;
              }
              var indent;
              var matches = line.match(INDENT_RE);
              if (!matches) {
                indent = 0;
              } else {
                indent = matches[0].length;
                if (matches[1]) {
                  spaces++;
                } else {
                  tabs++;
                }
              }
              var diff = indent - prev;
              prev = indent;
              if (diff) {
                isIndent = diff > 0;
                current = indents[isIndent ? diff : -diff];
                if (current) {
                  current[0]++;
                } else {
                  current = indents[diff] = [1, 0];
                }
              } else if (current) {
                current[1] += +isIndent;
              }
            });
            var amount = getMostUsed(indents);
            var type;
            var actual;
            if (!amount) {
              type = null;
              actual = '';
            } else if (spaces >= tabs) {
              type = 'space';
              actual = repeating(' ', amount);
            } else {
              type = 'tab';
              actual = repeating('\t', amount);
            }
            return {
              amount: amount,
              type: type,
              indent: actual
            };
          };
        }, {"repeating": 602}],
        409: [function(require, module, exports) {
          (function() {
            'use strict';
            function isExpression(node) {
              if (node == null) {
                return false;
              }
              switch (node.type) {
                case 'ArrayExpression':
                case 'AssignmentExpression':
                case 'BinaryExpression':
                case 'CallExpression':
                case 'ConditionalExpression':
                case 'FunctionExpression':
                case 'Identifier':
                case 'Literal':
                case 'LogicalExpression':
                case 'MemberExpression':
                case 'NewExpression':
                case 'ObjectExpression':
                case 'SequenceExpression':
                case 'ThisExpression':
                case 'UnaryExpression':
                case 'UpdateExpression':
                  return true;
              }
              return false;
            }
            function isIterationStatement(node) {
              if (node == null) {
                return false;
              }
              switch (node.type) {
                case 'DoWhileStatement':
                case 'ForInStatement':
                case 'ForStatement':
                case 'WhileStatement':
                  return true;
              }
              return false;
            }
            function isStatement(node) {
              if (node == null) {
                return false;
              }
              switch (node.type) {
                case 'BlockStatement':
                case 'BreakStatement':
                case 'ContinueStatement':
                case 'DebuggerStatement':
                case 'DoWhileStatement':
                case 'EmptyStatement':
                case 'ExpressionStatement':
                case 'ForInStatement':
                case 'ForStatement':
                case 'IfStatement':
                case 'LabeledStatement':
                case 'ReturnStatement':
                case 'SwitchStatement':
                case 'ThrowStatement':
                case 'TryStatement':
                case 'VariableDeclaration':
                case 'WhileStatement':
                case 'WithStatement':
                  return true;
              }
              return false;
            }
            function isSourceElement(node) {
              return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
            }
            function trailingStatement(node) {
              switch (node.type) {
                case 'IfStatement':
                  if (node.alternate != null) {
                    return node.alternate;
                  }
                  return node.consequent;
                case 'LabeledStatement':
                case 'ForStatement':
                case 'ForInStatement':
                case 'WhileStatement':
                case 'WithStatement':
                  return node.body;
              }
              return null;
            }
            function isProblematicIfStatement(node) {
              var current;
              if (node.type !== 'IfStatement') {
                return false;
              }
              if (node.alternate == null) {
                return false;
              }
              current = node.consequent;
              do {
                if (current.type === 'IfStatement') {
                  if (current.alternate == null) {
                    return true;
                  }
                }
                current = trailingStatement(current);
              } while (current);
              return false;
            }
            module.exports = {
              isExpression: isExpression,
              isStatement: isStatement,
              isIterationStatement: isIterationStatement,
              isSourceElement: isSourceElement,
              isProblematicIfStatement: isProblematicIfStatement,
              trailingStatement: trailingStatement
            };
          }());
        }, {}],
        410: [function(require, module, exports) {
          (function() {
            'use strict';
            var ES6Regex,
                ES5Regex,
                NON_ASCII_WHITESPACES,
                IDENTIFIER_START,
                IDENTIFIER_PART,
                ch;
            ES5Regex = {
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
              NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
            };
            ES6Regex = {
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            function isDecimalDigit(ch) {
              return 0x30 <= ch && ch <= 0x39;
            }
            function isHexDigit(ch) {
              return 0x30 <= ch && ch <= 0x39 || 0x61 <= ch && ch <= 0x66 || 0x41 <= ch && ch <= 0x46;
            }
            function isOctalDigit(ch) {
              return ch >= 0x30 && ch <= 0x37;
            }
            NON_ASCII_WHITESPACES = [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];
            function isWhiteSpace(ch) {
              return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
            }
            function isLineTerminator(ch) {
              return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
            }
            function fromCodePoint(cp) {
              if (cp <= 0xFFFF) {
                return String.fromCharCode(cp);
              }
              var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
              var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
              return cu1 + cu2;
            }
            IDENTIFIER_START = new Array(0x80);
            for (ch = 0; ch < 0x80; ++ch) {
              IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || ch >= 0x41 && ch <= 0x5A || ch === 0x24 || ch === 0x5F;
            }
            IDENTIFIER_PART = new Array(0x80);
            for (ch = 0; ch < 0x80; ++ch) {
              IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || ch >= 0x41 && ch <= 0x5A || ch >= 0x30 && ch <= 0x39 || ch === 0x24 || ch === 0x5F;
            }
            function isIdentifierStartES5(ch) {
              return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
            }
            function isIdentifierPartES5(ch) {
              return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
            }
            function isIdentifierStartES6(ch) {
              return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
            }
            function isIdentifierPartES6(ch) {
              return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
            }
            module.exports = {
              isDecimalDigit: isDecimalDigit,
              isHexDigit: isHexDigit,
              isOctalDigit: isOctalDigit,
              isWhiteSpace: isWhiteSpace,
              isLineTerminator: isLineTerminator,
              isIdentifierStartES5: isIdentifierStartES5,
              isIdentifierPartES5: isIdentifierPartES5,
              isIdentifierStartES6: isIdentifierStartES6,
              isIdentifierPartES6: isIdentifierPartES6
            };
          }());
        }, {}],
        411: [function(require, module, exports) {
          (function() {
            'use strict';
            var code = require('./code');
            function isStrictModeReservedWordES6(id) {
              switch (id) {
                case 'implements':
                case 'interface':
                case 'package':
                case 'private':
                case 'protected':
                case 'public':
                case 'static':
                case 'let':
                  return true;
                default:
                  return false;
              }
            }
            function isKeywordES5(id, strict) {
              if (!strict && id === 'yield') {
                return false;
              }
              return isKeywordES6(id, strict);
            }
            function isKeywordES6(id, strict) {
              if (strict && isStrictModeReservedWordES6(id)) {
                return true;
              }
              switch (id.length) {
                case 2:
                  return (id === 'if') || (id === 'in') || (id === 'do');
                case 3:
                  return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
                case 4:
                  return (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with') || (id === 'enum');
                case 5:
                  return (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super');
                case 6:
                  return (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') || (id === 'import');
                case 7:
                  return (id === 'default') || (id === 'finally') || (id === 'extends');
                case 8:
                  return (id === 'function') || (id === 'continue') || (id === 'debugger');
                case 10:
                  return (id === 'instanceof');
                default:
                  return false;
              }
            }
            function isReservedWordES5(id, strict) {
              return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
            }
            function isReservedWordES6(id, strict) {
              return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
            }
            function isRestrictedWord(id) {
              return id === 'eval' || id === 'arguments';
            }
            function isIdentifierNameES5(id) {
              var i,
                  iz,
                  ch;
              if (id.length === 0) {
                return false;
              }
              ch = id.charCodeAt(0);
              if (!code.isIdentifierStartES5(ch)) {
                return false;
              }
              for (i = 1, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i);
                if (!code.isIdentifierPartES5(ch)) {
                  return false;
                }
              }
              return true;
            }
            function decodeUtf16(lead, trail) {
              return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            }
            function isIdentifierNameES6(id) {
              var i,
                  iz,
                  ch,
                  lowCh,
                  check;
              if (id.length === 0) {
                return false;
              }
              check = code.isIdentifierStartES6;
              for (i = 0, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i);
                if (0xD800 <= ch && ch <= 0xDBFF) {
                  ++i;
                  if (i >= iz) {
                    return false;
                  }
                  lowCh = id.charCodeAt(i);
                  if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                  }
                  ch = decodeUtf16(ch, lowCh);
                }
                if (!check(ch)) {
                  return false;
                }
                check = code.isIdentifierPartES6;
              }
              return true;
            }
            function isIdentifierES5(id, strict) {
              return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
            }
            function isIdentifierES6(id, strict) {
              return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
            }
            module.exports = {
              isKeywordES5: isKeywordES5,
              isKeywordES6: isKeywordES6,
              isReservedWordES5: isReservedWordES5,
              isReservedWordES6: isReservedWordES6,
              isRestrictedWord: isRestrictedWord,
              isIdentifierNameES5: isIdentifierNameES5,
              isIdentifierNameES6: isIdentifierNameES6,
              isIdentifierES5: isIdentifierES5,
              isIdentifierES6: isIdentifierES6
            };
          }());
        }, {"./code": 410}],
        412: [function(require, module, exports) {
          (function() {
            'use strict';
            exports.ast = require('./ast');
            exports.code = require('./code');
            exports.keyword = require('./keyword');
          }());
        }, {
          "./ast": 409,
          "./code": 410,
          "./keyword": 411
        }],
        413: [function(require, module, exports) {
          module.exports = {
            "builtin": {
              "Array": false,
              "ArrayBuffer": false,
              "Boolean": false,
              "constructor": false,
              "Date": false,
              "decodeURI": false,
              "decodeURIComponent": false,
              "encodeURI": false,
              "encodeURIComponent": false,
              "Error": false,
              "eval": false,
              "EvalError": false,
              "Float32Array": false,
              "Float64Array": false,
              "Function": false,
              "hasOwnProperty": false,
              "Infinity": false,
              "Int16Array": false,
              "Int32Array": false,
              "Int8Array": false,
              "isFinite": false,
              "isNaN": false,
              "isPrototypeOf": false,
              "JSON": false,
              "Map": false,
              "Math": false,
              "NaN": false,
              "Number": false,
              "Object": false,
              "parseFloat": false,
              "parseInt": false,
              "Promise": false,
              "propertyIsEnumerable": false,
              "Proxy": false,
              "RangeError": false,
              "ReferenceError": false,
              "Reflect": false,
              "RegExp": false,
              "Set": false,
              "String": false,
              "Symbol": false,
              "SyntaxError": false,
              "System": false,
              "toLocaleString": false,
              "toString": false,
              "TypeError": false,
              "Uint16Array": false,
              "Uint32Array": false,
              "Uint8Array": false,
              "Uint8ClampedArray": false,
              "undefined": false,
              "URIError": false,
              "valueOf": false,
              "WeakMap": false,
              "WeakSet": false
            },
            "nonstandard": {
              "escape": false,
              "unescape": false
            },
            "browser": {
              "addEventListener": false,
              "alert": false,
              "applicationCache": false,
              "atob": false,
              "Audio": false,
              "AudioProcessingEvent": false,
              "BeforeUnloadEvent": false,
              "Blob": false,
              "blur": false,
              "btoa": false,
              "cancelAnimationFrame": false,
              "CanvasGradient": false,
              "CanvasPattern": false,
              "CanvasRenderingContext2D": false,
              "clearInterval": false,
              "clearTimeout": false,
              "close": false,
              "closed": false,
              "CloseEvent": false,
              "Comment": false,
              "CompositionEvent": false,
              "confirm": false,
              "console": false,
              "crypto": false,
              "CSS": false,
              "CustomEvent": false,
              "DataView": false,
              "Debug": false,
              "defaultStatus": false,
              "devicePixelRatio": false,
              "dispatchEvent": false,
              "document": false,
              "Document": false,
              "DocumentFragment": false,
              "DOMParser": false,
              "DragEvent": false,
              "Element": false,
              "ElementTimeControl": false,
              "ErrorEvent": false,
              "event": false,
              "Event": false,
              "FileReader": false,
              "fetch": false,
              "find": false,
              "focus": false,
              "FocusEvent": false,
              "FormData": false,
              "frameElement": false,
              "frames": false,
              "GamepadEvent": false,
              "getComputedStyle": false,
              "getSelection": false,
              "HashChangeEvent": false,
              "Headers": false,
              "history": false,
              "HTMLAnchorElement": false,
              "HTMLBaseElement": false,
              "HTMLBlockquoteElement": false,
              "HTMLBodyElement": false,
              "HTMLBRElement": false,
              "HTMLButtonElement": false,
              "HTMLCanvasElement": false,
              "HTMLDirectoryElement": false,
              "HTMLDivElement": false,
              "HTMLDListElement": false,
              "HTMLElement": false,
              "HTMLFieldSetElement": false,
              "HTMLFontElement": false,
              "HTMLFormElement": false,
              "HTMLFrameElement": false,
              "HTMLFrameSetElement": false,
              "HTMLHeadElement": false,
              "HTMLHeadingElement": false,
              "HTMLHRElement": false,
              "HTMLHtmlElement": false,
              "HTMLIFrameElement": false,
              "HTMLImageElement": false,
              "HTMLInputElement": false,
              "HTMLIsIndexElement": false,
              "HTMLLabelElement": false,
              "HTMLLayerElement": false,
              "HTMLLegendElement": false,
              "HTMLLIElement": false,
              "HTMLLinkElement": false,
              "HTMLMapElement": false,
              "HTMLMenuElement": false,
              "HTMLMetaElement": false,
              "HTMLModElement": false,
              "HTMLObjectElement": false,
              "HTMLOListElement": false,
              "HTMLOptGroupElement": false,
              "HTMLOptionElement": false,
              "HTMLParagraphElement": false,
              "HTMLParamElement": false,
              "HTMLPreElement": false,
              "HTMLQuoteElement": false,
              "HTMLScriptElement": false,
              "HTMLSelectElement": false,
              "HTMLStyleElement": false,
              "HTMLTableCaptionElement": false,
              "HTMLTableCellElement": false,
              "HTMLTableColElement": false,
              "HTMLTableElement": false,
              "HTMLTableRowElement": false,
              "HTMLTableSectionElement": false,
              "HTMLTextAreaElement": false,
              "HTMLTitleElement": false,
              "HTMLUListElement": false,
              "HTMLVideoElement": false,
              "IDBCursor": false,
              "IDBCursorWithValue": false,
              "IDBDatabase": false,
              "IDBEnvironment": false,
              "IDBFactory": false,
              "IDBIndex": false,
              "IDBKeyRange": false,
              "IDBObjectStore": false,
              "IDBOpenDBRequest": false,
              "IDBRequest": false,
              "IDBTransaction": false,
              "IDBVersionChangeEvent": false,
              "Image": false,
              "indexedDB": false,
              "innerHeight": false,
              "innerWidth": false,
              "InputEvent": false,
              "Intl": false,
              "KeyboardEvent": false,
              "length": false,
              "localStorage": false,
              "location": false,
              "matchMedia": false,
              "MessageChannel": false,
              "MessageEvent": false,
              "MessagePort": false,
              "MouseEvent": false,
              "moveBy": false,
              "moveTo": false,
              "MutationObserver": false,
              "name": false,
              "navigator": false,
              "Node": false,
              "NodeFilter": false,
              "NodeList": false,
              "Notification": false,
              "OfflineAudioCompletionEvent": false,
              "onbeforeunload": true,
              "onblur": true,
              "onerror": true,
              "onfocus": true,
              "onload": true,
              "onresize": true,
              "onunload": true,
              "open": false,
              "openDatabase": false,
              "opener": false,
              "opera": false,
              "Option": false,
              "outerHeight": false,
              "outerWidth": false,
              "PageTransitionEvent": false,
              "pageXOffset": false,
              "pageYOffset": false,
              "parent": false,
              "PopStateEvent": false,
              "postMessage": false,
              "print": false,
              "ProgressEvent": false,
              "prompt": false,
              "Range": false,
              "Request": false,
              "Response": false,
              "removeEventListener": false,
              "requestAnimationFrame": false,
              "resizeBy": false,
              "resizeTo": false,
              "screen": false,
              "screenX": false,
              "screenY": false,
              "scroll": false,
              "scrollbars": false,
              "scrollBy": false,
              "scrollTo": false,
              "scrollX": false,
              "scrollY": false,
              "self": false,
              "sessionStorage": false,
              "setInterval": false,
              "setTimeout": false,
              "SharedWorker": false,
              "showModalDialog": false,
              "status": false,
              "stop": false,
              "StorageEvent": false,
              "SVGAElement": false,
              "SVGAltGlyphDefElement": false,
              "SVGAltGlyphElement": false,
              "SVGAltGlyphItemElement": false,
              "SVGAngle": false,
              "SVGAnimateColorElement": false,
              "SVGAnimatedAngle": false,
              "SVGAnimatedBoolean": false,
              "SVGAnimatedEnumeration": false,
              "SVGAnimatedInteger": false,
              "SVGAnimatedLength": false,
              "SVGAnimatedLengthList": false,
              "SVGAnimatedNumber": false,
              "SVGAnimatedNumberList": false,
              "SVGAnimatedPathData": false,
              "SVGAnimatedPoints": false,
              "SVGAnimatedPreserveAspectRatio": false,
              "SVGAnimatedRect": false,
              "SVGAnimatedString": false,
              "SVGAnimatedTransformList": false,
              "SVGAnimateElement": false,
              "SVGAnimateMotionElement": false,
              "SVGAnimateTransformElement": false,
              "SVGAnimationElement": false,
              "SVGCircleElement": false,
              "SVGClipPathElement": false,
              "SVGColor": false,
              "SVGColorProfileElement": false,
              "SVGColorProfileRule": false,
              "SVGComponentTransferFunctionElement": false,
              "SVGCSSRule": false,
              "SVGCursorElement": false,
              "SVGDefsElement": false,
              "SVGDescElement": false,
              "SVGDocument": false,
              "SVGElement": false,
              "SVGElementInstance": false,
              "SVGElementInstanceList": false,
              "SVGEllipseElement": false,
              "SVGEvent": false,
              "SVGExternalResourcesRequired": false,
              "SVGFEBlendElement": false,
              "SVGFEColorMatrixElement": false,
              "SVGFEComponentTransferElement": false,
              "SVGFECompositeElement": false,
              "SVGFEConvolveMatrixElement": false,
              "SVGFEDiffuseLightingElement": false,
              "SVGFEDisplacementMapElement": false,
              "SVGFEDistantLightElement": false,
              "SVGFEFloodElement": false,
              "SVGFEFuncAElement": false,
              "SVGFEFuncBElement": false,
              "SVGFEFuncGElement": false,
              "SVGFEFuncRElement": false,
              "SVGFEGaussianBlurElement": false,
              "SVGFEImageElement": false,
              "SVGFEMergeElement": false,
              "SVGFEMergeNodeElement": false,
              "SVGFEMorphologyElement": false,
              "SVGFEOffsetElement": false,
              "SVGFEPointLightElement": false,
              "SVGFESpecularLightingElement": false,
              "SVGFESpotLightElement": false,
              "SVGFETileElement": false,
              "SVGFETurbulenceElement": false,
              "SVGFilterElement": false,
              "SVGFilterPrimitiveStandardAttributes": false,
              "SVGFitToViewBox": false,
              "SVGFontElement": false,
              "SVGFontFaceElement": false,
              "SVGFontFaceFormatElement": false,
              "SVGFontFaceNameElement": false,
              "SVGFontFaceSrcElement": false,
              "SVGFontFaceUriElement": false,
              "SVGForeignObjectElement": false,
              "SVGGElement": false,
              "SVGGlyphElement": false,
              "SVGGlyphRefElement": false,
              "SVGGradientElement": false,
              "SVGHKernElement": false,
              "SVGICCColor": false,
              "SVGImageElement": false,
              "SVGLangSpace": false,
              "SVGLength": false,
              "SVGLengthList": false,
              "SVGLinearGradientElement": false,
              "SVGLineElement": false,
              "SVGLocatable": false,
              "SVGMarkerElement": false,
              "SVGMaskElement": false,
              "SVGMatrix": false,
              "SVGMetadataElement": false,
              "SVGMissingGlyphElement": false,
              "SVGMPathElement": false,
              "SVGNumber": false,
              "SVGNumberList": false,
              "SVGPaint": false,
              "SVGPathElement": false,
              "SVGPathSeg": false,
              "SVGPathSegArcAbs": false,
              "SVGPathSegArcRel": false,
              "SVGPathSegClosePath": false,
              "SVGPathSegCurvetoCubicAbs": false,
              "SVGPathSegCurvetoCubicRel": false,
              "SVGPathSegCurvetoCubicSmoothAbs": false,
              "SVGPathSegCurvetoCubicSmoothRel": false,
              "SVGPathSegCurvetoQuadraticAbs": false,
              "SVGPathSegCurvetoQuadraticRel": false,
              "SVGPathSegCurvetoQuadraticSmoothAbs": false,
              "SVGPathSegCurvetoQuadraticSmoothRel": false,
              "SVGPathSegLinetoAbs": false,
              "SVGPathSegLinetoHorizontalAbs": false,
              "SVGPathSegLinetoHorizontalRel": false,
              "SVGPathSegLinetoRel": false,
              "SVGPathSegLinetoVerticalAbs": false,
              "SVGPathSegLinetoVerticalRel": false,
              "SVGPathSegList": false,
              "SVGPathSegMovetoAbs": false,
              "SVGPathSegMovetoRel": false,
              "SVGPatternElement": false,
              "SVGPoint": false,
              "SVGPointList": false,
              "SVGPolygonElement": false,
              "SVGPolylineElement": false,
              "SVGPreserveAspectRatio": false,
              "SVGRadialGradientElement": false,
              "SVGRect": false,
              "SVGRectElement": false,
              "SVGRenderingIntent": false,
              "SVGScriptElement": false,
              "SVGSetElement": false,
              "SVGStopElement": false,
              "SVGStringList": false,
              "SVGStylable": false,
              "SVGStyleElement": false,
              "SVGSVGElement": false,
              "SVGSwitchElement": false,
              "SVGSymbolElement": false,
              "SVGTests": false,
              "SVGTextContentElement": false,
              "SVGTextElement": false,
              "SVGTextPathElement": false,
              "SVGTextPositioningElement": false,
              "SVGTitleElement": false,
              "SVGTransform": false,
              "SVGTransformable": false,
              "SVGTransformList": false,
              "SVGTRefElement": false,
              "SVGTSpanElement": false,
              "SVGUnitTypes": false,
              "SVGURIReference": false,
              "SVGUseElement": false,
              "SVGViewElement": false,
              "SVGViewSpec": false,
              "SVGVKernElement": false,
              "SVGZoomAndPan": false,
              "Text": false,
              "TextDecoder": false,
              "TextEncoder": false,
              "TimeEvent": false,
              "top": false,
              "TouchEvent": false,
              "UIEvent": false,
              "URL": false,
              "WebGLActiveInfo": false,
              "WebGLBuffer": false,
              "WebGLContextEvent": false,
              "WebGLFramebuffer": false,
              "WebGLProgram": false,
              "WebGLRenderbuffer": false,
              "WebGLRenderingContext": false,
              "WebGLShader": false,
              "WebGLShaderPrecisionFormat": false,
              "WebGLTexture": false,
              "WebGLUniformLocation": false,
              "WebSocket": false,
              "WheelEvent": false,
              "window": false,
              "Window": false,
              "Worker": false,
              "XDomainRequest": false,
              "XMLHttpRequest": false,
              "XMLSerializer": false,
              "XPathEvaluator": false,
              "XPathException": false,
              "XPathExpression": false,
              "XPathNamespace": false,
              "XPathNSResolver": false,
              "XPathResult": false
            },
            "worker": {
              "importScripts": true,
              "postMessage": true,
              "self": true
            },
            "node": {
              "__dirname": false,
              "__filename": false,
              "arguments": false,
              "Buffer": false,
              "clearImmediate": false,
              "clearInterval": false,
              "clearTimeout": false,
              "console": false,
              "DataView": false,
              "exports": true,
              "GLOBAL": false,
              "global": false,
              "module": false,
              "process": false,
              "require": false,
              "setImmediate": false,
              "setInterval": false,
              "setTimeout": false
            },
            "amd": {
              "define": false,
              "require": false
            },
            "mocha": {
              "after": false,
              "afterEach": false,
              "before": false,
              "beforeEach": false,
              "context": false,
              "describe": false,
              "it": false,
              "setup": false,
              "specify": false,
              "suite": false,
              "suiteSetup": false,
              "suiteTeardown": false,
              "teardown": false,
              "test": false,
              "xcontext": false,
              "xdescribe": false,
              "xit": false,
              "xspecify": false
            },
            "jasmine": {
              "afterAll": false,
              "afterEach": false,
              "beforeAll": false,
              "beforeEach": false,
              "describe": false,
              "expect": false,
              "fail": false,
              "fdescribe": false,
              "fit": false,
              "it": false,
              "jasmine": false,
              "pending": false,
              "runs": false,
              "spyOn": false,
              "waits": false,
              "waitsFor": false,
              "xdescribe": false,
              "xit": false
            },
            "qunit": {
              "asyncTest": false,
              "deepEqual": false,
              "equal": false,
              "expect": false,
              "module": false,
              "notDeepEqual": false,
              "notEqual": false,
              "notPropEqual": false,
              "notStrictEqual": false,
              "ok": false,
              "propEqual": false,
              "QUnit": false,
              "raises": false,
              "start": false,
              "stop": false,
              "strictEqual": false,
              "test": false,
              "throws": false
            },
            "phantomjs": {
              "console": true,
              "exports": true,
              "phantom": true,
              "require": true,
              "WebPage": true
            },
            "couch": {
              "emit": false,
              "exports": false,
              "getRow": false,
              "log": false,
              "module": false,
              "provides": false,
              "require": false,
              "respond": false,
              "send": false,
              "start": false,
              "sum": false
            },
            "rhino": {
              "defineClass": false,
              "deserialize": false,
              "gc": false,
              "help": false,
              "importClass": false,
              "importPackage": false,
              "java": false,
              "load": false,
              "loadClass": false,
              "Packages": false,
              "print": false,
              "quit": false,
              "readFile": false,
              "readUrl": false,
              "runCommand": false,
              "seal": false,
              "serialize": false,
              "spawn": false,
              "sync": false,
              "toint32": false,
              "version": false
            },
            "wsh": {
              "ActiveXObject": true,
              "Enumerator": true,
              "GetObject": true,
              "ScriptEngine": true,
              "ScriptEngineBuildVersion": true,
              "ScriptEngineMajorVersion": true,
              "ScriptEngineMinorVersion": true,
              "VBArray": true,
              "WScript": true,
              "WSH": true,
              "XDomainRequest": true
            },
            "jquery": {
              "$": false,
              "jQuery": false
            },
            "yui": {
              "Y": false,
              "YUI": false,
              "YUI_config": false
            },
            "shelljs": {
              "cat": false,
              "cd": false,
              "chmod": false,
              "config": false,
              "cp": false,
              "dirs": false,
              "echo": false,
              "env": false,
              "error": false,
              "exec": false,
              "exit": false,
              "find": false,
              "grep": false,
              "ls": false,
              "mkdir": false,
              "mv": false,
              "popd": false,
              "pushd": false,
              "pwd": false,
              "rm": false,
              "sed": false,
              "target": false,
              "tempdir": false,
              "test": false,
              "which": false
            },
            "prototypejs": {
              "$": false,
              "$$": false,
              "$A": false,
              "$break": false,
              "$continue": false,
              "$F": false,
              "$H": false,
              "$R": false,
              "$w": false,
              "Abstract": false,
              "Ajax": false,
              "Autocompleter": false,
              "Builder": false,
              "Class": false,
              "Control": false,
              "Draggable": false,
              "Draggables": false,
              "Droppables": false,
              "Effect": false,
              "Element": false,
              "Enumerable": false,
              "Event": false,
              "Field": false,
              "Form": false,
              "Hash": false,
              "Insertion": false,
              "ObjectRange": false,
              "PeriodicalExecuter": false,
              "Position": false,
              "Prototype": false,
              "Scriptaculous": false,
              "Selector": false,
              "Sortable": false,
              "SortableObserver": false,
              "Sound": false,
              "Template": false,
              "Toggle": false,
              "Try": false
            },
            "meteor": {
              "$": false,
              "_": false,
              "Accounts": false,
              "App": false,
              "Assets": false,
              "Blaze": false,
              "check": false,
              "Cordova": false,
              "DDP": false,
              "DDPServer": false,
              "Deps": false,
              "EJSON": false,
              "Email": false,
              "HTTP": false,
              "Log": false,
              "Match": false,
              "Meteor": false,
              "Mongo": false,
              "MongoInternals": false,
              "Npm": false,
              "Package": false,
              "Plugin": false,
              "process": false,
              "Random": false,
              "ReactiveDict": false,
              "ReactiveVar": false,
              "Router": false,
              "Session": false,
              "share": false,
              "Spacebars": false,
              "Template": false,
              "Tinytest": false,
              "Tracker": false,
              "UI": false,
              "Utils": false,
              "WebApp": false,
              "WebAppInternals": false
            },
            "mongo": {
              "_isWindows": false,
              "_rand": false,
              "BulkWriteResult": false,
              "cat": false,
              "cd": false,
              "connect": false,
              "db": false,
              "getHostName": false,
              "getMemInfo": false,
              "hostname": false,
              "listFiles": false,
              "load": false,
              "ls": false,
              "md5sumFile": false,
              "mkdir": false,
              "Mongo": false,
              "ObjectId": false,
              "PlanCache": false,
              "pwd": false,
              "quit": false,
              "removeFile": false,
              "rs": false,
              "sh": false,
              "UUID": false,
              "version": false,
              "WriteResult": false
            },
            "applescript": {
              "$": false,
              "Application": false,
              "Automation": false,
              "console": false,
              "delay": false,
              "Library": false,
              "ObjC": false,
              "ObjectSpecifier": false,
              "Path": false,
              "Progress": false,
              "Ref": false
            }
          };
        }, {}],
        414: [function(require, module, exports) {
          module.exports = require('./globals.json');
        }, {"./globals.json": 413}],
        415: [function(require, module, exports) {
          var isFinite = require("is-finite");
          module.exports = Number.isInteger || function(val) {
            return typeof val === "number" && isFinite(val) && Math.floor(val) === val;
          };
        }, {"is-finite": 416}],
        416: [function(require, module, exports) {
          'use strict';
          var numberIsNan = require('number-is-nan');
          module.exports = Number.isFinite || function(val) {
            return !(typeof val !== 'number' || numberIsNan(val) || val === Infinity || val === -Infinity);
          };
        }, {"number-is-nan": 417}],
        417: [function(require, module, exports) {
          'use strict';
          module.exports = Number.isNaN || function(x) {
            return x !== x;
          };
        }, {}],
        418: [function(require, module, exports) {
          module.exports = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|((?:0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?))|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]{1,6}\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-*\/%&|^]|<{1,2}|>{1,3}|!=?|={1,2})=?|[?:~]|[;,.[\](){}])|(\s+)|(^$|[\s\S])/g;
          module.exports.matchToToken = function(match) {
            var token = {
              type: "invalid",
              value: match[0]
            };
            if (match[1])
              token.type = "string", token.closed = !!(match[3] || match[4]);
            else if (match[5])
              token.type = "comment";
            else if (match[6])
              token.type = "comment", token.closed = !!match[7];
            else if (match[8])
              token.type = "regex";
            else if (match[9])
              token.type = "number";
            else if (match[10])
              token.type = "name";
            else if (match[11])
              token.type = "punctuator";
            else if (match[12])
              token.type = "whitespace";
            return token;
          };
        }, {}],
        419: [function(require, module, exports) {
          var JSON5 = (typeof exports === 'object' ? exports : {});
          JSON5.parse = (function() {
            "use strict";
            var at,
                ch,
                escapee = {
                  "'": "'",
                  '"': '"',
                  '\\': '\\',
                  '/': '/',
                  '\n': '',
                  b: '\b',
                  f: '\f',
                  n: '\n',
                  r: '\r',
                  t: '\t'
                },
                ws = [' ', '\t', '\r', '\n', '\v', '\f', '\xA0', '\uFEFF'],
                text,
                error = function(m) {
                  var error = new SyntaxError();
                  error.message = m;
                  error.at = at;
                  error.text = text;
                  throw error;
                },
                next = function(c) {
                  if (c && c !== ch) {
                    error("Expected '" + c + "' instead of '" + ch + "'");
                  }
                  ch = text.charAt(at);
                  at += 1;
                  return ch;
                },
                peek = function() {
                  return text.charAt(at);
                },
                identifier = function() {
                  var key = ch;
                  if ((ch !== '_' && ch !== '$') && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {
                    error("Bad identifier");
                  }
                  while (next() && (ch === '_' || ch === '$' || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'))) {
                    key += ch;
                  }
                  return key;
                },
                number = function() {
                  var number,
                      sign = '',
                      string = '',
                      base = 10;
                  if (ch === '-' || ch === '+') {
                    sign = ch;
                    next(ch);
                  }
                  if (ch === 'I') {
                    number = word();
                    if (typeof number !== 'number' || isNaN(number)) {
                      error('Unexpected word for number');
                    }
                    return (sign === '-') ? -number : number;
                  }
                  if (ch === 'N') {
                    number = word();
                    if (!isNaN(number)) {
                      error('expected word to be NaN');
                    }
                    return number;
                  }
                  if (ch === '0') {
                    string += ch;
                    next();
                    if (ch === 'x' || ch === 'X') {
                      string += ch;
                      next();
                      base = 16;
                    } else if (ch >= '0' && ch <= '9') {
                      error('Octal literal');
                    }
                  }
                  switch (base) {
                    case 10:
                      while (ch >= '0' && ch <= '9') {
                        string += ch;
                        next();
                      }
                      if (ch === '.') {
                        string += '.';
                        while (next() && ch >= '0' && ch <= '9') {
                          string += ch;
                        }
                      }
                      if (ch === 'e' || ch === 'E') {
                        string += ch;
                        next();
                        if (ch === '-' || ch === '+') {
                          string += ch;
                          next();
                        }
                        while (ch >= '0' && ch <= '9') {
                          string += ch;
                          next();
                        }
                      }
                      break;
                    case 16:
                      while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
                        string += ch;
                        next();
                      }
                      break;
                  }
                  if (sign === '-') {
                    number = -string;
                  } else {
                    number = +string;
                  }
                  if (!isFinite(number)) {
                    error("Bad number");
                  } else {
                    return number;
                  }
                },
                string = function() {
                  var hex,
                      i,
                      string = '',
                      delim,
                      uffff;
                  if (ch === '"' || ch === "'") {
                    delim = ch;
                    while (next()) {
                      if (ch === delim) {
                        next();
                        return string;
                      } else if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                          uffff = 0;
                          for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                              break;
                            }
                            uffff = uffff * 16 + hex;
                          }
                          string += String.fromCharCode(uffff);
                        } else if (ch === '\r') {
                          if (peek() === '\n') {
                            next();
                          }
                        } else if (typeof escapee[ch] === 'string') {
                          string += escapee[ch];
                        } else {
                          break;
                        }
                      } else if (ch === '\n') {
                        break;
                      } else {
                        string += ch;
                      }
                    }
                  }
                  error("Bad string");
                },
                inlineComment = function() {
                  if (ch !== '/') {
                    error("Not an inline comment");
                  }
                  do {
                    next();
                    if (ch === '\n' || ch === '\r') {
                      next();
                      return;
                    }
                  } while (ch);
                },
                blockComment = function() {
                  if (ch !== '*') {
                    error("Not a block comment");
                  }
                  do {
                    next();
                    while (ch === '*') {
                      next('*');
                      if (ch === '/') {
                        next('/');
                        return;
                      }
                    }
                  } while (ch);
                  error("Unterminated block comment");
                },
                comment = function() {
                  if (ch !== '/') {
                    error("Not a comment");
                  }
                  next('/');
                  if (ch === '/') {
                    inlineComment();
                  } else if (ch === '*') {
                    blockComment();
                  } else {
                    error("Unrecognized comment");
                  }
                },
                white = function() {
                  while (ch) {
                    if (ch === '/') {
                      comment();
                    } else if (ws.indexOf(ch) >= 0) {
                      next();
                    } else {
                      return;
                    }
                  }
                },
                word = function() {
                  switch (ch) {
                    case 't':
                      next('t');
                      next('r');
                      next('u');
                      next('e');
                      return true;
                    case 'f':
                      next('f');
                      next('a');
                      next('l');
                      next('s');
                      next('e');
                      return false;
                    case 'n':
                      next('n');
                      next('u');
                      next('l');
                      next('l');
                      return null;
                    case 'I':
                      next('I');
                      next('n');
                      next('f');
                      next('i');
                      next('n');
                      next('i');
                      next('t');
                      next('y');
                      return Infinity;
                    case 'N':
                      next('N');
                      next('a');
                      next('N');
                      return NaN;
                  }
                  error("Unexpected '" + ch + "'");
                },
                value,
                array = function() {
                  var array = [];
                  if (ch === '[') {
                    next('[');
                    white();
                    while (ch) {
                      if (ch === ']') {
                        next(']');
                        return array;
                      }
                      if (ch === ',') {
                        error("Missing array element");
                      } else {
                        array.push(value());
                      }
                      white();
                      if (ch !== ',') {
                        next(']');
                        return array;
                      }
                      next(',');
                      white();
                    }
                  }
                  error("Bad array");
                },
                object = function() {
                  var key,
                      object = {};
                  if (ch === '{') {
                    next('{');
                    white();
                    while (ch) {
                      if (ch === '}') {
                        next('}');
                        return object;
                      }
                      if (ch === '"' || ch === "'") {
                        key = string();
                      } else {
                        key = identifier();
                      }
                      white();
                      next(':');
                      object[key] = value();
                      white();
                      if (ch !== ',') {
                        next('}');
                        return object;
                      }
                      next(',');
                      white();
                    }
                  }
                  error("Bad object");
                };
            value = function() {
              white();
              switch (ch) {
                case '{':
                  return object();
                case '[':
                  return array();
                case '"':
                case "'":
                  return string();
                case '-':
                case '+':
                case '.':
                  return number();
                default:
                  return ch >= '0' && ch <= '9' ? number() : word();
              }
            };
            return function(source, reviver) {
              var result;
              text = String(source);
              at = 0;
              ch = ' ';
              result = value();
              white();
              if (ch) {
                error("Syntax error");
              }
              return typeof reviver === 'function' ? (function walk(holder, key) {
                var k,
                    v,
                    value = holder[key];
                if (value && typeof value === 'object') {
                  for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = walk(value, k);
                      if (v !== undefined) {
                        value[k] = v;
                      } else {
                        delete value[k];
                      }
                    }
                  }
                }
                return reviver.call(holder, key, value);
              }({'': result}, '')) : result;
            };
          }());
          JSON5.stringify = function(obj, replacer, space) {
            if (replacer && (typeof(replacer) !== "function" && !isArray(replacer))) {
              throw new Error('Replacer must be a function or an array');
            }
            var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
              var value = holder[key];
              if (value && value.toJSON && typeof value.toJSON === "function") {
                value = value.toJSON();
              }
              if (typeof(replacer) === "function") {
                return replacer.call(holder, key, value);
              } else if (replacer) {
                if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {
                  return value;
                } else {
                  return undefined;
                }
              } else {
                return value;
              }
            };
            function isWordChar(char) {
              return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || (char >= '0' && char <= '9') || char === '_' || char === '$';
            }
            function isWordStart(char) {
              return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || char === '_' || char === '$';
            }
            function isWord(key) {
              if (typeof key !== 'string') {
                return false;
              }
              if (!isWordStart(key[0])) {
                return false;
              }
              var i = 1,
                  length = key.length;
              while (i < length) {
                if (!isWordChar(key[i])) {
                  return false;
                }
                i++;
              }
              return true;
            }
            JSON5.isWord = isWord;
            function isArray(obj) {
              if (Array.isArray) {
                return Array.isArray(obj);
              } else {
                return Object.prototype.toString.call(obj) === '[object Array]';
              }
            }
            function isDate(obj) {
              return Object.prototype.toString.call(obj) === '[object Date]';
            }
            isNaN = isNaN || function(val) {
              return typeof val === 'number' && val !== val;
            };
            var objStack = [];
            function checkForCircular(obj) {
              for (var i = 0; i < objStack.length; i++) {
                if (objStack[i] === obj) {
                  throw new TypeError("Converting circular structure to JSON");
                }
              }
            }
            function makeIndent(str, num, noNewLine) {
              if (!str) {
                return "";
              }
              if (str.length > 10) {
                str = str.substring(0, 10);
              }
              var indent = noNewLine ? "" : "\n";
              for (var i = 0; i < num; i++) {
                indent += str;
              }
              return indent;
            }
            var indentStr;
            if (space) {
              if (typeof space === "string") {
                indentStr = space;
              } else if (typeof space === "number" && space >= 0) {
                indentStr = makeIndent(" ", space, true);
              } else {}
            }
            var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                meta = {
                  '\b': '\\b',
                  '\t': '\\t',
                  '\n': '\\n',
                  '\f': '\\f',
                  '\r': '\\r',
                  '"': '\\"',
                  '\\': '\\\\'
                };
            function escapeString(string) {
              escapable.lastIndex = 0;
              return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
                var c = meta[a];
                return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
              }) + '"' : '"' + string + '"';
            }
            function internalStringify(holder, key, isTopLevel) {
              var buffer,
                  res;
              var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);
              if (obj_part && !isDate(obj_part)) {
                obj_part = obj_part.valueOf();
              }
              switch (typeof obj_part) {
                case "boolean":
                  return obj_part.toString();
                case "number":
                  if (isNaN(obj_part) || !isFinite(obj_part)) {
                    return "null";
                  }
                  return obj_part.toString();
                case "string":
                  return escapeString(obj_part.toString());
                case "object":
                  if (obj_part === null) {
                    return "null";
                  } else if (isArray(obj_part)) {
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);
                    for (var i = 0; i < obj_part.length; i++) {
                      res = internalStringify(obj_part, i, false);
                      buffer += makeIndent(indentStr, objStack.length);
                      if (res === null || typeof res === "undefined") {
                        buffer += "null";
                      } else {
                        buffer += res;
                      }
                      if (i < obj_part.length - 1) {
                        buffer += ",";
                      } else if (indentStr) {
                        buffer += "\n";
                      }
                    }
                    objStack.pop();
                    buffer += makeIndent(indentStr, objStack.length, true) + "]";
                  } else {
                    checkForCircular(obj_part);
                    buffer = "{";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part) {
                      if (obj_part.hasOwnProperty(prop)) {
                        var value = internalStringify(obj_part, prop, false);
                        isTopLevel = false;
                        if (typeof value !== "undefined" && value !== null) {
                          buffer += makeIndent(indentStr, objStack.length);
                          nonEmpty = true;
                          var key = isWord(prop) ? prop : escapeString(prop);
                          buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
                        }
                      }
                    }
                    objStack.pop();
                    if (nonEmpty) {
                      buffer = buffer.substring(0, buffer.length - 1) + makeIndent(indentStr, objStack.length) + "}";
                    } else {
                      buffer = '{}';
                    }
                  }
                  return buffer;
                default:
                  return undefined;
              }
            }
            var topLevelHolder = {"": obj};
            if (obj === undefined) {
              return getReplacedValueOrUndefined(topLevelHolder, '', true);
            }
            return internalStringify(topLevelHolder, '', true);
          };
        }, {}],
        420: [function(require, module, exports) {
          var leftPad = require("left-pad");
          function get(options, key, defaultValue) {
            return (key in options ? options[key] : defaultValue);
          }
          function lineNumbers(code, options) {
            var getOption = get.bind(null, options || {});
            var transform = getOption("transform", Function.prototype);
            var padding = getOption("padding", " ");
            var before = getOption("before", " ");
            var after = getOption("after", " | ");
            var start = getOption("start", 1);
            var isArray = Array.isArray(code);
            var lines = (isArray ? code : code.split("\n"));
            var end = start + lines.length - 1;
            var width = String(end).length;
            var numbered = lines.map(function(line, index) {
              var number = start + index;
              var params = {
                before: before,
                number: number,
                width: width,
                after: after,
                line: line
              };
              transform(params);
              return params.before + leftPad(params.number, width, padding) + params.after + params.line;
            });
            return (isArray ? numbered : numbered.join("\n"));
          }
          module.exports = lineNumbers;
        }, {"left-pad": 421}],
        421: [function(require, module, exports) {
          module.exports = leftpad;
          function leftpad(str, len, ch) {
            str = String(str);
            var i = -1;
            ch || (ch = ' ');
            len = len - str.length;
            while (++i < len) {
              str = ch + str;
            }
            return str;
          }
        }, {}],
        422: [function(require, module, exports) {
          function compact(array) {
            var index = -1,
                length = array ? array.length : 0,
                resIndex = -1,
                result = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result[++resIndex] = value;
              }
            }
            return result;
          }
          module.exports = compact;
        }, {}],
        423: [function(require, module, exports) {
          var baseFlatten = require('../internal/baseFlatten'),
              isIterateeCall = require('../internal/isIterateeCall');
          function flatten(array, isDeep, guard) {
            var length = array ? array.length : 0;
            if (guard && isIterateeCall(array, isDeep, guard)) {
              isDeep = false;
            }
            return length ? baseFlatten(array, isDeep) : [];
          }
          module.exports = flatten;
        }, {
          "../internal/baseFlatten": 452,
          "../internal/isIterateeCall": 502
        }],
        424: [function(require, module, exports) {
          function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
          }
          module.exports = last;
        }, {}],
        425: [function(require, module, exports) {
          var baseIndexOf = require('../internal/baseIndexOf');
          var arrayProto = Array.prototype;
          var splice = arrayProto.splice;
          function pull() {
            var args = arguments,
                array = args[0];
            if (!(array && array.length)) {
              return array;
            }
            var index = 0,
                indexOf = baseIndexOf,
                length = args.length;
            while (++index < length) {
              var fromIndex = 0,
                  value = args[index];
              while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          module.exports = pull;
        }, {"../internal/baseIndexOf": 459}],
        426: [function(require, module, exports) {
          var baseCallback = require('../internal/baseCallback'),
              baseUniq = require('../internal/baseUniq'),
              isIterateeCall = require('../internal/isIterateeCall'),
              sortedUniq = require('../internal/sortedUniq');
          function uniq(array, isSorted, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (isSorted != null && typeof isSorted != 'boolean') {
              thisArg = iteratee;
              iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
              isSorted = false;
            }
            iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
            return (isSorted) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
          }
          module.exports = uniq;
        }, {
          "../internal/baseCallback": 446,
          "../internal/baseUniq": 475,
          "../internal/isIterateeCall": 502,
          "../internal/sortedUniq": 508
        }],
        427: [function(require, module, exports) {
          module.exports = require('./includes');
        }, {"./includes": 430}],
        428: [function(require, module, exports) {
          module.exports = require('./forEach');
        }, {"./forEach": 429}],
        429: [function(require, module, exports) {
          var arrayEach = require('../internal/arrayEach'),
              baseEach = require('../internal/baseEach'),
              createForEach = require('../internal/createForEach');
          var forEach = createForEach(arrayEach, baseEach);
          module.exports = forEach;
        }, {
          "../internal/arrayEach": 438,
          "../internal/baseEach": 450,
          "../internal/createForEach": 487
        }],
        430: [function(require, module, exports) {
          var baseIndexOf = require('../internal/baseIndexOf'),
              getLength = require('../internal/getLength'),
              isArray = require('../lang/isArray'),
              isIterateeCall = require('../internal/isIterateeCall'),
              isLength = require('../internal/isLength'),
              isString = require('../lang/isString'),
              values = require('../object/values');
          var nativeMax = Math.max;
          function includes(collection, target, fromIndex, guard) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              collection = values(collection);
              length = collection.length;
            }
            if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
              fromIndex = 0;
            } else {
              fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
            }
            return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1) : (!!length && baseIndexOf(collection, target, fromIndex) > -1);
          }
          module.exports = includes;
        }, {
          "../internal/baseIndexOf": 459,
          "../internal/getLength": 493,
          "../internal/isIterateeCall": 502,
          "../internal/isLength": 504,
          "../lang/isArray": 514,
          "../lang/isString": 523,
          "../object/values": 534
        }],
        431: [function(require, module, exports) {
          var arrayMap = require('../internal/arrayMap'),
              baseCallback = require('../internal/baseCallback'),
              baseMap = require('../internal/baseMap'),
              isArray = require('../lang/isArray');
          function map(collection, iteratee, thisArg) {
            var func = isArray(collection) ? arrayMap : baseMap;
            iteratee = baseCallback(iteratee, thisArg, 3);
            return func(collection, iteratee);
          }
          module.exports = map;
        }, {
          "../internal/arrayMap": 439,
          "../internal/baseCallback": 446,
          "../internal/baseMap": 463,
          "../lang/isArray": 514
        }],
        432: [function(require, module, exports) {
          var arrayReduceRight = require('../internal/arrayReduceRight'),
              baseEachRight = require('../internal/baseEachRight'),
              createReduce = require('../internal/createReduce');
          var reduceRight = createReduce(arrayReduceRight, baseEachRight);
          module.exports = reduceRight;
        }, {
          "../internal/arrayReduceRight": 441,
          "../internal/baseEachRight": 451,
          "../internal/createReduce": 488
        }],
        433: [function(require, module, exports) {
          var arraySome = require('../internal/arraySome'),
              baseCallback = require('../internal/baseCallback'),
              baseSome = require('../internal/baseSome'),
              isArray = require('../lang/isArray'),
              isIterateeCall = require('../internal/isIterateeCall');
          function some(collection, predicate, thisArg) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
              predicate = undefined;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
              predicate = baseCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
          }
          module.exports = some;
        }, {
          "../internal/arraySome": 442,
          "../internal/baseCallback": 446,
          "../internal/baseSome": 472,
          "../internal/isIterateeCall": 502,
          "../lang/isArray": 514
        }],
        434: [function(require, module, exports) {
          var baseCallback = require('../internal/baseCallback'),
              baseMap = require('../internal/baseMap'),
              baseSortBy = require('../internal/baseSortBy'),
              compareAscending = require('../internal/compareAscending'),
              isIterateeCall = require('../internal/isIterateeCall');
          function sortBy(collection, iteratee, thisArg) {
            if (collection == null) {
              return [];
            }
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            var index = -1;
            iteratee = baseCallback(iteratee, thisArg, 3);
            var result = baseMap(collection, function(value, key, collection) {
              return {
                'criteria': iteratee(value, key, collection),
                'index': ++index,
                'value': value
              };
            });
            return baseSortBy(result, compareAscending);
          }
          module.exports = sortBy;
        }, {
          "../internal/baseCallback": 446,
          "../internal/baseMap": 463,
          "../internal/baseSortBy": 473,
          "../internal/compareAscending": 481,
          "../internal/isIterateeCall": 502
        }],
        435: [function(require, module, exports) {
          var FUNC_ERROR_TEXT = 'Expected a function';
          var nativeMax = Math.max;
          function restParam(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
            return function() {
              var args = arguments,
                  index = -1,
                  length = nativeMax(args.length - start, 0),
                  rest = Array(length);
              while (++index < length) {
                rest[index] = args[start + index];
              }
              switch (start) {
                case 0:
                  return func.call(this, rest);
                case 1:
                  return func.call(this, args[0], rest);
                case 2:
                  return func.call(this, args[0], args[1], rest);
              }
              var otherArgs = Array(start + 1);
              index = -1;
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = rest;
              return func.apply(this, otherArgs);
            };
          }
          module.exports = restParam;
        }, {}],
        436: [function(require, module, exports) {
          (function(global) {
            var cachePush = require('./cachePush'),
                getNative = require('./getNative');
            var Set = getNative(global, 'Set');
            var nativeCreate = getNative(Object, 'create');
            function SetCache(values) {
              var length = values ? values.length : 0;
              this.data = {
                'hash': nativeCreate(null),
                'set': new Set
              };
              while (length--) {
                this.push(values[length]);
              }
            }
            SetCache.prototype.push = cachePush;
            module.exports = SetCache;
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {
          "./cachePush": 480,
          "./getNative": 495
        }],
        437: [function(require, module, exports) {
          function arrayCopy(source, array) {
            var index = -1,
                length = source.length;
            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          module.exports = arrayCopy;
        }, {}],
        438: [function(require, module, exports) {
          function arrayEach(array, iteratee) {
            var index = -1,
                length = array.length;
            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break;
              }
            }
            return array;
          }
          module.exports = arrayEach;
        }, {}],
        439: [function(require, module, exports) {
          function arrayMap(array, iteratee) {
            var index = -1,
                length = array.length,
                result = Array(length);
            while (++index < length) {
              result[index] = iteratee(array[index], index, array);
            }
            return result;
          }
          module.exports = arrayMap;
        }, {}],
        440: [function(require, module, exports) {
          function arrayPush(array, values) {
            var index = -1,
                length = values.length,
                offset = array.length;
            while (++index < length) {
              array[offset + index] = values[index];
            }
            return array;
          }
          module.exports = arrayPush;
        }, {}],
        441: [function(require, module, exports) {
          function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
            var length = array.length;
            if (initFromArray && length) {
              accumulator = array[--length];
            }
            while (length--) {
              accumulator = iteratee(accumulator, array[length], length, array);
            }
            return accumulator;
          }
          module.exports = arrayReduceRight;
        }, {}],
        442: [function(require, module, exports) {
          function arraySome(array, predicate) {
            var index = -1,
                length = array.length;
            while (++index < length) {
              if (predicate(array[index], index, array)) {
                return true;
              }
            }
            return false;
          }
          module.exports = arraySome;
        }, {}],
        443: [function(require, module, exports) {
          function assignDefaults(objectValue, sourceValue) {
            return objectValue === undefined ? sourceValue : objectValue;
          }
          module.exports = assignDefaults;
        }, {}],
        444: [function(require, module, exports) {
          var keys = require('../object/keys');
          function assignWith(object, source, customizer) {
            var index = -1,
                props = keys(source),
                length = props.length;
            while (++index < length) {
              var key = props[index],
                  value = object[key],
                  result = customizer(value, source[key], key, object, source);
              if ((result === result ? (result !== value) : (value === value)) || (value === undefined && !(key in object))) {
                object[key] = result;
              }
            }
            return object;
          }
          module.exports = assignWith;
        }, {"../object/keys": 530}],
        445: [function(require, module, exports) {
          var baseCopy = require('./baseCopy'),
              keys = require('../object/keys');
          function baseAssign(object, source) {
            return source == null ? object : baseCopy(source, keys(source), object);
          }
          module.exports = baseAssign;
        }, {
          "../object/keys": 530,
          "./baseCopy": 449
        }],
        446: [function(require, module, exports) {
          var baseMatches = require('./baseMatches'),
              baseMatchesProperty = require('./baseMatchesProperty'),
              bindCallback = require('./bindCallback'),
              identity = require('../utility/identity'),
              property = require('../utility/property');
          function baseCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (type == 'function') {
              return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
            }
            if (func == null) {
              return identity;
            }
            if (type == 'object') {
              return baseMatches(func);
            }
            return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
          }
          module.exports = baseCallback;
        }, {
          "../utility/identity": 537,
          "../utility/property": 538,
          "./baseMatches": 464,
          "./baseMatchesProperty": 465,
          "./bindCallback": 477
        }],
        447: [function(require, module, exports) {
          var arrayCopy = require('./arrayCopy'),
              arrayEach = require('./arrayEach'),
              baseAssign = require('./baseAssign'),
              baseForOwn = require('./baseForOwn'),
              initCloneArray = require('./initCloneArray'),
              initCloneByTag = require('./initCloneByTag'),
              initCloneObject = require('./initCloneObject'),
              isArray = require('../lang/isArray'),
              isObject = require('../lang/isObject');
          var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              funcTag = '[object Function]',
              mapTag = '[object Map]',
              numberTag = '[object Number]',
              objectTag = '[object Object]',
              regexpTag = '[object RegExp]',
              setTag = '[object Set]',
              stringTag = '[object String]',
              weakMapTag = '[object WeakMap]';
          var arrayBufferTag = '[object ArrayBuffer]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
          var cloneableTags = {};
          cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
          cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
          var objectProto = Object.prototype;
          var objToString = objectProto.toString;
          function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
            var result;
            if (customizer) {
              result = object ? customizer(value, key, object) : customizer(value);
            }
            if (result !== undefined) {
              return result;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result = initCloneArray(value);
              if (!isDeep) {
                return arrayCopy(value, result);
              }
            } else {
              var tag = objToString.call(value),
                  isFunc = tag == funcTag;
              if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                result = initCloneObject(isFunc ? {} : value);
                if (!isDeep) {
                  return baseAssign(result, value);
                }
              } else {
                return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
              }
            }
            stackA || (stackA = []);
            stackB || (stackB = []);
            var length = stackA.length;
            while (length--) {
              if (stackA[length] == value) {
                return stackB[length];
              }
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
              result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
            });
            return result;
          }
          module.exports = baseClone;
        }, {
          "../lang/isArray": 514,
          "../lang/isObject": 520,
          "./arrayCopy": 437,
          "./arrayEach": 438,
          "./baseAssign": 445,
          "./baseForOwn": 455,
          "./initCloneArray": 497,
          "./initCloneByTag": 498,
          "./initCloneObject": 499
        }],
        448: [function(require, module, exports) {
          function baseCompareAscending(value, other) {
            if (value !== other) {
              var valIsNull = value === null,
                  valIsUndef = value === undefined,
                  valIsReflexive = value === value;
              var othIsNull = other === null,
                  othIsUndef = other === undefined,
                  othIsReflexive = other === other;
              if ((value > other && !othIsNull) || !valIsReflexive || (valIsNull && !othIsUndef && othIsReflexive) || (valIsUndef && othIsReflexive)) {
                return 1;
              }
              if ((value < other && !valIsNull) || !othIsReflexive || (othIsNull && !valIsUndef && valIsReflexive) || (othIsUndef && valIsReflexive)) {
                return -1;
              }
            }
            return 0;
          }
          module.exports = baseCompareAscending;
        }, {}],
        449: [function(require, module, exports) {
          function baseCopy(source, props, object) {
            object || (object = {});
            var index = -1,
                length = props.length;
            while (++index < length) {
              var key = props[index];
              object[key] = source[key];
            }
            return object;
          }
          module.exports = baseCopy;
        }, {}],
        450: [function(require, module, exports) {
          var baseForOwn = require('./baseForOwn'),
              createBaseEach = require('./createBaseEach');
          var baseEach = createBaseEach(baseForOwn);
          module.exports = baseEach;
        }, {
          "./baseForOwn": 455,
          "./createBaseEach": 483
        }],
        451: [function(require, module, exports) {
          var baseForOwnRight = require('./baseForOwnRight'),
              createBaseEach = require('./createBaseEach');
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          module.exports = baseEachRight;
        }, {
          "./baseForOwnRight": 456,
          "./createBaseEach": 483
        }],
        452: [function(require, module, exports) {
          var arrayPush = require('./arrayPush'),
              isArguments = require('../lang/isArguments'),
              isArray = require('../lang/isArray'),
              isArrayLike = require('./isArrayLike'),
              isObjectLike = require('./isObjectLike');
          function baseFlatten(array, isDeep, isStrict, result) {
            result || (result = []);
            var index = -1,
                length = array.length;
            while (++index < length) {
              var value = array[index];
              if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
                if (isDeep) {
                  baseFlatten(value, isDeep, isStrict, result);
                } else {
                  arrayPush(result, value);
                }
              } else if (!isStrict) {
                result[result.length] = value;
              }
            }
            return result;
          }
          module.exports = baseFlatten;
        }, {
          "../lang/isArguments": 513,
          "../lang/isArray": 514,
          "./arrayPush": 440,
          "./isArrayLike": 500,
          "./isObjectLike": 505
        }],
        453: [function(require, module, exports) {
          var createBaseFor = require('./createBaseFor');
          var baseFor = createBaseFor();
          module.exports = baseFor;
        }, {"./createBaseFor": 484}],
        454: [function(require, module, exports) {
          var baseFor = require('./baseFor'),
              keysIn = require('../object/keysIn');
          function baseForIn(object, iteratee) {
            return baseFor(object, iteratee, keysIn);
          }
          module.exports = baseForIn;
        }, {
          "../object/keysIn": 531,
          "./baseFor": 453
        }],
        455: [function(require, module, exports) {
          var baseFor = require('./baseFor'),
              keys = require('../object/keys');
          function baseForOwn(object, iteratee) {
            return baseFor(object, iteratee, keys);
          }
          module.exports = baseForOwn;
        }, {
          "../object/keys": 530,
          "./baseFor": 453
        }],
        456: [function(require, module, exports) {
          var baseForRight = require('./baseForRight'),
              keys = require('../object/keys');
          function baseForOwnRight(object, iteratee) {
            return baseForRight(object, iteratee, keys);
          }
          module.exports = baseForOwnRight;
        }, {
          "../object/keys": 530,
          "./baseForRight": 457
        }],
        457: [function(require, module, exports) {
          var createBaseFor = require('./createBaseFor');
          var baseForRight = createBaseFor(true);
          module.exports = baseForRight;
        }, {"./createBaseFor": 484}],
        458: [function(require, module, exports) {
          var toObject = require('./toObject');
          function baseGet(object, path, pathKey) {
            if (object == null) {
              return;
            }
            if (pathKey !== undefined && pathKey in toObject(object)) {
              path = [pathKey];
            }
            var index = 0,
                length = path.length;
            while (object != null && index < length) {
              object = object[path[index++]];
            }
            return (index && index == length) ? object : undefined;
          }
          module.exports = baseGet;
        }, {"./toObject": 509}],
        459: [function(require, module, exports) {
          var indexOfNaN = require('./indexOfNaN');
          function baseIndexOf(array, value, fromIndex) {
            if (value !== value) {
              return indexOfNaN(array, fromIndex);
            }
            var index = fromIndex - 1,
                length = array.length;
            while (++index < length) {
              if (array[index] === value) {
                return index;
              }
            }
            return -1;
          }
          module.exports = baseIndexOf;
        }, {"./indexOfNaN": 496}],
        460: [function(require, module, exports) {
          var baseIsEqualDeep = require('./baseIsEqualDeep'),
              isObject = require('../lang/isObject'),
              isObjectLike = require('./isObjectLike');
          function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
          }
          module.exports = baseIsEqual;
        }, {
          "../lang/isObject": 520,
          "./baseIsEqualDeep": 461,
          "./isObjectLike": 505
        }],
        461: [function(require, module, exports) {
          var equalArrays = require('./equalArrays'),
              equalByTag = require('./equalByTag'),
              equalObjects = require('./equalObjects'),
              isArray = require('../lang/isArray'),
              isTypedArray = require('../lang/isTypedArray');
          var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              objectTag = '[object Object]';
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var objToString = objectProto.toString;
          function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;
            if (!objIsArr) {
              objTag = objToString.call(object);
              if (objTag == argsTag) {
                objTag = objectTag;
              } else if (objTag != objectTag) {
                objIsArr = isTypedArray(object);
              }
            }
            if (!othIsArr) {
              othTag = objToString.call(other);
              if (othTag == argsTag) {
                othTag = objectTag;
              } else if (othTag != objectTag) {
                othIsArr = isTypedArray(other);
              }
            }
            var objIsObj = objTag == objectTag,
                othIsObj = othTag == objectTag,
                isSameTag = objTag == othTag;
            if (isSameTag && !(objIsArr || objIsObj)) {
              return equalByTag(object, other, objTag);
            }
            if (!isLoose) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
              if (objIsWrapped || othIsWrapped) {
                return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stackA || (stackA = []);
            stackB || (stackB = []);
            var length = stackA.length;
            while (length--) {
              if (stackA[length] == object) {
                return stackB[length] == other;
              }
            }
            stackA.push(object);
            stackB.push(other);
            var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
            stackA.pop();
            stackB.pop();
            return result;
          }
          module.exports = baseIsEqualDeep;
        }, {
          "../lang/isArray": 514,
          "../lang/isTypedArray": 524,
          "./equalArrays": 489,
          "./equalByTag": 490,
          "./equalObjects": 491
        }],
        462: [function(require, module, exports) {
          var baseIsEqual = require('./baseIsEqual'),
              toObject = require('./toObject');
          function baseIsMatch(object, matchData, customizer) {
            var index = matchData.length,
                length = index,
                noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = toObject(object);
            while (index--) {
              var data = matchData[index];
              if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false;
                }
              } else {
                var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                  return false;
                }
              }
            }
            return true;
          }
          module.exports = baseIsMatch;
        }, {
          "./baseIsEqual": 460,
          "./toObject": 509
        }],
        463: [function(require, module, exports) {
          var baseEach = require('./baseEach'),
              isArrayLike = require('./isArrayLike');
          function baseMap(collection, iteratee) {
            var index = -1,
                result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value, key, collection) {
              result[++index] = iteratee(value, key, collection);
            });
            return result;
          }
          module.exports = baseMap;
        }, {
          "./baseEach": 450,
          "./isArrayLike": 500
        }],
        464: [function(require, module, exports) {
          var baseIsMatch = require('./baseIsMatch'),
              getMatchData = require('./getMatchData'),
              toObject = require('./toObject');
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              var key = matchData[0][0],
                  value = matchData[0][1];
              return function(object) {
                if (object == null) {
                  return false;
                }
                return object[key] === value && (value !== undefined || (key in toObject(object)));
              };
            }
            return function(object) {
              return baseIsMatch(object, matchData);
            };
          }
          module.exports = baseMatches;
        }, {
          "./baseIsMatch": 462,
          "./getMatchData": 494,
          "./toObject": 509
        }],
        465: [function(require, module, exports) {
          var baseGet = require('./baseGet'),
              baseIsEqual = require('./baseIsEqual'),
              baseSlice = require('./baseSlice'),
              isArray = require('../lang/isArray'),
              isKey = require('./isKey'),
              isStrictComparable = require('./isStrictComparable'),
              last = require('../array/last'),
              toObject = require('./toObject'),
              toPath = require('./toPath');
          function baseMatchesProperty(path, srcValue) {
            var isArr = isArray(path),
                isCommon = isKey(path) && isStrictComparable(srcValue),
                pathKey = (path + '');
            path = toPath(path);
            return function(object) {
              if (object == null) {
                return false;
              }
              var key = pathKey;
              object = toObject(object);
              if ((isArr || !isCommon) && !(key in object)) {
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                if (object == null) {
                  return false;
                }
                key = last(path);
                object = toObject(object);
              }
              return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
            };
          }
          module.exports = baseMatchesProperty;
        }, {
          "../array/last": 424,
          "../lang/isArray": 514,
          "./baseGet": 458,
          "./baseIsEqual": 460,
          "./baseSlice": 471,
          "./isKey": 503,
          "./isStrictComparable": 506,
          "./toObject": 509,
          "./toPath": 510
        }],
        466: [function(require, module, exports) {
          var arrayEach = require('./arrayEach'),
              baseMergeDeep = require('./baseMergeDeep'),
              isArray = require('../lang/isArray'),
              isArrayLike = require('./isArrayLike'),
              isObject = require('../lang/isObject'),
              isObjectLike = require('./isObjectLike'),
              isTypedArray = require('../lang/isTypedArray'),
              keys = require('../object/keys');
          function baseMerge(object, source, customizer, stackA, stackB) {
            if (!isObject(object)) {
              return object;
            }
            var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
                props = isSrcArr ? undefined : keys(source);
            arrayEach(props || source, function(srcValue, key) {
              if (props) {
                key = srcValue;
                srcValue = source[key];
              }
              if (isObjectLike(srcValue)) {
                stackA || (stackA = []);
                stackB || (stackB = []);
                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
              } else {
                var value = object[key],
                    result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                    isCommon = result === undefined;
                if (isCommon) {
                  result = srcValue;
                }
                if ((result !== undefined || (isSrcArr && !(key in object))) && (isCommon || (result === result ? (result !== value) : (value === value)))) {
                  object[key] = result;
                }
              }
            });
            return object;
          }
          module.exports = baseMerge;
        }, {
          "../lang/isArray": 514,
          "../lang/isObject": 520,
          "../lang/isTypedArray": 524,
          "../object/keys": 530,
          "./arrayEach": 438,
          "./baseMergeDeep": 467,
          "./isArrayLike": 500,
          "./isObjectLike": 505
        }],
        467: [function(require, module, exports) {
          var arrayCopy = require('./arrayCopy'),
              isArguments = require('../lang/isArguments'),
              isArray = require('../lang/isArray'),
              isArrayLike = require('./isArrayLike'),
              isPlainObject = require('../lang/isPlainObject'),
              isTypedArray = require('../lang/isTypedArray'),
              toPlainObject = require('../lang/toPlainObject');
          function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
            var length = stackA.length,
                srcValue = source[key];
            while (length--) {
              if (stackA[length] == srcValue) {
                object[key] = stackB[length];
                return;
              }
            }
            var value = object[key],
                result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                isCommon = result === undefined;
            if (isCommon) {
              result = srcValue;
              if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                result = isArray(value) ? value : (isArrayLike(value) ? arrayCopy(value) : []);
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
              } else {
                isCommon = false;
              }
            }
            stackA.push(srcValue);
            stackB.push(result);
            if (isCommon) {
              object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
            } else if (result === result ? (result !== value) : (value === value)) {
              object[key] = result;
            }
          }
          module.exports = baseMergeDeep;
        }, {
          "../lang/isArguments": 513,
          "../lang/isArray": 514,
          "../lang/isPlainObject": 521,
          "../lang/isTypedArray": 524,
          "../lang/toPlainObject": 525,
          "./arrayCopy": 437,
          "./isArrayLike": 500
        }],
        468: [function(require, module, exports) {
          function baseProperty(key) {
            return function(object) {
              return object == null ? undefined : object[key];
            };
          }
          module.exports = baseProperty;
        }, {}],
        469: [function(require, module, exports) {
          var baseGet = require('./baseGet'),
              toPath = require('./toPath');
          function basePropertyDeep(path) {
            var pathKey = (path + '');
            path = toPath(path);
            return function(object) {
              return baseGet(object, path, pathKey);
            };
          }
          module.exports = basePropertyDeep;
        }, {
          "./baseGet": 458,
          "./toPath": 510
        }],
        470: [function(require, module, exports) {
          function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
            eachFunc(collection, function(value, index, collection) {
              accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
            });
            return accumulator;
          }
          module.exports = baseReduce;
        }, {}],
        471: [function(require, module, exports) {
          function baseSlice(array, start, end) {
            var index = -1,
                length = array.length;
            start = start == null ? 0 : (+start || 0);
            if (start < 0) {
              start = -start > length ? 0 : (length + start);
            }
            end = (end === undefined || end > length) ? length : (+end || 0);
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : ((end - start) >>> 0);
            start >>>= 0;
            var result = Array(length);
            while (++index < length) {
              result[index] = array[index + start];
            }
            return result;
          }
          module.exports = baseSlice;
        }, {}],
        472: [function(require, module, exports) {
          var baseEach = require('./baseEach');
          function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function(value, index, collection) {
              result = predicate(value, index, collection);
              return !result;
            });
            return !!result;
          }
          module.exports = baseSome;
        }, {"./baseEach": 450}],
        473: [function(require, module, exports) {
          function baseSortBy(array, comparer) {
            var length = array.length;
            array.sort(comparer);
            while (length--) {
              array[length] = array[length].value;
            }
            return array;
          }
          module.exports = baseSortBy;
        }, {}],
        474: [function(require, module, exports) {
          function baseToString(value) {
            return value == null ? '' : (value + '');
          }
          module.exports = baseToString;
        }, {}],
        475: [function(require, module, exports) {
          var baseIndexOf = require('./baseIndexOf'),
              cacheIndexOf = require('./cacheIndexOf'),
              createCache = require('./createCache');
          var LARGE_ARRAY_SIZE = 200;
          function baseUniq(array, iteratee) {
            var index = -1,
                indexOf = baseIndexOf,
                length = array.length,
                isCommon = true,
                isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
                seen = isLarge ? createCache() : null,
                result = [];
            if (seen) {
              indexOf = cacheIndexOf;
              isCommon = false;
            } else {
              isLarge = false;
              seen = iteratee ? [] : result;
            }
            outer: while (++index < length) {
              var value = array[index],
                  computed = iteratee ? iteratee(value, index, array) : value;
              if (isCommon && value === value) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee) {
                  seen.push(computed);
                }
                result.push(value);
              } else if (indexOf(seen, computed, 0) < 0) {
                if (iteratee || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            return result;
          }
          module.exports = baseUniq;
        }, {
          "./baseIndexOf": 459,
          "./cacheIndexOf": 479,
          "./createCache": 485
        }],
        476: [function(require, module, exports) {
          function baseValues(object, props) {
            var index = -1,
                length = props.length,
                result = Array(length);
            while (++index < length) {
              result[index] = object[props[index]];
            }
            return result;
          }
          module.exports = baseValues;
        }, {}],
        477: [function(require, module, exports) {
          var identity = require('../utility/identity');
          function bindCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
              return identity;
            }
            if (thisArg === undefined) {
              return func;
            }
            switch (argCount) {
              case 1:
                return function(value) {
                  return func.call(thisArg, value);
                };
              case 3:
                return function(value, index, collection) {
                  return func.call(thisArg, value, index, collection);
                };
              case 4:
                return function(accumulator, value, index, collection) {
                  return func.call(thisArg, accumulator, value, index, collection);
                };
              case 5:
                return function(value, other, key, object, source) {
                  return func.call(thisArg, value, other, key, object, source);
                };
            }
            return function() {
              return func.apply(thisArg, arguments);
            };
          }
          module.exports = bindCallback;
        }, {"../utility/identity": 537}],
        478: [function(require, module, exports) {
          (function(global) {
            var ArrayBuffer = global.ArrayBuffer,
                Uint8Array = global.Uint8Array;
            function bufferClone(buffer) {
              var result = new ArrayBuffer(buffer.byteLength),
                  view = new Uint8Array(result);
              view.set(new Uint8Array(buffer));
              return result;
            }
            module.exports = bufferClone;
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        479: [function(require, module, exports) {
          var isObject = require('../lang/isObject');
          function cacheIndexOf(cache, value) {
            var data = cache.data,
                result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
            return result ? 0 : -1;
          }
          module.exports = cacheIndexOf;
        }, {"../lang/isObject": 520}],
        480: [function(require, module, exports) {
          var isObject = require('../lang/isObject');
          function cachePush(value) {
            var data = this.data;
            if (typeof value == 'string' || isObject(value)) {
              data.set.add(value);
            } else {
              data.hash[value] = true;
            }
          }
          module.exports = cachePush;
        }, {"../lang/isObject": 520}],
        481: [function(require, module, exports) {
          var baseCompareAscending = require('./baseCompareAscending');
          function compareAscending(object, other) {
            return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
          }
          module.exports = compareAscending;
        }, {"./baseCompareAscending": 448}],
        482: [function(require, module, exports) {
          var bindCallback = require('./bindCallback'),
              isIterateeCall = require('./isIterateeCall'),
              restParam = require('../function/restParam');
          function createAssigner(assigner) {
            return restParam(function(object, sources) {
              var index = -1,
                  length = object == null ? 0 : sources.length,
                  customizer = length > 2 ? sources[length - 2] : undefined,
                  guard = length > 2 ? sources[2] : undefined,
                  thisArg = length > 1 ? sources[length - 1] : undefined;
              if (typeof customizer == 'function') {
                customizer = bindCallback(customizer, thisArg, 5);
                length -= 2;
              } else {
                customizer = typeof thisArg == 'function' ? thisArg : undefined;
                length -= (customizer ? 1 : 0);
              }
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, customizer);
                }
              }
              return object;
            });
          }
          module.exports = createAssigner;
        }, {
          "../function/restParam": 435,
          "./bindCallback": 477,
          "./isIterateeCall": 502
        }],
        483: [function(require, module, exports) {
          var getLength = require('./getLength'),
              isLength = require('./isLength'),
              toObject = require('./toObject');
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
              var length = collection ? getLength(collection) : 0;
              if (!isLength(length)) {
                return eachFunc(collection, iteratee);
              }
              var index = fromRight ? length : -1,
                  iterable = toObject(collection);
              while ((fromRight ? index-- : ++index < length)) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          module.exports = createBaseEach;
        }, {
          "./getLength": 493,
          "./isLength": 504,
          "./toObject": 509
        }],
        484: [function(require, module, exports) {
          var toObject = require('./toObject');
          function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
              var iterable = toObject(object),
                  props = keysFunc(object),
                  length = props.length,
                  index = fromRight ? length : -1;
              while ((fromRight ? index-- : ++index < length)) {
                var key = props[index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          module.exports = createBaseFor;
        }, {"./toObject": 509}],
        485: [function(require, module, exports) {
          (function(global) {
            var SetCache = require('./SetCache'),
                getNative = require('./getNative');
            var Set = getNative(global, 'Set');
            var nativeCreate = getNative(Object, 'create');
            function createCache(values) {
              return (nativeCreate && Set) ? new SetCache(values) : null;
            }
            module.exports = createCache;
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {
          "./SetCache": 436,
          "./getNative": 495
        }],
        486: [function(require, module, exports) {
          var restParam = require('../function/restParam');
          function createDefaults(assigner, customizer) {
            return restParam(function(args) {
              var object = args[0];
              if (object == null) {
                return object;
              }
              args.push(customizer);
              return assigner.apply(undefined, args);
            });
          }
          module.exports = createDefaults;
        }, {"../function/restParam": 435}],
        487: [function(require, module, exports) {
          var bindCallback = require('./bindCallback'),
              isArray = require('../lang/isArray');
          function createForEach(arrayFunc, eachFunc) {
            return function(collection, iteratee, thisArg) {
              return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
            };
          }
          module.exports = createForEach;
        }, {
          "../lang/isArray": 514,
          "./bindCallback": 477
        }],
        488: [function(require, module, exports) {
          var baseCallback = require('./baseCallback'),
              baseReduce = require('./baseReduce'),
              isArray = require('../lang/isArray');
          function createReduce(arrayFunc, eachFunc) {
            return function(collection, iteratee, accumulator, thisArg) {
              var initFromArray = arguments.length < 3;
              return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, baseCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
            };
          }
          module.exports = createReduce;
        }, {
          "../lang/isArray": 514,
          "./baseCallback": 446,
          "./baseReduce": 470
        }],
        489: [function(require, module, exports) {
          var arraySome = require('./arraySome');
          function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var index = -1,
                arrLength = array.length,
                othLength = other.length;
            if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
              return false;
            }
            while (++index < arrLength) {
              var arrValue = array[index],
                  othValue = other[index],
                  result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
              if (result !== undefined) {
                if (result) {
                  continue;
                }
                return false;
              }
              if (isLoose) {
                if (!arraySome(other, function(othValue) {
                  return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                })) {
                  return false;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                return false;
              }
            }
            return true;
          }
          module.exports = equalArrays;
        }, {"./arraySome": 442}],
        490: [function(require, module, exports) {
          var boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              numberTag = '[object Number]',
              regexpTag = '[object RegExp]',
              stringTag = '[object String]';
          function equalByTag(object, other, tag) {
            switch (tag) {
              case boolTag:
              case dateTag:
                return +object == +other;
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case numberTag:
                return (object != +object) ? other != +other : object == +other;
              case regexpTag:
              case stringTag:
                return object == (other + '');
            }
            return false;
          }
          module.exports = equalByTag;
        }, {}],
        491: [function(require, module, exports) {
          var keys = require('../object/keys');
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;
            if (objLength != othLength && !isLoose) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var skipCtor = isLoose;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key],
                  othValue = other[key],
                  result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
              if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                return false;
              }
              skipCtor || (skipCtor = key == 'constructor');
            }
            if (!skipCtor) {
              var objCtor = object.constructor,
                  othCtor = other.constructor;
              if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                return false;
              }
            }
            return true;
          }
          module.exports = equalObjects;
        }, {"../object/keys": 530}],
        492: [function(require, module, exports) {
          var regexpEscapes = {
            '0': 'x30',
            '1': 'x31',
            '2': 'x32',
            '3': 'x33',
            '4': 'x34',
            '5': 'x35',
            '6': 'x36',
            '7': 'x37',
            '8': 'x38',
            '9': 'x39',
            'A': 'x41',
            'B': 'x42',
            'C': 'x43',
            'D': 'x44',
            'E': 'x45',
            'F': 'x46',
            'a': 'x61',
            'b': 'x62',
            'c': 'x63',
            'd': 'x64',
            'e': 'x65',
            'f': 'x66',
            'n': 'x6e',
            'r': 'x72',
            't': 'x74',
            'u': 'x75',
            'v': 'x76',
            'x': 'x78'
          };
          var stringEscapes = {
            '\\': '\\',
            "'": "'",
            '\n': 'n',
            '\r': 'r',
            '\u2028': 'u2028',
            '\u2029': 'u2029'
          };
          function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
            if (leadingChar) {
              chr = regexpEscapes[chr];
            } else if (whitespaceChar) {
              chr = stringEscapes[chr];
            }
            return '\\' + chr;
          }
          module.exports = escapeRegExpChar;
        }, {}],
        493: [function(require, module, exports) {
          var baseProperty = require('./baseProperty');
          var getLength = baseProperty('length');
          module.exports = getLength;
        }, {"./baseProperty": 468}],
        494: [function(require, module, exports) {
          var isStrictComparable = require('./isStrictComparable'),
              pairs = require('../object/pairs');
          function getMatchData(object) {
            var result = pairs(object),
                length = result.length;
            while (length--) {
              result[length][2] = isStrictComparable(result[length][1]);
            }
            return result;
          }
          module.exports = getMatchData;
        }, {
          "../object/pairs": 533,
          "./isStrictComparable": 506
        }],
        495: [function(require, module, exports) {
          var isNative = require('../lang/isNative');
          function getNative(object, key) {
            var value = object == null ? undefined : object[key];
            return isNative(value) ? value : undefined;
          }
          module.exports = getNative;
        }, {"../lang/isNative": 518}],
        496: [function(require, module, exports) {
          function indexOfNaN(array, fromIndex, fromRight) {
            var length = array.length,
                index = fromIndex + (fromRight ? 0 : -1);
            while ((fromRight ? index-- : ++index < length)) {
              var other = array[index];
              if (other !== other) {
                return index;
              }
            }
            return -1;
          }
          module.exports = indexOfNaN;
        }, {}],
        497: [function(require, module, exports) {
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function initCloneArray(array) {
            var length = array.length,
                result = new array.constructor(length);
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }
          module.exports = initCloneArray;
        }, {}],
        498: [function(require, module, exports) {
          var bufferClone = require('./bufferClone');
          var boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              numberTag = '[object Number]',
              regexpTag = '[object RegExp]',
              stringTag = '[object String]';
          var arrayBufferTag = '[object ArrayBuffer]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
          var reFlags = /\w*$/;
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return bufferClone(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                var buffer = object.buffer;
                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                var result = new Ctor(object.source, reFlags.exec(object));
                result.lastIndex = object.lastIndex;
            }
            return result;
          }
          module.exports = initCloneByTag;
        }, {"./bufferClone": 478}],
        499: [function(require, module, exports) {
          function initCloneObject(object) {
            var Ctor = object.constructor;
            if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
              Ctor = Object;
            }
            return new Ctor;
          }
          module.exports = initCloneObject;
        }, {}],
        500: [function(require, module, exports) {
          var getLength = require('./getLength'),
              isLength = require('./isLength');
          function isArrayLike(value) {
            return value != null && isLength(getLength(value));
          }
          module.exports = isArrayLike;
        }, {
          "./getLength": 493,
          "./isLength": 504
        }],
        501: [function(require, module, exports) {
          var reIsUint = /^\d+$/;
          var MAX_SAFE_INTEGER = 9007199254740991;
          function isIndex(value, length) {
            value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return value > -1 && value % 1 == 0 && value < length;
          }
          module.exports = isIndex;
        }, {}],
        502: [function(require, module, exports) {
          var isArrayLike = require('./isArrayLike'),
              isIndex = require('./isIndex'),
              isObject = require('../lang/isObject');
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
              var other = object[index];
              return value === value ? (value === other) : (other !== other);
            }
            return false;
          }
          module.exports = isIterateeCall;
        }, {
          "../lang/isObject": 520,
          "./isArrayLike": 500,
          "./isIndex": 501
        }],
        503: [function(require, module, exports) {
          var isArray = require('../lang/isArray'),
              toObject = require('./toObject');
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
              reIsPlainProp = /^\w*$/;
          function isKey(value, object) {
            var type = typeof value;
            if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
              return true;
            }
            if (isArray(value)) {
              return false;
            }
            var result = !reIsDeepProp.test(value);
            return result || (object != null && value in toObject(object));
          }
          module.exports = isKey;
        }, {
          "../lang/isArray": 514,
          "./toObject": 509
        }],
        504: [function(require, module, exports) {
          var MAX_SAFE_INTEGER = 9007199254740991;
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          module.exports = isLength;
        }, {}],
        505: [function(require, module, exports) {
          function isObjectLike(value) {
            return !!value && typeof value == 'object';
          }
          module.exports = isObjectLike;
        }, {}],
        506: [function(require, module, exports) {
          var isObject = require('../lang/isObject');
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          module.exports = isStrictComparable;
        }, {"../lang/isObject": 520}],
        507: [function(require, module, exports) {
          var isArguments = require('../lang/isArguments'),
              isArray = require('../lang/isArray'),
              isIndex = require('./isIndex'),
              isLength = require('./isLength'),
              keysIn = require('../object/keysIn');
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function shimKeys(object) {
            var props = keysIn(object),
                propsLength = props.length,
                length = propsLength && object.length;
            var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
            var index = -1,
                result = [];
            while (++index < propsLength) {
              var key = props[index];
              if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                result.push(key);
              }
            }
            return result;
          }
          module.exports = shimKeys;
        }, {
          "../lang/isArguments": 513,
          "../lang/isArray": 514,
          "../object/keysIn": 531,
          "./isIndex": 501,
          "./isLength": 504
        }],
        508: [function(require, module, exports) {
          function sortedUniq(array, iteratee) {
            var seen,
                index = -1,
                length = array.length,
                resIndex = -1,
                result = [];
            while (++index < length) {
              var value = array[index],
                  computed = iteratee ? iteratee(value, index, array) : value;
              if (!index || seen !== computed) {
                seen = computed;
                result[++resIndex] = value;
              }
            }
            return result;
          }
          module.exports = sortedUniq;
        }, {}],
        509: [function(require, module, exports) {
          var isObject = require('../lang/isObject');
          function toObject(value) {
            return isObject(value) ? value : Object(value);
          }
          module.exports = toObject;
        }, {"../lang/isObject": 520}],
        510: [function(require, module, exports) {
          var baseToString = require('./baseToString'),
              isArray = require('../lang/isArray');
          var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
          var reEscapeChar = /\\(\\)?/g;
          function toPath(value) {
            if (isArray(value)) {
              return value;
            }
            var result = [];
            baseToString(value).replace(rePropName, function(match, number, quote, string) {
              result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
            });
            return result;
          }
          module.exports = toPath;
        }, {
          "../lang/isArray": 514,
          "./baseToString": 474
        }],
        511: [function(require, module, exports) {
          var baseClone = require('../internal/baseClone'),
              bindCallback = require('../internal/bindCallback'),
              isIterateeCall = require('../internal/isIterateeCall');
          function clone(value, isDeep, customizer, thisArg) {
            if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
              isDeep = false;
            } else if (typeof isDeep == 'function') {
              thisArg = customizer;
              customizer = isDeep;
              isDeep = false;
            }
            return typeof customizer == 'function' ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3)) : baseClone(value, isDeep);
          }
          module.exports = clone;
        }, {
          "../internal/baseClone": 447,
          "../internal/bindCallback": 477,
          "../internal/isIterateeCall": 502
        }],
        512: [function(require, module, exports) {
          var baseClone = require('../internal/baseClone'),
              bindCallback = require('../internal/bindCallback');
          function cloneDeep(value, customizer, thisArg) {
            return typeof customizer == 'function' ? baseClone(value, true, bindCallback(customizer, thisArg, 3)) : baseClone(value, true);
          }
          module.exports = cloneDeep;
        }, {
          "../internal/baseClone": 447,
          "../internal/bindCallback": 477
        }],
        513: [function(require, module, exports) {
          var isArrayLike = require('../internal/isArrayLike'),
              isObjectLike = require('../internal/isObjectLike');
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var propertyIsEnumerable = objectProto.propertyIsEnumerable;
          function isArguments(value) {
            return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
          }
          module.exports = isArguments;
        }, {
          "../internal/isArrayLike": 500,
          "../internal/isObjectLike": 505
        }],
        514: [function(require, module, exports) {
          var getNative = require('../internal/getNative'),
              isLength = require('../internal/isLength'),
              isObjectLike = require('../internal/isObjectLike');
          var arrayTag = '[object Array]';
          var objectProto = Object.prototype;
          var objToString = objectProto.toString;
          var nativeIsArray = getNative(Array, 'isArray');
          var isArray = nativeIsArray || function(value) {
            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
          };
          module.exports = isArray;
        }, {
          "../internal/getNative": 495,
          "../internal/isLength": 504,
          "../internal/isObjectLike": 505
        }],
        515: [function(require, module, exports) {
          var isObjectLike = require('../internal/isObjectLike');
          var boolTag = '[object Boolean]';
          var objectProto = Object.prototype;
          var objToString = objectProto.toString;
          function isBoolean(value) {
            return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
          }
          module.exports = isBoolean;
        }, {"../internal/isObjectLike": 505}],
        516: [function(require, module, exports) {
          var isArguments = require('./isArguments'),
              isArray = require('./isArray'),
              isArrayLike = require('../internal/isArrayLike'),
              isFunction = require('./isFunction'),
              isObjectLike = require('../internal/isObjectLike'),
              isString = require('./isString'),
              keys = require('../object/keys');
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
              return !value.length;
            }
            return !keys(value).length;
          }
          module.exports = isEmpty;
        }, {
          "../internal/isArrayLike": 500,
          "../internal/isObjectLike": 505,
          "../object/keys": 530,
          "./isArguments": 513,
          "./isArray": 514,
          "./isFunction": 517,
          "./isString": 523
        }],
        517: [function(require, module, exports) {
          var isObject = require('./isObject');
          var funcTag = '[object Function]';
          var objectProto = Object.prototype;
          var objToString = objectProto.toString;
          function isFunction(value) {
            return isObject(value) && objToString.call(value) == funcTag;
          }
          module.exports = isFunction;
        }, {"./isObject": 520}],
        518: [function(require, module, exports) {
          var isFunction = require('./isFunction'),
              isObjectLike = require('../internal/isObjectLike');
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          var objectProto = Object.prototype;
          var fnToString = Function.prototype.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
          function isNative(value) {
            if (value == null) {
              return false;
            }
            if (isFunction(value)) {
              return reIsNative.test(fnToString.call(value));
            }
            return isObjectLike(value) && reIsHostCtor.test(value);
          }
          module.exports = isNative;
        }, {
          "../internal/isObjectLike": 505,
          "./isFunction": 517
        }],
        519: [function(require, module, exports) {
          var isObjectLike = require('../internal/isObjectLike');
          var numberTag = '[object Number]';
          var objectProto = Object.prototype;
          var objToString = objectProto.toString;
          function isNumber(value) {
            return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
          }
          module.exports = isNumber;
        }, {"../internal/isObjectLike": 505}],
        520: [function(require, module, exports) {
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }
          module.exports = isObject;
        }, {}],
        521: [function(require, module, exports) {
          var baseForIn = require('../internal/baseForIn'),
              isArguments = require('./isArguments'),
              isObjectLike = require('../internal/isObjectLike');
          var objectTag = '[object Object]';
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var objToString = objectProto.toString;
          function isPlainObject(value) {
            var Ctor;
            if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
              return false;
            }
            var result;
            baseForIn(value, function(subValue, key) {
              result = key;
            });
            return result === undefined || hasOwnProperty.call(value, result);
          }
          module.exports = isPlainObject;
        }, {
          "../internal/baseForIn": 454,
          "../internal/isObjectLike": 505,
          "./isArguments": 513
        }],
        522: [function(require, module, exports) {
          var isObject = require('./isObject');
          var regexpTag = '[object RegExp]';
          var objectProto = Object.prototype;
          var objToString = objectProto.toString;
          function isRegExp(value) {
            return isObject(value) && objToString.call(value) == regexpTag;
          }
          module.exports = isRegExp;
        }, {"./isObject": 520}],
        523: [function(require, module, exports) {
          var isObjectLike = require('../internal/isObjectLike');
          var stringTag = '[object String]';
          var objectProto = Object.prototype;
          var objToString = objectProto.toString;
          function isString(value) {
            return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
          }
          module.exports = isString;
        }, {"../internal/isObjectLike": 505}],
        524: [function(require, module, exports) {
          var isLength = require('../internal/isLength'),
              isObjectLike = require('../internal/isObjectLike');
          var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              funcTag = '[object Function]',
              mapTag = '[object Map]',
              numberTag = '[object Number]',
              objectTag = '[object Object]',
              regexpTag = '[object RegExp]',
              setTag = '[object Set]',
              stringTag = '[object String]',
              weakMapTag = '[object WeakMap]';
          var arrayBufferTag = '[object ArrayBuffer]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
          var objectProto = Object.prototype;
          var objToString = objectProto.toString;
          function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
          }
          module.exports = isTypedArray;
        }, {
          "../internal/isLength": 504,
          "../internal/isObjectLike": 505
        }],
        525: [function(require, module, exports) {
          var baseCopy = require('../internal/baseCopy'),
              keysIn = require('../object/keysIn');
          function toPlainObject(value) {
            return baseCopy(value, keysIn(value));
          }
          module.exports = toPlainObject;
        }, {
          "../internal/baseCopy": 449,
          "../object/keysIn": 531
        }],
        526: [function(require, module, exports) {
          var assignWith = require('../internal/assignWith'),
              baseAssign = require('../internal/baseAssign'),
              createAssigner = require('../internal/createAssigner');
          var assign = createAssigner(function(object, source, customizer) {
            return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
          });
          module.exports = assign;
        }, {
          "../internal/assignWith": 444,
          "../internal/baseAssign": 445,
          "../internal/createAssigner": 482
        }],
        527: [function(require, module, exports) {
          var assign = require('./assign'),
              assignDefaults = require('../internal/assignDefaults'),
              createDefaults = require('../internal/createDefaults');
          var defaults = createDefaults(assign, assignDefaults);
          module.exports = defaults;
        }, {
          "../internal/assignDefaults": 443,
          "../internal/createDefaults": 486,
          "./assign": 526
        }],
        528: [function(require, module, exports) {
          module.exports = require('./assign');
        }, {"./assign": 526}],
        529: [function(require, module, exports) {
          var baseGet = require('../internal/baseGet'),
              baseSlice = require('../internal/baseSlice'),
              isArguments = require('../lang/isArguments'),
              isArray = require('../lang/isArray'),
              isIndex = require('../internal/isIndex'),
              isKey = require('../internal/isKey'),
              isLength = require('../internal/isLength'),
              last = require('../array/last'),
              toPath = require('../internal/toPath');
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function has(object, path) {
            if (object == null) {
              return false;
            }
            var result = hasOwnProperty.call(object, path);
            if (!result && !isKey(path)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              path = last(path);
              result = hasOwnProperty.call(object, path);
            }
            return result || (isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object)));
          }
          module.exports = has;
        }, {
          "../array/last": 424,
          "../internal/baseGet": 458,
          "../internal/baseSlice": 471,
          "../internal/isIndex": 501,
          "../internal/isKey": 503,
          "../internal/isLength": 504,
          "../internal/toPath": 510,
          "../lang/isArguments": 513,
          "../lang/isArray": 514
        }],
        530: [function(require, module, exports) {
          var getNative = require('../internal/getNative'),
              isArrayLike = require('../internal/isArrayLike'),
              isObject = require('../lang/isObject'),
              shimKeys = require('../internal/shimKeys');
          var nativeKeys = getNative(Object, 'keys');
          var keys = !nativeKeys ? shimKeys : function(object) {
            var Ctor = object == null ? undefined : object.constructor;
            if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
              return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
          };
          module.exports = keys;
        }, {
          "../internal/getNative": 495,
          "../internal/isArrayLike": 500,
          "../internal/shimKeys": 507,
          "../lang/isObject": 520
        }],
        531: [function(require, module, exports) {
          var isArguments = require('../lang/isArguments'),
              isArray = require('../lang/isArray'),
              isIndex = require('../internal/isIndex'),
              isLength = require('../internal/isLength'),
              isObject = require('../lang/isObject');
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function keysIn(object) {
            if (object == null) {
              return [];
            }
            if (!isObject(object)) {
              object = Object(object);
            }
            var length = object.length;
            length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
            var Ctor = object.constructor,
                index = -1,
                isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                result = Array(length),
                skipIndexes = length > 0;
            while (++index < length) {
              result[index] = (index + '');
            }
            for (var key in object) {
              if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }
          module.exports = keysIn;
        }, {
          "../internal/isIndex": 501,
          "../internal/isLength": 504,
          "../lang/isArguments": 513,
          "../lang/isArray": 514,
          "../lang/isObject": 520
        }],
        532: [function(require, module, exports) {
          var baseMerge = require('../internal/baseMerge'),
              createAssigner = require('../internal/createAssigner');
          var merge = createAssigner(baseMerge);
          module.exports = merge;
        }, {
          "../internal/baseMerge": 466,
          "../internal/createAssigner": 482
        }],
        533: [function(require, module, exports) {
          var keys = require('./keys'),
              toObject = require('../internal/toObject');
          function pairs(object) {
            object = toObject(object);
            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);
            while (++index < length) {
              var key = props[index];
              result[index] = [key, object[key]];
            }
            return result;
          }
          module.exports = pairs;
        }, {
          "../internal/toObject": 509,
          "./keys": 530
        }],
        534: [function(require, module, exports) {
          var baseValues = require('../internal/baseValues'),
              keys = require('./keys');
          function values(object) {
            return baseValues(object, keys(object));
          }
          module.exports = values;
        }, {
          "../internal/baseValues": 476,
          "./keys": 530
        }],
        535: [function(require, module, exports) {
          var baseToString = require('../internal/baseToString'),
              escapeRegExpChar = require('../internal/escapeRegExpChar');
          var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
              reHasRegExpChars = RegExp(reRegExpChars.source);
          function escapeRegExp(string) {
            string = baseToString(string);
            return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, escapeRegExpChar) : (string || '(?:)');
          }
          module.exports = escapeRegExp;
        }, {
          "../internal/baseToString": 474,
          "../internal/escapeRegExpChar": 492
        }],
        536: [function(require, module, exports) {
          var baseToString = require('../internal/baseToString');
          var nativeMin = Math.min;
          function startsWith(string, target, position) {
            string = baseToString(string);
            position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
            return string.lastIndexOf(target, position) == position;
          }
          module.exports = startsWith;
        }, {"../internal/baseToString": 474}],
        537: [function(require, module, exports) {
          function identity(value) {
            return value;
          }
          module.exports = identity;
        }, {}],
        538: [function(require, module, exports) {
          var baseProperty = require('../internal/baseProperty'),
              basePropertyDeep = require('../internal/basePropertyDeep'),
              isKey = require('../internal/isKey');
          function property(path) {
            return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
          }
          module.exports = property;
        }, {
          "../internal/baseProperty": 468,
          "../internal/basePropertyDeep": 469,
          "../internal/isKey": 503
        }],
        539: [function(require, module, exports) {
          module.exports = minimatch;
          minimatch.Minimatch = Minimatch;
          var path = {sep: '/'};
          try {
            path = require('path');
          } catch (er) {}
          var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
          var expand = require('brace-expansion');
          var qmark = '[^/]';
          var star = qmark + '*?';
          var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';
          var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';
          var reSpecials = charSet('().*{}+?[]^$\\!');
          function charSet(s) {
            return s.split('').reduce(function(set, c) {
              set[c] = true;
              return set;
            }, {});
          }
          var slashSplit = /\/+/;
          minimatch.filter = filter;
          function filter(pattern, options) {
            options = options || {};
            return function(p, i, list) {
              return minimatch(p, pattern, options);
            };
          }
          function ext(a, b) {
            a = a || {};
            b = b || {};
            var t = {};
            Object.keys(b).forEach(function(k) {
              t[k] = b[k];
            });
            Object.keys(a).forEach(function(k) {
              t[k] = a[k];
            });
            return t;
          }
          minimatch.defaults = function(def) {
            if (!def || !Object.keys(def).length)
              return minimatch;
            var orig = minimatch;
            var m = function minimatch(p, pattern, options) {
              return orig.minimatch(p, pattern, ext(def, options));
            };
            m.Minimatch = function Minimatch(pattern, options) {
              return new orig.Minimatch(pattern, ext(def, options));
            };
            return m;
          };
          Minimatch.defaults = function(def) {
            if (!def || !Object.keys(def).length)
              return Minimatch;
            return minimatch.defaults(def).Minimatch;
          };
          function minimatch(p, pattern, options) {
            if (typeof pattern !== 'string') {
              throw new TypeError('glob pattern string required');
            }
            if (!options)
              options = {};
            if (!options.nocomment && pattern.charAt(0) === '#') {
              return false;
            }
            if (pattern.trim() === '')
              return p === '';
            return new Minimatch(pattern, options).match(p);
          }
          function Minimatch(pattern, options) {
            if (!(this instanceof Minimatch)) {
              return new Minimatch(pattern, options);
            }
            if (typeof pattern !== 'string') {
              throw new TypeError('glob pattern string required');
            }
            if (!options)
              options = {};
            pattern = pattern.trim();
            if (path.sep !== '/') {
              pattern = pattern.split(path.sep).join('/');
            }
            this.options = options;
            this.set = [];
            this.pattern = pattern;
            this.regexp = null;
            this.negate = false;
            this.comment = false;
            this.empty = false;
            this.make();
          }
          Minimatch.prototype.debug = function() {};
          Minimatch.prototype.make = make;
          function make() {
            if (this._made)
              return;
            var pattern = this.pattern;
            var options = this.options;
            if (!options.nocomment && pattern.charAt(0) === '#') {
              this.comment = true;
              return;
            }
            if (!pattern) {
              this.empty = true;
              return;
            }
            this.parseNegate();
            var set = this.globSet = this.braceExpand();
            if (options.debug)
              this.debug = console.error;
            this.debug(this.pattern, set);
            set = this.globParts = set.map(function(s) {
              return s.split(slashSplit);
            });
            this.debug(this.pattern, set);
            set = set.map(function(s, si, set) {
              return s.map(this.parse, this);
            }, this);
            this.debug(this.pattern, set);
            set = set.filter(function(s) {
              return s.indexOf(false) === -1;
            });
            this.debug(this.pattern, set);
            this.set = set;
          }
          Minimatch.prototype.parseNegate = parseNegate;
          function parseNegate() {
            var pattern = this.pattern;
            var negate = false;
            var options = this.options;
            var negateOffset = 0;
            if (options.nonegate)
              return;
            for (var i = 0,
                l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
              negate = !negate;
              negateOffset++;
            }
            if (negateOffset)
              this.pattern = pattern.substr(negateOffset);
            this.negate = negate;
          }
          minimatch.braceExpand = function(pattern, options) {
            return braceExpand(pattern, options);
          };
          Minimatch.prototype.braceExpand = braceExpand;
          function braceExpand(pattern, options) {
            if (!options) {
              if (this instanceof Minimatch) {
                options = this.options;
              } else {
                options = {};
              }
            }
            pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
            if (typeof pattern === 'undefined') {
              throw new Error('undefined pattern');
            }
            if (options.nobrace || !pattern.match(/\{.*\}/)) {
              return [pattern];
            }
            return expand(pattern);
          }
          Minimatch.prototype.parse = parse;
          var SUBPARSE = {};
          function parse(pattern, isSub) {
            var options = this.options;
            if (!options.noglobstar && pattern === '**')
              return GLOBSTAR;
            if (pattern === '')
              return '';
            var re = '';
            var hasMagic = !!options.nocase;
            var escaping = false;
            var patternListStack = [];
            var negativeLists = [];
            var plType;
            var stateChar;
            var inClass = false;
            var reClassStart = -1;
            var classStart = -1;
            var patternStart = pattern.charAt(0) === '.' ? '' : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
            var self = this;
            function clearStateChar() {
              if (stateChar) {
                switch (stateChar) {
                  case '*':
                    re += star;
                    hasMagic = true;
                    break;
                  case '?':
                    re += qmark;
                    hasMagic = true;
                    break;
                  default:
                    re += '\\' + stateChar;
                    break;
                }
                self.debug('clearStateChar %j %j', stateChar, re);
                stateChar = false;
              }
            }
            for (var i = 0,
                len = pattern.length,
                c; (i < len) && (c = pattern.charAt(i)); i++) {
              this.debug('%s\t%s %s %j', pattern, i, re, c);
              if (escaping && reSpecials[c]) {
                re += '\\' + c;
                escaping = false;
                continue;
              }
              switch (c) {
                case '/':
                  return false;
                case '\\':
                  clearStateChar();
                  escaping = true;
                  continue;
                case '?':
                case '*':
                case '+':
                case '@':
                case '!':
                  this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);
                  if (inClass) {
                    this.debug('  in class');
                    if (c === '!' && i === classStart + 1)
                      c = '^';
                    re += c;
                    continue;
                  }
                  self.debug('call clearStateChar %j', stateChar);
                  clearStateChar();
                  stateChar = c;
                  if (options.noext)
                    clearStateChar();
                  continue;
                case '(':
                  if (inClass) {
                    re += '(';
                    continue;
                  }
                  if (!stateChar) {
                    re += '\\(';
                    continue;
                  }
                  plType = stateChar;
                  patternListStack.push({
                    type: plType,
                    start: i - 1,
                    reStart: re.length
                  });
                  re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
                  this.debug('plType %j %j', stateChar, re);
                  stateChar = false;
                  continue;
                case ')':
                  if (inClass || !patternListStack.length) {
                    re += '\\)';
                    continue;
                  }
                  clearStateChar();
                  hasMagic = true;
                  re += ')';
                  var pl = patternListStack.pop();
                  plType = pl.type;
                  switch (plType) {
                    case '!':
                      negativeLists.push(pl);
                      re += ')[^/]*?)';
                      pl.reEnd = re.length;
                      break;
                    case '?':
                    case '+':
                    case '*':
                      re += plType;
                      break;
                    case '@':
                      break;
                  }
                  continue;
                case '|':
                  if (inClass || !patternListStack.length || escaping) {
                    re += '\\|';
                    escaping = false;
                    continue;
                  }
                  clearStateChar();
                  re += '|';
                  continue;
                case '[':
                  clearStateChar();
                  if (inClass) {
                    re += '\\' + c;
                    continue;
                  }
                  inClass = true;
                  classStart = i;
                  reClassStart = re.length;
                  re += c;
                  continue;
                case ']':
                  if (i === classStart + 1 || !inClass) {
                    re += '\\' + c;
                    escaping = false;
                    continue;
                  }
                  if (inClass) {
                    var cs = pattern.substring(classStart + 1, i);
                    try {
                      RegExp('[' + cs + ']');
                    } catch (er) {
                      var sp = this.parse(cs, SUBPARSE);
                      re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
                      hasMagic = hasMagic || sp[1];
                      inClass = false;
                      continue;
                    }
                  }
                  hasMagic = true;
                  inClass = false;
                  re += c;
                  continue;
                default:
                  clearStateChar();
                  if (escaping) {
                    escaping = false;
                  } else if (reSpecials[c] && !(c === '^' && inClass)) {
                    re += '\\';
                  }
                  re += c;
              }
            }
            if (inClass) {
              cs = pattern.substr(classStart + 1);
              sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + '\\[' + sp[0];
              hasMagic = hasMagic || sp[1];
            }
            for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
              var tail = re.slice(pl.reStart + 3);
              tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function(_, $1, $2) {
                if (!$2) {
                  $2 = '\\';
                }
                return $1 + $1 + $2 + '|';
              });
              this.debug('tail=%j\n   %s', tail, tail);
              var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
              hasMagic = true;
              re = re.slice(0, pl.reStart) + t + '\\(' + tail;
            }
            clearStateChar();
            if (escaping) {
              re += '\\\\';
            }
            var addPatternStart = false;
            switch (re.charAt(0)) {
              case '.':
              case '[':
              case '(':
                addPatternStart = true;
            }
            for (var n = negativeLists.length - 1; n > -1; n--) {
              var nl = negativeLists[n];
              var nlBefore = re.slice(0, nl.reStart);
              var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
              var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
              var nlAfter = re.slice(nl.reEnd);
              nlLast += nlAfter;
              var openParensBefore = nlBefore.split('(').length - 1;
              var cleanAfter = nlAfter;
              for (i = 0; i < openParensBefore; i++) {
                cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
              }
              nlAfter = cleanAfter;
              var dollar = '';
              if (nlAfter === '' && isSub !== SUBPARSE) {
                dollar = '$';
              }
              var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
              re = newRe;
            }
            if (re !== '' && hasMagic) {
              re = '(?=.)' + re;
            }
            if (addPatternStart) {
              re = patternStart + re;
            }
            if (isSub === SUBPARSE) {
              return [re, hasMagic];
            }
            if (!hasMagic) {
              return globUnescape(pattern);
            }
            var flags = options.nocase ? 'i' : '';
            var regExp = new RegExp('^' + re + '$', flags);
            regExp._glob = pattern;
            regExp._src = re;
            return regExp;
          }
          minimatch.makeRe = function(pattern, options) {
            return new Minimatch(pattern, options || {}).makeRe();
          };
          Minimatch.prototype.makeRe = makeRe;
          function makeRe() {
            if (this.regexp || this.regexp === false)
              return this.regexp;
            var set = this.set;
            if (!set.length) {
              this.regexp = false;
              return this.regexp;
            }
            var options = this.options;
            var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
            var flags = options.nocase ? 'i' : '';
            var re = set.map(function(pattern) {
              return pattern.map(function(p) {
                return (p === GLOBSTAR) ? twoStar : (typeof p === 'string') ? regExpEscape(p) : p._src;
              }).join('\\\/');
            }).join('|');
            re = '^(?:' + re + ')$';
            if (this.negate)
              re = '^(?!' + re + ').*$';
            try {
              this.regexp = new RegExp(re, flags);
            } catch (ex) {
              this.regexp = false;
            }
            return this.regexp;
          }
          minimatch.match = function(list, pattern, options) {
            options = options || {};
            var mm = new Minimatch(pattern, options);
            list = list.filter(function(f) {
              return mm.match(f);
            });
            if (mm.options.nonull && !list.length) {
              list.push(pattern);
            }
            return list;
          };
          Minimatch.prototype.match = match;
          function match(f, partial) {
            this.debug('match', f, this.pattern);
            if (this.comment)
              return false;
            if (this.empty)
              return f === '';
            if (f === '/' && partial)
              return true;
            var options = this.options;
            if (path.sep !== '/') {
              f = f.split(path.sep).join('/');
            }
            f = f.split(slashSplit);
            this.debug(this.pattern, 'split', f);
            var set = this.set;
            this.debug(this.pattern, 'set', set);
            var filename;
            var i;
            for (i = f.length - 1; i >= 0; i--) {
              filename = f[i];
              if (filename)
                break;
            }
            for (i = 0; i < set.length; i++) {
              var pattern = set[i];
              var file = f;
              if (options.matchBase && pattern.length === 1) {
                file = [filename];
              }
              var hit = this.matchOne(file, pattern, partial);
              if (hit) {
                if (options.flipNegate)
                  return true;
                return !this.negate;
              }
            }
            if (options.flipNegate)
              return false;
            return this.negate;
          }
          Minimatch.prototype.matchOne = function(file, pattern, partial) {
            var options = this.options;
            this.debug('matchOne', {
              'this': this,
              file: file,
              pattern: pattern
            });
            this.debug('matchOne', file.length, pattern.length);
            for (var fi = 0,
                pi = 0,
                fl = file.length,
                pl = pattern.length; (fi < fl) && (pi < pl); fi++, pi++) {
              this.debug('matchOne loop');
              var p = pattern[pi];
              var f = file[fi];
              this.debug(pattern, p, f);
              if (p === false)
                return false;
              if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                  this.debug('** at the end');
                  for (; fi < fl; fi++) {
                    if (file[fi] === '.' || file[fi] === '..' || (!options.dot && file[fi].charAt(0) === '.'))
                      return false;
                  }
                  return true;
                }
                while (fr < fl) {
                  var swallowee = file[fr];
                  this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                  if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                    this.debug('globstar found match!', fr, fl, swallowee);
                    return true;
                  } else {
                    if (swallowee === '.' || swallowee === '..' || (!options.dot && swallowee.charAt(0) === '.')) {
                      this.debug('dot detected!', file, fr, pattern, pr);
                      break;
                    }
                    this.debug('globstar swallow a segment, and continue');
                    fr++;
                  }
                }
                if (partial) {
                  this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                  if (fr === fl)
                    return true;
                }
                return false;
              }
              var hit;
              if (typeof p === 'string') {
                if (options.nocase) {
                  hit = f.toLowerCase() === p.toLowerCase();
                } else {
                  hit = f === p;
                }
                this.debug('string match', p, f, hit);
              } else {
                hit = f.match(p);
                this.debug('pattern match', p, f, hit);
              }
              if (!hit)
                return false;
            }
            if (fi === fl && pi === pl) {
              return true;
            } else if (fi === fl) {
              return partial;
            } else if (pi === pl) {
              var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');
              return emptyFileEnd;
            }
            throw new Error('wtf?');
          };
          function globUnescape(s) {
            return s.replace(/\\(.)/g, '$1');
          }
          function regExpEscape(s) {
            return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
          }
        }, {
          "brace-expansion": 540,
          "path": 11
        }],
        540: [function(require, module, exports) {
          var concatMap = require('concat-map');
          var balanced = require('balanced-match');
          module.exports = expandTop;
          var escSlash = '\0SLASH' + Math.random() + '\0';
          var escOpen = '\0OPEN' + Math.random() + '\0';
          var escClose = '\0CLOSE' + Math.random() + '\0';
          var escComma = '\0COMMA' + Math.random() + '\0';
          var escPeriod = '\0PERIOD' + Math.random() + '\0';
          function numeric(str) {
            return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
          }
          function escapeBraces(str) {
            return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
          }
          function unescapeBraces(str) {
            return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
          }
          function parseCommaParts(str) {
            if (!str)
              return [''];
            var parts = [];
            var m = balanced('{', '}', str);
            if (!m)
              return str.split(',');
            var pre = m.pre;
            var body = m.body;
            var post = m.post;
            var p = pre.split(',');
            p[p.length - 1] += '{' + body + '}';
            var postParts = parseCommaParts(post);
            if (post.length) {
              p[p.length - 1] += postParts.shift();
              p.push.apply(p, postParts);
            }
            parts.push.apply(parts, p);
            return parts;
          }
          function expandTop(str) {
            if (!str)
              return [];
            return expand(escapeBraces(str), true).map(unescapeBraces);
          }
          function identity(e) {
            return e;
          }
          function embrace(str) {
            return '{' + str + '}';
          }
          function isPadded(el) {
            return /^-?0\d/.test(el);
          }
          function lte(i, y) {
            return i <= y;
          }
          function gte(i, y) {
            return i >= y;
          }
          function expand(str, isTop) {
            var expansions = [];
            var m = balanced('{', '}', str);
            if (!m || /\$$/.test(m.pre))
              return [str];
            var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
            var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
            var isSequence = isNumericSequence || isAlphaSequence;
            var isOptions = /^(.*,)+(.+)?$/.test(m.body);
            if (!isSequence && !isOptions) {
              if (m.post.match(/,.*}/)) {
                str = m.pre + '{' + m.body + escClose + m.post;
                return expand(str);
              }
              return [str];
            }
            var n;
            if (isSequence) {
              n = m.body.split(/\.\./);
            } else {
              n = parseCommaParts(m.body);
              if (n.length === 1) {
                n = expand(n[0], false).map(embrace);
                if (n.length === 1) {
                  var post = m.post.length ? expand(m.post, false) : [''];
                  return post.map(function(p) {
                    return m.pre + n[0] + p;
                  });
                }
              }
            }
            var pre = m.pre;
            var post = m.post.length ? expand(m.post, false) : [''];
            var N;
            if (isSequence) {
              var x = numeric(n[0]);
              var y = numeric(n[1]);
              var width = Math.max(n[0].length, n[1].length);
              var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
              var test = lte;
              var reverse = y < x;
              if (reverse) {
                incr *= -1;
                test = gte;
              }
              var pad = n.some(isPadded);
              N = [];
              for (var i = x; test(i, y); i += incr) {
                var c;
                if (isAlphaSequence) {
                  c = String.fromCharCode(i);
                  if (c === '\\')
                    c = '';
                } else {
                  c = String(i);
                  if (pad) {
                    var need = width - c.length;
                    if (need > 0) {
                      var z = new Array(need + 1).join('0');
                      if (i < 0)
                        c = '-' + z + c.slice(1);
                      else
                        c = z + c;
                    }
                  }
                }
                N.push(c);
              }
            } else {
              N = concatMap(n, function(el) {
                return expand(el, false);
              });
            }
            for (var j = 0; j < N.length; j++) {
              for (var k = 0; k < post.length; k++) {
                var expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion)
                  expansions.push(expansion);
              }
            }
            return expansions;
          }
        }, {
          "balanced-match": 541,
          "concat-map": 542
        }],
        541: [function(require, module, exports) {
          module.exports = balanced;
          function balanced(a, b, str) {
            var bal = 0;
            var m = {};
            var ended = false;
            for (var i = 0; i < str.length; i++) {
              if (a == str.substr(i, a.length)) {
                if (!('start' in m))
                  m.start = i;
                bal++;
              } else if (b == str.substr(i, b.length) && 'start' in m) {
                ended = true;
                bal--;
                if (!bal) {
                  m.end = i;
                  m.pre = str.substr(0, m.start);
                  m.body = (m.end - m.start > 1) ? str.substring(m.start + a.length, m.end) : '';
                  m.post = str.slice(m.end + b.length);
                  return m;
                }
              }
            }
            if (bal && ended) {
              var start = m.start + a.length;
              m = balanced(a, b, str.substr(start));
              if (m) {
                m.start += start;
                m.end += start;
                m.pre = str.slice(0, start) + m.pre;
              }
              return m;
            }
          }
        }, {}],
        542: [function(require, module, exports) {
          module.exports = function(xs, fn) {
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              var x = fn(xs[i], i);
              if (isArray(x))
                res.push.apply(res, x);
              else
                res.push(x);
            }
            return res;
          };
          var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
          };
        }, {}],
        543: [function(require, module, exports) {
          'use strict';
          var fs = require('fs');
          module.exports = function(pth, cb) {
            var fn = typeof fs.access === 'function' ? fs.access : fs.stat;
            fn(pth, function(err) {
              cb(null, !err);
            });
          };
          module.exports.sync = function(pth) {
            var fn = typeof fs.accessSync === 'function' ? fs.accessSync : fs.statSync;
            try {
              fn(pth);
              return true;
            } catch (err) {
              return false;
            }
          };
        }, {"fs": 1}],
        544: [function(require, module, exports) {
          (function(process) {
            'use strict';
            function posix(path) {
              return path.charAt(0) === '/';
            }
            ;
            function win32(path) {
              var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
              var result = splitDeviceRe.exec(path);
              var device = result[1] || '';
              var isUnc = !!device && device.charAt(1) !== ':';
              return !!result[2] || isUnc;
            }
            ;
            module.exports = process.platform === 'win32' ? win32 : posix;
            module.exports.posix = posix;
            module.exports.win32 = win32;
          }).call(this, require('_process'));
        }, {"_process": 12}],
        545: [function(require, module, exports) {
          "use strict";
          var originalObject = Object;
          var originalDefProp = Object.defineProperty;
          var originalCreate = Object.create;
          function defProp(obj, name, value) {
            if (originalDefProp)
              try {
                originalDefProp.call(originalObject, obj, name, {value: value});
              } catch (definePropertyIsBrokenInIE8) {
                obj[name] = value;
              }
            else {
              obj[name] = value;
            }
          }
          function makeSafeToCall(fun) {
            if (fun) {
              defProp(fun, "call", fun.call);
              defProp(fun, "apply", fun.apply);
            }
            return fun;
          }
          makeSafeToCall(originalDefProp);
          makeSafeToCall(originalCreate);
          var hasOwn = makeSafeToCall(Object.prototype.hasOwnProperty);
          var numToStr = makeSafeToCall(Number.prototype.toString);
          var strSlice = makeSafeToCall(String.prototype.slice);
          var cloner = function() {};
          function create(prototype) {
            if (originalCreate) {
              return originalCreate.call(originalObject, prototype);
            }
            cloner.prototype = prototype || null;
            return new cloner;
          }
          var rand = Math.random;
          var uniqueKeys = create(null);
          function makeUniqueKey() {
            do
              var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
 while (hasOwn.call(uniqueKeys, uniqueKey));
            return uniqueKeys[uniqueKey] = uniqueKey;
          }
          function internString(str) {
            var obj = {};
            obj[str] = true;
            return Object.keys(obj)[0];
          }
          defProp(exports, "makeUniqueKey", makeUniqueKey);
          var originalGetOPNs = Object.getOwnPropertyNames;
          Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
            for (var names = originalGetOPNs(object),
                src = 0,
                dst = 0,
                len = names.length; src < len; ++src) {
              if (!hasOwn.call(uniqueKeys, names[src])) {
                if (src > dst) {
                  names[dst] = names[src];
                }
                ++dst;
              }
            }
            names.length = dst;
            return names;
          };
          function defaultCreatorFn(object) {
            return create(null);
          }
          function makeAccessor(secretCreatorFn) {
            var brand = makeUniqueKey();
            var passkey = create(null);
            secretCreatorFn = secretCreatorFn || defaultCreatorFn;
            function register(object) {
              var secret;
              function vault(key, forget) {
                if (key === passkey) {
                  return forget ? secret = null : secret || (secret = secretCreatorFn(object));
                }
              }
              defProp(object, brand, vault);
            }
            function accessor(object) {
              if (!hasOwn.call(object, brand))
                register(object);
              return object[brand](passkey);
            }
            accessor.forget = function(object) {
              if (hasOwn.call(object, brand))
                object[brand](passkey, true);
            };
            return accessor;
          }
          defProp(exports, "makeAccessor", makeAccessor);
        }, {}],
        546: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("recast").types;
          var isArray = types.builtInTypes.array;
          var b = types.builders;
          var n = types.namedTypes;
          var leap = require("./leap");
          var meta = require("./meta");
          var util = require("./util");
          var runtimeProperty = util.runtimeProperty;
          var hasOwn = Object.prototype.hasOwnProperty;
          function Emitter(contextId) {
            assert.ok(this instanceof Emitter);
            n.Identifier.assert(contextId);
            this.nextTempId = 0;
            Object.defineProperties(this, {
              contextId: {value: contextId},
              listing: {value: []},
              marked: {value: [true]},
              finalLoc: {value: loc()},
              tryEntries: {value: []}
            });
            Object.defineProperties(this, {leapManager: {value: new leap.LeapManager(this)}});
          }
          var Ep = Emitter.prototype;
          exports.Emitter = Emitter;
          function loc() {
            return b.literal(-1);
          }
          Ep.mark = function(loc) {
            n.Literal.assert(loc);
            var index = this.listing.length;
            if (loc.value === -1) {
              loc.value = index;
            } else {
              assert.strictEqual(loc.value, index);
            }
            this.marked[index] = true;
            return loc;
          };
          Ep.emit = function(node) {
            if (n.Expression.check(node))
              node = b.expressionStatement(node);
            n.Statement.assert(node);
            this.listing.push(node);
          };
          Ep.emitAssign = function(lhs, rhs) {
            this.emit(this.assign(lhs, rhs));
            return lhs;
          };
          Ep.assign = function(lhs, rhs) {
            return b.expressionStatement(b.assignmentExpression("=", lhs, rhs));
          };
          Ep.contextProperty = function(name, computed) {
            return b.memberExpression(this.contextId, computed ? b.literal(name) : b.identifier(name), !!computed);
          };
          Ep.stop = function(rval) {
            if (rval) {
              this.setReturnValue(rval);
            }
            this.jump(this.finalLoc);
          };
          Ep.setReturnValue = function(valuePath) {
            n.Expression.assert(valuePath.value);
            this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
          };
          Ep.clearPendingException = function(tryLoc, assignee) {
            n.Literal.assert(tryLoc);
            var catchCall = b.callExpression(this.contextProperty("catch", true), [tryLoc]);
            if (assignee) {
              this.emitAssign(assignee, catchCall);
            } else {
              this.emit(catchCall);
            }
          };
          Ep.jump = function(toLoc) {
            this.emitAssign(this.contextProperty("next"), toLoc);
            this.emit(b.breakStatement());
          };
          Ep.jumpIf = function(test, toLoc) {
            n.Expression.assert(test);
            n.Literal.assert(toLoc);
            this.emit(b.ifStatement(test, b.blockStatement([this.assign(this.contextProperty("next"), toLoc), b.breakStatement()])));
          };
          Ep.jumpIfNot = function(test, toLoc) {
            n.Expression.assert(test);
            n.Literal.assert(toLoc);
            var negatedTest;
            if (n.UnaryExpression.check(test) && test.operator === "!") {
              negatedTest = test.argument;
            } else {
              negatedTest = b.unaryExpression("!", test);
            }
            this.emit(b.ifStatement(negatedTest, b.blockStatement([this.assign(this.contextProperty("next"), toLoc), b.breakStatement()])));
          };
          Ep.makeTempVar = function() {
            return this.contextProperty("t" + this.nextTempId++);
          };
          Ep.getContextFunction = function(id) {
            return b.functionExpression(id || null, [this.contextId], b.blockStatement([this.getDispatchLoop()]), false, false);
          };
          Ep.getDispatchLoop = function() {
            var self = this;
            var cases = [];
            var current;
            var alreadyEnded = false;
            self.listing.forEach(function(stmt, i) {
              if (self.marked.hasOwnProperty(i)) {
                cases.push(b.switchCase(b.literal(i), current = []));
                alreadyEnded = false;
              }
              if (!alreadyEnded) {
                current.push(stmt);
                if (isSwitchCaseEnder(stmt))
                  alreadyEnded = true;
              }
            });
            this.finalLoc.value = this.listing.length;
            cases.push(b.switchCase(this.finalLoc, []), b.switchCase(b.literal("end"), [b.returnStatement(b.callExpression(this.contextProperty("stop"), []))]));
            return b.whileStatement(b.literal(1), b.switchStatement(b.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
          };
          function isSwitchCaseEnder(stmt) {
            return n.BreakStatement.check(stmt) || n.ContinueStatement.check(stmt) || n.ReturnStatement.check(stmt) || n.ThrowStatement.check(stmt);
          }
          Ep.getTryLocsList = function() {
            if (this.tryEntries.length === 0) {
              return null;
            }
            var lastLocValue = 0;
            return b.arrayExpression(this.tryEntries.map(function(tryEntry) {
              var thisLocValue = tryEntry.firstLoc.value;
              assert.ok(thisLocValue >= lastLocValue, "try entries out of order");
              lastLocValue = thisLocValue;
              var ce = tryEntry.catchEntry;
              var fe = tryEntry.finallyEntry;
              var locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];
              if (fe) {
                locs[2] = fe.firstLoc;
                locs[3] = fe.afterLoc;
              }
              return b.arrayExpression(locs);
            }));
          };
          Ep.explode = function(path, ignoreResult) {
            assert.ok(path instanceof types.NodePath);
            var node = path.value;
            var self = this;
            n.Node.assert(node);
            if (n.Statement.check(node))
              return self.explodeStatement(path);
            if (n.Expression.check(node))
              return self.explodeExpression(path, ignoreResult);
            if (n.Declaration.check(node))
              throw getDeclError(node);
            switch (node.type) {
              case "Program":
                return path.get("body").map(self.explodeStatement, self);
              case "VariableDeclarator":
                throw getDeclError(node);
              case "Property":
              case "SwitchCase":
              case "CatchClause":
                throw new Error(node.type + " nodes should be handled by their parents");
              default:
                throw new Error("unknown Node of type " + JSON.stringify(node.type));
            }
          };
          function getDeclError(node) {
            return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
          }
          Ep.explodeStatement = function(path, labelId) {
            assert.ok(path instanceof types.NodePath);
            var stmt = path.value;
            var self = this;
            n.Statement.assert(stmt);
            if (labelId) {
              n.Identifier.assert(labelId);
            } else {
              labelId = null;
            }
            if (n.BlockStatement.check(stmt)) {
              return path.get("body").each(self.explodeStatement, self);
            }
            if (!meta.containsLeap(stmt)) {
              self.emit(stmt);
              return;
            }
            switch (stmt.type) {
              case "ExpressionStatement":
                self.explodeExpression(path.get("expression"), true);
                break;
              case "LabeledStatement":
                var after = loc();
                self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function() {
                  self.explodeStatement(path.get("body"), stmt.label);
                });
                self.mark(after);
                break;
              case "WhileStatement":
                var before = loc();
                var after = loc();
                self.mark(before);
                self.jumpIfNot(self.explodeExpression(path.get("test")), after);
                self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function() {
                  self.explodeStatement(path.get("body"));
                });
                self.jump(before);
                self.mark(after);
                break;
              case "DoWhileStatement":
                var first = loc();
                var test = loc();
                var after = loc();
                self.mark(first);
                self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function() {
                  self.explode(path.get("body"));
                });
                self.mark(test);
                self.jumpIf(self.explodeExpression(path.get("test")), first);
                self.mark(after);
                break;
              case "ForStatement":
                var head = loc();
                var update = loc();
                var after = loc();
                if (stmt.init) {
                  self.explode(path.get("init"), true);
                }
                self.mark(head);
                if (stmt.test) {
                  self.jumpIfNot(self.explodeExpression(path.get("test")), after);
                } else {}
                self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function() {
                  self.explodeStatement(path.get("body"));
                });
                self.mark(update);
                if (stmt.update) {
                  self.explode(path.get("update"), true);
                }
                self.jump(head);
                self.mark(after);
                break;
              case "ForInStatement":
                var head = loc();
                var after = loc();
                var keyIterNextFn = self.makeTempVar();
                self.emitAssign(keyIterNextFn, b.callExpression(runtimeProperty("keys"), [self.explodeExpression(path.get("right"))]));
                self.mark(head);
                var keyInfoTmpVar = self.makeTempVar();
                self.jumpIf(b.memberExpression(b.assignmentExpression("=", keyInfoTmpVar, b.callExpression(keyIterNextFn, [])), b.identifier("done"), false), after);
                self.emitAssign(stmt.left, b.memberExpression(keyInfoTmpVar, b.identifier("value"), false));
                self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function() {
                  self.explodeStatement(path.get("body"));
                });
                self.jump(head);
                self.mark(after);
                break;
              case "BreakStatement":
                self.emitAbruptCompletion({
                  type: "break",
                  target: self.leapManager.getBreakLoc(stmt.label)
                });
                break;
              case "ContinueStatement":
                self.emitAbruptCompletion({
                  type: "continue",
                  target: self.leapManager.getContinueLoc(stmt.label)
                });
                break;
              case "SwitchStatement":
                var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
                var after = loc();
                var defaultLoc = loc();
                var condition = defaultLoc;
                var caseLocs = [];
                var cases = stmt.cases || [];
                for (var i = cases.length - 1; i >= 0; --i) {
                  var c = cases[i];
                  n.SwitchCase.assert(c);
                  if (c.test) {
                    condition = b.conditionalExpression(b.binaryExpression("===", disc, c.test), caseLocs[i] = loc(), condition);
                  } else {
                    caseLocs[i] = defaultLoc;
                  }
                }
                self.jump(self.explodeExpression(new types.NodePath(condition, path, "discriminant")));
                self.leapManager.withEntry(new leap.SwitchEntry(after), function() {
                  path.get("cases").each(function(casePath) {
                    var c = casePath.value;
                    var i = casePath.name;
                    self.mark(caseLocs[i]);
                    casePath.get("consequent").each(self.explodeStatement, self);
                  });
                });
                self.mark(after);
                if (defaultLoc.value === -1) {
                  self.mark(defaultLoc);
                  assert.strictEqual(after.value, defaultLoc.value);
                }
                break;
              case "IfStatement":
                var elseLoc = stmt.alternate && loc();
                var after = loc();
                self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
                self.explodeStatement(path.get("consequent"));
                if (elseLoc) {
                  self.jump(after);
                  self.mark(elseLoc);
                  self.explodeStatement(path.get("alternate"));
                }
                self.mark(after);
                break;
              case "ReturnStatement":
                self.emitAbruptCompletion({
                  type: "return",
                  value: self.explodeExpression(path.get("argument"))
                });
                break;
              case "WithStatement":
                throw new Error(node.type + " not supported in generator functions.");
              case "TryStatement":
                var after = loc();
                var handler = stmt.handler;
                if (!handler && stmt.handlers) {
                  handler = stmt.handlers[0] || null;
                }
                var catchLoc = handler && loc();
                var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);
                var finallyLoc = stmt.finalizer && loc();
                var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);
                var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
                self.tryEntries.push(tryEntry);
                self.updateContextPrevLoc(tryEntry.firstLoc);
                self.leapManager.withEntry(tryEntry, function() {
                  self.explodeStatement(path.get("block"));
                  if (catchLoc) {
                    if (finallyLoc) {
                      self.jump(finallyLoc);
                    } else {
                      self.jump(after);
                    }
                    self.updateContextPrevLoc(self.mark(catchLoc));
                    var bodyPath = path.get("handler", "body");
                    var safeParam = self.makeTempVar();
                    self.clearPendingException(tryEntry.firstLoc, safeParam);
                    var catchScope = bodyPath.scope;
                    var catchParamName = handler.param.name;
                    n.CatchClause.assert(catchScope.node);
                    assert.strictEqual(catchScope.lookup(catchParamName), catchScope);
                    types.visit(bodyPath, {
                      visitIdentifier: function(path) {
                        if (util.isReference(path, catchParamName) && path.scope.lookup(catchParamName) === catchScope) {
                          return safeParam;
                        }
                        this.traverse(path);
                      },
                      visitFunction: function(path) {
                        if (path.scope.declares(catchParamName)) {
                          return false;
                        }
                        this.traverse(path);
                      }
                    });
                    self.leapManager.withEntry(catchEntry, function() {
                      self.explodeStatement(bodyPath);
                    });
                  }
                  if (finallyLoc) {
                    self.updateContextPrevLoc(self.mark(finallyLoc));
                    self.leapManager.withEntry(finallyEntry, function() {
                      self.explodeStatement(path.get("finalizer"));
                    });
                    self.emit(b.returnStatement(b.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])));
                  }
                });
                self.mark(after);
                break;
              case "ThrowStatement":
                self.emit(b.throwStatement(self.explodeExpression(path.get("argument"))));
                break;
              default:
                throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
            }
          };
          Ep.emitAbruptCompletion = function(record) {
            if (!isValidCompletion(record)) {
              assert.ok(false, "invalid completion record: " + JSON.stringify(record));
            }
            assert.notStrictEqual(record.type, "normal", "normal completions are not abrupt");
            var abruptArgs = [b.literal(record.type)];
            if (record.type === "break" || record.type === "continue") {
              n.Literal.assert(record.target);
              abruptArgs[1] = record.target;
            } else if (record.type === "return" || record.type === "throw") {
              if (record.value) {
                n.Expression.assert(record.value);
                abruptArgs[1] = record.value;
              }
            }
            this.emit(b.returnStatement(b.callExpression(this.contextProperty("abrupt"), abruptArgs)));
          };
          function isValidCompletion(record) {
            var type = record.type;
            if (type === "normal") {
              return !hasOwn.call(record, "target");
            }
            if (type === "break" || type === "continue") {
              return !hasOwn.call(record, "value") && n.Literal.check(record.target);
            }
            if (type === "return" || type === "throw") {
              return hasOwn.call(record, "value") && !hasOwn.call(record, "target");
            }
            return false;
          }
          Ep.getUnmarkedCurrentLoc = function() {
            return b.literal(this.listing.length);
          };
          Ep.updateContextPrevLoc = function(loc) {
            if (loc) {
              n.Literal.assert(loc);
              if (loc.value === -1) {
                loc.value = this.listing.length;
              } else {
                assert.strictEqual(loc.value, this.listing.length);
              }
            } else {
              loc = this.getUnmarkedCurrentLoc();
            }
            this.emitAssign(this.contextProperty("prev"), loc);
          };
          Ep.explodeExpression = function(path, ignoreResult) {
            assert.ok(path instanceof types.NodePath);
            var expr = path.value;
            if (expr) {
              n.Expression.assert(expr);
            } else {
              return expr;
            }
            var self = this;
            var result;
            function finish(expr) {
              n.Expression.assert(expr);
              if (ignoreResult) {
                self.emit(expr);
              } else {
                return expr;
              }
            }
            if (!meta.containsLeap(expr)) {
              return finish(expr);
            }
            var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);
            function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
              assert.ok(childPath instanceof types.NodePath);
              assert.ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to " + "be assigned to a temporary variable?");
              var result = self.explodeExpression(childPath, ignoreChildResult);
              if (ignoreChildResult) {} else if (tempVar || (hasLeapingChildren && !n.Literal.check(result))) {
                result = self.emitAssign(tempVar || self.makeTempVar(), result);
              }
              return result;
            }
            switch (expr.type) {
              case "MemberExpression":
                return finish(b.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? explodeViaTempVar(null, path.get("property")) : expr.property, expr.computed));
              case "CallExpression":
                var calleePath = path.get("callee");
                var argsPath = path.get("arguments");
                var newCallee;
                var newArgs = [];
                var hasLeapingArgs = false;
                argsPath.each(function(argPath) {
                  hasLeapingArgs = hasLeapingArgs || meta.containsLeap(argPath.value);
                });
                if (n.MemberExpression.check(calleePath.value)) {
                  if (hasLeapingArgs) {
                    var newObject = explodeViaTempVar(self.makeTempVar(), calleePath.get("object"));
                    var newProperty = calleePath.value.computed ? explodeViaTempVar(null, calleePath.get("property")) : calleePath.value.property;
                    newArgs.unshift(newObject);
                    newCallee = b.memberExpression(b.memberExpression(newObject, newProperty, calleePath.value.computed), b.identifier("call"), false);
                  } else {
                    newCallee = self.explodeExpression(calleePath);
                  }
                } else {
                  newCallee = self.explodeExpression(calleePath);
                  if (n.MemberExpression.check(newCallee)) {
                    newCallee = b.sequenceExpression([b.literal(0), newCallee]);
                  }
                }
                argsPath.each(function(argPath) {
                  newArgs.push(explodeViaTempVar(null, argPath));
                });
                return finish(b.callExpression(newCallee, newArgs));
              case "NewExpression":
                return finish(b.newExpression(explodeViaTempVar(null, path.get("callee")), path.get("arguments").map(function(argPath) {
                  return explodeViaTempVar(null, argPath);
                })));
              case "ObjectExpression":
                return finish(b.objectExpression(path.get("properties").map(function(propPath) {
                  return b.property(propPath.value.kind, propPath.value.key, explodeViaTempVar(null, propPath.get("value")));
                })));
              case "ArrayExpression":
                return finish(b.arrayExpression(path.get("elements").map(function(elemPath) {
                  return explodeViaTempVar(null, elemPath);
                })));
              case "SequenceExpression":
                var lastIndex = expr.expressions.length - 1;
                path.get("expressions").each(function(exprPath) {
                  if (exprPath.name === lastIndex) {
                    result = self.explodeExpression(exprPath, ignoreResult);
                  } else {
                    self.explodeExpression(exprPath, true);
                  }
                });
                return result;
              case "LogicalExpression":
                var after = loc();
                if (!ignoreResult) {
                  result = self.makeTempVar();
                }
                var left = explodeViaTempVar(result, path.get("left"));
                if (expr.operator === "&&") {
                  self.jumpIfNot(left, after);
                } else {
                  assert.strictEqual(expr.operator, "||");
                  self.jumpIf(left, after);
                }
                explodeViaTempVar(result, path.get("right"), ignoreResult);
                self.mark(after);
                return result;
              case "ConditionalExpression":
                var elseLoc = loc();
                var after = loc();
                var test = self.explodeExpression(path.get("test"));
                self.jumpIfNot(test, elseLoc);
                if (!ignoreResult) {
                  result = self.makeTempVar();
                }
                explodeViaTempVar(result, path.get("consequent"), ignoreResult);
                self.jump(after);
                self.mark(elseLoc);
                explodeViaTempVar(result, path.get("alternate"), ignoreResult);
                self.mark(after);
                return result;
              case "UnaryExpression":
                return finish(b.unaryExpression(expr.operator, self.explodeExpression(path.get("argument")), !!expr.prefix));
              case "BinaryExpression":
                return finish(b.binaryExpression(expr.operator, explodeViaTempVar(null, path.get("left")), explodeViaTempVar(null, path.get("right"))));
              case "AssignmentExpression":
                return finish(b.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
              case "UpdateExpression":
                return finish(b.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));
              case "YieldExpression":
                var after = loc();
                var arg = expr.argument && self.explodeExpression(path.get("argument"));
                if (arg && expr.delegate) {
                  var result = self.makeTempVar();
                  self.emit(b.returnStatement(b.callExpression(self.contextProperty("delegateYield"), [arg, b.literal(result.property.name), after])));
                  self.mark(after);
                  return result;
                }
                self.emitAssign(self.contextProperty("next"), after);
                self.emit(b.returnStatement(arg || null));
                self.mark(after);
                return self.contextProperty("sent");
              default:
                throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
            }
          };
        }, {
          "./leap": 548,
          "./meta": 549,
          "./util": 550,
          "assert": 2,
          "recast": 577
        }],
        547: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("recast").types;
          var n = types.namedTypes;
          var b = types.builders;
          var hasOwn = Object.prototype.hasOwnProperty;
          exports.hoist = function(funPath) {
            assert.ok(funPath instanceof types.NodePath);
            n.Function.assert(funPath.value);
            var vars = {};
            function varDeclToExpr(vdec, includeIdentifiers) {
              n.VariableDeclaration.assert(vdec);
              var exprs = [];
              vdec.declarations.forEach(function(dec) {
                vars[dec.id.name] = dec.id;
                if (dec.init) {
                  exprs.push(b.assignmentExpression("=", dec.id, dec.init));
                } else if (includeIdentifiers) {
                  exprs.push(dec.id);
                }
              });
              if (exprs.length === 0)
                return null;
              if (exprs.length === 1)
                return exprs[0];
              return b.sequenceExpression(exprs);
            }
            types.visit(funPath.get("body"), {
              visitVariableDeclaration: function(path) {
                var expr = varDeclToExpr(path.value, false);
                if (expr === null) {
                  path.replace();
                } else {
                  return b.expressionStatement(expr);
                }
                return false;
              },
              visitForStatement: function(path) {
                var init = path.value.init;
                if (n.VariableDeclaration.check(init)) {
                  path.get("init").replace(varDeclToExpr(init, false));
                }
                this.traverse(path);
              },
              visitForInStatement: function(path) {
                var left = path.value.left;
                if (n.VariableDeclaration.check(left)) {
                  path.get("left").replace(varDeclToExpr(left, true));
                }
                this.traverse(path);
              },
              visitFunctionDeclaration: function(path) {
                var node = path.value;
                vars[node.id.name] = node.id;
                var parentNode = path.parent.node;
                var assignment = b.expressionStatement(b.assignmentExpression("=", node.id, b.functionExpression(node.id, node.params, node.body, node.generator, node.expression)));
                if (n.BlockStatement.check(path.parent.node)) {
                  path.parent.get("body").unshift(assignment);
                  path.replace();
                } else {
                  path.replace(assignment);
                }
                return false;
              },
              visitFunctionExpression: function(path) {
                return false;
              }
            });
            var paramNames = {};
            funPath.get("params").each(function(paramPath) {
              var param = paramPath.value;
              if (n.Identifier.check(param)) {
                paramNames[param.name] = param;
              } else {}
            });
            var declarations = [];
            Object.keys(vars).forEach(function(name) {
              if (!hasOwn.call(paramNames, name)) {
                declarations.push(b.variableDeclarator(vars[name], null));
              }
            });
            if (declarations.length === 0) {
              return null;
            }
            return b.variableDeclaration("var", declarations);
          };
        }, {
          "assert": 2,
          "recast": 577
        }],
        548: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("recast").types;
          var n = types.namedTypes;
          var b = types.builders;
          var inherits = require("util").inherits;
          var hasOwn = Object.prototype.hasOwnProperty;
          function Entry() {
            assert.ok(this instanceof Entry);
          }
          function FunctionEntry(returnLoc) {
            Entry.call(this);
            n.Literal.assert(returnLoc);
            this.returnLoc = returnLoc;
          }
          inherits(FunctionEntry, Entry);
          exports.FunctionEntry = FunctionEntry;
          function LoopEntry(breakLoc, continueLoc, label) {
            Entry.call(this);
            n.Literal.assert(breakLoc);
            n.Literal.assert(continueLoc);
            if (label) {
              n.Identifier.assert(label);
            } else {
              label = null;
            }
            this.breakLoc = breakLoc;
            this.continueLoc = continueLoc;
            this.label = label;
          }
          inherits(LoopEntry, Entry);
          exports.LoopEntry = LoopEntry;
          function SwitchEntry(breakLoc) {
            Entry.call(this);
            n.Literal.assert(breakLoc);
            this.breakLoc = breakLoc;
          }
          inherits(SwitchEntry, Entry);
          exports.SwitchEntry = SwitchEntry;
          function TryEntry(firstLoc, catchEntry, finallyEntry) {
            Entry.call(this);
            n.Literal.assert(firstLoc);
            if (catchEntry) {
              assert.ok(catchEntry instanceof CatchEntry);
            } else {
              catchEntry = null;
            }
            if (finallyEntry) {
              assert.ok(finallyEntry instanceof FinallyEntry);
            } else {
              finallyEntry = null;
            }
            assert.ok(catchEntry || finallyEntry);
            this.firstLoc = firstLoc;
            this.catchEntry = catchEntry;
            this.finallyEntry = finallyEntry;
          }
          inherits(TryEntry, Entry);
          exports.TryEntry = TryEntry;
          function CatchEntry(firstLoc, paramId) {
            Entry.call(this);
            n.Literal.assert(firstLoc);
            n.Identifier.assert(paramId);
            this.firstLoc = firstLoc;
            this.paramId = paramId;
          }
          inherits(CatchEntry, Entry);
          exports.CatchEntry = CatchEntry;
          function FinallyEntry(firstLoc, afterLoc) {
            Entry.call(this);
            n.Literal.assert(firstLoc);
            n.Literal.assert(afterLoc);
            this.firstLoc = firstLoc;
            this.afterLoc = afterLoc;
          }
          inherits(FinallyEntry, Entry);
          exports.FinallyEntry = FinallyEntry;
          function LabeledEntry(breakLoc, label) {
            Entry.call(this);
            n.Literal.assert(breakLoc);
            n.Identifier.assert(label);
            this.breakLoc = breakLoc;
            this.label = label;
          }
          inherits(LabeledEntry, Entry);
          exports.LabeledEntry = LabeledEntry;
          function LeapManager(emitter) {
            assert.ok(this instanceof LeapManager);
            var Emitter = require("./emit").Emitter;
            assert.ok(emitter instanceof Emitter);
            this.emitter = emitter;
            this.entryStack = [new FunctionEntry(emitter.finalLoc)];
          }
          var LMp = LeapManager.prototype;
          exports.LeapManager = LeapManager;
          LMp.withEntry = function(entry, callback) {
            assert.ok(entry instanceof Entry);
            this.entryStack.push(entry);
            try {
              callback.call(this.emitter);
            } finally {
              var popped = this.entryStack.pop();
              assert.strictEqual(popped, entry);
            }
          };
          LMp._findLeapLocation = function(property, label) {
            for (var i = this.entryStack.length - 1; i >= 0; --i) {
              var entry = this.entryStack[i];
              var loc = entry[property];
              if (loc) {
                if (label) {
                  if (entry.label && entry.label.name === label.name) {
                    return loc;
                  }
                } else if (entry instanceof LabeledEntry) {} else {
                  return loc;
                }
              }
            }
            return null;
          };
          LMp.getBreakLoc = function(label) {
            return this._findLeapLocation("breakLoc", label);
          };
          LMp.getContinueLoc = function(label) {
            return this._findLeapLocation("continueLoc", label);
          };
        }, {
          "./emit": 546,
          "assert": 2,
          "recast": 577,
          "util": 30
        }],
        549: [function(require, module, exports) {
          var assert = require("assert");
          var m = require("private").makeAccessor();
          var types = require("recast").types;
          var isArray = types.builtInTypes.array;
          var n = types.namedTypes;
          var hasOwn = Object.prototype.hasOwnProperty;
          function makePredicate(propertyName, knownTypes) {
            function onlyChildren(node) {
              n.Node.assert(node);
              var result = false;
              function check(child) {
                if (result) {} else if (isArray.check(child)) {
                  child.some(check);
                } else if (n.Node.check(child)) {
                  assert.strictEqual(result, false);
                  result = predicate(child);
                }
                return result;
              }
              types.eachField(node, function(name, child) {
                check(child);
              });
              return result;
            }
            function predicate(node) {
              n.Node.assert(node);
              var meta = m(node);
              if (hasOwn.call(meta, propertyName))
                return meta[propertyName];
              if (hasOwn.call(opaqueTypes, node.type))
                return meta[propertyName] = false;
              if (hasOwn.call(knownTypes, node.type))
                return meta[propertyName] = true;
              return meta[propertyName] = onlyChildren(node);
            }
            predicate.onlyChildren = onlyChildren;
            return predicate;
          }
          var opaqueTypes = {FunctionExpression: true};
          var sideEffectTypes = {
            CallExpression: true,
            ForInStatement: true,
            UnaryExpression: true,
            BinaryExpression: true,
            AssignmentExpression: true,
            UpdateExpression: true,
            NewExpression: true
          };
          var leapTypes = {
            YieldExpression: true,
            BreakStatement: true,
            ContinueStatement: true,
            ReturnStatement: true,
            ThrowStatement: true
          };
          for (var type in leapTypes) {
            if (hasOwn.call(leapTypes, type)) {
              sideEffectTypes[type] = leapTypes[type];
            }
          }
          exports.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
          exports.containsLeap = makePredicate("containsLeap", leapTypes);
        }, {
          "assert": 2,
          "private": 545,
          "recast": 577
        }],
        550: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("recast").types;
          var n = types.namedTypes;
          var b = types.builders;
          var hasOwn = Object.prototype.hasOwnProperty;
          exports.defaults = function(obj) {
            var len = arguments.length;
            var extension;
            for (var i = 1; i < len; ++i) {
              if ((extension = arguments[i])) {
                for (var key in extension) {
                  if (hasOwn.call(extension, key) && !hasOwn.call(obj, key)) {
                    obj[key] = extension[key];
                  }
                }
              }
            }
            return obj;
          };
          exports.runtimeProperty = function(name) {
            return b.memberExpression(b.identifier("regeneratorRuntime"), b.identifier(name), false);
          };
          exports.isReference = function(path, name) {
            var node = path.value;
            if (!n.Identifier.check(node)) {
              return false;
            }
            if (name && node.name !== name) {
              return false;
            }
            var parent = path.parent.value;
            switch (parent.type) {
              case "VariableDeclarator":
                return path.name === "init";
              case "MemberExpression":
                return path.name === "object" || (parent.computed && path.name === "property");
              case "FunctionExpression":
              case "FunctionDeclaration":
              case "ArrowFunctionExpression":
                if (path.name === "id") {
                  return false;
                }
                if (path.parentPath.name === "params" && parent.params === path.parentPath.value && parent.params[path.name] === node) {
                  return false;
                }
                return true;
              case "ClassDeclaration":
              case "ClassExpression":
                return path.name !== "id";
              case "CatchClause":
                return path.name !== "param";
              case "Property":
              case "MethodDefinition":
                return path.name !== "key";
              case "ImportSpecifier":
              case "ImportDefaultSpecifier":
              case "ImportNamespaceSpecifier":
              case "LabeledStatement":
                return false;
              default:
                return true;
            }
          };
        }, {
          "assert": 2,
          "recast": 577
        }],
        551: [function(require, module, exports) {
          var assert = require("assert");
          var fs = require("fs");
          var recast = require("recast");
          var types = recast.types;
          var n = types.namedTypes;
          var b = types.builders;
          var isArray = types.builtInTypes.array;
          var isObject = types.builtInTypes.object;
          var NodePath = types.NodePath;
          var hoist = require("./hoist").hoist;
          var Emitter = require("./emit").Emitter;
          var util = require("./util");
          var runtimeProperty = util.runtimeProperty;
          var getMarkInfo = require("private").makeAccessor();
          exports.transform = function transform(node, options) {
            options = options || {};
            var path = node instanceof NodePath ? node : new NodePath(node);
            visitor.visit(path, options);
            node = path.value;
            if (options.includeRuntime === true || (options.includeRuntime === 'if used' && visitor.wasChangeReported())) {
              injectRuntime(n.File.check(node) ? node.program : node);
            }
            options.madeChanges = visitor.wasChangeReported();
            return node;
          };
          function injectRuntime(program) {
            n.Program.assert(program);
            var runtimePath = require("..").runtime.path;
            var runtime = fs.readFileSync(runtimePath, "utf8");
            var runtimeBody = recast.parse(runtime, {sourceFileName: runtimePath}).program.body;
            var body = program.body;
            body.unshift.apply(body, runtimeBody);
          }
          var visitor = types.PathVisitor.fromMethodsObject({
            reset: function(node, options) {
              this.options = options;
            },
            visitFunction: function(path) {
              this.traverse(path);
              var node = path.value;
              var shouldTransformAsync = node.async && !this.options.disableAsync;
              if (!node.generator && !shouldTransformAsync) {
                return;
              }
              this.reportChanged();
              if (node.expression) {
                node.expression = false;
                node.body = b.blockStatement([b.returnStatement(node.body)]);
              }
              if (shouldTransformAsync) {
                awaitVisitor.visit(path.get("body"));
              }
              var outerBody = [];
              var innerBody = [];
              var bodyPath = path.get("body", "body");
              bodyPath.each(function(childPath) {
                var node = childPath.value;
                if (node && node._blockHoist != null) {
                  outerBody.push(node);
                } else {
                  innerBody.push(node);
                }
              });
              if (outerBody.length > 0) {
                bodyPath.replace(innerBody);
              }
              var outerFnExpr = getOuterFnExpr(path);
              n.Identifier.assert(node.id);
              var innerFnId = b.identifier(node.id.name + "$");
              var contextId = path.scope.declareTemporary("context$");
              var argsId = path.scope.declareTemporary("args$");
              var vars = hoist(path);
              var didRenameArguments = renameArguments(path, argsId);
              if (didRenameArguments) {
                vars = vars || b.variableDeclaration("var", []);
                vars.declarations.push(b.variableDeclarator(argsId, b.identifier("arguments")));
              }
              var emitter = new Emitter(contextId);
              emitter.explode(path.get("body"));
              if (vars && vars.declarations.length > 0) {
                outerBody.push(vars);
              }
              var wrapArgs = [emitter.getContextFunction(innerFnId), node.generator ? outerFnExpr : b.literal(null), b.thisExpression()];
              var tryLocsList = emitter.getTryLocsList();
              if (tryLocsList) {
                wrapArgs.push(tryLocsList);
              }
              var wrapCall = b.callExpression(runtimeProperty(shouldTransformAsync ? "async" : "wrap"), wrapArgs);
              outerBody.push(b.returnStatement(wrapCall));
              node.body = b.blockStatement(outerBody);
              var wasGeneratorFunction = node.generator;
              if (wasGeneratorFunction) {
                node.generator = false;
              }
              if (shouldTransformAsync) {
                node.async = false;
              }
              if (wasGeneratorFunction && n.Expression.check(node)) {
                return b.callExpression(runtimeProperty("mark"), [node]);
              }
            },
            visitForOfStatement: function(path) {
              this.traverse(path);
              var node = path.value;
              var tempIterId = path.scope.declareTemporary("t$");
              var tempIterDecl = b.variableDeclarator(tempIterId, b.callExpression(runtimeProperty("values"), [node.right]));
              var tempInfoId = path.scope.declareTemporary("t$");
              var tempInfoDecl = b.variableDeclarator(tempInfoId, null);
              var init = node.left;
              var loopId;
              if (n.VariableDeclaration.check(init)) {
                loopId = init.declarations[0].id;
                init.declarations.push(tempIterDecl, tempInfoDecl);
              } else {
                loopId = init;
                init = b.variableDeclaration("var", [tempIterDecl, tempInfoDecl]);
              }
              n.Identifier.assert(loopId);
              var loopIdAssignExprStmt = b.expressionStatement(b.assignmentExpression("=", loopId, b.memberExpression(tempInfoId, b.identifier("value"), false)));
              if (n.BlockStatement.check(node.body)) {
                node.body.body.unshift(loopIdAssignExprStmt);
              } else {
                node.body = b.blockStatement([loopIdAssignExprStmt, node.body]);
              }
              return b.forStatement(init, b.unaryExpression("!", b.memberExpression(b.assignmentExpression("=", tempInfoId, b.callExpression(b.memberExpression(tempIterId, b.identifier("next"), false), [])), b.identifier("done"), false)), null, node.body);
            }
          });
          function getOuterFnExpr(funPath) {
            var node = funPath.value;
            n.Function.assert(node);
            if (node.generator && n.FunctionDeclaration.check(node)) {
              var pp = funPath.parent;
              while (pp && !(n.BlockStatement.check(pp.value) || n.Program.check(pp.value))) {
                pp = pp.parent;
              }
              if (!pp) {
                return node.id;
              }
              var markDecl = getRuntimeMarkDecl(pp);
              var markedArray = markDecl.declarations[0].id;
              var funDeclIdArray = markDecl.declarations[0].init.callee.object;
              n.ArrayExpression.assert(funDeclIdArray);
              var index = funDeclIdArray.elements.length;
              funDeclIdArray.elements.push(node.id);
              return b.memberExpression(markedArray, b.literal(index), true);
            }
            return node.id || (node.id = funPath.scope.parent.declareTemporary("callee$"));
          }
          function getRuntimeMarkDecl(blockPath) {
            assert.ok(blockPath instanceof NodePath);
            var block = blockPath.node;
            isArray.assert(block.body);
            var info = getMarkInfo(block);
            if (info.decl) {
              return info.decl;
            }
            info.decl = b.variableDeclaration("var", [b.variableDeclarator(blockPath.scope.declareTemporary("marked"), b.callExpression(b.memberExpression(b.arrayExpression([]), b.identifier("map"), false), [runtimeProperty("mark")]))]);
            for (var i = 0; i < block.body.length; ++i) {
              if (!shouldNotHoistAbove(blockPath.get("body", i))) {
                break;
              }
            }
            blockPath.get("body").insertAt(i, info.decl);
            return info.decl;
          }
          function shouldNotHoistAbove(stmtPath) {
            var value = stmtPath.value;
            n.Statement.assert(value);
            return n.ExpressionStatement.check(value) && n.Literal.check(value.expression) && value.expression.value === "use strict";
          }
          function renameArguments(funcPath, argsId) {
            assert.ok(funcPath instanceof types.NodePath);
            var func = funcPath.value;
            var didRenameArguments = false;
            recast.visit(funcPath, {
              visitFunction: function(path) {
                if (path.value === func) {
                  this.traverse(path);
                } else {
                  return false;
                }
              },
              visitIdentifier: function(path) {
                if (path.value.name === "arguments" && util.isReference(path)) {
                  path.replace(argsId);
                  didRenameArguments = true;
                  return false;
                }
                this.traverse(path);
              }
            });
            return didRenameArguments;
          }
          var awaitVisitor = types.PathVisitor.fromMethodsObject({
            visitFunction: function(path) {
              return false;
            },
            visitAwaitExpression: function(path) {
              var argument = path.value.argument;
              if (path.value.all) {
                argument = b.callExpression(b.memberExpression(b.identifier("Promise"), b.identifier("all"), false), [argument]);
              }
              return b.yieldExpression(b.callExpression(runtimeProperty("awrap"), [argument]), false);
            }
          });
        }, {
          "..": 552,
          "./emit": 546,
          "./hoist": 547,
          "./util": 550,
          "assert": 2,
          "fs": 1,
          "private": 545,
          "recast": 577
        }],
        552: [function(require, module, exports) {
          (function(__dirname) {
            var assert = require("assert");
            var path = require("path");
            var fs = require("fs");
            var through = require("through");
            var transform = require("./lib/visit").transform;
            var utils = require("./lib/util");
            var recast = require("recast");
            var types = recast.types;
            var genOrAsyncFunExp = /\bfunction\s*\*|\basync\b/;
            var blockBindingExp = /\b(let|const)\s+/;
            function exports(file, options) {
              var data = [];
              return through(write, end);
              function write(buf) {
                data.push(buf);
              }
              function end() {
                this.queue(compile(data.join(""), options).code);
                this.queue(null);
              }
            }
            module.exports = exports;
            function runtime() {
              require("./runtime");
            }
            exports.runtime = runtime;
            runtime.path = path.join(__dirname, "runtime.js");
            function compile(source, options) {
              options = normalizeOptions(options);
              if (!genOrAsyncFunExp.test(source)) {
                return {code: (options.includeRuntime === true ? fs.readFileSync(path.join(__dirname, "runtime.js"), "utf-8") + "\n" : "") + source};
              }
              var recastOptions = getRecastOptions(options);
              var ast = recast.parse(source, recastOptions);
              var nodePath = new types.NodePath(ast);
              var programPath = nodePath.get("program");
              if (shouldVarify(source, options)) {
                varifyAst(programPath.node);
              }
              transform(programPath, options);
              return recast.print(nodePath, recastOptions);
            }
            function normalizeOptions(options) {
              options = utils.defaults(options || {}, {
                includeRuntime: false,
                supportBlockBinding: true
              });
              if (!options.esprima) {
                options.esprima = require("esprima-fb");
              }
              assert.ok(/harmony/.test(options.esprima.version), "Bad esprima version: " + options.esprima.version);
              return options;
            }
            function getRecastOptions(options) {
              var recastOptions = {range: true};
              function copy(name) {
                if (name in options) {
                  recastOptions[name] = options[name];
                }
              }
              copy("esprima");
              copy("sourceFileName");
              copy("sourceMapName");
              copy("inputSourceMap");
              copy("sourceRoot");
              return recastOptions;
            }
            function shouldVarify(source, options) {
              var supportBlockBinding = !!options.supportBlockBinding;
              if (supportBlockBinding) {
                if (!blockBindingExp.test(source)) {
                  supportBlockBinding = false;
                }
              }
              return supportBlockBinding;
            }
            function varify(source, options) {
              var recastOptions = getRecastOptions(normalizeOptions(options));
              var ast = recast.parse(source, recastOptions);
              varifyAst(ast.program);
              return recast.print(ast, recastOptions).code;
            }
            function varifyAst(ast) {
              types.namedTypes.Program.assert(ast);
              var defsResult = require("defs")(ast, {
                ast: true,
                disallowUnknownReferences: false,
                disallowDuplicated: false,
                disallowVars: false,
                loopClosures: "iife"
              });
              if (defsResult.errors) {
                throw new Error(defsResult.errors.join("\n"));
              }
              return ast;
            }
            exports.varify = varify;
            exports.types = types;
            exports.compile = compile;
            exports.transform = transform;
          }).call(this, "/node_modules/regenerator");
        }, {
          "./lib/util": 550,
          "./lib/visit": 551,
          "./runtime": 595,
          "assert": 2,
          "defs": 553,
          "esprima-fb": 1,
          "fs": 1,
          "path": 11,
          "recast": 577,
          "through": 594
        }],
        553: [function(require, module, exports) {
          "use strict";
          var assert = require("assert");
          var is = require("simple-is");
          var fmt = require("simple-fmt");
          var stringmap = require("stringmap");
          var stringset = require("stringset");
          var alter = require("alter");
          var traverse = require("ast-traverse");
          var breakable = require("breakable");
          var Scope = require("./scope");
          var error = require("./error");
          var getline = error.getline;
          var options = require("./options");
          var Stats = require("./stats");
          var jshint_vars = require("./jshint_globals/vars.js");
          function isConstLet(kind) {
            return is.someof(kind, ["const", "let"]);
          }
          function isVarConstLet(kind) {
            return is.someof(kind, ["var", "const", "let"]);
          }
          function isNonFunctionBlock(node) {
            return node.type === "BlockStatement" && is.noneof(node.$parent.type, ["FunctionDeclaration", "FunctionExpression"]);
          }
          function isForWithConstLet(node) {
            return node.type === "ForStatement" && node.init && node.init.type === "VariableDeclaration" && isConstLet(node.init.kind);
          }
          function isForInOfWithConstLet(node) {
            return isForInOf(node) && node.left.type === "VariableDeclaration" && isConstLet(node.left.kind);
          }
          function isForInOf(node) {
            return is.someof(node.type, ["ForInStatement", "ForOfStatement"]);
          }
          function isFunction(node) {
            return is.someof(node.type, ["FunctionDeclaration", "FunctionExpression"]);
          }
          function isLoop(node) {
            return is.someof(node.type, ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement"]);
          }
          function isReference(node) {
            var parent = node.$parent;
            return node.$refToScope || node.type === "Identifier" && !(parent.type === "VariableDeclarator" && parent.id === node) && !(parent.type === "MemberExpression" && parent.computed === false && parent.property === node) && !(parent.type === "Property" && parent.key === node) && !(parent.type === "LabeledStatement" && parent.label === node) && !(parent.type === "CatchClause" && parent.param === node) && !(isFunction(parent) && parent.id === node) && !(isFunction(parent) && is.someof(node, parent.params)) && true;
          }
          function isLvalue(node) {
            return isReference(node) && ((node.$parent.type === "AssignmentExpression" && node.$parent.left === node) || (node.$parent.type === "UpdateExpression" && node.$parent.argument === node));
          }
          function createScopes(node, parent) {
            assert(!node.$scope);
            node.$parent = parent;
            node.$scope = node.$parent ? node.$parent.$scope : null;
            if (node.type === "Program") {
              node.$scope = new Scope({
                kind: "hoist",
                node: node,
                parent: null
              });
            } else if (isFunction(node)) {
              node.$scope = new Scope({
                kind: "hoist",
                node: node,
                parent: node.$parent.$scope
              });
              if (node.id) {
                assert(node.id.type === "Identifier");
                if (node.type === "FunctionDeclaration") {
                  node.$parent.$scope.add(node.id.name, "fun", node.id, null);
                } else if (node.type === "FunctionExpression") {
                  node.$scope.add(node.id.name, "fun", node.id, null);
                } else {
                  assert(false);
                }
              }
              node.params.forEach(function(param) {
                node.$scope.add(param.name, "param", param, null);
              });
            } else if (node.type === "VariableDeclaration") {
              assert(isVarConstLet(node.kind));
              node.declarations.forEach(function(declarator) {
                assert(declarator.type === "VariableDeclarator");
                var name = declarator.id.name;
                if (options.disallowVars && node.kind === "var") {
                  error(getline(declarator), "var {0} is not allowed (use let or const)", name);
                }
                node.$scope.add(name, node.kind, declarator.id, declarator.range[1]);
              });
            } else if (isForWithConstLet(node) || isForInOfWithConstLet(node)) {
              node.$scope = new Scope({
                kind: "block",
                node: node,
                parent: node.$parent.$scope
              });
            } else if (isNonFunctionBlock(node)) {
              node.$scope = new Scope({
                kind: "block",
                node: node,
                parent: node.$parent.$scope
              });
            } else if (node.type === "CatchClause") {
              var identifier = node.param;
              node.$scope = new Scope({
                kind: "catch-block",
                node: node,
                parent: node.$parent.$scope
              });
              node.$scope.add(identifier.name, "caught", identifier, null);
              node.$scope.closestHoistScope().markPropagates(identifier.name);
            }
          }
          function createTopScope(programScope, environments, globals) {
            function inject(obj) {
              for (var name in obj) {
                var writeable = obj[name];
                var kind = (writeable ? "var" : "const");
                if (topScope.hasOwn(name)) {
                  topScope.remove(name);
                }
                topScope.add(name, kind, {loc: {start: {line: -1}}}, -1);
              }
            }
            var topScope = new Scope({
              kind: "hoist",
              node: {},
              parent: null
            });
            var complementary = {
              undefined: false,
              Infinity: false,
              console: false
            };
            inject(complementary);
            inject(jshint_vars.reservedVars);
            inject(jshint_vars.ecmaIdentifiers);
            if (environments) {
              environments.forEach(function(env) {
                if (!jshint_vars[env]) {
                  error(-1, 'environment "{0}" not found', env);
                } else {
                  inject(jshint_vars[env]);
                }
              });
            }
            if (globals) {
              inject(globals);
            }
            programScope.parent = topScope;
            topScope.children.push(programScope);
            return topScope;
          }
          function setupReferences(ast, allIdentifiers, opts) {
            var analyze = (is.own(opts, "analyze") ? opts.analyze : true);
            function visit(node) {
              if (!isReference(node)) {
                return;
              }
              allIdentifiers.add(node.name);
              var scope = node.$scope.lookup(node.name);
              if (analyze && !scope && options.disallowUnknownReferences) {
                error(getline(node), "reference to unknown global variable {0}", node.name);
              }
              if (analyze && scope && is.someof(scope.getKind(node.name), ["const", "let"])) {
                var allowedFromPos = scope.getFromPos(node.name);
                var referencedAtPos = node.range[0];
                assert(is.finitenumber(allowedFromPos));
                assert(is.finitenumber(referencedAtPos));
                if (referencedAtPos < allowedFromPos) {
                  if (!node.$scope.hasFunctionScopeBetween(scope)) {
                    error(getline(node), "{0} is referenced before its declaration", node.name);
                  }
                }
              }
              node.$refToScope = scope;
            }
            traverse(ast, {pre: visit});
          }
          function varify(ast, stats, allIdentifiers, changes) {
            function unique(name) {
              assert(allIdentifiers.has(name));
              for (var cnt = 0; ; cnt++) {
                var genName = name + "$" + String(cnt);
                if (!allIdentifiers.has(genName)) {
                  return genName;
                }
              }
            }
            function renameDeclarations(node) {
              if (node.type === "VariableDeclaration" && isConstLet(node.kind)) {
                var hoistScope = node.$scope.closestHoistScope();
                var origScope = node.$scope;
                changes.push({
                  start: node.range[0],
                  end: node.range[0] + node.kind.length,
                  str: "var"
                });
                node.declarations.forEach(function(declarator) {
                  assert(declarator.type === "VariableDeclarator");
                  var name = declarator.id.name;
                  stats.declarator(node.kind);
                  var rename = (origScope !== hoistScope && (hoistScope.hasOwn(name) || hoistScope.doesPropagate(name)));
                  var newName = (rename ? unique(name) : name);
                  origScope.remove(name);
                  hoistScope.add(newName, "var", declarator.id, declarator.range[1]);
                  origScope.moves = origScope.moves || stringmap();
                  origScope.moves.set(name, {
                    name: newName,
                    scope: hoistScope
                  });
                  allIdentifiers.add(newName);
                  if (newName !== name) {
                    stats.rename(name, newName, getline(declarator));
                    declarator.id.originalName = name;
                    declarator.id.name = newName;
                    changes.push({
                      start: declarator.id.range[0],
                      end: declarator.id.range[1],
                      str: newName
                    });
                  }
                });
                node.kind = "var";
              }
            }
            function renameReferences(node) {
              if (!node.$refToScope) {
                return;
              }
              var move = node.$refToScope.moves && node.$refToScope.moves.get(node.name);
              if (!move) {
                return;
              }
              node.$refToScope = move.scope;
              if (node.name !== move.name) {
                node.originalName = node.name;
                node.name = move.name;
                if (node.alterop) {
                  var existingOp = null;
                  for (var i = 0; i < changes.length; i++) {
                    var op = changes[i];
                    if (op.node === node) {
                      existingOp = op;
                      break;
                    }
                  }
                  assert(existingOp);
                  existingOp.str = move.name;
                } else {
                  changes.push({
                    start: node.range[0],
                    end: node.range[1],
                    str: move.name
                  });
                }
              }
            }
            traverse(ast, {pre: renameDeclarations});
            traverse(ast, {pre: renameReferences});
            ast.$scope.traverse({pre: function(scope) {
                delete scope.moves;
              }});
          }
          function detectLoopClosures(ast) {
            traverse(ast, {pre: visit});
            function detectIifyBodyBlockers(body, node) {
              return breakable(function(brk) {
                traverse(body, {pre: function(n) {
                    if (isFunction(n)) {
                      return false;
                    }
                    var err = true;
                    var msg = "loop-variable {0} is captured by a loop-closure that can't be transformed due to use of {1} at line {2}";
                    if (n.type === "BreakStatement") {
                      error(getline(node), msg, node.name, "break", getline(n));
                    } else if (n.type === "ContinueStatement") {
                      error(getline(node), msg, node.name, "continue", getline(n));
                    } else if (n.type === "ReturnStatement") {
                      error(getline(node), msg, node.name, "return", getline(n));
                    } else if (n.type === "YieldExpression") {
                      error(getline(node), msg, node.name, "yield", getline(n));
                    } else if (n.type === "Identifier" && n.name === "arguments") {
                      error(getline(node), msg, node.name, "arguments", getline(n));
                    } else if (n.type === "VariableDeclaration" && n.kind === "var") {
                      error(getline(node), msg, node.name, "var", getline(n));
                    } else {
                      err = false;
                    }
                    if (err) {
                      brk(true);
                    }
                  }});
                return false;
              });
            }
            function visit(node) {
              var loopNode = null;
              if (isReference(node) && node.$refToScope && isConstLet(node.$refToScope.getKind(node.name))) {
                for (var n = node.$refToScope.node; ; ) {
                  if (isFunction(n)) {
                    return;
                  } else if (isLoop(n)) {
                    loopNode = n;
                    break;
                  }
                  n = n.$parent;
                  if (!n) {
                    return;
                  }
                }
                assert(isLoop(loopNode));
                var defScope = node.$refToScope;
                var generateIIFE = (options.loopClosures === "iife");
                for (var s = node.$scope; s; s = s.parent) {
                  if (s === defScope) {
                    return;
                  } else if (isFunction(s.node)) {
                    if (!generateIIFE) {
                      var msg = "loop-variable {0} is captured by a loop-closure. Tried \"loopClosures\": \"iife\" in defs-config.json?";
                      return error(getline(node), msg, node.name);
                    }
                    if (loopNode.type === "ForStatement" && defScope.node === loopNode) {
                      var declarationNode = defScope.getNode(node.name);
                      return error(getline(declarationNode), "Not yet specced ES6 feature. {0} is declared in for-loop header and then captured in loop closure", declarationNode.name);
                    }
                    if (detectIifyBodyBlockers(loopNode.body, node)) {
                      return;
                    }
                    loopNode.$iify = true;
                  }
                }
              }
            }
          }
          function transformLoopClosures(root, ops, options) {
            function insertOp(pos, str, node) {
              var op = {
                start: pos,
                end: pos,
                str: str
              };
              if (node) {
                op.node = node;
              }
              ops.push(op);
            }
            traverse(root, {pre: function(node) {
                if (!node.$iify) {
                  return;
                }
                var hasBlock = (node.body.type === "BlockStatement");
                var insertHead = (hasBlock ? node.body.range[0] + 1 : node.body.range[0]);
                var insertFoot = (hasBlock ? node.body.range[1] - 1 : node.body.range[1]);
                var forInName = (isForInOf(node) && node.left.declarations[0].id.name);
                ;
                var iifeHead = fmt("(function({0}){", forInName ? forInName : "");
                var iifeTail = fmt("}).call(this{0});", forInName ? ", " + forInName : "");
                var iifeFragment = options.parse(iifeHead + iifeTail);
                var iifeExpressionStatement = iifeFragment.body[0];
                var iifeBlockStatement = iifeExpressionStatement.expression.callee.object.body;
                if (hasBlock) {
                  var forBlockStatement = node.body;
                  var tmp = forBlockStatement.body;
                  forBlockStatement.body = [iifeExpressionStatement];
                  iifeBlockStatement.body = tmp;
                } else {
                  var tmp$0 = node.body;
                  node.body = iifeExpressionStatement;
                  iifeBlockStatement.body[0] = tmp$0;
                }
                insertOp(insertHead, iifeHead);
                if (forInName) {
                  insertOp(insertFoot, "}).call(this, ");
                  var args = iifeExpressionStatement.expression.arguments;
                  var iifeArgumentIdentifier = args[1];
                  iifeArgumentIdentifier.alterop = true;
                  insertOp(insertFoot, forInName, iifeArgumentIdentifier);
                  insertOp(insertFoot, ");");
                } else {
                  insertOp(insertFoot, iifeTail);
                }
              }});
          }
          function detectConstAssignment(ast) {
            traverse(ast, {pre: function(node) {
                if (isLvalue(node)) {
                  var scope = node.$scope.lookup(node.name);
                  if (scope && scope.getKind(node.name) === "const") {
                    error(getline(node), "can't assign to const variable {0}", node.name);
                  }
                }
              }});
          }
          function detectConstantLets(ast) {
            traverse(ast, {pre: function(node) {
                if (isLvalue(node)) {
                  var scope = node.$scope.lookup(node.name);
                  if (scope) {
                    scope.markWrite(node.name);
                  }
                }
              }});
            ast.$scope.detectUnmodifiedLets();
          }
          function setupScopeAndReferences(root, opts) {
            traverse(root, {pre: createScopes});
            var topScope = createTopScope(root.$scope, options.environments, options.globals);
            var allIdentifiers = stringset();
            topScope.traverse({pre: function(scope) {
                allIdentifiers.addMany(scope.decls.keys());
              }});
            setupReferences(root, allIdentifiers, opts);
            return allIdentifiers;
          }
          function cleanupTree(root) {
            traverse(root, {pre: function(node) {
                for (var prop in node) {
                  if (prop[0] === "$") {
                    delete node[prop];
                  }
                }
              }});
          }
          function run(src, config) {
            for (var key in config) {
              options[key] = config[key];
            }
            var parsed;
            if (is.object(src)) {
              if (!options.ast) {
                return {errors: ["Can't produce string output when input is an AST. " + "Did you forget to set options.ast = true?"]};
              }
              parsed = src;
            } else if (is.string(src)) {
              try {
                parsed = options.parse(src, {
                  loc: true,
                  range: true
                });
              } catch (e) {
                return {errors: [fmt("line {0} column {1}: Error during input file parsing\n{2}\n{3}", e.lineNumber, e.column, src.split("\n")[e.lineNumber - 1], fmt.repeat(" ", e.column - 1) + "^")]};
              }
            } else {
              return {errors: ["Input was neither an AST object nor a string."]};
            }
            var ast = parsed;
            error.reset();
            var allIdentifiers = setupScopeAndReferences(ast, {});
            detectLoopClosures(ast);
            detectConstAssignment(ast);
            var changes = [];
            transformLoopClosures(ast, changes, options);
            if (error.errors.length >= 1) {
              return {errors: error.errors};
            }
            if (changes.length > 0) {
              cleanupTree(ast);
              allIdentifiers = setupScopeAndReferences(ast, {analyze: false});
            }
            assert(error.errors.length === 0);
            var stats = new Stats();
            varify(ast, stats, allIdentifiers, changes);
            if (options.ast) {
              cleanupTree(ast);
              return {
                stats: stats,
                ast: ast
              };
            } else {
              var transformedSrc = alter(src, changes);
              return {
                stats: stats,
                src: transformedSrc
              };
            }
          }
          module.exports = run;
        }, {
          "./error": 554,
          "./jshint_globals/vars.js": 555,
          "./options": 556,
          "./scope": 557,
          "./stats": 558,
          "alter": 559,
          "assert": 2,
          "ast-traverse": 561,
          "breakable": 562,
          "simple-fmt": 563,
          "simple-is": 564,
          "stringmap": 565,
          "stringset": 566
        }],
        554: [function(require, module, exports) {
          "use strict";
          var fmt = require("simple-fmt");
          var assert = require("assert");
          function error(line, var_args) {
            assert(arguments.length >= 2);
            var msg = (arguments.length === 2 ? String(var_args) : fmt.apply(fmt, Array.prototype.slice.call(arguments, 1)));
            error.errors.push(line === -1 ? msg : fmt("line {0}: {1}", line, msg));
          }
          error.reset = function() {
            error.errors = [];
          };
          error.getline = function(node) {
            if (node && node.loc && node.loc.start) {
              return node.loc.start.line;
            }
            return -1;
          };
          error.reset();
          module.exports = error;
        }, {
          "assert": 2,
          "simple-fmt": 563
        }],
        555: [function(require, module, exports) {
          "use strict";
          exports.reservedVars = {
            arguments: false,
            NaN: false
          };
          exports.ecmaIdentifiers = {
            Array: false,
            Boolean: false,
            Date: false,
            decodeURI: false,
            decodeURIComponent: false,
            encodeURI: false,
            encodeURIComponent: false,
            Error: false,
            "eval": false,
            EvalError: false,
            Function: false,
            hasOwnProperty: false,
            isFinite: false,
            isNaN: false,
            JSON: false,
            Math: false,
            Map: false,
            Number: false,
            Object: false,
            parseInt: false,
            parseFloat: false,
            RangeError: false,
            ReferenceError: false,
            RegExp: false,
            Set: false,
            String: false,
            SyntaxError: false,
            TypeError: false,
            URIError: false,
            WeakMap: false
          };
          exports.browser = {
            ArrayBuffer: false,
            ArrayBufferView: false,
            Audio: false,
            Blob: false,
            addEventListener: false,
            applicationCache: false,
            atob: false,
            blur: false,
            btoa: false,
            clearInterval: false,
            clearTimeout: false,
            close: false,
            closed: false,
            DataView: false,
            DOMParser: false,
            defaultStatus: false,
            document: false,
            Element: false,
            event: false,
            FileReader: false,
            Float32Array: false,
            Float64Array: false,
            FormData: false,
            focus: false,
            frames: false,
            getComputedStyle: false,
            HTMLElement: false,
            HTMLAnchorElement: false,
            HTMLBaseElement: false,
            HTMLBlockquoteElement: false,
            HTMLBodyElement: false,
            HTMLBRElement: false,
            HTMLButtonElement: false,
            HTMLCanvasElement: false,
            HTMLDirectoryElement: false,
            HTMLDivElement: false,
            HTMLDListElement: false,
            HTMLFieldSetElement: false,
            HTMLFontElement: false,
            HTMLFormElement: false,
            HTMLFrameElement: false,
            HTMLFrameSetElement: false,
            HTMLHeadElement: false,
            HTMLHeadingElement: false,
            HTMLHRElement: false,
            HTMLHtmlElement: false,
            HTMLIFrameElement: false,
            HTMLImageElement: false,
            HTMLInputElement: false,
            HTMLIsIndexElement: false,
            HTMLLabelElement: false,
            HTMLLayerElement: false,
            HTMLLegendElement: false,
            HTMLLIElement: false,
            HTMLLinkElement: false,
            HTMLMapElement: false,
            HTMLMenuElement: false,
            HTMLMetaElement: false,
            HTMLModElement: false,
            HTMLObjectElement: false,
            HTMLOListElement: false,
            HTMLOptGroupElement: false,
            HTMLOptionElement: false,
            HTMLParagraphElement: false,
            HTMLParamElement: false,
            HTMLPreElement: false,
            HTMLQuoteElement: false,
            HTMLScriptElement: false,
            HTMLSelectElement: false,
            HTMLStyleElement: false,
            HTMLTableCaptionElement: false,
            HTMLTableCellElement: false,
            HTMLTableColElement: false,
            HTMLTableElement: false,
            HTMLTableRowElement: false,
            HTMLTableSectionElement: false,
            HTMLTextAreaElement: false,
            HTMLTitleElement: false,
            HTMLUListElement: false,
            HTMLVideoElement: false,
            history: false,
            Int16Array: false,
            Int32Array: false,
            Int8Array: false,
            Image: false,
            length: false,
            localStorage: false,
            location: false,
            MessageChannel: false,
            MessageEvent: false,
            MessagePort: false,
            moveBy: false,
            moveTo: false,
            MutationObserver: false,
            name: false,
            Node: false,
            NodeFilter: false,
            navigator: false,
            onbeforeunload: true,
            onblur: true,
            onerror: true,
            onfocus: true,
            onload: true,
            onresize: true,
            onunload: true,
            open: false,
            openDatabase: false,
            opener: false,
            Option: false,
            parent: false,
            print: false,
            removeEventListener: false,
            resizeBy: false,
            resizeTo: false,
            screen: false,
            scroll: false,
            scrollBy: false,
            scrollTo: false,
            sessionStorage: false,
            setInterval: false,
            setTimeout: false,
            SharedWorker: false,
            status: false,
            top: false,
            Uint16Array: false,
            Uint32Array: false,
            Uint8Array: false,
            Uint8ClampedArray: false,
            WebSocket: false,
            window: false,
            Worker: false,
            XMLHttpRequest: false,
            XMLSerializer: false,
            XPathEvaluator: false,
            XPathException: false,
            XPathExpression: false,
            XPathNamespace: false,
            XPathNSResolver: false,
            XPathResult: false
          };
          exports.devel = {
            alert: false,
            confirm: false,
            console: false,
            Debug: false,
            opera: false,
            prompt: false
          };
          exports.worker = {
            importScripts: true,
            postMessage: true,
            self: true
          };
          exports.nonstandard = {
            escape: false,
            unescape: false
          };
          exports.couch = {
            "require": false,
            respond: false,
            getRow: false,
            emit: false,
            send: false,
            start: false,
            sum: false,
            log: false,
            exports: false,
            module: false,
            provides: false
          };
          exports.node = {
            __filename: false,
            __dirname: false,
            Buffer: false,
            DataView: false,
            console: false,
            exports: true,
            GLOBAL: false,
            global: false,
            module: false,
            process: false,
            require: false,
            setTimeout: false,
            clearTimeout: false,
            setInterval: false,
            clearInterval: false
          };
          exports.phantom = {
            phantom: true,
            require: true,
            WebPage: true
          };
          exports.rhino = {
            defineClass: false,
            deserialize: false,
            gc: false,
            help: false,
            importPackage: false,
            "java": false,
            load: false,
            loadClass: false,
            print: false,
            quit: false,
            readFile: false,
            readUrl: false,
            runCommand: false,
            seal: false,
            serialize: false,
            spawn: false,
            sync: false,
            toint32: false,
            version: false
          };
          exports.wsh = {
            ActiveXObject: true,
            Enumerator: true,
            GetObject: true,
            ScriptEngine: true,
            ScriptEngineBuildVersion: true,
            ScriptEngineMajorVersion: true,
            ScriptEngineMinorVersion: true,
            VBArray: true,
            WSH: true,
            WScript: true,
            XDomainRequest: true
          };
          exports.dojo = {
            dojo: false,
            dijit: false,
            dojox: false,
            define: false,
            "require": false
          };
          exports.jquery = {
            "$": false,
            jQuery: false
          };
          exports.mootools = {
            "$": false,
            "$$": false,
            Asset: false,
            Browser: false,
            Chain: false,
            Class: false,
            Color: false,
            Cookie: false,
            Core: false,
            Document: false,
            DomReady: false,
            DOMEvent: false,
            DOMReady: false,
            Drag: false,
            Element: false,
            Elements: false,
            Event: false,
            Events: false,
            Fx: false,
            Group: false,
            Hash: false,
            HtmlTable: false,
            Iframe: false,
            IframeShim: false,
            InputValidator: false,
            instanceOf: false,
            Keyboard: false,
            Locale: false,
            Mask: false,
            MooTools: false,
            Native: false,
            Options: false,
            OverText: false,
            Request: false,
            Scroller: false,
            Slick: false,
            Slider: false,
            Sortables: false,
            Spinner: false,
            Swiff: false,
            Tips: false,
            Type: false,
            typeOf: false,
            URI: false,
            Window: false
          };
          exports.prototypejs = {
            "$": false,
            "$$": false,
            "$A": false,
            "$F": false,
            "$H": false,
            "$R": false,
            "$break": false,
            "$continue": false,
            "$w": false,
            Abstract: false,
            Ajax: false,
            Class: false,
            Enumerable: false,
            Element: false,
            Event: false,
            Field: false,
            Form: false,
            Hash: false,
            Insertion: false,
            ObjectRange: false,
            PeriodicalExecuter: false,
            Position: false,
            Prototype: false,
            Selector: false,
            Template: false,
            Toggle: false,
            Try: false,
            Autocompleter: false,
            Builder: false,
            Control: false,
            Draggable: false,
            Draggables: false,
            Droppables: false,
            Effect: false,
            Sortable: false,
            SortableObserver: false,
            Sound: false,
            Scriptaculous: false
          };
          exports.yui = {
            YUI: false,
            Y: false,
            YUI_config: false
          };
        }, {}],
        556: [function(require, module, exports) {
          module.exports = {
            disallowVars: false,
            disallowDuplicated: true,
            disallowUnknownReferences: true,
            parse: require("esprima-fb").parse
          };
        }, {"esprima-fb": 1}],
        557: [function(require, module, exports) {
          "use strict";
          var assert = require("assert");
          var stringmap = require("stringmap");
          var stringset = require("stringset");
          var is = require("simple-is");
          var fmt = require("simple-fmt");
          var error = require("./error");
          var getline = error.getline;
          var options = require("./options");
          function Scope(args) {
            assert(is.someof(args.kind, ["hoist", "block", "catch-block"]));
            assert(is.object(args.node));
            assert(args.parent === null || is.object(args.parent));
            this.kind = args.kind;
            this.node = args.node;
            this.parent = args.parent;
            this.children = [];
            this.decls = stringmap();
            this.written = stringset();
            this.propagates = (this.kind === "hoist" ? stringset() : null);
            if (this.parent) {
              this.parent.children.push(this);
            }
          }
          Scope.prototype.print = function(indent) {
            indent = indent || 0;
            var scope = this;
            var names = this.decls.keys().map(function(name) {
              return fmt("{0} [{1}]", name, scope.decls.get(name).kind);
            }).join(", ");
            var propagates = this.propagates ? this.propagates.items().join(", ") : "";
            console.log(fmt("{0}{1}: {2}. propagates: {3}", fmt.repeat(" ", indent), this.node.type, names, propagates));
            this.children.forEach(function(c) {
              c.print(indent + 2);
            });
          };
          Scope.prototype.add = function(name, kind, node, referableFromPos) {
            assert(is.someof(kind, ["fun", "param", "var", "caught", "const", "let"]));
            function isConstLet(kind) {
              return is.someof(kind, ["const", "let"]);
            }
            var scope = this;
            if (is.someof(kind, ["fun", "param", "var"])) {
              while (scope.kind !== "hoist") {
                if (scope.decls.has(name) && isConstLet(scope.decls.get(name).kind)) {
                  return error(getline(node), "{0} is already declared", name);
                }
                scope = scope.parent;
              }
            }
            if (scope.decls.has(name) && (options.disallowDuplicated || isConstLet(scope.decls.get(name).kind) || isConstLet(kind))) {
              return error(getline(node), "{0} is already declared", name);
            }
            var declaration = {
              kind: kind,
              node: node
            };
            if (referableFromPos) {
              assert(is.someof(kind, ["var", "const", "let"]));
              declaration.from = referableFromPos;
            }
            scope.decls.set(name, declaration);
          };
          Scope.prototype.getKind = function(name) {
            assert(is.string(name));
            var decl = this.decls.get(name);
            return decl ? decl.kind : null;
          };
          Scope.prototype.getNode = function(name) {
            assert(is.string(name));
            var decl = this.decls.get(name);
            return decl ? decl.node : null;
          };
          Scope.prototype.getFromPos = function(name) {
            assert(is.string(name));
            var decl = this.decls.get(name);
            return decl ? decl.from : null;
          };
          Scope.prototype.hasOwn = function(name) {
            return this.decls.has(name);
          };
          Scope.prototype.remove = function(name) {
            return this.decls.remove(name);
          };
          Scope.prototype.doesPropagate = function(name) {
            return this.propagates.has(name);
          };
          Scope.prototype.markPropagates = function(name) {
            this.propagates.add(name);
          };
          Scope.prototype.closestHoistScope = function() {
            var scope = this;
            while (scope.kind !== "hoist") {
              scope = scope.parent;
            }
            return scope;
          };
          Scope.prototype.hasFunctionScopeBetween = function(outer) {
            function isFunction(node) {
              return is.someof(node.type, ["FunctionDeclaration", "FunctionExpression"]);
            }
            for (var scope = this; scope; scope = scope.parent) {
              if (scope === outer) {
                return false;
              }
              if (isFunction(scope.node)) {
                return true;
              }
            }
            throw new Error("wasn't inner scope of outer");
          };
          Scope.prototype.lookup = function(name) {
            for (var scope = this; scope; scope = scope.parent) {
              if (scope.decls.has(name)) {
                return scope;
              } else if (scope.kind === "hoist") {
                scope.propagates.add(name);
              }
            }
            return null;
          };
          Scope.prototype.markWrite = function(name) {
            assert(is.string(name));
            this.written.add(name);
          };
          Scope.prototype.detectUnmodifiedLets = function() {
            var outmost = this;
            function detect(scope) {
              if (scope !== outmost) {
                scope.decls.keys().forEach(function(name) {
                  if (scope.getKind(name) === "let" && !scope.written.has(name)) {
                    return error(getline(scope.getNode(name)), "{0} is declared as let but never modified so could be const", name);
                  }
                });
              }
              scope.children.forEach(function(childScope) {
                detect(childScope);
              });
            }
            detect(this);
          };
          Scope.prototype.traverse = function(options) {
            options = options || {};
            var pre = options.pre;
            var post = options.post;
            function visit(scope) {
              if (pre) {
                pre(scope);
              }
              scope.children.forEach(function(childScope) {
                visit(childScope);
              });
              if (post) {
                post(scope);
              }
            }
            visit(this);
          };
          module.exports = Scope;
        }, {
          "./error": 554,
          "./options": 556,
          "assert": 2,
          "simple-fmt": 563,
          "simple-is": 564,
          "stringmap": 565,
          "stringset": 566
        }],
        558: [function(require, module, exports) {
          var fmt = require("simple-fmt");
          var is = require("simple-is");
          var assert = require("assert");
          function Stats() {
            this.lets = 0;
            this.consts = 0;
            this.renames = [];
          }
          Stats.prototype.declarator = function(kind) {
            assert(is.someof(kind, ["const", "let"]));
            if (kind === "const") {
              this.consts++;
            } else {
              this.lets++;
            }
          };
          Stats.prototype.rename = function(oldName, newName, line) {
            this.renames.push({
              oldName: oldName,
              newName: newName,
              line: line
            });
          };
          Stats.prototype.toString = function() {
            var renames = this.renames.map(function(r) {
              return r;
            }).sort(function(a, b) {
              return a.line - b.line;
            });
            var renameStr = renames.map(function(rename) {
              return fmt("\nline {0}: {1} => {2}", rename.line, rename.oldName, rename.newName);
            }).join("");
            var sum = this.consts + this.lets;
            var constlets = (sum === 0 ? "can't calculate const coverage (0 consts, 0 lets)" : fmt("{0}% const coverage ({1} consts, {2} lets)", Math.floor(100 * this.consts / sum), this.consts, this.lets));
            return constlets + renameStr + "\n";
          };
          module.exports = Stats;
        }, {
          "assert": 2,
          "simple-fmt": 563,
          "simple-is": 564
        }],
        559: [function(require, module, exports) {
          var assert = require("assert");
          var stableSort = require("stable");
          function alter(str, fragments) {
            "use strict";
            var isArray = Array.isArray || function(v) {
              return Object.prototype.toString.call(v) === "[object Array]";
            };
            ;
            assert(typeof str === "string");
            assert(isArray(fragments));
            var sortedFragments = stableSort(fragments, function(a, b) {
              return a.start - b.start;
            });
            var outs = [];
            var pos = 0;
            for (var i = 0; i < sortedFragments.length; i++) {
              var frag = sortedFragments[i];
              assert(pos <= frag.start);
              assert(frag.start <= frag.end);
              outs.push(str.slice(pos, frag.start));
              outs.push(frag.str);
              pos = frag.end;
            }
            if (pos < str.length) {
              outs.push(str.slice(pos));
            }
            return outs.join("");
          }
          if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
            module.exports = alter;
          }
        }, {
          "assert": 2,
          "stable": 560
        }],
        560: [function(require, module, exports) {
          (function() {
            var stable = function(arr, comp) {
              return exec(arr.slice(), comp);
            };
            stable.inplace = function(arr, comp) {
              var result = exec(arr, comp);
              if (result !== arr) {
                pass(result, null, arr.length, arr);
              }
              return arr;
            };
            function exec(arr, comp) {
              if (typeof(comp) !== 'function') {
                comp = function(a, b) {
                  return String(a).localeCompare(b);
                };
              }
              var len = arr.length;
              if (len <= 1) {
                return arr;
              }
              var buffer = new Array(len);
              for (var chk = 1; chk < len; chk *= 2) {
                pass(arr, comp, chk, buffer);
                var tmp = arr;
                arr = buffer;
                buffer = tmp;
              }
              return arr;
            }
            var pass = function(arr, comp, chk, result) {
              var len = arr.length;
              var i = 0;
              var dbl = chk * 2;
              var l,
                  r,
                  e;
              var li,
                  ri;
              for (l = 0; l < len; l += dbl) {
                r = l + chk;
                e = r + chk;
                if (r > len)
                  r = len;
                if (e > len)
                  e = len;
                li = l;
                ri = r;
                while (true) {
                  if (li < r && ri < e) {
                    if (comp(arr[li], arr[ri]) <= 0) {
                      result[i++] = arr[li++];
                    } else {
                      result[i++] = arr[ri++];
                    }
                  } else if (li < r) {
                    result[i++] = arr[li++];
                  } else if (ri < e) {
                    result[i++] = arr[ri++];
                  } else {
                    break;
                  }
                }
              }
            };
            if (typeof(module) !== 'undefined') {
              module.exports = stable;
            } else {
              window.stable = stable;
            }
          })();
        }, {}],
        561: [function(require, module, exports) {
          function traverse(root, options) {
            "use strict";
            options = options || {};
            var pre = options.pre;
            var post = options.post;
            var skipProperty = options.skipProperty;
            function visit(node, parent, prop, idx) {
              if (!node || typeof node.type !== "string") {
                return;
              }
              var res = undefined;
              if (pre) {
                res = pre(node, parent, prop, idx);
              }
              if (res !== false) {
                for (var prop in node) {
                  if (skipProperty ? skipProperty(prop, node) : prop[0] === "$") {
                    continue;
                  }
                  var child = node[prop];
                  if (Array.isArray(child)) {
                    for (var i = 0; i < child.length; i++) {
                      visit(child[i], node, prop, i);
                    }
                  } else {
                    visit(child, node, prop);
                  }
                }
              }
              if (post) {
                post(node, parent, prop, idx);
              }
            }
            visit(root, null);
          }
          ;
          if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
            module.exports = traverse;
          }
        }, {}],
        562: [function(require, module, exports) {
          var breakable = (function() {
            "use strict";
            function Val(val, brk) {
              this.val = val;
              this.brk = brk;
            }
            function make_brk() {
              return function brk(val) {
                throw new Val(val, brk);
              };
            }
            function breakable(fn) {
              var brk = make_brk();
              try {
                return fn(brk);
              } catch (e) {
                if (e instanceof Val && e.brk === brk) {
                  return e.val;
                }
                throw e;
              }
            }
            return breakable;
          })();
          if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
            module.exports = breakable;
          }
        }, {}],
        563: [function(require, module, exports) {
          var fmt = (function() {
            "use strict";
            function fmt(str, var_args) {
              var args = Array.prototype.slice.call(arguments, 1);
              return str.replace(/\{(\d+)\}/g, function(s, match) {
                return (match in args ? args[match] : s);
              });
            }
            function obj(str, obj) {
              return str.replace(/\{([_$a-zA-Z0-9][_$a-zA-Z0-9]*)\}/g, function(s, match) {
                return (match in obj ? obj[match] : s);
              });
            }
            function repeat(str, n) {
              return (new Array(n + 1)).join(str);
            }
            fmt.fmt = fmt;
            fmt.obj = obj;
            fmt.repeat = repeat;
            return fmt;
          })();
          if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
            module.exports = fmt;
          }
        }, {}],
        564: [function(require, module, exports) {
          var is = (function() {
            "use strict";
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var toString = Object.prototype.toString;
            var _undefined = void 0;
            return {
              nan: function(v) {
                return v !== v;
              },
              boolean: function(v) {
                return typeof v === "boolean";
              },
              number: function(v) {
                return typeof v === "number";
              },
              string: function(v) {
                return typeof v === "string";
              },
              fn: function(v) {
                return typeof v === "function";
              },
              object: function(v) {
                return v !== null && typeof v === "object";
              },
              primitive: function(v) {
                var t = typeof v;
                return v === null || v === _undefined || t === "boolean" || t === "number" || t === "string";
              },
              array: Array.isArray || function(v) {
                return toString.call(v) === "[object Array]";
              },
              finitenumber: function(v) {
                return typeof v === "number" && isFinite(v);
              },
              someof: function(v, values) {
                return values.indexOf(v) >= 0;
              },
              noneof: function(v, values) {
                return values.indexOf(v) === -1;
              },
              own: function(obj, prop) {
                return hasOwnProperty.call(obj, prop);
              }
            };
          })();
          if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
            module.exports = is;
          }
        }, {}],
        565: [function(require, module, exports) {
          var StringMap = (function() {
            "use strict";
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var create = (function() {
              function hasOwnEnumerableProps(obj) {
                for (var prop in obj) {
                  if (hasOwnProperty.call(obj, prop)) {
                    return true;
                  }
                }
                return false;
              }
              function hasOwnPollutedProps(obj) {
                return hasOwnProperty.call(obj, "__count__") || hasOwnProperty.call(obj, "__parent__");
              }
              var useObjectCreate = false;
              if (typeof Object.create === "function") {
                if (!hasOwnEnumerableProps(Object.create(null))) {
                  useObjectCreate = true;
                }
              }
              if (useObjectCreate === false) {
                if (hasOwnEnumerableProps({})) {
                  throw new Error("StringMap environment error 0, please file a bug at https://github.com/olov/stringmap/issues");
                }
              }
              var o = (useObjectCreate ? Object.create(null) : {});
              var useProtoClear = false;
              if (hasOwnPollutedProps(o)) {
                o.__proto__ = null;
                if (hasOwnEnumerableProps(o) || hasOwnPollutedProps(o)) {
                  throw new Error("StringMap environment error 1, please file a bug at https://github.com/olov/stringmap/issues");
                }
                useProtoClear = true;
              }
              return function() {
                var o = (useObjectCreate ? Object.create(null) : {});
                if (useProtoClear) {
                  o.__proto__ = null;
                }
                return o;
              };
            })();
            function stringmap(optional_object) {
              if (!(this instanceof stringmap)) {
                return new stringmap(optional_object);
              }
              this.obj = create();
              this.hasProto = false;
              this.proto = undefined;
              if (optional_object) {
                this.setMany(optional_object);
              }
            }
            ;
            stringmap.prototype.has = function(key) {
              if (typeof key !== "string") {
                throw new Error("StringMap expected string key");
              }
              return (key === "__proto__" ? this.hasProto : hasOwnProperty.call(this.obj, key));
            };
            stringmap.prototype.get = function(key) {
              if (typeof key !== "string") {
                throw new Error("StringMap expected string key");
              }
              return (key === "__proto__" ? this.proto : (hasOwnProperty.call(this.obj, key) ? this.obj[key] : undefined));
            };
            stringmap.prototype.set = function(key, value) {
              if (typeof key !== "string") {
                throw new Error("StringMap expected string key");
              }
              if (key === "__proto__") {
                this.hasProto = true;
                this.proto = value;
              } else {
                this.obj[key] = value;
              }
            };
            stringmap.prototype.remove = function(key) {
              if (typeof key !== "string") {
                throw new Error("StringMap expected string key");
              }
              var didExist = this.has(key);
              if (key === "__proto__") {
                this.hasProto = false;
                this.proto = undefined;
              } else {
                delete this.obj[key];
              }
              return didExist;
            };
            stringmap.prototype['delete'] = stringmap.prototype.remove;
            stringmap.prototype.isEmpty = function() {
              for (var key in this.obj) {
                if (hasOwnProperty.call(this.obj, key)) {
                  return false;
                }
              }
              return !this.hasProto;
            };
            stringmap.prototype.size = function() {
              var len = 0;
              for (var key in this.obj) {
                if (hasOwnProperty.call(this.obj, key)) {
                  ++len;
                }
              }
              return (this.hasProto ? len + 1 : len);
            };
            stringmap.prototype.keys = function() {
              var keys = [];
              for (var key in this.obj) {
                if (hasOwnProperty.call(this.obj, key)) {
                  keys.push(key);
                }
              }
              if (this.hasProto) {
                keys.push("__proto__");
              }
              return keys;
            };
            stringmap.prototype.values = function() {
              var values = [];
              for (var key in this.obj) {
                if (hasOwnProperty.call(this.obj, key)) {
                  values.push(this.obj[key]);
                }
              }
              if (this.hasProto) {
                values.push(this.proto);
              }
              return values;
            };
            stringmap.prototype.items = function() {
              var items = [];
              for (var key in this.obj) {
                if (hasOwnProperty.call(this.obj, key)) {
                  items.push([key, this.obj[key]]);
                }
              }
              if (this.hasProto) {
                items.push(["__proto__", this.proto]);
              }
              return items;
            };
            stringmap.prototype.setMany = function(object) {
              if (object === null || (typeof object !== "object" && typeof object !== "function")) {
                throw new Error("StringMap expected Object");
              }
              for (var key in object) {
                if (hasOwnProperty.call(object, key)) {
                  this.set(key, object[key]);
                }
              }
              return this;
            };
            stringmap.prototype.merge = function(other) {
              var keys = other.keys();
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                this.set(key, other.get(key));
              }
              return this;
            };
            stringmap.prototype.map = function(fn) {
              var keys = this.keys();
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                keys[i] = fn(this.get(key), key);
              }
              return keys;
            };
            stringmap.prototype.forEach = function(fn) {
              var keys = this.keys();
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                fn(this.get(key), key);
              }
            };
            stringmap.prototype.clone = function() {
              var other = stringmap();
              return other.merge(this);
            };
            stringmap.prototype.toString = function() {
              var self = this;
              return "{" + this.keys().map(function(key) {
                return JSON.stringify(key) + ":" + JSON.stringify(self.get(key));
              }).join(",") + "}";
            };
            return stringmap;
          })();
          if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
            module.exports = StringMap;
          }
        }, {}],
        566: [function(require, module, exports) {
          var StringSet = (function() {
            "use strict";
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var create = (function() {
              function hasOwnEnumerableProps(obj) {
                for (var prop in obj) {
                  if (hasOwnProperty.call(obj, prop)) {
                    return true;
                  }
                }
                return false;
              }
              function hasOwnPollutedProps(obj) {
                return hasOwnProperty.call(obj, "__count__") || hasOwnProperty.call(obj, "__parent__");
              }
              var useObjectCreate = false;
              if (typeof Object.create === "function") {
                if (!hasOwnEnumerableProps(Object.create(null))) {
                  useObjectCreate = true;
                }
              }
              if (useObjectCreate === false) {
                if (hasOwnEnumerableProps({})) {
                  throw new Error("StringSet environment error 0, please file a bug at https://github.com/olov/stringset/issues");
                }
              }
              var o = (useObjectCreate ? Object.create(null) : {});
              var useProtoClear = false;
              if (hasOwnPollutedProps(o)) {
                o.__proto__ = null;
                if (hasOwnEnumerableProps(o) || hasOwnPollutedProps(o)) {
                  throw new Error("StringSet environment error 1, please file a bug at https://github.com/olov/stringset/issues");
                }
                useProtoClear = true;
              }
              return function() {
                var o = (useObjectCreate ? Object.create(null) : {});
                if (useProtoClear) {
                  o.__proto__ = null;
                }
                return o;
              };
            })();
            function stringset(optional_array) {
              if (!(this instanceof stringset)) {
                return new stringset(optional_array);
              }
              this.obj = create();
              this.hasProto = false;
              if (optional_array) {
                this.addMany(optional_array);
              }
            }
            ;
            stringset.prototype.has = function(item) {
              if (typeof item !== "string") {
                throw new Error("StringSet expected string item");
              }
              return (item === "__proto__" ? this.hasProto : hasOwnProperty.call(this.obj, item));
            };
            stringset.prototype.add = function(item) {
              if (typeof item !== "string") {
                throw new Error("StringSet expected string item");
              }
              if (item === "__proto__") {
                this.hasProto = true;
              } else {
                this.obj[item] = true;
              }
            };
            stringset.prototype.remove = function(item) {
              if (typeof item !== "string") {
                throw new Error("StringSet expected string item");
              }
              var didExist = this.has(item);
              if (item === "__proto__") {
                this.hasProto = false;
              } else {
                delete this.obj[item];
              }
              return didExist;
            };
            stringset.prototype['delete'] = stringset.prototype.remove;
            stringset.prototype.isEmpty = function() {
              for (var item in this.obj) {
                if (hasOwnProperty.call(this.obj, item)) {
                  return false;
                }
              }
              return !this.hasProto;
            };
            stringset.prototype.size = function() {
              var len = 0;
              for (var item in this.obj) {
                if (hasOwnProperty.call(this.obj, item)) {
                  ++len;
                }
              }
              return (this.hasProto ? len + 1 : len);
            };
            stringset.prototype.items = function() {
              var items = [];
              for (var item in this.obj) {
                if (hasOwnProperty.call(this.obj, item)) {
                  items.push(item);
                }
              }
              if (this.hasProto) {
                items.push("__proto__");
              }
              return items;
            };
            stringset.prototype.addMany = function(items) {
              if (!Array.isArray(items)) {
                throw new Error("StringSet expected array");
              }
              for (var i = 0; i < items.length; i++) {
                this.add(items[i]);
              }
              return this;
            };
            stringset.prototype.merge = function(other) {
              this.addMany(other.items());
              return this;
            };
            stringset.prototype.clone = function() {
              var other = stringset();
              return other.merge(this);
            };
            stringset.prototype.toString = function() {
              return "{" + this.items().map(JSON.stringify).join(",") + "}";
            };
            return stringset;
          })();
          if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
            module.exports = StringSet;
          }
        }, {}],
        567: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("./types");
          var n = types.namedTypes;
          var isArray = types.builtInTypes.array;
          var isObject = types.builtInTypes.object;
          var linesModule = require("./lines");
          var fromString = linesModule.fromString;
          var Lines = linesModule.Lines;
          var concat = linesModule.concat;
          var util = require("./util");
          var comparePos = util.comparePos;
          var childNodesCacheKey = require("private").makeUniqueKey();
          function getSortedChildNodes(node, resultArray) {
            if (!node) {
              return;
            }
            util.fixFaultyLocations(node);
            if (resultArray) {
              if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {
                for (var i = resultArray.length - 1; i >= 0; --i) {
                  if (comparePos(resultArray[i].loc.end, node.loc.start) <= 0) {
                    break;
                  }
                }
                resultArray.splice(i + 1, 0, node);
                return;
              }
            } else if (node[childNodesCacheKey]) {
              return node[childNodesCacheKey];
            }
            var names;
            if (isArray.check(node)) {
              names = Object.keys(node);
            } else if (isObject.check(node)) {
              names = types.getFieldNames(node);
            } else {
              return;
            }
            if (!resultArray) {
              Object.defineProperty(node, childNodesCacheKey, {
                value: resultArray = [],
                enumerable: false
              });
            }
            for (var i = 0,
                nameCount = names.length; i < nameCount; ++i) {
              getSortedChildNodes(node[names[i]], resultArray);
            }
            return resultArray;
          }
          function decorateComment(node, comment) {
            var childNodes = getSortedChildNodes(node);
            var left = 0,
                right = childNodes.length;
            while (left < right) {
              var middle = (left + right) >> 1;
              var child = childNodes[middle];
              if (comparePos(child.loc.start, comment.loc.start) <= 0 && comparePos(comment.loc.end, child.loc.end) <= 0) {
                decorateComment(comment.enclosingNode = child, comment);
                return;
              }
              if (comparePos(child.loc.end, comment.loc.start) <= 0) {
                var precedingNode = child;
                left = middle + 1;
                continue;
              }
              if (comparePos(comment.loc.end, child.loc.start) <= 0) {
                var followingNode = child;
                right = middle;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (precedingNode) {
              comment.precedingNode = precedingNode;
            }
            if (followingNode) {
              comment.followingNode = followingNode;
            }
          }
          exports.attach = function(comments, ast, lines) {
            if (!isArray.check(comments)) {
              return;
            }
            var tiesToBreak = [];
            comments.forEach(function(comment) {
              comment.loc.lines = lines;
              decorateComment(ast, comment);
              var pn = comment.precedingNode;
              var en = comment.enclosingNode;
              var fn = comment.followingNode;
              if (pn && fn) {
                var tieCount = tiesToBreak.length;
                if (tieCount > 0) {
                  var lastTie = tiesToBreak[tieCount - 1];
                  assert.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);
                  if (lastTie.followingNode !== comment.followingNode) {
                    breakTies(tiesToBreak, lines);
                  }
                }
                tiesToBreak.push(comment);
              } else if (pn) {
                breakTies(tiesToBreak, lines);
                addTrailingComment(pn, comment);
              } else if (fn) {
                breakTies(tiesToBreak, lines);
                addLeadingComment(fn, comment);
              } else if (en) {
                breakTies(tiesToBreak, lines);
                addDanglingComment(en, comment);
              } else {
                throw new Error("AST contains no nodes at all?");
              }
            });
            breakTies(tiesToBreak, lines);
            comments.forEach(function(comment) {
              delete comment.precedingNode;
              delete comment.enclosingNode;
              delete comment.followingNode;
            });
          };
          function breakTies(tiesToBreak, lines) {
            var tieCount = tiesToBreak.length;
            if (tieCount === 0) {
              return;
            }
            var pn = tiesToBreak[0].precedingNode;
            var fn = tiesToBreak[0].followingNode;
            var gapEndPos = fn.loc.start;
            for (var indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
              var comment = tiesToBreak[indexOfFirstLeadingComment - 1];
              assert.strictEqual(comment.precedingNode, pn);
              assert.strictEqual(comment.followingNode, fn);
              var gap = lines.sliceString(comment.loc.end, gapEndPos);
              if (/\S/.test(gap)) {
                break;
              }
              gapEndPos = comment.loc.start;
            }
            while (indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && comment.type === "Line" && comment.loc.start.column > fn.loc.start.column) {
              ++indexOfFirstLeadingComment;
            }
            tiesToBreak.forEach(function(comment, i) {
              if (i < indexOfFirstLeadingComment) {
                addTrailingComment(pn, comment);
              } else {
                addLeadingComment(fn, comment);
              }
            });
            tiesToBreak.length = 0;
          }
          function addCommentHelper(node, comment) {
            var comments = node.comments || (node.comments = []);
            comments.push(comment);
          }
          function addLeadingComment(node, comment) {
            comment.leading = true;
            comment.trailing = false;
            addCommentHelper(node, comment);
          }
          function addDanglingComment(node, comment) {
            comment.leading = false;
            comment.trailing = false;
            addCommentHelper(node, comment);
          }
          function addTrailingComment(node, comment) {
            comment.leading = false;
            comment.trailing = true;
            addCommentHelper(node, comment);
          }
          function printLeadingComment(commentPath, print) {
            var comment = commentPath.getValue();
            n.Comment.assert(comment);
            var loc = comment.loc;
            var lines = loc && loc.lines;
            var parts = [print(commentPath)];
            if (comment.trailing) {
              parts.push("\n");
            } else if (lines instanceof Lines) {
              var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end));
              if (trailingSpace.length === 1) {
                parts.push(trailingSpace);
              } else {
                parts.push(new Array(trailingSpace.length).join("\n"));
              }
            } else {
              parts.push("\n");
            }
            return concat(parts);
          }
          function printTrailingComment(commentPath, print) {
            var comment = commentPath.getValue(commentPath);
            n.Comment.assert(comment);
            var loc = comment.loc;
            var lines = loc && loc.lines;
            var parts = [];
            if (lines instanceof Lines) {
              var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();
              var leadingSpace = lines.slice(fromPos, loc.start);
              if (leadingSpace.length === 1) {
                parts.push(leadingSpace);
              } else {
                parts.push(new Array(leadingSpace.length).join("\n"));
              }
            }
            parts.push(print(commentPath));
            return concat(parts);
          }
          exports.printComments = function(path, print) {
            var value = path.getValue();
            var innerLines = print(path);
            var comments = n.Node.check(value) && types.getFieldValue(value, "comments");
            if (!comments || comments.length === 0) {
              return innerLines;
            }
            var leadingParts = [];
            var trailingParts = [innerLines];
            path.each(function(commentPath) {
              var comment = commentPath.getValue();
              var leading = types.getFieldValue(comment, "leading");
              var trailing = types.getFieldValue(comment, "trailing");
              if (leading || (trailing && comment.type !== "Block")) {
                leadingParts.push(printLeadingComment(commentPath, print));
              } else if (trailing) {
                assert.strictEqual(comment.type, "Block");
                trailingParts.push(printTrailingComment(commentPath, print));
              }
            }, "comments");
            leadingParts.push.apply(leadingParts, trailingParts);
            return concat(leadingParts);
          };
        }, {
          "./lines": 569,
          "./types": 575,
          "./util": 576,
          "assert": 2,
          "private": 545
        }],
        568: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("./types");
          var n = types.namedTypes;
          var Node = n.Node;
          var isArray = types.builtInTypes.array;
          var isNumber = types.builtInTypes.number;
          function FastPath(value) {
            assert.ok(this instanceof FastPath);
            this.stack = [value];
          }
          var FPp = FastPath.prototype;
          module.exports = FastPath;
          FastPath.from = function(obj) {
            if (obj instanceof FastPath) {
              return obj.copy();
            }
            if (obj instanceof types.NodePath) {
              var copy = Object.create(FastPath.prototype);
              var stack = [obj.value];
              for (var pp; (pp = obj.parentPath); obj = pp)
                stack.push(obj.name, pp.value);
              copy.stack = stack.reverse();
              return copy;
            }
            return new FastPath(obj);
          };
          FPp.copy = function copy() {
            var copy = Object.create(FastPath.prototype);
            copy.stack = this.stack.slice(0);
            return copy;
          };
          FPp.getName = function getName() {
            var s = this.stack;
            var len = s.length;
            if (len > 1) {
              return s[len - 2];
            }
            return null;
          };
          FPp.getValue = function getValue() {
            var s = this.stack;
            return s[s.length - 1];
          };
          function getNodeHelper(path, count) {
            var s = path.stack;
            for (var i = s.length - 1; i >= 0; i -= 2) {
              var value = s[i];
              if (n.Node.check(value) && --count < 0) {
                return value;
              }
            }
            return null;
          }
          FPp.getNode = function getNode(count) {
            return getNodeHelper(this, ~~count);
          };
          FPp.getParentNode = function getParentNode(count) {
            return getNodeHelper(this, ~~count + 1);
          };
          FPp.getRootValue = function getRootValue() {
            var s = this.stack;
            if (s.length % 2 === 0) {
              return s[1];
            }
            return s[0];
          };
          FPp.call = function call(callback) {
            var s = this.stack;
            var origLen = s.length;
            var value = s[origLen - 1];
            var argc = arguments.length;
            for (var i = 1; i < argc; ++i) {
              var name = arguments[i];
              value = value[name];
              s.push(name, value);
            }
            var result = callback(this);
            s.length = origLen;
            return result;
          };
          FPp.each = function each(callback) {
            var s = this.stack;
            var origLen = s.length;
            var value = s[origLen - 1];
            var argc = arguments.length;
            for (var i = 1; i < argc; ++i) {
              var name = arguments[i];
              value = value[name];
              s.push(name, value);
            }
            for (var i = 0; i < value.length; ++i) {
              if (i in value) {
                s.push(i, value[i]);
                callback(this);
                s.length -= 2;
              }
            }
            s.length = origLen;
          };
          FPp.map = function map(callback) {
            var s = this.stack;
            var origLen = s.length;
            var value = s[origLen - 1];
            var argc = arguments.length;
            for (var i = 1; i < argc; ++i) {
              var name = arguments[i];
              value = value[name];
              s.push(name, value);
            }
            var result = new Array(value.length);
            for (var i = 0; i < value.length; ++i) {
              if (i in value) {
                s.push(i, value[i]);
                result[i] = callback(this, i);
                s.length -= 2;
              }
            }
            s.length = origLen;
            return result;
          };
          FPp.needsParens = function(assumeExpressionContext) {
            var parent = this.getParentNode();
            if (!parent) {
              return false;
            }
            var name = this.getName();
            var node = this.getNode();
            if (this.getValue() !== node) {
              return false;
            }
            if (!n.Expression.check(node)) {
              return false;
            }
            if (node.type === "Identifier") {
              return false;
            }
            if (parent.type === "ParenthesizedExpression") {
              return false;
            }
            switch (node.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return parent.type === "MemberExpression" && name === "object" && parent.object === node;
              case "BinaryExpression":
              case "LogicalExpression":
                switch (parent.type) {
                  case "CallExpression":
                    return name === "callee" && parent.callee === node;
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                    return true;
                  case "MemberExpression":
                    return name === "object" && parent.object === node;
                  case "BinaryExpression":
                  case "LogicalExpression":
                    var po = parent.operator;
                    var pp = PRECEDENCE[po];
                    var no = node.operator;
                    var np = PRECEDENCE[no];
                    if (pp > np) {
                      return true;
                    }
                    if (pp === np && name === "right") {
                      assert.strictEqual(parent.right, node);
                      return true;
                    }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (parent.type) {
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return name !== "expression";
                  default:
                    return true;
                }
              case "YieldExpression":
                switch (parent.type) {
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "CallExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ConditionalExpression":
                  case "YieldExpression":
                    return true;
                  default:
                    return false;
                }
              case "Literal":
                return parent.type === "MemberExpression" && isNumber.check(node.value) && name === "object" && parent.object === node;
              case "AssignmentExpression":
              case "ConditionalExpression":
                switch (parent.type) {
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                    return true;
                  case "CallExpression":
                    return name === "callee" && parent.callee === node;
                  case "ConditionalExpression":
                    return name === "test" && parent.test === node;
                  case "MemberExpression":
                    return name === "object" && parent.object === node;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                return isBinary(parent);
              case "ObjectExpression":
                if (parent.type === "ArrowFunctionExpression" && name === "body") {
                  return true;
                }
              default:
                if (parent.type === "NewExpression" && name === "callee" && parent.callee === node) {
                  return containsCallExpression(node);
                }
            }
            if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())
              return true;
            return false;
          };
          function isBinary(node) {
            return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
          }
          function isUnaryLike(node) {
            return n.UnaryExpression.check(node) || (n.SpreadElement && n.SpreadElement.check(node)) || (n.SpreadProperty && n.SpreadProperty.check(node));
          }
          var PRECEDENCE = {};
          [["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"]].forEach(function(tier, i) {
            tier.forEach(function(op) {
              PRECEDENCE[op] = i;
            });
          });
          function containsCallExpression(node) {
            if (n.CallExpression.check(node)) {
              return true;
            }
            if (isArray.check(node)) {
              return node.some(containsCallExpression);
            }
            if (n.Node.check(node)) {
              return types.someField(node, function(name, child) {
                return containsCallExpression(child);
              });
            }
            return false;
          }
          FPp.canBeFirstInStatement = function() {
            var node = this.getNode();
            return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);
          };
          FPp.firstInStatement = function() {
            var s = this.stack;
            var parentName,
                parent;
            var childName,
                child;
            for (var i = s.length - 1; i >= 0; i -= 2) {
              if (n.Node.check(s[i])) {
                childName = parentName;
                child = parent;
                parentName = s[i - 1];
                parent = s[i];
              }
              if (!parent || !child) {
                continue;
              }
              if (n.BlockStatement.check(parent) && parentName === "body" && childName === 0) {
                assert.strictEqual(parent.body[0], child);
                return true;
              }
              if (n.ExpressionStatement.check(parent) && childName === "expression") {
                assert.strictEqual(parent.expression, child);
                return true;
              }
              if (n.SequenceExpression.check(parent) && parentName === "expressions" && childName === 0) {
                assert.strictEqual(parent.expressions[0], child);
                continue;
              }
              if (n.CallExpression.check(parent) && childName === "callee") {
                assert.strictEqual(parent.callee, child);
                continue;
              }
              if (n.MemberExpression.check(parent) && childName === "object") {
                assert.strictEqual(parent.object, child);
                continue;
              }
              if (n.ConditionalExpression.check(parent) && childName === "test") {
                assert.strictEqual(parent.test, child);
                continue;
              }
              if (isBinary(parent) && childName === "left") {
                assert.strictEqual(parent.left, child);
                continue;
              }
              if (n.UnaryExpression.check(parent) && !parent.prefix && childName === "argument") {
                assert.strictEqual(parent.argument, child);
                continue;
              }
              return false;
            }
            return true;
          };
        }, {
          "./types": 575,
          "assert": 2
        }],
        569: [function(require, module, exports) {
          var assert = require("assert");
          var sourceMap = require("source-map");
          var normalizeOptions = require("./options").normalize;
          var secretKey = require("private").makeUniqueKey();
          var types = require("./types");
          var isString = types.builtInTypes.string;
          var comparePos = require("./util").comparePos;
          var Mapping = require("./mapping");
          function getSecret(lines) {
            return lines[secretKey];
          }
          function Lines(infos, sourceFileName) {
            assert.ok(this instanceof Lines);
            assert.ok(infos.length > 0);
            if (sourceFileName) {
              isString.assert(sourceFileName);
            } else {
              sourceFileName = null;
            }
            Object.defineProperty(this, secretKey, {value: {
                infos: infos,
                mappings: [],
                name: sourceFileName,
                cachedSourceMap: null
              }});
            if (sourceFileName) {
              getSecret(this).mappings.push(new Mapping(this, {
                start: this.firstPos(),
                end: this.lastPos()
              }));
            }
          }
          exports.Lines = Lines;
          var Lp = Lines.prototype;
          Object.defineProperties(Lp, {
            length: {get: function() {
                return getSecret(this).infos.length;
              }},
            name: {get: function() {
                return getSecret(this).name;
              }}
          });
          function copyLineInfo(info) {
            return {
              line: info.line,
              indent: info.indent,
              sliceStart: info.sliceStart,
              sliceEnd: info.sliceEnd
            };
          }
          var fromStringCache = {};
          var hasOwn = fromStringCache.hasOwnProperty;
          var maxCacheKeyLen = 10;
          function countSpaces(spaces, tabWidth) {
            var count = 0;
            var len = spaces.length;
            for (var i = 0; i < len; ++i) {
              switch (spaces.charCodeAt(i)) {
                case 9:
                  assert.strictEqual(typeof tabWidth, "number");
                  assert.ok(tabWidth > 0);
                  var next = Math.ceil(count / tabWidth) * tabWidth;
                  if (next === count) {
                    count += tabWidth;
                  } else {
                    count = next;
                  }
                  break;
                case 11:
                case 12:
                case 13:
                case 0xfeff:
                  break;
                case 32:
                default:
                  count += 1;
                  break;
              }
            }
            return count;
          }
          exports.countSpaces = countSpaces;
          var leadingSpaceExp = /^\s*/;
          function fromString(string, options) {
            if (string instanceof Lines)
              return string;
            string += "";
            var tabWidth = options && options.tabWidth;
            var tabless = string.indexOf("\t") < 0;
            var cacheable = !options && tabless && (string.length <= maxCacheKeyLen);
            assert.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string);
            if (cacheable && hasOwn.call(fromStringCache, string))
              return fromStringCache[string];
            var lines = new Lines(string.split("\n").map(function(line) {
              var spaces = leadingSpaceExp.exec(line)[0];
              return {
                line: line,
                indent: countSpaces(spaces, tabWidth),
                sliceStart: spaces.length,
                sliceEnd: line.length
              };
            }), normalizeOptions(options).sourceFileName);
            if (cacheable)
              fromStringCache[string] = lines;
            return lines;
          }
          exports.fromString = fromString;
          function isOnlyWhitespace(string) {
            return !/\S/.test(string);
          }
          Lp.toString = function(options) {
            return this.sliceString(this.firstPos(), this.lastPos(), options);
          };
          Lp.getSourceMap = function(sourceMapName, sourceRoot) {
            if (!sourceMapName) {
              return null;
            }
            var targetLines = this;
            function updateJSON(json) {
              json = json || {};
              isString.assert(sourceMapName);
              json.file = sourceMapName;
              if (sourceRoot) {
                isString.assert(sourceRoot);
                json.sourceRoot = sourceRoot;
              }
              return json;
            }
            var secret = getSecret(targetLines);
            if (secret.cachedSourceMap) {
              return updateJSON(secret.cachedSourceMap.toJSON());
            }
            var smg = new sourceMap.SourceMapGenerator(updateJSON());
            var sourcesToContents = {};
            secret.mappings.forEach(function(mapping) {
              var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) || mapping.sourceLines.lastPos();
              var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) || targetLines.lastPos();
              while (comparePos(sourceCursor, mapping.sourceLoc.end) < 0 && comparePos(targetCursor, mapping.targetLoc.end) < 0) {
                var sourceChar = mapping.sourceLines.charAt(sourceCursor);
                var targetChar = targetLines.charAt(targetCursor);
                assert.strictEqual(sourceChar, targetChar);
                var sourceName = mapping.sourceLines.name;
                smg.addMapping({
                  source: sourceName,
                  original: {
                    line: sourceCursor.line,
                    column: sourceCursor.column
                  },
                  generated: {
                    line: targetCursor.line,
                    column: targetCursor.column
                  }
                });
                if (!hasOwn.call(sourcesToContents, sourceName)) {
                  var sourceContent = mapping.sourceLines.toString();
                  smg.setSourceContent(sourceName, sourceContent);
                  sourcesToContents[sourceName] = sourceContent;
                }
                targetLines.nextPos(targetCursor, true);
                mapping.sourceLines.nextPos(sourceCursor, true);
              }
            });
            secret.cachedSourceMap = smg;
            return smg.toJSON();
          };
          Lp.bootstrapCharAt = function(pos) {
            assert.strictEqual(typeof pos, "object");
            assert.strictEqual(typeof pos.line, "number");
            assert.strictEqual(typeof pos.column, "number");
            var line = pos.line,
                column = pos.column,
                strings = this.toString().split("\n"),
                string = strings[line - 1];
            if (typeof string === "undefined")
              return "";
            if (column === string.length && line < strings.length)
              return "\n";
            if (column >= string.length)
              return "";
            return string.charAt(column);
          };
          Lp.charAt = function(pos) {
            assert.strictEqual(typeof pos, "object");
            assert.strictEqual(typeof pos.line, "number");
            assert.strictEqual(typeof pos.column, "number");
            var line = pos.line,
                column = pos.column,
                secret = getSecret(this),
                infos = secret.infos,
                info = infos[line - 1],
                c = column;
            if (typeof info === "undefined" || c < 0)
              return "";
            var indent = this.getIndentAt(line);
            if (c < indent)
              return " ";
            c += info.sliceStart - indent;
            if (c === info.sliceEnd && line < this.length)
              return "\n";
            if (c >= info.sliceEnd)
              return "";
            return info.line.charAt(c);
          };
          Lp.stripMargin = function(width, skipFirstLine) {
            if (width === 0)
              return this;
            assert.ok(width > 0, "negative margin: " + width);
            if (skipFirstLine && this.length === 1)
              return this;
            var secret = getSecret(this);
            var lines = new Lines(secret.infos.map(function(info, i) {
              if (info.line && (i > 0 || !skipFirstLine)) {
                info = copyLineInfo(info);
                info.indent = Math.max(0, info.indent - width);
              }
              return info;
            }));
            if (secret.mappings.length > 0) {
              var newMappings = getSecret(lines).mappings;
              assert.strictEqual(newMappings.length, 0);
              secret.mappings.forEach(function(mapping) {
                newMappings.push(mapping.indent(width, skipFirstLine, true));
              });
            }
            return lines;
          };
          Lp.indent = function(by) {
            if (by === 0)
              return this;
            var secret = getSecret(this);
            var lines = new Lines(secret.infos.map(function(info) {
              if (info.line) {
                info = copyLineInfo(info);
                info.indent += by;
              }
              return info;
            }));
            if (secret.mappings.length > 0) {
              var newMappings = getSecret(lines).mappings;
              assert.strictEqual(newMappings.length, 0);
              secret.mappings.forEach(function(mapping) {
                newMappings.push(mapping.indent(by));
              });
            }
            return lines;
          };
          Lp.indentTail = function(by) {
            if (by === 0)
              return this;
            if (this.length < 2)
              return this;
            var secret = getSecret(this);
            var lines = new Lines(secret.infos.map(function(info, i) {
              if (i > 0 && info.line) {
                info = copyLineInfo(info);
                info.indent += by;
              }
              return info;
            }));
            if (secret.mappings.length > 0) {
              var newMappings = getSecret(lines).mappings;
              assert.strictEqual(newMappings.length, 0);
              secret.mappings.forEach(function(mapping) {
                newMappings.push(mapping.indent(by, true));
              });
            }
            return lines;
          };
          Lp.getIndentAt = function(line) {
            assert.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
            var secret = getSecret(this),
                info = secret.infos[line - 1];
            return Math.max(info.indent, 0);
          };
          Lp.guessTabWidth = function() {
            var secret = getSecret(this);
            if (hasOwn.call(secret, "cachedTabWidth")) {
              return secret.cachedTabWidth;
            }
            var counts = [];
            var lastIndent = 0;
            for (var line = 1,
                last = this.length; line <= last; ++line) {
              var info = secret.infos[line - 1];
              var sliced = info.line.slice(info.sliceStart, info.sliceEnd);
              if (isOnlyWhitespace(sliced)) {
                continue;
              }
              var diff = Math.abs(info.indent - lastIndent);
              counts[diff] = ~~counts[diff] + 1;
              lastIndent = info.indent;
            }
            var maxCount = -1;
            var result = 2;
            for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {
              if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
                maxCount = counts[tabWidth];
                result = tabWidth;
              }
            }
            return secret.cachedTabWidth = result;
          };
          Lp.isOnlyWhitespace = function() {
            return isOnlyWhitespace(this.toString());
          };
          Lp.isPrecededOnlyByWhitespace = function(pos) {
            var secret = getSecret(this);
            var info = secret.infos[pos.line - 1];
            var indent = Math.max(info.indent, 0);
            var diff = pos.column - indent;
            if (diff <= 0) {
              return true;
            }
            var start = info.sliceStart;
            var end = Math.min(start + diff, info.sliceEnd);
            var prefix = info.line.slice(start, end);
            return isOnlyWhitespace(prefix);
          };
          Lp.getLineLength = function(line) {
            var secret = getSecret(this),
                info = secret.infos[line - 1];
            return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
          };
          Lp.nextPos = function(pos, skipSpaces) {
            var l = Math.max(pos.line, 0),
                c = Math.max(pos.column, 0);
            if (c < this.getLineLength(l)) {
              pos.column += 1;
              return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
            }
            if (l < this.length) {
              pos.line += 1;
              pos.column = 0;
              return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
            }
            return false;
          };
          Lp.prevPos = function(pos, skipSpaces) {
            var l = pos.line,
                c = pos.column;
            if (c < 1) {
              l -= 1;
              if (l < 1)
                return false;
              c = this.getLineLength(l);
            } else {
              c = Math.min(c - 1, this.getLineLength(l));
            }
            pos.line = l;
            pos.column = c;
            return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
          };
          Lp.firstPos = function() {
            return {
              line: 1,
              column: 0
            };
          };
          Lp.lastPos = function() {
            return {
              line: this.length,
              column: this.getLineLength(this.length)
            };
          };
          Lp.skipSpaces = function(pos, backward, modifyInPlace) {
            if (pos) {
              pos = modifyInPlace ? pos : {
                line: pos.line,
                column: pos.column
              };
            } else if (backward) {
              pos = this.lastPos();
            } else {
              pos = this.firstPos();
            }
            if (backward) {
              while (this.prevPos(pos)) {
                if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {
                  return pos;
                }
              }
              return null;
            } else {
              while (isOnlyWhitespace(this.charAt(pos))) {
                if (!this.nextPos(pos)) {
                  return null;
                }
              }
              return pos;
            }
          };
          Lp.trimLeft = function() {
            var pos = this.skipSpaces(this.firstPos(), false, true);
            return pos ? this.slice(pos) : emptyLines;
          };
          Lp.trimRight = function() {
            var pos = this.skipSpaces(this.lastPos(), true, true);
            return pos ? this.slice(this.firstPos(), pos) : emptyLines;
          };
          Lp.trim = function() {
            var start = this.skipSpaces(this.firstPos(), false, true);
            if (start === null)
              return emptyLines;
            var end = this.skipSpaces(this.lastPos(), true, true);
            assert.notStrictEqual(end, null);
            return this.slice(start, end);
          };
          Lp.eachPos = function(callback, startPos, skipSpaces) {
            var pos = this.firstPos();
            if (startPos) {
              pos.line = startPos.line, pos.column = startPos.column;
            }
            if (skipSpaces && !this.skipSpaces(pos, false, true)) {
              return;
            }
            do
              callback.call(this, pos);
 while (this.nextPos(pos, skipSpaces));
          };
          Lp.bootstrapSlice = function(start, end) {
            var strings = this.toString().split("\n").slice(start.line - 1, end.line);
            strings.push(strings.pop().slice(0, end.column));
            strings[0] = strings[0].slice(start.column);
            return fromString(strings.join("\n"));
          };
          Lp.slice = function(start, end) {
            if (!end) {
              if (!start) {
                return this;
              }
              end = this.lastPos();
            }
            var secret = getSecret(this);
            var sliced = secret.infos.slice(start.line - 1, end.line);
            if (start.line === end.line) {
              sliced[0] = sliceInfo(sliced[0], start.column, end.column);
            } else {
              assert.ok(start.line < end.line);
              sliced[0] = sliceInfo(sliced[0], start.column);
              sliced.push(sliceInfo(sliced.pop(), 0, end.column));
            }
            var lines = new Lines(sliced);
            if (secret.mappings.length > 0) {
              var newMappings = getSecret(lines).mappings;
              assert.strictEqual(newMappings.length, 0);
              secret.mappings.forEach(function(mapping) {
                var sliced = mapping.slice(this, start, end);
                if (sliced) {
                  newMappings.push(sliced);
                }
              }, this);
            }
            return lines;
          };
          function sliceInfo(info, startCol, endCol) {
            var sliceStart = info.sliceStart;
            var sliceEnd = info.sliceEnd;
            var indent = Math.max(info.indent, 0);
            var lineLength = indent + sliceEnd - sliceStart;
            if (typeof endCol === "undefined") {
              endCol = lineLength;
            }
            startCol = Math.max(startCol, 0);
            endCol = Math.min(endCol, lineLength);
            endCol = Math.max(endCol, startCol);
            if (endCol < indent) {
              indent = endCol;
              sliceEnd = sliceStart;
            } else {
              sliceEnd -= lineLength - endCol;
            }
            lineLength = endCol;
            lineLength -= startCol;
            if (startCol < indent) {
              indent -= startCol;
            } else {
              startCol -= indent;
              indent = 0;
              sliceStart += startCol;
            }
            assert.ok(indent >= 0);
            assert.ok(sliceStart <= sliceEnd);
            assert.strictEqual(lineLength, indent + sliceEnd - sliceStart);
            if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {
              return info;
            }
            return {
              line: info.line,
              indent: indent,
              sliceStart: sliceStart,
              sliceEnd: sliceEnd
            };
          }
          Lp.bootstrapSliceString = function(start, end, options) {
            return this.slice(start, end).toString(options);
          };
          Lp.sliceString = function(start, end, options) {
            if (!end) {
              if (!start) {
                return this;
              }
              end = this.lastPos();
            }
            options = normalizeOptions(options);
            var infos = getSecret(this).infos;
            var parts = [];
            var tabWidth = options.tabWidth;
            for (var line = start.line; line <= end.line; ++line) {
              var info = infos[line - 1];
              if (line === start.line) {
                if (line === end.line) {
                  info = sliceInfo(info, start.column, end.column);
                } else {
                  info = sliceInfo(info, start.column);
                }
              } else if (line === end.line) {
                info = sliceInfo(info, 0, end.column);
              }
              var indent = Math.max(info.indent, 0);
              var before = info.line.slice(0, info.sliceStart);
              if (options.reuseWhitespace && isOnlyWhitespace(before) && countSpaces(before, options.tabWidth) === indent) {
                parts.push(info.line.slice(0, info.sliceEnd));
                continue;
              }
              var tabs = 0;
              var spaces = indent;
              if (options.useTabs) {
                tabs = Math.floor(indent / tabWidth);
                spaces -= tabs * tabWidth;
              }
              var result = "";
              if (tabs > 0) {
                result += new Array(tabs + 1).join("\t");
              }
              if (spaces > 0) {
                result += new Array(spaces + 1).join(" ");
              }
              result += info.line.slice(info.sliceStart, info.sliceEnd);
              parts.push(result);
            }
            return parts.join("\n");
          };
          Lp.isEmpty = function() {
            return this.length < 2 && this.getLineLength(1) < 1;
          };
          Lp.join = function(elements) {
            var separator = this;
            var separatorSecret = getSecret(separator);
            var infos = [];
            var mappings = [];
            var prevInfo;
            function appendSecret(secret) {
              if (secret === null)
                return;
              if (prevInfo) {
                var info = secret.infos[0];
                var indent = new Array(info.indent + 1).join(" ");
                var prevLine = infos.length;
                var prevColumn = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
                prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd);
                prevInfo.sliceEnd = prevInfo.line.length;
                if (secret.mappings.length > 0) {
                  secret.mappings.forEach(function(mapping) {
                    mappings.push(mapping.add(prevLine, prevColumn));
                  });
                }
              } else if (secret.mappings.length > 0) {
                mappings.push.apply(mappings, secret.mappings);
              }
              secret.infos.forEach(function(info, i) {
                if (!prevInfo || i > 0) {
                  prevInfo = copyLineInfo(info);
                  infos.push(prevInfo);
                }
              });
            }
            function appendWithSeparator(secret, i) {
              if (i > 0)
                appendSecret(separatorSecret);
              appendSecret(secret);
            }
            elements.map(function(elem) {
              var lines = fromString(elem);
              if (lines.isEmpty())
                return null;
              return getSecret(lines);
            }).forEach(separator.isEmpty() ? appendSecret : appendWithSeparator);
            if (infos.length < 1)
              return emptyLines;
            var lines = new Lines(infos);
            getSecret(lines).mappings = mappings;
            return lines;
          };
          exports.concat = function(elements) {
            return emptyLines.join(elements);
          };
          Lp.concat = function(other) {
            var args = arguments,
                list = [this];
            list.push.apply(list, args);
            assert.strictEqual(list.length, args.length + 1);
            return emptyLines.join(list);
          };
          var emptyLines = fromString("");
        }, {
          "./mapping": 570,
          "./options": 571,
          "./types": 575,
          "./util": 576,
          "assert": 2,
          "private": 545,
          "source-map": 607
        }],
        570: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("./types");
          var isString = types.builtInTypes.string;
          var isNumber = types.builtInTypes.number;
          var SourceLocation = types.namedTypes.SourceLocation;
          var Position = types.namedTypes.Position;
          var linesModule = require("./lines");
          var comparePos = require("./util").comparePos;
          function Mapping(sourceLines, sourceLoc, targetLoc) {
            assert.ok(this instanceof Mapping);
            assert.ok(sourceLines instanceof linesModule.Lines);
            SourceLocation.assert(sourceLoc);
            if (targetLoc) {
              assert.ok(isNumber.check(targetLoc.start.line) && isNumber.check(targetLoc.start.column) && isNumber.check(targetLoc.end.line) && isNumber.check(targetLoc.end.column));
            } else {
              targetLoc = sourceLoc;
            }
            Object.defineProperties(this, {
              sourceLines: {value: sourceLines},
              sourceLoc: {value: sourceLoc},
              targetLoc: {value: targetLoc}
            });
          }
          var Mp = Mapping.prototype;
          module.exports = Mapping;
          Mp.slice = function(lines, start, end) {
            assert.ok(lines instanceof linesModule.Lines);
            Position.assert(start);
            if (end) {
              Position.assert(end);
            } else {
              end = lines.lastPos();
            }
            var sourceLines = this.sourceLines;
            var sourceLoc = this.sourceLoc;
            var targetLoc = this.targetLoc;
            function skip(name) {
              var sourceFromPos = sourceLoc[name];
              var targetFromPos = targetLoc[name];
              var targetToPos = start;
              if (name === "end") {
                targetToPos = end;
              } else {
                assert.strictEqual(name, "start");
              }
              return skipChars(sourceLines, sourceFromPos, lines, targetFromPos, targetToPos);
            }
            if (comparePos(start, targetLoc.start) <= 0) {
              if (comparePos(targetLoc.end, end) <= 0) {
                targetLoc = {
                  start: subtractPos(targetLoc.start, start.line, start.column),
                  end: subtractPos(targetLoc.end, start.line, start.column)
                };
              } else if (comparePos(end, targetLoc.start) <= 0) {
                return null;
              } else {
                sourceLoc = {
                  start: sourceLoc.start,
                  end: skip("end")
                };
                targetLoc = {
                  start: subtractPos(targetLoc.start, start.line, start.column),
                  end: subtractPos(end, start.line, start.column)
                };
              }
            } else {
              if (comparePos(targetLoc.end, start) <= 0) {
                return null;
              }
              if (comparePos(targetLoc.end, end) <= 0) {
                sourceLoc = {
                  start: skip("start"),
                  end: sourceLoc.end
                };
                targetLoc = {
                  start: {
                    line: 1,
                    column: 0
                  },
                  end: subtractPos(targetLoc.end, start.line, start.column)
                };
              } else {
                sourceLoc = {
                  start: skip("start"),
                  end: skip("end")
                };
                targetLoc = {
                  start: {
                    line: 1,
                    column: 0
                  },
                  end: subtractPos(end, start.line, start.column)
                };
              }
            }
            return new Mapping(this.sourceLines, sourceLoc, targetLoc);
          };
          Mp.add = function(line, column) {
            return new Mapping(this.sourceLines, this.sourceLoc, {
              start: addPos(this.targetLoc.start, line, column),
              end: addPos(this.targetLoc.end, line, column)
            });
          };
          function addPos(toPos, line, column) {
            return {
              line: toPos.line + line - 1,
              column: (toPos.line === 1) ? toPos.column + column : toPos.column
            };
          }
          Mp.subtract = function(line, column) {
            return new Mapping(this.sourceLines, this.sourceLoc, {
              start: subtractPos(this.targetLoc.start, line, column),
              end: subtractPos(this.targetLoc.end, line, column)
            });
          };
          function subtractPos(fromPos, line, column) {
            return {
              line: fromPos.line - line + 1,
              column: (fromPos.line === line) ? fromPos.column - column : fromPos.column
            };
          }
          Mp.indent = function(by, skipFirstLine, noNegativeColumns) {
            if (by === 0) {
              return this;
            }
            var targetLoc = this.targetLoc;
            var startLine = targetLoc.start.line;
            var endLine = targetLoc.end.line;
            if (skipFirstLine && startLine === 1 && endLine === 1) {
              return this;
            }
            targetLoc = {
              start: targetLoc.start,
              end: targetLoc.end
            };
            if (!skipFirstLine || startLine > 1) {
              var startColumn = targetLoc.start.column + by;
              targetLoc.start = {
                line: startLine,
                column: noNegativeColumns ? Math.max(0, startColumn) : startColumn
              };
            }
            if (!skipFirstLine || endLine > 1) {
              var endColumn = targetLoc.end.column + by;
              targetLoc.end = {
                line: endLine,
                column: noNegativeColumns ? Math.max(0, endColumn) : endColumn
              };
            }
            return new Mapping(this.sourceLines, this.sourceLoc, targetLoc);
          };
          function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
            assert.ok(sourceLines instanceof linesModule.Lines);
            assert.ok(targetLines instanceof linesModule.Lines);
            Position.assert(sourceFromPos);
            Position.assert(targetFromPos);
            Position.assert(targetToPos);
            var targetComparison = comparePos(targetFromPos, targetToPos);
            if (targetComparison === 0) {
              return sourceFromPos;
            }
            if (targetComparison < 0) {
              var sourceCursor = sourceLines.skipSpaces(sourceFromPos);
              var targetCursor = targetLines.skipSpaces(targetFromPos);
              var lineDiff = targetToPos.line - targetCursor.line;
              sourceCursor.line += lineDiff;
              targetCursor.line += lineDiff;
              if (lineDiff > 0) {
                sourceCursor.column = 0;
                targetCursor.column = 0;
              } else {
                assert.strictEqual(lineDiff, 0);
              }
              while (comparePos(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, true)) {
                assert.ok(sourceLines.nextPos(sourceCursor, true));
                assert.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
              }
            } else {
              var sourceCursor = sourceLines.skipSpaces(sourceFromPos, true);
              var targetCursor = targetLines.skipSpaces(targetFromPos, true);
              var lineDiff = targetToPos.line - targetCursor.line;
              sourceCursor.line += lineDiff;
              targetCursor.line += lineDiff;
              if (lineDiff < 0) {
                sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
                targetCursor.column = targetLines.getLineLength(targetCursor.line);
              } else {
                assert.strictEqual(lineDiff, 0);
              }
              while (comparePos(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, true)) {
                assert.ok(sourceLines.prevPos(sourceCursor, true));
                assert.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
              }
            }
            return sourceCursor;
          }
        }, {
          "./lines": 569,
          "./types": 575,
          "./util": 576,
          "assert": 2
        }],
        571: [function(require, module, exports) {
          var defaults = {
            esprima: require("esprima-fb"),
            tabWidth: 4,
            useTabs: false,
            reuseWhitespace: true,
            wrapColumn: 74,
            sourceFileName: null,
            sourceMapName: null,
            sourceRoot: null,
            inputSourceMap: null,
            range: false,
            tolerant: true,
            quote: null,
            trailingComma: false
          },
              hasOwn = defaults.hasOwnProperty;
          exports.normalize = function(options) {
            options = options || defaults;
            function get(key) {
              return hasOwn.call(options, key) ? options[key] : defaults[key];
            }
            return {
              tabWidth: +get("tabWidth"),
              useTabs: !!get("useTabs"),
              reuseWhitespace: !!get("reuseWhitespace"),
              wrapColumn: Math.max(get("wrapColumn"), 0),
              sourceFileName: get("sourceFileName"),
              sourceMapName: get("sourceMapName"),
              sourceRoot: get("sourceRoot"),
              inputSourceMap: get("inputSourceMap"),
              esprima: get("esprima"),
              range: get("range"),
              tolerant: get("tolerant"),
              quote: get("quote"),
              trailingComma: get("trailingComma")
            };
          };
        }, {"esprima-fb": 1}],
        572: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("./types");
          var n = types.namedTypes;
          var b = types.builders;
          var isObject = types.builtInTypes.object;
          var isArray = types.builtInTypes.array;
          var isFunction = types.builtInTypes.function;
          var Patcher = require("./patcher").Patcher;
          var normalizeOptions = require("./options").normalize;
          var fromString = require("./lines").fromString;
          var attachComments = require("./comments").attach;
          var util = require("./util");
          exports.parse = function parse(source, options) {
            options = normalizeOptions(options);
            var lines = fromString(source, options);
            var sourceWithoutTabs = lines.toString({
              tabWidth: options.tabWidth,
              reuseWhitespace: false,
              useTabs: false
            });
            var comments = [];
            var program = options.esprima.parse(sourceWithoutTabs, {
              loc: true,
              locations: true,
              range: options.range,
              comment: true,
              onComment: comments,
              tolerant: options.tolerant,
              ecmaVersion: 6,
              sourceType: 'module'
            });
            program.loc = program.loc || {
              start: lines.firstPos(),
              end: lines.lastPos()
            };
            program.loc.lines = lines;
            program.loc.indent = 0;
            var trueProgramLoc = util.getTrueLoc(program, lines);
            program.loc.start = trueProgramLoc.start;
            program.loc.end = trueProgramLoc.end;
            if (program.comments) {
              comments = program.comments;
              delete program.comments;
            }
            var file = b.file(program);
            file.loc = {
              lines: lines,
              indent: 0,
              start: lines.firstPos(),
              end: lines.lastPos()
            };
            attachComments(comments, program.body.length ? file.program : file, lines);
            return new TreeCopier(lines).copy(file);
          };
          function TreeCopier(lines) {
            assert.ok(this instanceof TreeCopier);
            this.lines = lines;
            this.indent = 0;
          }
          var TCp = TreeCopier.prototype;
          TCp.copy = function(node) {
            if (isArray.check(node)) {
              return node.map(this.copy, this);
            }
            if (!isObject.check(node)) {
              return node;
            }
            util.fixFaultyLocations(node);
            var copy = Object.create(Object.getPrototypeOf(node), {original: {
                value: node,
                configurable: false,
                enumerable: false,
                writable: true
              }});
            var loc = node.loc;
            var oldIndent = this.indent;
            var newIndent = oldIndent;
            if (loc) {
              if (node.type === "Block" || node.type === "Line" || this.lines.isPrecededOnlyByWhitespace(loc.start)) {
                newIndent = this.indent = loc.start.column;
              }
              loc.lines = this.lines;
              loc.indent = newIndent;
            }
            var keys = Object.keys(node);
            var keyCount = keys.length;
            for (var i = 0; i < keyCount; ++i) {
              var key = keys[i];
              if (key === "loc") {
                copy[key] = node[key];
              } else {
                copy[key] = this.copy(node[key]);
              }
            }
            this.indent = oldIndent;
            return copy;
          };
        }, {
          "./comments": 567,
          "./lines": 569,
          "./options": 571,
          "./patcher": 573,
          "./types": 575,
          "./util": 576,
          "assert": 2
        }],
        573: [function(require, module, exports) {
          var assert = require("assert");
          var linesModule = require("./lines");
          var types = require("./types");
          var getFieldValue = types.getFieldValue;
          var Printable = types.namedTypes.Printable;
          var Expression = types.namedTypes.Expression;
          var SourceLocation = types.namedTypes.SourceLocation;
          var util = require("./util");
          var comparePos = util.comparePos;
          var FastPath = require("./fast-path");
          var isObject = types.builtInTypes.object;
          var isArray = types.builtInTypes.array;
          var isString = types.builtInTypes.string;
          var riskyAdjoiningCharExp = /[0-9a-z_$]/i;
          function Patcher(lines) {
            assert.ok(this instanceof Patcher);
            assert.ok(lines instanceof linesModule.Lines);
            var self = this,
                replacements = [];
            self.replace = function(loc, lines) {
              if (isString.check(lines))
                lines = linesModule.fromString(lines);
              replacements.push({
                lines: lines,
                start: loc.start,
                end: loc.end
              });
            };
            self.get = function(loc) {
              loc = loc || {
                start: {
                  line: 1,
                  column: 0
                },
                end: {
                  line: lines.length,
                  column: lines.getLineLength(lines.length)
                }
              };
              var sliceFrom = loc.start,
                  toConcat = [];
              function pushSlice(from, to) {
                assert.ok(comparePos(from, to) <= 0);
                toConcat.push(lines.slice(from, to));
              }
              replacements.sort(function(a, b) {
                return comparePos(a.start, b.start);
              }).forEach(function(rep) {
                if (comparePos(sliceFrom, rep.start) > 0) {} else {
                  pushSlice(sliceFrom, rep.start);
                  toConcat.push(rep.lines);
                  sliceFrom = rep.end;
                }
              });
              pushSlice(sliceFrom, loc.end);
              return linesModule.concat(toConcat);
            };
          }
          exports.Patcher = Patcher;
          var Pp = Patcher.prototype;
          Pp.tryToReprintComments = function(newNode, oldNode, print) {
            var patcher = this;
            if (!newNode.comments && !oldNode.comments) {
              return true;
            }
            var newPath = FastPath.from(newNode);
            var oldPath = FastPath.from(oldNode);
            newPath.stack.push("comments", getSurroundingComments(newNode));
            oldPath.stack.push("comments", getSurroundingComments(oldNode));
            var reprints = [];
            var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
            if (ableToReprintComments && reprints.length > 0) {
              reprints.forEach(function(reprint) {
                var oldComment = reprint.oldPath.getValue();
                assert.ok(oldComment.leading || oldComment.trailing);
                patcher.replace(oldComment.loc, print(reprint.newPath).indentTail(oldComment.loc.indent));
              });
            }
            return ableToReprintComments;
          };
          function getSurroundingComments(node) {
            var result = [];
            if (node.comments && node.comments.length > 0) {
              node.comments.forEach(function(comment) {
                if (comment.leading || comment.trailing) {
                  result.push(comment);
                }
              });
            }
            return result;
          }
          Pp.deleteComments = function(node) {
            if (!node.comments) {
              return;
            }
            var patcher = this;
            node.comments.forEach(function(comment) {
              if (comment.leading) {
                patcher.replace({
                  start: comment.loc.start,
                  end: node.loc.lines.skipSpaces(comment.loc.end, false, false)
                }, "");
              } else if (comment.trailing) {
                patcher.replace({
                  start: node.loc.lines.skipSpaces(comment.loc.start, true, false),
                  end: comment.loc.end
                }, "");
              }
            });
          };
          exports.getReprinter = function(path) {
            assert.ok(path instanceof FastPath);
            var node = path.getValue();
            if (!Printable.check(node))
              return;
            var orig = node.original;
            var origLoc = orig && orig.loc;
            var lines = origLoc && origLoc.lines;
            var reprints = [];
            if (!lines || !findReprints(path, reprints))
              return;
            return function(print) {
              var patcher = new Patcher(lines);
              reprints.forEach(function(reprint) {
                var newNode = reprint.newPath.getValue();
                var oldNode = reprint.oldPath.getValue();
                SourceLocation.assert(oldNode.loc, true);
                var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);
                if (needToPrintNewPathWithComments) {
                  patcher.deleteComments(oldNode);
                }
                var pos = util.copyPos(oldNode.loc.start);
                var needsLeadingSpace = lines.prevPos(pos) && riskyAdjoiningCharExp.test(lines.charAt(pos));
                var newLines = print(reprint.newPath, needToPrintNewPathWithComments).indentTail(oldNode.loc.indent);
                var needsTrailingSpace = riskyAdjoiningCharExp.test(lines.charAt(oldNode.loc.end));
                if (needsLeadingSpace || needsTrailingSpace) {
                  var newParts = [];
                  needsLeadingSpace && newParts.push(" ");
                  newParts.push(newLines);
                  needsTrailingSpace && newParts.push(" ");
                  newLines = linesModule.concat(newParts);
                }
                patcher.replace(oldNode.loc, newLines);
              });
              return patcher.get(origLoc).indentTail(-orig.loc.indent);
            };
          };
          function findReprints(newPath, reprints) {
            var newNode = newPath.getValue();
            Printable.assert(newNode);
            var oldNode = newNode.original;
            Printable.assert(oldNode);
            assert.deepEqual(reprints, []);
            if (newNode.type !== oldNode.type) {
              return false;
            }
            var oldPath = new FastPath(oldNode);
            var canReprint = findChildReprints(newPath, oldPath, reprints);
            if (!canReprint) {
              reprints.length = 0;
            }
            return canReprint;
          }
          function findAnyReprints(newPath, oldPath, reprints) {
            var newNode = newPath.getValue();
            var oldNode = oldPath.getValue();
            if (newNode === oldNode)
              return true;
            if (isArray.check(newNode))
              return findArrayReprints(newPath, oldPath, reprints);
            if (isObject.check(newNode))
              return findObjectReprints(newPath, oldPath, reprints);
            return false;
          }
          function findArrayReprints(newPath, oldPath, reprints) {
            var newNode = newPath.getValue();
            var oldNode = oldPath.getValue();
            isArray.assert(newNode);
            var len = newNode.length;
            if (!(isArray.check(oldNode) && oldNode.length === len))
              return false;
            for (var i = 0; i < len; ++i) {
              newPath.stack.push(i, newNode[i]);
              oldPath.stack.push(i, oldNode[i]);
              var canReprint = findAnyReprints(newPath, oldPath, reprints);
              newPath.stack.length -= 2;
              oldPath.stack.length -= 2;
              if (!canReprint) {
                return false;
              }
            }
            return true;
          }
          function findObjectReprints(newPath, oldPath, reprints) {
            var newNode = newPath.getValue();
            isObject.assert(newNode);
            if (newNode.original === null) {
              return false;
            }
            var oldNode = oldPath.getValue();
            if (!isObject.check(oldNode))
              return false;
            if (Printable.check(newNode)) {
              if (!Printable.check(oldNode)) {
                return false;
              }
              if (newNode.type === oldNode.type) {
                var childReprints = [];
                if (findChildReprints(newPath, oldPath, childReprints)) {
                  reprints.push.apply(reprints, childReprints);
                } else if (oldNode.loc) {
                  reprints.push({
                    oldPath: oldPath.copy(),
                    newPath: newPath.copy()
                  });
                } else {
                  return false;
                }
                return true;
              }
              if (Expression.check(newNode) && Expression.check(oldNode) && oldNode.loc) {
                reprints.push({
                  oldPath: oldPath.copy(),
                  newPath: newPath.copy()
                });
                return true;
              }
              return false;
            }
            return findChildReprints(newPath, oldPath, reprints);
          }
          var reusablePos = {
            line: 1,
            column: 0
          };
          var nonSpaceExp = /\S/;
          function hasOpeningParen(oldPath) {
            var oldNode = oldPath.getValue();
            var loc = oldNode.loc;
            var lines = loc && loc.lines;
            if (lines) {
              var pos = reusablePos;
              pos.line = loc.start.line;
              pos.column = loc.start.column;
              while (lines.prevPos(pos)) {
                var ch = lines.charAt(pos);
                if (ch === "(") {
                  return comparePos(oldPath.getRootValue().loc.start, pos) <= 0;
                }
                if (nonSpaceExp.test(ch)) {
                  return false;
                }
              }
            }
            return false;
          }
          function hasClosingParen(oldPath) {
            var oldNode = oldPath.getValue();
            var loc = oldNode.loc;
            var lines = loc && loc.lines;
            if (lines) {
              var pos = reusablePos;
              pos.line = loc.end.line;
              pos.column = loc.end.column;
              do {
                var ch = lines.charAt(pos);
                if (ch === ")") {
                  return comparePos(pos, oldPath.getRootValue().loc.end) <= 0;
                }
                if (nonSpaceExp.test(ch)) {
                  return false;
                }
              } while (lines.nextPos(pos));
            }
            return false;
          }
          function hasParens(oldPath) {
            return hasOpeningParen(oldPath) && hasClosingParen(oldPath);
          }
          function findChildReprints(newPath, oldPath, reprints) {
            var newNode = newPath.getValue();
            var oldNode = oldPath.getValue();
            isObject.assert(newNode);
            isObject.assert(oldNode);
            if (newNode.original === null) {
              return false;
            }
            if (!newPath.canBeFirstInStatement() && newPath.firstInStatement() && !hasOpeningParen(oldPath))
              return false;
            if (newPath.needsParens(true) && !hasParens(oldPath)) {
              return false;
            }
            for (var k in util.getUnionOfKeys(newNode, oldNode)) {
              if (k === "loc")
                continue;
              newPath.stack.push(k, types.getFieldValue(newNode, k));
              oldPath.stack.push(k, types.getFieldValue(oldNode, k));
              var canReprint = findAnyReprints(newPath, oldPath, reprints);
              newPath.stack.length -= 2;
              oldPath.stack.length -= 2;
              if (!canReprint) {
                return false;
              }
            }
            return true;
          }
        }, {
          "./fast-path": 568,
          "./lines": 569,
          "./types": 575,
          "./util": 576,
          "assert": 2
        }],
        574: [function(require, module, exports) {
          var assert = require("assert");
          var sourceMap = require("source-map");
          var printComments = require("./comments").printComments;
          var linesModule = require("./lines");
          var fromString = linesModule.fromString;
          var concat = linesModule.concat;
          var normalizeOptions = require("./options").normalize;
          var getReprinter = require("./patcher").getReprinter;
          var types = require("./types");
          var namedTypes = types.namedTypes;
          var isString = types.builtInTypes.string;
          var isObject = types.builtInTypes.object;
          var FastPath = require("./fast-path");
          var util = require("./util");
          function PrintResult(code, sourceMap) {
            assert.ok(this instanceof PrintResult);
            isString.assert(code);
            this.code = code;
            if (sourceMap) {
              isObject.assert(sourceMap);
              this.map = sourceMap;
            }
          }
          var PRp = PrintResult.prototype;
          var warnedAboutToString = false;
          PRp.toString = function() {
            if (!warnedAboutToString) {
              console.warn("Deprecation warning: recast.print now returns an object with " + "a .code property. You appear to be treating the object as a " + "string, which might still work but is strongly discouraged.");
              warnedAboutToString = true;
            }
            return this.code;
          };
          var emptyPrintResult = new PrintResult("");
          function Printer(originalOptions) {
            assert.ok(this instanceof Printer);
            var explicitTabWidth = originalOptions && originalOptions.tabWidth;
            var options = normalizeOptions(originalOptions);
            assert.notStrictEqual(options, originalOptions);
            options.sourceFileName = null;
            function printWithComments(path) {
              assert.ok(path instanceof FastPath);
              return printComments(path, print);
            }
            function print(path, includeComments) {
              if (includeComments)
                return printWithComments(path);
              assert.ok(path instanceof FastPath);
              if (!explicitTabWidth) {
                var oldTabWidth = options.tabWidth;
                var loc = path.getNode().loc;
                if (loc && loc.lines && loc.lines.guessTabWidth) {
                  options.tabWidth = loc.lines.guessTabWidth();
                  var lines = maybeReprint(path);
                  options.tabWidth = oldTabWidth;
                  return lines;
                }
              }
              return maybeReprint(path);
            }
            function maybeReprint(path) {
              var reprinter = getReprinter(path);
              if (reprinter)
                return maybeAddParens(path, reprinter(print));
              return printRootGenerically(path);
            }
            function printRootGenerically(path) {
              return genericPrint(path, options, printWithComments);
            }
            function printGenerically(path) {
              return genericPrint(path, options, printGenerically);
            }
            this.print = function(ast) {
              if (!ast) {
                return emptyPrintResult;
              }
              var lines = print(FastPath.from(ast), true);
              return new PrintResult(lines.toString(options), util.composeSourceMaps(options.inputSourceMap, lines.getSourceMap(options.sourceMapName, options.sourceRoot)));
            };
            this.printGenerically = function(ast) {
              if (!ast) {
                return emptyPrintResult;
              }
              var path = FastPath.from(ast);
              var oldReuseWhitespace = options.reuseWhitespace;
              options.reuseWhitespace = false;
              var pr = new PrintResult(printGenerically(path).toString(options));
              options.reuseWhitespace = oldReuseWhitespace;
              return pr;
            };
          }
          exports.Printer = Printer;
          function maybeAddParens(path, lines) {
            return path.needsParens() ? concat(["(", lines, ")"]) : lines;
          }
          function genericPrint(path, options, printPath) {
            assert.ok(path instanceof FastPath);
            return maybeAddParens(path, genericPrintNoParens(path, options, printPath));
          }
          function genericPrintNoParens(path, options, print) {
            var n = path.getValue();
            if (!n) {
              return fromString("");
            }
            if (typeof n === "string") {
              return fromString(n, options);
            }
            namedTypes.Printable.assert(n);
            switch (n.type) {
              case "File":
                return path.call(print, "program");
              case "Program":
                return path.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options, print);
                }, "body");
              case "Noop":
              case "EmptyStatement":
                return fromString("");
              case "ExpressionStatement":
                return concat([path.call(print, "expression"), ";"]);
              case "ParenthesizedExpression":
                return concat(["(", path.call(print, "expression"), ")"]);
              case "BinaryExpression":
              case "LogicalExpression":
              case "AssignmentExpression":
                return fromString(" ").join([path.call(print, "left"), n.operator, path.call(print, "right")]);
              case "AssignmentPattern":
                return concat([path.call(print, "left"), "=", path.call(print, "right")]);
              case "MemberExpression":
                var parts = [path.call(print, "object")];
                var property = path.call(print, "property");
                if (n.computed) {
                  parts.push("[", property, "]");
                } else {
                  parts.push(".", property);
                }
                return concat(parts);
              case "MetaProperty":
                return concat([path.call(print, "meta"), ".", path.call(print, "property")]);
              case "BindExpression":
                var parts = [];
                if (n.object) {
                  parts.push(path.call(print, "object"));
                }
                parts.push("::", path.call(print, "callee"));
                return concat(parts);
              case "Path":
                return fromString(".").join(n.body);
              case "Identifier":
                return concat([fromString(n.name, options), path.call(print, "typeAnnotation")]);
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return concat(["...", path.call(print, "argument")]);
              case "FunctionDeclaration":
              case "FunctionExpression":
                var parts = [];
                if (n.async)
                  parts.push("async ");
                parts.push("function");
                if (n.generator)
                  parts.push("*");
                if (n.id) {
                  parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
                }
                parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "returnType"), " ", path.call(print, "body"));
                return concat(parts);
              case "ArrowFunctionExpression":
                var parts = [];
                if (n.async)
                  parts.push("async ");
                if (n.params.length === 1 && !n.rest && n.params[0].type !== 'SpreadElementPattern' && n.params[0].type !== 'RestElement') {
                  parts.push(path.call(print, "params", 0));
                } else {
                  parts.push("(", printFunctionParams(path, options, print), ")");
                }
                parts.push(" => ", path.call(print, "body"));
                return concat(parts);
              case "MethodDefinition":
                var parts = [];
                if (n.static) {
                  parts.push("static ");
                }
                parts.push(printMethod(path, options, print));
                return concat(parts);
              case "YieldExpression":
                var parts = ["yield"];
                if (n.delegate)
                  parts.push("*");
                if (n.argument)
                  parts.push(" ", path.call(print, "argument"));
                return concat(parts);
              case "AwaitExpression":
                var parts = ["await"];
                if (n.all)
                  parts.push("*");
                if (n.argument)
                  parts.push(" ", path.call(print, "argument"));
                return concat(parts);
              case "ModuleDeclaration":
                var parts = ["module", path.call(print, "id")];
                if (n.source) {
                  assert.ok(!n.body);
                  parts.push("from", path.call(print, "source"));
                } else {
                  parts.push(path.call(print, "body"));
                }
                return fromString(" ").join(parts);
              case "ImportSpecifier":
                var parts = [];
                if (n.imported) {
                  parts.push(path.call(print, "imported"));
                  if (n.local && n.local.name !== n.imported.name) {
                    parts.push(" as ", path.call(print, "local"));
                  }
                } else if (n.id) {
                  parts.push(path.call(print, "id"));
                  if (n.name) {
                    parts.push(" as ", path.call(print, "name"));
                  }
                }
                return concat(parts);
              case "ExportSpecifier":
                var parts = [];
                if (n.local) {
                  parts.push(path.call(print, "local"));
                  if (n.exported && n.exported.name !== n.local.name) {
                    parts.push(" as ", path.call(print, "exported"));
                  }
                } else if (n.id) {
                  parts.push(path.call(print, "id"));
                  if (n.name) {
                    parts.push(" as ", path.call(print, "name"));
                  }
                }
                return concat(parts);
              case "ExportBatchSpecifier":
                return fromString("*");
              case "ImportNamespaceSpecifier":
                return concat(["* as ", path.call(print, "id")]);
              case "ImportDefaultSpecifier":
                return path.call(print, "id");
              case "ExportDeclaration":
                var parts = ["export"];
                if (n["default"]) {
                  parts.push(" default");
                } else if (n.specifiers && n.specifiers.length > 0) {
                  if (n.specifiers.length === 1 && n.specifiers[0].type === "ExportBatchSpecifier") {
                    parts.push(" *");
                  } else {
                    parts.push(" { ", fromString(", ").join(path.map(print, "specifiers")), " }");
                  }
                  if (n.source)
                    parts.push(" from ", path.call(print, "source"));
                  parts.push(";");
                  return concat(parts);
                }
                if (n.declaration) {
                  var decLines = path.call(print, "declaration");
                  parts.push(" ", decLines);
                  if (lastNonSpaceCharacter(decLines) !== ";") {
                    parts.push(";");
                  }
                }
                return concat(parts);
              case "ExportDefaultDeclaration":
                return concat(["export default ", path.call(print, "declaration")]);
              case "ExportNamedDeclaration":
                var parts = ["export "];
                if (n.declaration) {
                  parts.push(path.call(print, "declaration"));
                }
                if (n.specifiers && n.specifiers.length > 0) {
                  parts.push(n.declaration ? ", {" : "{", fromString(", ").join(path.map(print, "specifiers")), "}");
                }
                if (n.source) {
                  parts.push(" from ", path.call(print, "source"));
                }
                return concat(parts);
              case "ExportAllDeclaration":
                var parts = ["export *"];
                if (n.exported) {
                  parts.push(" as ", path.call(print, "exported"));
                }
                return concat([" from ", path.call(print, "source")]);
              case "ExportNamespaceSpecifier":
                return concat(["* as ", path.call(print, "exported")]);
              case "ExportDefaultSpecifier":
                return path.call(print, "exported");
              case "ImportDeclaration":
                var parts = ["import "];
                if (n.importKind && n.importKind !== "value") {
                  parts.push(n.importKind + " ");
                }
                if (n.specifiers && n.specifiers.length > 0) {
                  var foundImportSpecifier = false;
                  path.each(function(specifierPath) {
                    var i = specifierPath.getName();
                    if (i > 0) {
                      parts.push(", ");
                    }
                    var value = specifierPath.getValue();
                    if (namedTypes.ImportDefaultSpecifier.check(value) || namedTypes.ImportNamespaceSpecifier.check(value)) {
                      assert.strictEqual(foundImportSpecifier, false);
                    } else {
                      namedTypes.ImportSpecifier.assert(value);
                      if (!foundImportSpecifier) {
                        foundImportSpecifier = true;
                        parts.push("{");
                      }
                    }
                    parts.push(print(specifierPath));
                  }, "specifiers");
                  if (foundImportSpecifier) {
                    parts.push("}");
                  }
                  parts.push(" from ");
                }
                parts.push(path.call(print, "source"), ";");
                return concat(parts);
              case "BlockStatement":
                var naked = path.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options, print);
                }, "body");
                if (naked.isEmpty()) {
                  return fromString("{}");
                }
                return concat(["{\n", naked.indent(options.tabWidth), "\n}"]);
              case "ReturnStatement":
                var parts = ["return"];
                if (n.argument) {
                  var argLines = path.call(print, "argument");
                  if (argLines.length > 1 && (namedTypes.XJSElement && namedTypes.XJSElement.check(n.argument) || namedTypes.JSXElement && namedTypes.JSXElement.check(n.argument))) {
                    parts.push(" (\n", argLines.indent(options.tabWidth), "\n)");
                  } else {
                    parts.push(" ", argLines);
                  }
                }
                parts.push(";");
                return concat(parts);
              case "CallExpression":
                return concat([path.call(print, "callee"), printArgumentsList(path, options, print)]);
              case "ObjectExpression":
              case "ObjectPattern":
              case "ObjectTypeAnnotation":
                var allowBreak = false;
                var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
                var separator = isTypeAnnotation ? ';' : ',';
                var fields = [];
                if (isTypeAnnotation) {
                  fields.push("indexers", "callProperties");
                }
                fields.push("properties");
                var len = 0;
                fields.forEach(function(field) {
                  len += n[field].length;
                });
                var oneLine = (isTypeAnnotation && len === 1) || len === 0;
                var parts = [oneLine ? "{" : "{\n"];
                var i = 0;
                fields.forEach(function(field) {
                  path.each(function(childPath) {
                    var lines = print(childPath);
                    if (!oneLine) {
                      lines = lines.indent(options.tabWidth);
                    }
                    var multiLine = !isTypeAnnotation && lines.length > 1;
                    if (multiLine && allowBreak) {
                      parts.push("\n");
                    }
                    parts.push(lines);
                    if (i < len - 1) {
                      parts.push(separator + (multiLine ? "\n\n" : "\n"));
                      allowBreak = !multiLine;
                    } else if (len !== 1 && isTypeAnnotation) {
                      parts.push(separator);
                    } else if (options.trailingComma) {
                      parts.push(separator);
                    }
                    i++;
                  }, field);
                });
                parts.push(oneLine ? "}" : "\n}");
                return concat(parts);
              case "PropertyPattern":
                return concat([path.call(print, "key"), ": ", path.call(print, "pattern")]);
              case "Property":
                if (n.method || n.kind === "get" || n.kind === "set") {
                  return printMethod(path, options, print);
                }
                var parts = [];
                if (n.decorators) {
                  path.each(function(decoratorPath) {
                    parts.push(print(decoratorPath), "\n");
                  }, "decorators");
                }
                var key = path.call(print, "key");
                if (n.computed) {
                  parts.push("[", key, "]");
                } else {
                  parts.push(key);
                }
                if (!n.shorthand) {
                  parts.push(": ", path.call(print, "value"));
                }
                return concat(parts);
              case "Decorator":
                return concat(["@", path.call(print, "expression")]);
              case "ArrayExpression":
              case "ArrayPattern":
                var elems = n.elements,
                    len = elems.length;
                var printed = path.map(print, "elements");
                var joined = fromString(", ").join(printed);
                var oneLine = joined.getLineLength(1) <= options.wrapColumn;
                var parts = [oneLine ? "[" : "[\n"];
                path.each(function(elemPath) {
                  var i = elemPath.getName();
                  var elem = elemPath.getValue();
                  if (!elem) {
                    parts.push(",");
                  } else {
                    var lines = printed[i];
                    if (oneLine) {
                      if (i > 0)
                        parts.push(" ");
                    } else {
                      lines = lines.indent(options.tabWidth);
                    }
                    parts.push(lines);
                    if (i < len - 1 || (!oneLine && options.trailingComma))
                      parts.push(",");
                    if (!oneLine)
                      parts.push("\n");
                  }
                }, "elements");
                parts.push("]");
                return concat(parts);
              case "SequenceExpression":
                return fromString(", ").join(path.map(print, "expressions"));
              case "ThisExpression":
                return fromString("this");
              case "Super":
                return fromString("super");
              case "Literal":
                if (typeof n.value !== "string")
                  return fromString(n.value, options);
                return fromString(nodeStr(n.value, options), options);
              case "ModuleSpecifier":
                if (n.local) {
                  throw new Error("The ESTree ModuleSpecifier type should be abstract");
                }
                return fromString(nodeStr(n.value, options), options);
              case "UnaryExpression":
                var parts = [n.operator];
                if (/[a-z]$/.test(n.operator))
                  parts.push(" ");
                parts.push(path.call(print, "argument"));
                return concat(parts);
              case "UpdateExpression":
                var parts = [path.call(print, "argument"), n.operator];
                if (n.prefix)
                  parts.reverse();
                return concat(parts);
              case "ConditionalExpression":
                return concat(["(", path.call(print, "test"), " ? ", path.call(print, "consequent"), " : ", path.call(print, "alternate"), ")"]);
              case "NewExpression":
                var parts = ["new ", path.call(print, "callee")];
                var args = n.arguments;
                if (args) {
                  parts.push(printArgumentsList(path, options, print));
                }
                return concat(parts);
              case "VariableDeclaration":
                var parts = [n.kind, " "];
                var maxLen = 0;
                var printed = path.map(function(childPath) {
                  var lines = print(childPath);
                  maxLen = Math.max(lines.length, maxLen);
                  return lines;
                }, "declarations");
                if (maxLen === 1) {
                  parts.push(fromString(", ").join(printed));
                } else if (printed.length > 1) {
                  parts.push(fromString(",\n").join(printed).indentTail(n.kind.length + 1));
                } else {
                  parts.push(printed[0]);
                }
                var parentNode = path.getParentNode();
                if (!namedTypes.ForStatement.check(parentNode) && !namedTypes.ForInStatement.check(parentNode) && !(namedTypes.ForOfStatement && namedTypes.ForOfStatement.check(parentNode))) {
                  parts.push(";");
                }
                return concat(parts);
              case "VariableDeclarator":
                return n.init ? fromString(" = ").join([path.call(print, "id"), path.call(print, "init")]) : path.call(print, "id");
              case "WithStatement":
                return concat(["with (", path.call(print, "object"), ") ", path.call(print, "body")]);
              case "IfStatement":
                var con = adjustClause(path.call(print, "consequent"), options),
                    parts = ["if (", path.call(print, "test"), ")", con];
                if (n.alternate)
                  parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path.call(print, "alternate"), options));
                return concat(parts);
              case "ForStatement":
                var init = path.call(print, "init"),
                    sep = init.length > 1 ? ";\n" : "; ",
                    forParen = "for (",
                    indented = fromString(sep).join([init, path.call(print, "test"), path.call(print, "update")]).indentTail(forParen.length),
                    head = concat([forParen, indented, ")"]),
                    clause = adjustClause(path.call(print, "body"), options),
                    parts = [head];
                if (head.length > 1) {
                  parts.push("\n");
                  clause = clause.trimLeft();
                }
                parts.push(clause);
                return concat(parts);
              case "WhileStatement":
                return concat(["while (", path.call(print, "test"), ")", adjustClause(path.call(print, "body"), options)]);
              case "ForInStatement":
                return concat([n.each ? "for each (" : "for (", path.call(print, "left"), " in ", path.call(print, "right"), ")", adjustClause(path.call(print, "body"), options)]);
              case "ForOfStatement":
                return concat(["for (", path.call(print, "left"), " of ", path.call(print, "right"), ")", adjustClause(path.call(print, "body"), options)]);
              case "DoWhileStatement":
                var doBody = concat(["do", adjustClause(path.call(print, "body"), options)]),
                    parts = [doBody];
                if (endsWithBrace(doBody))
                  parts.push(" while");
                else
                  parts.push("\nwhile");
                parts.push(" (", path.call(print, "test"), ");");
                return concat(parts);
              case "DoExpression":
                var statements = path.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options, print);
                }, "body");
                return concat(["do {\n", statements.indent(options.tabWidth), "\n}"]);
              case "BreakStatement":
                var parts = ["break"];
                if (n.label)
                  parts.push(" ", path.call(print, "label"));
                parts.push(";");
                return concat(parts);
              case "ContinueStatement":
                var parts = ["continue"];
                if (n.label)
                  parts.push(" ", path.call(print, "label"));
                parts.push(";");
                return concat(parts);
              case "LabeledStatement":
                return concat([path.call(print, "label"), ":\n", path.call(print, "body")]);
              case "TryStatement":
                var parts = ["try ", path.call(print, "block")];
                if (n.handler) {
                  parts.push(" ", path.call(print, "handler"));
                } else if (n.handlers) {
                  path.each(function(handlerPath) {
                    parts.push(" ", print(handlerPath));
                  }, "handlers");
                }
                if (n.finalizer) {
                  parts.push(" finally ", path.call(print, "finalizer"));
                }
                return concat(parts);
              case "CatchClause":
                var parts = ["catch (", path.call(print, "param")];
                if (n.guard)
                  parts.push(" if ", path.call(print, "guard"));
                parts.push(") ", path.call(print, "body"));
                return concat(parts);
              case "ThrowStatement":
                return concat(["throw ", path.call(print, "argument"), ";"]);
              case "SwitchStatement":
                return concat(["switch (", path.call(print, "discriminant"), ") {\n", fromString("\n").join(path.map(print, "cases")), "\n}"]);
              case "SwitchCase":
                var parts = [];
                if (n.test)
                  parts.push("case ", path.call(print, "test"), ":");
                else
                  parts.push("default:");
                if (n.consequent.length > 0) {
                  parts.push("\n", path.call(function(consequentPath) {
                    return printStatementSequence(consequentPath, options, print);
                  }, "consequent").indent(options.tabWidth));
                }
                return concat(parts);
              case "DebuggerStatement":
                return fromString("debugger;");
              case "XJSAttribute":
              case "JSXAttribute":
                var parts = [path.call(print, "name")];
                if (n.value)
                  parts.push("=", path.call(print, "value"));
                return concat(parts);
              case "XJSIdentifier":
              case "JSXIdentifier":
                return fromString(n.name, options);
              case "XJSNamespacedName":
              case "JSXNamespacedName":
                return fromString(":").join([path.call(print, "namespace"), path.call(print, "name")]);
              case "XJSMemberExpression":
              case "JSXMemberExpression":
                return fromString(".").join([path.call(print, "object"), path.call(print, "property")]);
              case "XJSSpreadAttribute":
              case "JSXSpreadAttribute":
                return concat(["{...", path.call(print, "argument"), "}"]);
              case "XJSExpressionContainer":
              case "JSXExpressionContainer":
                return concat(["{", path.call(print, "expression"), "}"]);
              case "XJSElement":
              case "JSXElement":
                var openingLines = path.call(print, "openingElement");
                if (n.openingElement.selfClosing) {
                  assert.ok(!n.closingElement);
                  return openingLines;
                }
                var childLines = concat(path.map(function(childPath) {
                  var child = childPath.getValue();
                  if (namedTypes.Literal.check(child) && typeof child.value === "string") {
                    if (/\S/.test(child.value)) {
                      return child.value.replace(/^\s+|\s+$/g, "");
                    } else if (/\n/.test(child.value)) {
                      return "\n";
                    }
                  }
                  return print(childPath);
                }, "children")).indentTail(options.tabWidth);
                var closingLines = path.call(print, "closingElement");
                return concat([openingLines, childLines, closingLines]);
              case "XJSOpeningElement":
              case "JSXOpeningElement":
                var parts = ["<", path.call(print, "name")];
                var attrParts = [];
                path.each(function(attrPath) {
                  attrParts.push(" ", print(attrPath));
                }, "attributes");
                var attrLines = concat(attrParts);
                var needLineWrap = (attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn);
                if (needLineWrap) {
                  attrParts.forEach(function(part, i) {
                    if (part === " ") {
                      assert.strictEqual(i % 2, 0);
                      attrParts[i] = "\n";
                    }
                  });
                  attrLines = concat(attrParts).indentTail(options.tabWidth);
                }
                parts.push(attrLines, n.selfClosing ? " />" : ">");
                return concat(parts);
              case "XJSClosingElement":
              case "JSXClosingElement":
                return concat(["</", path.call(print, "name"), ">"]);
              case "XJSText":
              case "JSXText":
                return fromString(n.value, options);
              case "XJSEmptyExpression":
              case "JSXEmptyExpression":
                return fromString("");
              case "TypeAnnotatedIdentifier":
                return concat([path.call(print, "annotation"), " ", path.call(print, "identifier")]);
              case "ClassBody":
                if (n.body.length === 0) {
                  return fromString("{}");
                }
                return concat(["{\n", path.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options, print);
                }, "body").indent(options.tabWidth), "\n}"]);
              case "ClassPropertyDefinition":
                var parts = ["static ", path.call(print, "definition")];
                if (!namedTypes.MethodDefinition.check(n.definition))
                  parts.push(";");
                return concat(parts);
              case "ClassProperty":
                var parts = [];
                if (n.static)
                  parts.push("static ");
                parts.push(path.call(print, "key"));
                if (n.typeAnnotation)
                  parts.push(path.call(print, "typeAnnotation"));
                if (n.value)
                  parts.push(" = ", path.call(print, "value"));
                parts.push(";");
                return concat(parts);
              case "ClassDeclaration":
              case "ClassExpression":
                var parts = ["class"];
                if (n.id) {
                  parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
                }
                if (n.superClass) {
                  parts.push(" extends ", path.call(print, "superClass"), path.call(print, "superTypeParameters"));
                }
                if (n["implements"]) {
                  parts.push(" implements ", fromString(", ").join(path.map(print, "implements")));
                }
                parts.push(" ", path.call(print, "body"));
                return concat(parts);
              case "TemplateElement":
                return fromString(n.value.raw, options);
              case "TemplateLiteral":
                var expressions = path.map(print, "expressions");
                var parts = [];
                path.each(function(childPath) {
                  var i = childPath.getName();
                  parts.push(print(childPath));
                  if (i < expressions.length) {
                    parts.push("${", expressions[i], "}");
                  }
                }, "quasis");
                return concat(parts);
              case "TaggedTemplateExpression":
                return concat([path.call(print, "tag"), "`", path.call(print, "quasi"), "`"]);
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "TupleTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(n.type));
              case "Block":
                return concat(["/*", fromString(n.value, options), "*/"]);
              case "Line":
                return concat(["//", fromString(n.value, options)]);
              case "TypeAnnotation":
                var parts = [];
                if (n.typeAnnotation) {
                  if (n.typeAnnotation.type !== "FunctionTypeAnnotation") {
                    parts.push(": ");
                  }
                  parts.push(path.call(print, "typeAnnotation"));
                  return concat(parts);
                }
                return fromString("");
              case "AnyTypeAnnotation":
                return fromString("any", options);
              case "MixedTypeAnnotation":
                return fromString("mixed", options);
              case "ArrayTypeAnnotation":
                return concat([path.call(print, "elementType"), "[]"]);
              case "BooleanTypeAnnotation":
                return fromString("boolean", options);
              case "BooleanLiteralTypeAnnotation":
                assert.strictEqual(typeof n.value, "boolean");
                return fromString("" + n.value, options);
              case "DeclareClass":
                return concat([fromString("declare class ", options), path.call(print, "id"), " ", path.call(print, "body")]);
              case "DeclareFunction":
                return concat([fromString("declare function ", options), path.call(print, "id"), ";"]);
              case "DeclareModule":
                return concat([fromString("declare module ", options), path.call(print, "id"), " ", path.call(print, "body")]);
              case "DeclareVariable":
                return concat([fromString("declare var ", options), path.call(print, "id"), ";"]);
              case "FunctionTypeAnnotation":
                var parts = [];
                var parent = path.getParentNode(0);
                var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) || namedTypes.DeclareFunction.check(path.getParentNode(2)));
                var needsColon = isArrowFunctionTypeAnnotation && !namedTypes.FunctionTypeParam.check(parent);
                if (needsColon) {
                  parts.push(": ");
                }
                parts.push("(", fromString(", ").join(path.map(print, "params")), ")");
                if (n.returnType) {
                  parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path.call(print, "returnType"));
                }
                return concat(parts);
              case "FunctionTypeParam":
                return concat([path.call(print, "name"), ": ", path.call(print, "typeAnnotation")]);
              case "GenericTypeAnnotation":
                return concat([path.call(print, "id"), path.call(print, "typeParameters")]);
              case "InterfaceDeclaration":
                var parts = [fromString("interface ", options), path.call(print, "id"), path.call(print, "typeParameters"), " "];
                if (n["extends"]) {
                  parts.push("extends ", fromString(", ").join(path.map(print, "extends")));
                }
                parts.push(" ", path.call(print, "body"));
                return concat(parts);
              case "ClassImplements":
              case "InterfaceExtends":
                return concat([path.call(print, "id"), path.call(print, "typeParameters")]);
              case "IntersectionTypeAnnotation":
                return fromString(" & ").join(path.map(print, "types"));
              case "NullableTypeAnnotation":
                return concat(["?", path.call(print, "typeAnnotation")]);
              case "NumberTypeAnnotation":
                return fromString("number", options);
              case "ObjectTypeCallProperty":
                return path.call(print, "value");
              case "ObjectTypeIndexer":
                return concat(["[", path.call(print, "id"), ": ", path.call(print, "key"), "]: ", path.call(print, "value")]);
              case "ObjectTypeProperty":
                return concat([path.call(print, "key"), ": ", path.call(print, "value")]);
              case "QualifiedTypeIdentifier":
                return concat([path.call(print, "qualification"), ".", path.call(print, "id")]);
              case "StringLiteralTypeAnnotation":
                return fromString(nodeStr(n.value, options), options);
              case "NumberLiteralTypeAnnotation":
                assert.strictEqual(typeof n.value, "number");
                return fromString("" + n.value, options);
              case "StringTypeAnnotation":
                return fromString("string", options);
              case "TypeAlias":
                return concat(["type ", path.call(print, "id"), " = ", path.call(print, "right"), ";"]);
              case "TypeCastExpression":
                return concat(["(", path.call(print, "expression"), path.call(print, "typeAnnotation"), ")"]);
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation":
                return concat(["<", fromString(", ").join(path.map(print, "params")), ">"]);
              case "TypeofTypeAnnotation":
                return concat([fromString("typeof ", options), path.call(print, "argument")]);
              case "UnionTypeAnnotation":
                return fromString(" | ").join(path.map(print, "types"));
              case "VoidTypeAnnotation":
                return fromString("void", options);
              case "ClassHeritage":
              case "ComprehensionBlock":
              case "ComprehensionExpression":
              case "Glob":
              case "GeneratorExpression":
              case "LetStatement":
              case "LetExpression":
              case "GraphExpression":
              case "GraphIndexExpression":
              case "XMLDefaultDeclaration":
              case "XMLAnyName":
              case "XMLQualifiedIdentifier":
              case "XMLFunctionQualifiedIdentifier":
              case "XMLAttributeSelector":
              case "XMLFilterExpression":
              case "XML":
              case "XMLElement":
              case "XMLList":
              case "XMLEscape":
              case "XMLText":
              case "XMLStartTag":
              case "XMLEndTag":
              case "XMLPointTag":
              case "XMLName":
              case "XMLAttribute":
              case "XMLCdata":
              case "XMLComment":
              case "XMLProcessingInstruction":
              default:
                debugger;
                throw new Error("unknown type: " + JSON.stringify(n.type));
            }
            return p;
          }
          function printStatementSequence(path, options, print) {
            var inClassBody = namedTypes.ClassBody && namedTypes.ClassBody.check(path.getParentNode());
            var filtered = [];
            var sawComment = false;
            var sawStatement = false;
            path.each(function(stmtPath) {
              var i = stmtPath.getName();
              var stmt = stmtPath.getValue();
              if (!stmt) {
                return;
              }
              if (stmt.type === "EmptyStatement") {
                return;
              }
              if (namedTypes.Comment.check(stmt)) {
                sawComment = true;
              } else if (!inClassBody) {
                namedTypes.Statement.assert(stmt);
                sawStatement = true;
              }
              filtered.push({
                node: stmt,
                printed: print(stmtPath)
              });
            });
            if (sawComment) {
              assert.strictEqual(sawStatement, false, "Comments may appear as statements in otherwise empty statement " + "lists, but may not coexist with non-Comment nodes.");
            }
            var prevTrailingSpace = null;
            var len = filtered.length;
            var parts = [];
            filtered.forEach(function(info, i) {
              var printed = info.printed;
              var stmt = info.node;
              var multiLine = printed.length > 1;
              var notFirst = i > 0;
              var notLast = i < len - 1;
              var leadingSpace;
              var trailingSpace;
              var lines = stmt && stmt.loc && stmt.loc.lines;
              var trueLoc = lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);
              if (notFirst) {
                if (trueLoc) {
                  var beforeStart = lines.skipSpaces(trueLoc.start, true);
                  var beforeStartLine = beforeStart ? beforeStart.line : 1;
                  var leadingGap = trueLoc.start.line - beforeStartLine;
                  leadingSpace = Array(leadingGap + 1).join("\n");
                } else {
                  leadingSpace = multiLine ? "\n\n" : "\n";
                }
              } else {
                leadingSpace = "";
              }
              if (notLast) {
                if (trueLoc) {
                  var afterEnd = lines.skipSpaces(trueLoc.end);
                  var afterEndLine = afterEnd ? afterEnd.line : lines.length;
                  var trailingGap = afterEndLine - trueLoc.end.line;
                  trailingSpace = Array(trailingGap + 1).join("\n");
                } else {
                  trailingSpace = multiLine ? "\n\n" : "\n";
                }
              } else {
                trailingSpace = "";
              }
              parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);
              if (notLast) {
                prevTrailingSpace = trailingSpace;
              } else if (trailingSpace) {
                parts.push(trailingSpace);
              }
            });
            return concat(parts);
          }
          function maxSpace(s1, s2) {
            if (!s1 && !s2) {
              return fromString("");
            }
            if (!s1) {
              return fromString(s2);
            }
            if (!s2) {
              return fromString(s1);
            }
            var spaceLines1 = fromString(s1);
            var spaceLines2 = fromString(s2);
            if (spaceLines2.length > spaceLines1.length) {
              return spaceLines2;
            }
            return spaceLines1;
          }
          function printMethod(path, options, print) {
            var node = path.getNode();
            var kind = node.kind;
            var parts = [];
            namedTypes.FunctionExpression.assert(node.value);
            if (node.decorators) {
              path.each(function(decoratorPath) {
                parts.push(print(decoratorPath), "\n");
              }, "decorators");
            }
            if (node.value.async) {
              parts.push("async ");
            }
            if (!kind || kind === "init") {
              if (node.value.generator) {
                parts.push("*");
              }
            } else {
              assert.ok(kind === "get" || kind === "set");
              parts.push(kind, " ");
            }
            var key = path.call(print, "key");
            if (node.computed) {
              key = concat(["[", key, "]"]);
            }
            parts.push(key, path.call(print, "value", "typeParameters"), "(", path.call(function(valuePath) {
              return printFunctionParams(valuePath, options, print);
            }, "value"), ")", path.call(print, "value", "returnType"), " ", path.call(print, "value", "body"));
            return concat(parts);
          }
          function printArgumentsList(path, options, print) {
            var printed = path.map(print, "arguments");
            var joined = fromString(", ").join(printed);
            if (joined.getLineLength(1) > options.wrapColumn) {
              joined = fromString(",\n").join(printed);
              return concat(["(\n", joined.indent(options.tabWidth), options.trailingComma ? ",\n)" : "\n)"]);
            }
            return concat(["(", joined, ")"]);
          }
          function printFunctionParams(path, options, print) {
            var fun = path.getValue();
            namedTypes.Function.assert(fun);
            var printed = path.map(print, "params");
            if (fun.defaults) {
              path.each(function(defExprPath) {
                var i = defExprPath.getName();
                var p = printed[i];
                if (p && defExprPath.getValue()) {
                  printed[i] = concat([p, "=", print(defExprPath)]);
                }
              }, "defaults");
            }
            if (fun.rest) {
              printed.push(concat(["...", path.call(print, "rest")]));
            }
            var joined = fromString(", ").join(printed);
            if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {
              joined = fromString(",\n").join(printed);
              if (options.trailingComma && !fun.rest) {
                joined = concat([joined, ",\n"]);
              }
              return concat(["\n", joined.indent(options.tabWidth)]);
            }
            return joined;
          }
          function adjustClause(clause, options) {
            if (clause.length > 1)
              return concat([" ", clause]);
            return concat(["\n", maybeAddSemicolon(clause).indent(options.tabWidth)]);
          }
          function lastNonSpaceCharacter(lines) {
            var pos = lines.lastPos();
            do {
              var ch = lines.charAt(pos);
              if (/\S/.test(ch))
                return ch;
            } while (lines.prevPos(pos));
          }
          function endsWithBrace(lines) {
            return lastNonSpaceCharacter(lines) === "}";
          }
          function swapQuotes(str) {
            return str.replace(/['"]/g, function(m) {
              return m === '"' ? '\'' : '"';
            });
          }
          function nodeStr(str, options) {
            isString.assert(str);
            switch (options.quote) {
              case "auto":
                var double = JSON.stringify(str);
                var single = swapQuotes(JSON.stringify(swapQuotes(str)));
                return double.length > single.length ? single : double;
              case "single":
                return swapQuotes(JSON.stringify(swapQuotes(str)));
              case "double":
              default:
                return JSON.stringify(str);
            }
          }
          function maybeAddSemicolon(lines) {
            var eoc = lastNonSpaceCharacter(lines);
            if (!eoc || "\n};".indexOf(eoc) < 0)
              return concat([lines, ";"]);
            return lines;
          }
        }, {
          "./comments": 567,
          "./fast-path": 568,
          "./lines": 569,
          "./options": 571,
          "./patcher": 573,
          "./types": 575,
          "./util": 576,
          "assert": 2,
          "source-map": 607
        }],
        575: [function(require, module, exports) {
          module.exports = require("ast-types");
        }, {"ast-types": 593}],
        576: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("./types");
          var getFieldValue = types.getFieldValue;
          var n = types.namedTypes;
          var sourceMap = require("source-map");
          var SourceMapConsumer = sourceMap.SourceMapConsumer;
          var SourceMapGenerator = sourceMap.SourceMapGenerator;
          var hasOwn = Object.prototype.hasOwnProperty;
          function getUnionOfKeys() {
            var result = {};
            var argc = arguments.length;
            for (var i = 0; i < argc; ++i) {
              var keys = Object.keys(arguments[i]);
              var keyCount = keys.length;
              for (var j = 0; j < keyCount; ++j) {
                result[keys[j]] = true;
              }
            }
            return result;
          }
          exports.getUnionOfKeys = getUnionOfKeys;
          function comparePos(pos1, pos2) {
            return (pos1.line - pos2.line) || (pos1.column - pos2.column);
          }
          exports.comparePos = comparePos;
          function copyPos(pos) {
            return {
              line: pos.line,
              column: pos.column
            };
          }
          exports.copyPos = copyPos;
          exports.composeSourceMaps = function(formerMap, latterMap) {
            if (formerMap) {
              if (!latterMap) {
                return formerMap;
              }
            } else {
              return latterMap || null;
            }
            var smcFormer = new SourceMapConsumer(formerMap);
            var smcLatter = new SourceMapConsumer(latterMap);
            var smg = new SourceMapGenerator({
              file: latterMap.file,
              sourceRoot: latterMap.sourceRoot
            });
            var sourcesToContents = {};
            smcLatter.eachMapping(function(mapping) {
              var origPos = smcFormer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
              var sourceName = origPos.source;
              if (sourceName === null) {
                return;
              }
              smg.addMapping({
                source: sourceName,
                original: copyPos(origPos),
                generated: {
                  line: mapping.generatedLine,
                  column: mapping.generatedColumn
                },
                name: mapping.name
              });
              var sourceContent = smcFormer.sourceContentFor(sourceName);
              if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {
                sourcesToContents[sourceName] = sourceContent;
                smg.setSourceContent(sourceName, sourceContent);
              }
            });
            return smg.toJSON();
          };
          exports.getTrueLoc = function(node, lines) {
            if (!node.loc) {
              return null;
            }
            var start = node.loc.start;
            var end = node.loc.end;
            if (node.comments) {
              node.comments.forEach(function(comment) {
                if (comment.loc) {
                  if (comparePos(comment.loc.start, start) < 0) {
                    start = comment.loc.start;
                  }
                  if (comparePos(end, comment.loc.end) < 0) {
                    end = comment.loc.end;
                  }
                }
              });
            }
            return {
              start: lines.skipSpaces(start, false, false),
              end: lines.skipSpaces(end, true, false)
            };
          };
          exports.fixFaultyLocations = function(node) {
            if ((n.MethodDefinition && n.MethodDefinition.check(node)) || (n.Property.check(node) && (node.method || node.shorthand))) {
              node.value.loc = null;
              if (n.FunctionExpression.check(node.value)) {
                node.value.id = null;
              }
            }
            var loc = node.loc;
            if (loc) {
              if (loc.start.line < 1) {
                loc.start.line = 1;
              }
              if (loc.end.line < 1) {
                loc.end.line = 1;
              }
            }
          };
        }, {
          "./types": 575,
          "assert": 2,
          "source-map": 607
        }],
        577: [function(require, module, exports) {
          (function(process) {
            var types = require("./lib/types");
            var parse = require("./lib/parser").parse;
            var Printer = require("./lib/printer").Printer;
            function print(node, options) {
              return new Printer(options).print(node);
            }
            function prettyPrint(node, options) {
              return new Printer(options).printGenerically(node);
            }
            function run(transformer, options) {
              return runFile(process.argv[2], transformer, options);
            }
            function runFile(path, transformer, options) {
              require("fs").readFile(path, "utf-8", function(err, code) {
                if (err) {
                  console.error(err);
                  return;
                }
                runString(code, transformer, options);
              });
            }
            function defaultWriteback(output) {
              process.stdout.write(output);
            }
            function runString(code, transformer, options) {
              var writeback = options && options.writeback || defaultWriteback;
              transformer(parse(code, options), function(node) {
                writeback(print(node, options).code);
              });
            }
            Object.defineProperties(exports, {
              parse: {
                enumerable: true,
                value: parse
              },
              visit: {
                enumerable: true,
                value: types.visit
              },
              print: {
                enumerable: true,
                value: print
              },
              prettyPrint: {
                enumerable: false,
                value: prettyPrint
              },
              types: {
                enumerable: false,
                value: types
              },
              run: {
                enumerable: false,
                value: run
              }
            });
          }).call(this, require('_process'));
        }, {
          "./lib/parser": 572,
          "./lib/printer": 574,
          "./lib/types": 575,
          "_process": 12,
          "fs": 1
        }],
        578: [function(require, module, exports) {
          require("./es7");
          var types = require("../lib/types");
          var defaults = require("../lib/shared").defaults;
          var def = types.Type.def;
          var or = types.Type.or;
          def("Noop").bases("Node").build();
          def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
          def("Super").bases("Expression").build();
          def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression"));
          def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
          def("Property").field("decorators", or([def("Decorator")], null), defaults["null"]);
          def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults["null"]);
          def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
          def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
          def("ModuleSpecifier").bases("Specifier").field("local", def("Identifier"));
          def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
          def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
          def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
          def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression")));
          def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
          def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
          def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
          def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
          def("ExportAllDeclaration").bases("Declaration").build("exported", "source").field("exported", or(def("Identifier"), null)).field("source", def("Literal"));
        }, {
          "../lib/shared": 591,
          "../lib/types": 592,
          "./es7": 582
        }],
        579: [function(require, module, exports) {
          var types = require("../lib/types");
          var Type = types.Type;
          var def = Type.def;
          var or = Type.or;
          var shared = require("../lib/shared");
          var defaults = shared.defaults;
          var geq = shared.geq;
          def("Printable").field("loc", or(def("SourceLocation"), null), defaults["null"], true);
          def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults["null"], true);
          def("SourceLocation").build("start", "end", "source").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults["null"]);
          def("Position").build("line", "column").field("line", geq(1)).field("column", geq(0));
          def("File").bases("Node").build("program").field("program", def("Program"));
          def("Program").bases("Node").build("body").field("body", [def("Statement")]);
          def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement"));
          def("Statement").bases("Node");
          def("EmptyStatement").bases("Statement").build();
          def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
          def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
          def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults["null"]);
          def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
          def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults["null"]);
          def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults["null"]);
          def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
          def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults["false"]);
          def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null));
          def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
          def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
            return this.handlers && this.handlers[0] || null;
          }).field("handlers", [def("CatchClause")], function() {
            return this.handler ? [this.handler] : [];
          }, true).field("guardedHandlers", [def("CatchClause")], defaults.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults["null"]);
          def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or(def("Expression"), null), defaults["null"]).field("body", def("BlockStatement"));
          def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
          def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
          def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement"));
          def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
          def("DebuggerStatement").bases("Statement").build();
          def("Declaration").bases("Statement");
          def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
          def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
          def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
          def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null));
          def("Expression").bases("Node", "Pattern");
          def("ThisExpression").bases("Expression").build();
          def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]);
          def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
          def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression"));
          def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
          var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
          def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults["true"]);
          var BinaryOperator = or("==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "&", "|", "^", "in", "instanceof", "..");
          def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
          var AssignmentOperator = or("=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&=");
          def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", def("Pattern")).field("right", def("Expression"));
          var UpdateOperator = or("++", "--");
          def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
          var LogicalOperator = or("||", "&&");
          def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
          def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
          def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
          def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
          def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, defaults["false"]);
          def("Pattern").bases("Node");
          def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]);
          def("Identifier").bases("Node", "Expression", "Pattern").build("name").field("name", String);
          def("Literal").bases("Node", "Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp)).field("regex", or({
            pattern: String,
            flags: String
          }, null), function() {
            if (this.value instanceof RegExp) {
              var flags = "";
              if (this.value.ignoreCase)
                flags += "i";
              if (this.value.multiline)
                flags += "m";
              if (this.value.global)
                flags += "g";
              return {
                pattern: this.value.source,
                flags: flags
              };
            }
            return null;
          });
          def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults["true"]).field("trailing", Boolean, defaults["false"]);
          def("Block").bases("Comment").build("value", "leading", "trailing");
          def("Line").bases("Comment").build("value", "leading", "trailing");
        }, {
          "../lib/shared": 591,
          "../lib/types": 592
        }],
        580: [function(require, module, exports) {
          require("./core");
          var types = require("../lib/types");
          var def = types.Type.def;
          var or = types.Type.or;
          def("XMLDefaultDeclaration").bases("Declaration").field("namespace", def("Expression"));
          def("XMLAnyName").bases("Expression");
          def("XMLQualifiedIdentifier").bases("Expression").field("left", or(def("Identifier"), def("XMLAnyName"))).field("right", or(def("Identifier"), def("Expression"))).field("computed", Boolean);
          def("XMLFunctionQualifiedIdentifier").bases("Expression").field("right", or(def("Identifier"), def("Expression"))).field("computed", Boolean);
          def("XMLAttributeSelector").bases("Expression").field("attribute", def("Expression"));
          def("XMLFilterExpression").bases("Expression").field("left", def("Expression")).field("right", def("Expression"));
          def("XMLElement").bases("XML", "Expression").field("contents", [def("XML")]);
          def("XMLList").bases("XML", "Expression").field("contents", [def("XML")]);
          def("XML").bases("Node");
          def("XMLEscape").bases("XML").field("expression", def("Expression"));
          def("XMLText").bases("XML").field("text", String);
          def("XMLStartTag").bases("XML").field("contents", [def("XML")]);
          def("XMLEndTag").bases("XML").field("contents", [def("XML")]);
          def("XMLPointTag").bases("XML").field("contents", [def("XML")]);
          def("XMLName").bases("XML").field("contents", or(String, [def("XML")]));
          def("XMLAttribute").bases("XML").field("value", String);
          def("XMLCdata").bases("XML").field("contents", String);
          def("XMLComment").bases("XML").field("contents", String);
          def("XMLProcessingInstruction").bases("XML").field("target", String).field("contents", or(String, null));
        }, {
          "../lib/types": 592,
          "./core": 579
        }],
        581: [function(require, module, exports) {
          require("./core");
          var types = require("../lib/types");
          var def = types.Type.def;
          var or = types.Type.or;
          var defaults = require("../lib/shared").defaults;
          def("Function").field("generator", Boolean, defaults["false"]).field("expression", Boolean, defaults["false"]).field("defaults", [or(def("Expression"), null)], defaults.emptyArray).field("rest", or(def("Identifier"), null), defaults["null"]);
          def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern"));
          def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
          def("FunctionDeclaration").build("id", "params", "body", "generator", "expression");
          def("FunctionExpression").build("id", "params", "body", "generator", "expression");
          def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults["null"]).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", false, defaults["false"]);
          def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults["false"]);
          def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
          def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
          def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
          def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults["false"]).field("shorthand", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]);
          def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults["false"]);
          def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]);
          def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]);
          def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", def("Function")).field("computed", Boolean, defaults["false"]).field("static", Boolean, defaults["false"]);
          def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
          def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
          def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
          def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
          def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
          var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"));
          def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults["false"]);
          def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
          def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
          def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults["null"]);
          def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults["null"]).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults["null"]).field("implements", [def("ClassImplements")], defaults.emptyArray);
          def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults["null"]);
          def("Specifier").bases("Node");
          def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
          def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
          def("TemplateElement").bases("Node").build("value", "tail").field("value", {
            "cooked": String,
            "raw": String
          }).field("tail", Boolean);
        }, {
          "../lib/shared": 591,
          "../lib/types": 592,
          "./core": 579
        }],
        582: [function(require, module, exports) {
          require("./es6");
          var types = require("../lib/types");
          var def = types.Type.def;
          var or = types.Type.or;
          var builtin = types.builtInTypes;
          var defaults = require("../lib/shared").defaults;
          def("Function").field("async", Boolean, defaults["false"]);
          def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
          def("ObjectExpression").field("properties", [or(def("Property"), def("SpreadProperty"))]);
          def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
          def("ObjectPattern").field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"))]);
          def("AwaitExpression").bases("Expression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults["false"]);
        }, {
          "../lib/shared": 591,
          "../lib/types": 592,
          "./es6": 581
        }],
        583: [function(require, module, exports) {
          require("./es7");
          var types = require("../lib/types");
          var defaults = require("../lib/shared").defaults;
          var def = types.Type.def;
          var or = types.Type.or;
          def("VariableDeclaration").field("declarations", [or(def("VariableDeclarator"), def("Identifier"))]);
          def("Property").field("value", or(def("Expression"), def("Pattern")));
          def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]);
          def("ObjectPattern").field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"))]);
          def("NamedSpecifier").bases("Specifier").field("id", def("Identifier")).field("name", or(def("Identifier"), null), defaults["null"]);
          def("ExportSpecifier").bases("NamedSpecifier").build("id", "name");
          def("ExportBatchSpecifier").bases("Specifier").build();
          def("ImportSpecifier").bases("NamedSpecifier").build("id", "name");
          def("ImportNamespaceSpecifier").bases("Specifier").build("id").field("id", def("Identifier"));
          def("ImportDefaultSpecifier").bases("Specifier").build("id").field("id", def("Identifier"));
          def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(def("Declaration"), def("Expression"), null)).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
          def("ImportDeclaration").bases("Declaration").build("specifiers", "source").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults.emptyArray).field("source", def("Literal"));
        }, {
          "../lib/shared": 591,
          "../lib/types": 592,
          "./es7": 582
        }],
        584: [function(require, module, exports) {
          require("./es7");
          var types = require("../lib/types");
          var def = types.Type.def;
          var or = types.Type.or;
          var defaults = require("../lib/shared").defaults;
          def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(def("Literal"), def("JSXExpressionContainer"), null), defaults["null"]);
          def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
          def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
          def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults.false);
          var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
          def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
          var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
          def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", def("Expression"));
          def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults["null"]).field("children", [or(def("JSXElement"), def("JSXExpressionContainer"), def("JSXText"), def("Literal"))], defaults.emptyArray).field("name", JSXElementName, function() {
            return this.openingElement.name;
          }).field("selfClosing", Boolean, function() {
            return this.openingElement.selfClosing;
          }).field("attributes", JSXAttributes, function() {
            return this.openingElement.attributes;
          });
          def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults.emptyArray).field("selfClosing", Boolean, defaults["false"]);
          def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
          def("JSXText").bases("Literal").build("value").field("value", String);
          def("JSXEmptyExpression").bases("Expression").build();
          def("Type").bases("Node");
          def("AnyTypeAnnotation").bases("Type").build();
          def("MixedTypeAnnotation").bases("Type").build();
          def("VoidTypeAnnotation").bases("Type").build();
          def("NumberTypeAnnotation").bases("Type").build();
          def("NumberLiteralTypeAnnotation").bases("Type").build("value", "raw").field("value", Number).field("raw", String);
          def("StringTypeAnnotation").bases("Type").build();
          def("StringLiteralTypeAnnotation").bases("Type").build("value", "raw").field("value", String).field("raw", String);
          def("BooleanTypeAnnotation").bases("Type").build();
          def("BooleanLiteralTypeAnnotation").bases("Type").build("value", "raw").field("value", Boolean).field("raw", String);
          def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("Type"));
          def("NullableTypeAnnotation").bases("Type").build("typeAnnotation").field("typeAnnotation", def("Type"));
          def("FunctionTypeAnnotation").bases("Type").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("Type")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null));
          def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", def("Identifier")).field("typeAnnotation", def("Type")).field("optional", Boolean);
          def("ArrayTypeAnnotation").bases("Type").build("elementType").field("elementType", def("Type"));
          def("ObjectTypeAnnotation").bases("Type").build("properties").field("properties", [def("ObjectTypeProperty")]).field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray);
          def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("Type")).field("optional", Boolean);
          def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("Type")).field("value", def("Type"));
          def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, false);
          def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
          def("GenericTypeAnnotation").bases("Type").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null));
          def("MemberTypeAnnotation").bases("Type").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
          def("UnionTypeAnnotation").bases("Type").build("types").field("types", [def("Type")]);
          def("IntersectionTypeAnnotation").bases("Type").build("types").field("types", [def("Type")]);
          def("TypeofTypeAnnotation").bases("Type").build("argument").field("argument", def("Type"));
          def("Identifier").field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);
          def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("Identifier")]);
          def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("Type")]);
          def("Function").field("returnType", or(def("TypeAnnotation"), null), defaults["null"]).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"]);
          def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("typeAnnotation", or(def("TypeAnnotation"), null)).field("static", Boolean, defaults["false"]);
          def("ClassImplements").field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);
          def("InterfaceDeclaration").bases("Statement").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
          def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null));
          def("TypeAlias").bases("Statement").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("Type"));
          def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
          def("TupleTypeAnnotation").bases("Type").build("types").field("types", [def("Type")]);
          def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
          def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier"));
          def("DeclareClass").bases("InterfaceDeclaration").build("id");
          def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
        }, {
          "../lib/shared": 591,
          "../lib/types": 592,
          "./es7": 582
        }],
        585: [function(require, module, exports) {
          require("./core");
          var types = require("../lib/types");
          var def = types.Type.def;
          var or = types.Type.or;
          var shared = require("../lib/shared");
          var geq = shared.geq;
          var defaults = shared.defaults;
          def("Function").field("body", or(def("BlockStatement"), def("Expression")));
          def("ForInStatement").build("left", "right", "body", "each").field("each", Boolean, defaults["false"]);
          def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
          def("LetStatement").bases("Statement").build("head", "body").field("head", [def("VariableDeclarator")]).field("body", def("Statement"));
          def("LetExpression").bases("Expression").build("head", "body").field("head", [def("VariableDeclarator")]).field("body", def("Expression"));
          def("GraphExpression").bases("Expression").build("index", "expression").field("index", geq(0)).field("expression", def("Literal"));
          def("GraphIndexExpression").bases("Expression").build("index").field("index", geq(0));
        }, {
          "../lib/shared": 591,
          "../lib/types": 592,
          "./core": 579
        }],
        586: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("../main");
          var getFieldNames = types.getFieldNames;
          var getFieldValue = types.getFieldValue;
          var isArray = types.builtInTypes.array;
          var isObject = types.builtInTypes.object;
          var isDate = types.builtInTypes.Date;
          var isRegExp = types.builtInTypes.RegExp;
          var hasOwn = Object.prototype.hasOwnProperty;
          function astNodesAreEquivalent(a, b, problemPath) {
            if (isArray.check(problemPath)) {
              problemPath.length = 0;
            } else {
              problemPath = null;
            }
            return areEquivalent(a, b, problemPath);
          }
          astNodesAreEquivalent.assert = function(a, b) {
            var problemPath = [];
            if (!astNodesAreEquivalent(a, b, problemPath)) {
              if (problemPath.length === 0) {
                assert.strictEqual(a, b);
              } else {
                assert.ok(false, "Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
              }
            }
          };
          function subscriptForProperty(property) {
            if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
              return "." + property;
            }
            return "[" + JSON.stringify(property) + "]";
          }
          function areEquivalent(a, b, problemPath) {
            if (a === b) {
              return true;
            }
            if (isArray.check(a)) {
              return arraysAreEquivalent(a, b, problemPath);
            }
            if (isObject.check(a)) {
              return objectsAreEquivalent(a, b, problemPath);
            }
            if (isDate.check(a)) {
              return isDate.check(b) && (+a === +b);
            }
            if (isRegExp.check(a)) {
              return isRegExp.check(b) && (a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase);
            }
            return a == b;
          }
          function arraysAreEquivalent(a, b, problemPath) {
            isArray.assert(a);
            var aLength = a.length;
            if (!isArray.check(b) || b.length !== aLength) {
              if (problemPath) {
                problemPath.push("length");
              }
              return false;
            }
            for (var i = 0; i < aLength; ++i) {
              if (problemPath) {
                problemPath.push(i);
              }
              if (i in a !== i in b) {
                return false;
              }
              if (!areEquivalent(a[i], b[i], problemPath)) {
                return false;
              }
              if (problemPath) {
                assert.strictEqual(problemPath.pop(), i);
              }
            }
            return true;
          }
          function objectsAreEquivalent(a, b, problemPath) {
            isObject.assert(a);
            if (!isObject.check(b)) {
              return false;
            }
            if (a.type !== b.type) {
              if (problemPath) {
                problemPath.push("type");
              }
              return false;
            }
            var aNames = getFieldNames(a);
            var aNameCount = aNames.length;
            var bNames = getFieldNames(b);
            var bNameCount = bNames.length;
            if (aNameCount === bNameCount) {
              for (var i = 0; i < aNameCount; ++i) {
                var name = aNames[i];
                var aChild = getFieldValue(a, name);
                var bChild = getFieldValue(b, name);
                if (problemPath) {
                  problemPath.push(name);
                }
                if (!areEquivalent(aChild, bChild, problemPath)) {
                  return false;
                }
                if (problemPath) {
                  assert.strictEqual(problemPath.pop(), name);
                }
              }
              return true;
            }
            if (!problemPath) {
              return false;
            }
            var seenNames = Object.create(null);
            for (i = 0; i < aNameCount; ++i) {
              seenNames[aNames[i]] = true;
            }
            for (i = 0; i < bNameCount; ++i) {
              name = bNames[i];
              if (!hasOwn.call(seenNames, name)) {
                problemPath.push(name);
                return false;
              }
              delete seenNames[name];
            }
            for (name in seenNames) {
              problemPath.push(name);
              break;
            }
            return false;
          }
          module.exports = astNodesAreEquivalent;
        }, {
          "../main": 593,
          "assert": 2
        }],
        587: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("./types");
          var n = types.namedTypes;
          var b = types.builders;
          var isNumber = types.builtInTypes.number;
          var isArray = types.builtInTypes.array;
          var Path = require("./path");
          var Scope = require("./scope");
          function NodePath(value, parentPath, name) {
            assert.ok(this instanceof NodePath);
            Path.call(this, value, parentPath, name);
          }
          require("util").inherits(NodePath, Path);
          var NPp = NodePath.prototype;
          Object.defineProperties(NPp, {
            node: {get: function() {
                Object.defineProperty(this, "node", {
                  configurable: true,
                  value: this._computeNode()
                });
                return this.node;
              }},
            parent: {get: function() {
                Object.defineProperty(this, "parent", {
                  configurable: true,
                  value: this._computeParent()
                });
                return this.parent;
              }},
            scope: {get: function() {
                Object.defineProperty(this, "scope", {
                  configurable: true,
                  value: this._computeScope()
                });
                return this.scope;
              }}
          });
          NPp.replace = function() {
            delete this.node;
            delete this.parent;
            delete this.scope;
            return Path.prototype.replace.apply(this, arguments);
          };
          NPp.prune = function() {
            var remainingNodePath = this.parent;
            this.replace();
            return cleanUpNodesAfterPrune(remainingNodePath);
          };
          NPp._computeNode = function() {
            var value = this.value;
            if (n.Node.check(value)) {
              return value;
            }
            var pp = this.parentPath;
            return pp && pp.node || null;
          };
          NPp._computeParent = function() {
            var value = this.value;
            var pp = this.parentPath;
            if (!n.Node.check(value)) {
              while (pp && !n.Node.check(pp.value)) {
                pp = pp.parentPath;
              }
              if (pp) {
                pp = pp.parentPath;
              }
            }
            while (pp && !n.Node.check(pp.value)) {
              pp = pp.parentPath;
            }
            return pp || null;
          };
          NPp._computeScope = function() {
            var value = this.value;
            var pp = this.parentPath;
            var scope = pp && pp.scope;
            if (n.Node.check(value) && Scope.isEstablishedBy(value)) {
              scope = new Scope(this, scope);
            }
            return scope || null;
          };
          NPp.getValueProperty = function(name) {
            return types.getFieldValue(this.value, name);
          };
          NPp.needsParens = function(assumeExpressionContext) {
            var pp = this.parentPath;
            if (!pp) {
              return false;
            }
            var node = this.value;
            if (!n.Expression.check(node)) {
              return false;
            }
            if (node.type === "Identifier") {
              return false;
            }
            while (!n.Node.check(pp.value)) {
              pp = pp.parentPath;
              if (!pp) {
                return false;
              }
            }
            var parent = pp.value;
            switch (node.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return parent.type === "MemberExpression" && this.name === "object" && parent.object === node;
              case "BinaryExpression":
              case "LogicalExpression":
                switch (parent.type) {
                  case "CallExpression":
                    return this.name === "callee" && parent.callee === node;
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                    return true;
                  case "MemberExpression":
                    return this.name === "object" && parent.object === node;
                  case "BinaryExpression":
                  case "LogicalExpression":
                    var po = parent.operator;
                    var pp = PRECEDENCE[po];
                    var no = node.operator;
                    var np = PRECEDENCE[no];
                    if (pp > np) {
                      return true;
                    }
                    if (pp === np && this.name === "right") {
                      assert.strictEqual(parent.right, node);
                      return true;
                    }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (parent.type) {
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return this.name !== "expression";
                  default:
                    return true;
                }
              case "YieldExpression":
                switch (parent.type) {
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "CallExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ConditionalExpression":
                  case "YieldExpression":
                    return true;
                  default:
                    return false;
                }
              case "Literal":
                return parent.type === "MemberExpression" && isNumber.check(node.value) && this.name === "object" && parent.object === node;
              case "AssignmentExpression":
              case "ConditionalExpression":
                switch (parent.type) {
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                    return true;
                  case "CallExpression":
                    return this.name === "callee" && parent.callee === node;
                  case "ConditionalExpression":
                    return this.name === "test" && parent.test === node;
                  case "MemberExpression":
                    return this.name === "object" && parent.object === node;
                  default:
                    return false;
                }
              default:
                if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node) {
                  return containsCallExpression(node);
                }
            }
            if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())
              return true;
            return false;
          };
          function isBinary(node) {
            return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
          }
          function isUnaryLike(node) {
            return n.UnaryExpression.check(node) || (n.SpreadElement && n.SpreadElement.check(node)) || (n.SpreadProperty && n.SpreadProperty.check(node));
          }
          var PRECEDENCE = {};
          [["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"]].forEach(function(tier, i) {
            tier.forEach(function(op) {
              PRECEDENCE[op] = i;
            });
          });
          function containsCallExpression(node) {
            if (n.CallExpression.check(node)) {
              return true;
            }
            if (isArray.check(node)) {
              return node.some(containsCallExpression);
            }
            if (n.Node.check(node)) {
              return types.someField(node, function(name, child) {
                return containsCallExpression(child);
              });
            }
            return false;
          }
          NPp.canBeFirstInStatement = function() {
            var node = this.node;
            return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);
          };
          NPp.firstInStatement = function() {
            return firstInStatement(this);
          };
          function firstInStatement(path) {
            for (var node,
                parent; path.parent; path = path.parent) {
              node = path.node;
              parent = path.parent.node;
              if (n.BlockStatement.check(parent) && path.parent.name === "body" && path.name === 0) {
                assert.strictEqual(parent.body[0], node);
                return true;
              }
              if (n.ExpressionStatement.check(parent) && path.name === "expression") {
                assert.strictEqual(parent.expression, node);
                return true;
              }
              if (n.SequenceExpression.check(parent) && path.parent.name === "expressions" && path.name === 0) {
                assert.strictEqual(parent.expressions[0], node);
                continue;
              }
              if (n.CallExpression.check(parent) && path.name === "callee") {
                assert.strictEqual(parent.callee, node);
                continue;
              }
              if (n.MemberExpression.check(parent) && path.name === "object") {
                assert.strictEqual(parent.object, node);
                continue;
              }
              if (n.ConditionalExpression.check(parent) && path.name === "test") {
                assert.strictEqual(parent.test, node);
                continue;
              }
              if (isBinary(parent) && path.name === "left") {
                assert.strictEqual(parent.left, node);
                continue;
              }
              if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === "argument") {
                assert.strictEqual(parent.argument, node);
                continue;
              }
              return false;
            }
            return true;
          }
          function cleanUpNodesAfterPrune(remainingNodePath) {
            if (n.VariableDeclaration.check(remainingNodePath.node)) {
              var declarations = remainingNodePath.get('declarations').value;
              if (!declarations || declarations.length === 0) {
                return remainingNodePath.prune();
              }
            } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
              if (!remainingNodePath.get('expression').value) {
                return remainingNodePath.prune();
              }
            } else if (n.IfStatement.check(remainingNodePath.node)) {
              cleanUpIfStatementAfterPrune(remainingNodePath);
            }
            return remainingNodePath;
          }
          function cleanUpIfStatementAfterPrune(ifStatement) {
            var testExpression = ifStatement.get('test').value;
            var alternate = ifStatement.get('alternate').value;
            var consequent = ifStatement.get('consequent').value;
            if (!consequent && !alternate) {
              var testExpressionStatement = b.expressionStatement(testExpression);
              ifStatement.replace(testExpressionStatement);
            } else if (!consequent && alternate) {
              var negatedTestExpression = b.unaryExpression('!', testExpression, true);
              if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
                negatedTestExpression = testExpression.argument;
              }
              ifStatement.get("test").replace(negatedTestExpression);
              ifStatement.get("consequent").replace(alternate);
              ifStatement.get("alternate").replace();
            }
          }
          module.exports = NodePath;
        }, {
          "./path": 589,
          "./scope": 590,
          "./types": 592,
          "assert": 2,
          "util": 30
        }],
        588: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("./types");
          var NodePath = require("./node-path");
          var Printable = types.namedTypes.Printable;
          var isArray = types.builtInTypes.array;
          var isObject = types.builtInTypes.object;
          var isFunction = types.builtInTypes.function;
          var hasOwn = Object.prototype.hasOwnProperty;
          var undefined;
          function PathVisitor() {
            assert.ok(this instanceof PathVisitor);
            this._reusableContextStack = [];
            this._methodNameTable = computeMethodNameTable(this);
            this._shouldVisitComments = hasOwn.call(this._methodNameTable, "Block") || hasOwn.call(this._methodNameTable, "Line");
            this.Context = makeContextConstructor(this);
            this._visiting = false;
            this._changeReported = false;
          }
          function computeMethodNameTable(visitor) {
            var typeNames = Object.create(null);
            for (var methodName in visitor) {
              if (/^visit[A-Z]/.test(methodName)) {
                typeNames[methodName.slice("visit".length)] = true;
              }
            }
            var supertypeTable = types.computeSupertypeLookupTable(typeNames);
            var methodNameTable = Object.create(null);
            var typeNames = Object.keys(supertypeTable);
            var typeNameCount = typeNames.length;
            for (var i = 0; i < typeNameCount; ++i) {
              var typeName = typeNames[i];
              methodName = "visit" + supertypeTable[typeName];
              if (isFunction.check(visitor[methodName])) {
                methodNameTable[typeName] = methodName;
              }
            }
            return methodNameTable;
          }
          PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
            if (methods instanceof PathVisitor) {
              return methods;
            }
            if (!isObject.check(methods)) {
              return new PathVisitor;
            }
            function Visitor() {
              assert.ok(this instanceof Visitor);
              PathVisitor.call(this);
            }
            var Vp = Visitor.prototype = Object.create(PVp);
            Vp.constructor = Visitor;
            extend(Vp, methods);
            extend(Visitor, PathVisitor);
            isFunction.assert(Visitor.fromMethodsObject);
            isFunction.assert(Visitor.visit);
            return new Visitor;
          };
          function extend(target, source) {
            for (var property in source) {
              if (hasOwn.call(source, property)) {
                target[property] = source[property];
              }
            }
            return target;
          }
          PathVisitor.visit = function visit(node, methods) {
            return PathVisitor.fromMethodsObject(methods).visit(node);
          };
          var PVp = PathVisitor.prototype;
          var recursiveVisitWarning = ["Recursively calling visitor.visit(path) resets visitor state.", "Try this.visit(path) or this.traverse(path) instead."].join(" ");
          PVp.visit = function() {
            assert.ok(!this._visiting, recursiveVisitWarning);
            this._visiting = true;
            this._changeReported = false;
            this._abortRequested = false;
            var argc = arguments.length;
            var args = new Array(argc);
            for (var i = 0; i < argc; ++i) {
              args[i] = arguments[i];
            }
            if (!(args[0] instanceof NodePath)) {
              args[0] = new NodePath({root: args[0]}).get("root");
            }
            this.reset.apply(this, args);
            try {
              var root = this.visitWithoutReset(args[0]);
              var didNotThrow = true;
            } finally {
              this._visiting = false;
              if (!didNotThrow && this._abortRequested) {
                return args[0].value;
              }
            }
            return root;
          };
          PVp.AbortRequest = function AbortRequest() {};
          PVp.abort = function() {
            var visitor = this;
            visitor._abortRequested = true;
            var request = new visitor.AbortRequest();
            request.cancel = function() {
              visitor._abortRequested = false;
            };
            throw request;
          };
          PVp.reset = function(path) {};
          PVp.visitWithoutReset = function(path) {
            if (this instanceof this.Context) {
              return this.visitor.visitWithoutReset(path);
            }
            assert.ok(path instanceof NodePath);
            var value = path.value;
            var methodName = Printable.check(value) && this._methodNameTable[value.type];
            if (methodName) {
              var context = this.acquireContext(path);
              try {
                return context.invokeVisitorMethod(methodName);
              } finally {
                this.releaseContext(context);
              }
            } else {
              return visitChildren(path, this);
            }
          };
          function visitChildren(path, visitor) {
            assert.ok(path instanceof NodePath);
            assert.ok(visitor instanceof PathVisitor);
            var value = path.value;
            if (isArray.check(value)) {
              path.each(visitor.visitWithoutReset, visitor);
            } else if (!isObject.check(value)) {} else {
              var childNames = types.getFieldNames(value);
              if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) {
                childNames.push("comments");
              }
              var childCount = childNames.length;
              var childPaths = [];
              for (var i = 0; i < childCount; ++i) {
                var childName = childNames[i];
                if (!hasOwn.call(value, childName)) {
                  value[childName] = types.getFieldValue(value, childName);
                }
                childPaths.push(path.get(childName));
              }
              for (var i = 0; i < childCount; ++i) {
                visitor.visitWithoutReset(childPaths[i]);
              }
            }
            return path.value;
          }
          PVp.acquireContext = function(path) {
            if (this._reusableContextStack.length === 0) {
              return new this.Context(path);
            }
            return this._reusableContextStack.pop().reset(path);
          };
          PVp.releaseContext = function(context) {
            assert.ok(context instanceof this.Context);
            this._reusableContextStack.push(context);
            context.currentPath = null;
          };
          PVp.reportChanged = function() {
            this._changeReported = true;
          };
          PVp.wasChangeReported = function() {
            return this._changeReported;
          };
          function makeContextConstructor(visitor) {
            function Context(path) {
              assert.ok(this instanceof Context);
              assert.ok(this instanceof PathVisitor);
              assert.ok(path instanceof NodePath);
              Object.defineProperty(this, "visitor", {
                value: visitor,
                writable: false,
                enumerable: true,
                configurable: false
              });
              this.currentPath = path;
              this.needToCallTraverse = true;
              Object.seal(this);
            }
            assert.ok(visitor instanceof PathVisitor);
            var Cp = Context.prototype = Object.create(visitor);
            Cp.constructor = Context;
            extend(Cp, sharedContextProtoMethods);
            return Context;
          }
          var sharedContextProtoMethods = Object.create(null);
          sharedContextProtoMethods.reset = function reset(path) {
            assert.ok(this instanceof this.Context);
            assert.ok(path instanceof NodePath);
            this.currentPath = path;
            this.needToCallTraverse = true;
            return this;
          };
          sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
            assert.ok(this instanceof this.Context);
            assert.ok(this.currentPath instanceof NodePath);
            var result = this.visitor[methodName].call(this, this.currentPath);
            if (result === false) {
              this.needToCallTraverse = false;
            } else if (result !== undefined) {
              this.currentPath = this.currentPath.replace(result)[0];
              if (this.needToCallTraverse) {
                this.traverse(this.currentPath);
              }
            }
            assert.strictEqual(this.needToCallTraverse, false, "Must either call this.traverse or return false in " + methodName);
            var path = this.currentPath;
            return path && path.value;
          };
          sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {
            assert.ok(this instanceof this.Context);
            assert.ok(path instanceof NodePath);
            assert.ok(this.currentPath instanceof NodePath);
            this.needToCallTraverse = false;
            return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
          };
          sharedContextProtoMethods.visit = function visit(path, newVisitor) {
            assert.ok(this instanceof this.Context);
            assert.ok(path instanceof NodePath);
            assert.ok(this.currentPath instanceof NodePath);
            this.needToCallTraverse = false;
            return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);
          };
          sharedContextProtoMethods.reportChanged = function reportChanged() {
            this.visitor.reportChanged();
          };
          sharedContextProtoMethods.abort = function abort() {
            this.needToCallTraverse = false;
            this.visitor.abort();
          };
          module.exports = PathVisitor;
        }, {
          "./node-path": 587,
          "./types": 592,
          "assert": 2
        }],
        589: [function(require, module, exports) {
          var assert = require("assert");
          var Op = Object.prototype;
          var hasOwn = Op.hasOwnProperty;
          var types = require("./types");
          var isArray = types.builtInTypes.array;
          var isNumber = types.builtInTypes.number;
          var Ap = Array.prototype;
          var slice = Ap.slice;
          var map = Ap.map;
          function Path(value, parentPath, name) {
            assert.ok(this instanceof Path);
            if (parentPath) {
              assert.ok(parentPath instanceof Path);
            } else {
              parentPath = null;
              name = null;
            }
            this.value = value;
            this.parentPath = parentPath;
            this.name = name;
            this.__childCache = null;
          }
          var Pp = Path.prototype;
          function getChildCache(path) {
            return path.__childCache || (path.__childCache = Object.create(null));
          }
          function getChildPath(path, name) {
            var cache = getChildCache(path);
            var actualChildValue = path.getValueProperty(name);
            var childPath = cache[name];
            if (!hasOwn.call(cache, name) || childPath.value !== actualChildValue) {
              childPath = cache[name] = new path.constructor(actualChildValue, path, name);
            }
            return childPath;
          }
          Pp.getValueProperty = function getValueProperty(name) {
            return this.value[name];
          };
          Pp.get = function get(name) {
            var path = this;
            var names = arguments;
            var count = names.length;
            for (var i = 0; i < count; ++i) {
              path = getChildPath(path, names[i]);
            }
            return path;
          };
          Pp.each = function each(callback, context) {
            var childPaths = [];
            var len = this.value.length;
            var i = 0;
            for (var i = 0; i < len; ++i) {
              if (hasOwn.call(this.value, i)) {
                childPaths[i] = this.get(i);
              }
            }
            context = context || this;
            for (i = 0; i < len; ++i) {
              if (hasOwn.call(childPaths, i)) {
                callback.call(context, childPaths[i]);
              }
            }
          };
          Pp.map = function map(callback, context) {
            var result = [];
            this.each(function(childPath) {
              result.push(callback.call(this, childPath));
            }, context);
            return result;
          };
          Pp.filter = function filter(callback, context) {
            var result = [];
            this.each(function(childPath) {
              if (callback.call(this, childPath)) {
                result.push(childPath);
              }
            }, context);
            return result;
          };
          function emptyMoves() {}
          function getMoves(path, offset, start, end) {
            isArray.assert(path.value);
            if (offset === 0) {
              return emptyMoves;
            }
            var length = path.value.length;
            if (length < 1) {
              return emptyMoves;
            }
            var argc = arguments.length;
            if (argc === 2) {
              start = 0;
              end = length;
            } else if (argc === 3) {
              start = Math.max(start, 0);
              end = length;
            } else {
              start = Math.max(start, 0);
              end = Math.min(end, length);
            }
            isNumber.assert(start);
            isNumber.assert(end);
            var moves = Object.create(null);
            var cache = getChildCache(path);
            for (var i = start; i < end; ++i) {
              if (hasOwn.call(path.value, i)) {
                var childPath = path.get(i);
                assert.strictEqual(childPath.name, i);
                var newIndex = i + offset;
                childPath.name = newIndex;
                moves[newIndex] = childPath;
                delete cache[i];
              }
            }
            delete cache.length;
            return function() {
              for (var newIndex in moves) {
                var childPath = moves[newIndex];
                assert.strictEqual(childPath.name, +newIndex);
                cache[newIndex] = childPath;
                path.value[newIndex] = childPath.value;
              }
            };
          }
          Pp.shift = function shift() {
            var move = getMoves(this, -1);
            var result = this.value.shift();
            move();
            return result;
          };
          Pp.unshift = function unshift(node) {
            var move = getMoves(this, arguments.length);
            var result = this.value.unshift.apply(this.value, arguments);
            move();
            return result;
          };
          Pp.push = function push(node) {
            isArray.assert(this.value);
            delete getChildCache(this).length;
            return this.value.push.apply(this.value, arguments);
          };
          Pp.pop = function pop() {
            isArray.assert(this.value);
            var cache = getChildCache(this);
            delete cache[this.value.length - 1];
            delete cache.length;
            return this.value.pop();
          };
          Pp.insertAt = function insertAt(index, node) {
            var argc = arguments.length;
            var move = getMoves(this, argc - 1, index);
            if (move === emptyMoves) {
              return this;
            }
            index = Math.max(index, 0);
            for (var i = 1; i < argc; ++i) {
              this.value[index + i - 1] = arguments[i];
            }
            move();
            return this;
          };
          Pp.insertBefore = function insertBefore(node) {
            var pp = this.parentPath;
            var argc = arguments.length;
            var insertAtArgs = [this.name];
            for (var i = 0; i < argc; ++i) {
              insertAtArgs.push(arguments[i]);
            }
            return pp.insertAt.apply(pp, insertAtArgs);
          };
          Pp.insertAfter = function insertAfter(node) {
            var pp = this.parentPath;
            var argc = arguments.length;
            var insertAtArgs = [this.name + 1];
            for (var i = 0; i < argc; ++i) {
              insertAtArgs.push(arguments[i]);
            }
            return pp.insertAt.apply(pp, insertAtArgs);
          };
          function repairRelationshipWithParent(path) {
            assert.ok(path instanceof Path);
            var pp = path.parentPath;
            if (!pp) {
              return path;
            }
            var parentValue = pp.value;
            var parentCache = getChildCache(pp);
            if (parentValue[path.name] === path.value) {
              parentCache[path.name] = path;
            } else if (isArray.check(parentValue)) {
              var i = parentValue.indexOf(path.value);
              if (i >= 0) {
                parentCache[path.name = i] = path;
              }
            } else {
              parentValue[path.name] = path.value;
              parentCache[path.name] = path;
            }
            assert.strictEqual(parentValue[path.name], path.value);
            assert.strictEqual(path.parentPath.get(path.name), path);
            return path;
          }
          Pp.replace = function replace(replacement) {
            var results = [];
            var parentValue = this.parentPath.value;
            var parentCache = getChildCache(this.parentPath);
            var count = arguments.length;
            repairRelationshipWithParent(this);
            if (isArray.check(parentValue)) {
              var originalLength = parentValue.length;
              var move = getMoves(this.parentPath, count - 1, this.name + 1);
              var spliceArgs = [this.name, 1];
              for (var i = 0; i < count; ++i) {
                spliceArgs.push(arguments[i]);
              }
              var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
              assert.strictEqual(splicedOut[0], this.value);
              assert.strictEqual(parentValue.length, originalLength - 1 + count);
              move();
              if (count === 0) {
                delete this.value;
                delete parentCache[this.name];
                this.__childCache = null;
              } else {
                assert.strictEqual(parentValue[this.name], replacement);
                if (this.value !== replacement) {
                  this.value = replacement;
                  this.__childCache = null;
                }
                for (i = 0; i < count; ++i) {
                  results.push(this.parentPath.get(this.name + i));
                }
                assert.strictEqual(results[0], this);
              }
            } else if (count === 1) {
              if (this.value !== replacement) {
                this.__childCache = null;
              }
              this.value = parentValue[this.name] = replacement;
              results.push(this);
            } else if (count === 0) {
              delete parentValue[this.name];
              delete this.value;
              this.__childCache = null;
            } else {
              assert.ok(false, "Could not replace path");
            }
            return results;
          };
          module.exports = Path;
        }, {
          "./types": 592,
          "assert": 2
        }],
        590: [function(require, module, exports) {
          var assert = require("assert");
          var types = require("./types");
          var Type = types.Type;
          var namedTypes = types.namedTypes;
          var Node = namedTypes.Node;
          var Expression = namedTypes.Expression;
          var isArray = types.builtInTypes.array;
          var hasOwn = Object.prototype.hasOwnProperty;
          var b = types.builders;
          function Scope(path, parentScope) {
            assert.ok(this instanceof Scope);
            assert.ok(path instanceof require("./node-path"));
            ScopeType.assert(path.value);
            var depth;
            if (parentScope) {
              assert.ok(parentScope instanceof Scope);
              depth = parentScope.depth + 1;
            } else {
              parentScope = null;
              depth = 0;
            }
            Object.defineProperties(this, {
              path: {value: path},
              node: {value: path.value},
              isGlobal: {
                value: !parentScope,
                enumerable: true
              },
              depth: {value: depth},
              parent: {value: parentScope},
              bindings: {value: {}}
            });
          }
          var scopeTypes = [namedTypes.Program, namedTypes.Function, namedTypes.CatchClause];
          var ScopeType = Type.or.apply(Type, scopeTypes);
          Scope.isEstablishedBy = function(node) {
            return ScopeType.check(node);
          };
          var Sp = Scope.prototype;
          Sp.didScan = false;
          Sp.declares = function(name) {
            this.scan();
            return hasOwn.call(this.bindings, name);
          };
          Sp.declareTemporary = function(prefix) {
            if (prefix) {
              assert.ok(/^[a-z$_]/i.test(prefix), prefix);
            } else {
              prefix = "t$";
            }
            prefix += this.depth.toString(36) + "$";
            this.scan();
            var index = 0;
            while (this.declares(prefix + index)) {
              ++index;
            }
            var name = prefix + index;
            return this.bindings[name] = types.builders.identifier(name);
          };
          Sp.injectTemporary = function(identifier, init) {
            identifier || (identifier = this.declareTemporary());
            var bodyPath = this.path.get("body");
            if (namedTypes.BlockStatement.check(bodyPath.value)) {
              bodyPath = bodyPath.get("body");
            }
            bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init || null)]));
            return identifier;
          };
          Sp.scan = function(force) {
            if (force || !this.didScan) {
              for (var name in this.bindings) {
                delete this.bindings[name];
              }
              scanScope(this.path, this.bindings);
              this.didScan = true;
            }
          };
          Sp.getBindings = function() {
            this.scan();
            return this.bindings;
          };
          function scanScope(path, bindings) {
            var node = path.value;
            ScopeType.assert(node);
            if (namedTypes.CatchClause.check(node)) {
              addPattern(path.get("param"), bindings);
            } else {
              recursiveScanScope(path, bindings);
            }
          }
          function recursiveScanScope(path, bindings) {
            var node = path.value;
            if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {
              addPattern(path.parent.get("id"), bindings);
            }
            if (!node) {} else if (isArray.check(node)) {
              path.each(function(childPath) {
                recursiveScanChild(childPath, bindings);
              });
            } else if (namedTypes.Function.check(node)) {
              path.get("params").each(function(paramPath) {
                addPattern(paramPath, bindings);
              });
              recursiveScanChild(path.get("body"), bindings);
            } else if (namedTypes.VariableDeclarator.check(node)) {
              addPattern(path.get("id"), bindings);
              recursiveScanChild(path.get("init"), bindings);
            } else if (node.type === "ImportSpecifier" || node.type === "ImportNamespaceSpecifier" || node.type === "ImportDefaultSpecifier") {
              addPattern(path.get(node.local ? "local" : node.name ? "name" : "id"), bindings);
            } else if (Node.check(node) && !Expression.check(node)) {
              types.eachField(node, function(name, child) {
                var childPath = path.get(name);
                assert.strictEqual(childPath.value, child);
                recursiveScanChild(childPath, bindings);
              });
            }
          }
          function recursiveScanChild(path, bindings) {
            var node = path.value;
            if (!node || Expression.check(node)) {} else if (namedTypes.FunctionDeclaration.check(node)) {
              addPattern(path.get("id"), bindings);
            } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node)) {
              addPattern(path.get("id"), bindings);
            } else if (ScopeType.check(node)) {
              if (namedTypes.CatchClause.check(node)) {
                var catchParamName = node.param.name;
                var hadBinding = hasOwn.call(bindings, catchParamName);
                recursiveScanScope(path.get("body"), bindings);
                if (!hadBinding) {
                  delete bindings[catchParamName];
                }
              }
            } else {
              recursiveScanScope(path, bindings);
            }
          }
          function addPattern(patternPath, bindings) {
            var pattern = patternPath.value;
            namedTypes.Pattern.assert(pattern);
            if (namedTypes.Identifier.check(pattern)) {
              if (hasOwn.call(bindings, pattern.name)) {
                bindings[pattern.name].push(patternPath);
              } else {
                bindings[pattern.name] = [patternPath];
              }
            } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {
              patternPath.get('properties').each(function(propertyPath) {
                var property = propertyPath.value;
                if (namedTypes.Pattern.check(property)) {
                  addPattern(propertyPath, bindings);
                } else if (namedTypes.Property.check(property)) {
                  addPattern(propertyPath.get('value'), bindings);
                } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {
                  addPattern(propertyPath.get('argument'), bindings);
                }
              });
            } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {
              patternPath.get('elements').each(function(elementPath) {
                var element = elementPath.value;
                if (namedTypes.Pattern.check(element)) {
                  addPattern(elementPath, bindings);
                } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {
                  addPattern(elementPath.get("argument"), bindings);
                }
              });
            } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {
              addPattern(patternPath.get('pattern'), bindings);
            } else if ((namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern)) || (namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern))) {
              addPattern(patternPath.get('argument'), bindings);
            }
          }
          Sp.lookup = function(name) {
            for (var scope = this; scope; scope = scope.parent)
              if (scope.declares(name))
                break;
            return scope;
          };
          Sp.getGlobalScope = function() {
            var scope = this;
            while (!scope.isGlobal)
              scope = scope.parent;
            return scope;
          };
          module.exports = Scope;
        }, {
          "./node-path": 587,
          "./types": 592,
          "assert": 2
        }],
        591: [function(require, module, exports) {
          var types = require("../lib/types");
          var Type = types.Type;
          var builtin = types.builtInTypes;
          var isNumber = builtin.number;
          exports.geq = function(than) {
            return new Type(function(value) {
              return isNumber.check(value) && value >= than;
            }, isNumber + " >= " + than);
          };
          exports.defaults = {
            "null": function() {
              return null;
            },
            "emptyArray": function() {
              return [];
            },
            "false": function() {
              return false;
            },
            "true": function() {
              return true;
            },
            "undefined": function() {}
          };
          var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
          exports.isPrimitive = new Type(function(value) {
            if (value === null)
              return true;
            var type = typeof value;
            return !(type === "object" || type === "function");
          }, naiveIsPrimitive.toString());
        }, {"../lib/types": 592}],
        592: [function(require, module, exports) {
          var assert = require("assert");
          var Ap = Array.prototype;
          var slice = Ap.slice;
          var map = Ap.map;
          var each = Ap.forEach;
          var Op = Object.prototype;
          var objToStr = Op.toString;
          var funObjStr = objToStr.call(function() {});
          var strObjStr = objToStr.call("");
          var hasOwn = Op.hasOwnProperty;
          function Type(check, name) {
            var self = this;
            assert.ok(self instanceof Type, self);
            assert.strictEqual(objToStr.call(check), funObjStr, check + " is not a function");
            var nameObjStr = objToStr.call(name);
            assert.ok(nameObjStr === funObjStr || nameObjStr === strObjStr, name + " is neither a function nor a string");
            Object.defineProperties(self, {
              name: {value: name},
              check: {value: function(value, deep) {
                  var result = check.call(self, value, deep);
                  if (!result && deep && objToStr.call(deep) === funObjStr)
                    deep(self, value);
                  return result;
                }}
            });
          }
          var Tp = Type.prototype;
          exports.Type = Type;
          Tp.assert = function(value, deep) {
            if (!this.check(value, deep)) {
              var str = shallowStringify(value);
              assert.ok(false, str + " does not match type " + this);
              return false;
            }
            return true;
          };
          function shallowStringify(value) {
            if (isObject.check(value))
              return "{" + Object.keys(value).map(function(key) {
                return key + ": " + value[key];
              }).join(", ") + "}";
            if (isArray.check(value))
              return "[" + value.map(shallowStringify).join(", ") + "]";
            return JSON.stringify(value);
          }
          Tp.toString = function() {
            var name = this.name;
            if (isString.check(name))
              return name;
            if (isFunction.check(name))
              return name.call(this) + "";
            return name + " type";
          };
          var builtInCtorFns = [];
          var builtInCtorTypes = [];
          var builtInTypes = {};
          exports.builtInTypes = builtInTypes;
          function defBuiltInType(example, name) {
            var objStr = objToStr.call(example);
            var type = new Type(function(value) {
              return objToStr.call(value) === objStr;
            }, name);
            builtInTypes[name] = type;
            if (example && typeof example.constructor === "function") {
              builtInCtorFns.push(example.constructor);
              builtInCtorTypes.push(type);
            }
            return type;
          }
          var isString = defBuiltInType("truthy", "string");
          var isFunction = defBuiltInType(function() {}, "function");
          var isArray = defBuiltInType([], "array");
          var isObject = defBuiltInType({}, "object");
          var isRegExp = defBuiltInType(/./, "RegExp");
          var isDate = defBuiltInType(new Date, "Date");
          var isNumber = defBuiltInType(3, "number");
          var isBoolean = defBuiltInType(true, "boolean");
          var isNull = defBuiltInType(null, "null");
          var isUndefined = defBuiltInType(void 0, "undefined");
          function toType(from, name) {
            if (from instanceof Type)
              return from;
            if (from instanceof Def)
              return from.type;
            if (isArray.check(from))
              return Type.fromArray(from);
            if (isObject.check(from))
              return Type.fromObject(from);
            if (isFunction.check(from)) {
              var bicfIndex = builtInCtorFns.indexOf(from);
              if (bicfIndex >= 0) {
                return builtInCtorTypes[bicfIndex];
              }
              return new Type(from, name);
            }
            return new Type(function(value) {
              return value === from;
            }, isUndefined.check(name) ? function() {
              return from + "";
            } : name);
          }
          Type.or = function() {
            var types = [];
            var len = arguments.length;
            for (var i = 0; i < len; ++i)
              types.push(toType(arguments[i]));
            return new Type(function(value, deep) {
              for (var i = 0; i < len; ++i)
                if (types[i].check(value, deep))
                  return true;
              return false;
            }, function() {
              return types.join(" | ");
            });
          };
          Type.fromArray = function(arr) {
            assert.ok(isArray.check(arr));
            assert.strictEqual(arr.length, 1, "only one element type is permitted for typed arrays");
            return toType(arr[0]).arrayOf();
          };
          Tp.arrayOf = function() {
            var elemType = this;
            return new Type(function(value, deep) {
              return isArray.check(value) && value.every(function(elem) {
                return elemType.check(elem, deep);
              });
            }, function() {
              return "[" + elemType + "]";
            });
          };
          Type.fromObject = function(obj) {
            var fields = Object.keys(obj).map(function(name) {
              return new Field(name, obj[name]);
            });
            return new Type(function(value, deep) {
              return isObject.check(value) && fields.every(function(field) {
                return field.type.check(value[field.name], deep);
              });
            }, function() {
              return "{ " + fields.join(", ") + " }";
            });
          };
          function Field(name, type, defaultFn, hidden) {
            var self = this;
            assert.ok(self instanceof Field);
            isString.assert(name);
            type = toType(type);
            var properties = {
              name: {value: name},
              type: {value: type},
              hidden: {value: !!hidden}
            };
            if (isFunction.check(defaultFn)) {
              properties.defaultFn = {value: defaultFn};
            }
            Object.defineProperties(self, properties);
          }
          var Fp = Field.prototype;
          Fp.toString = function() {
            return JSON.stringify(this.name) + ": " + this.type;
          };
          Fp.getValue = function(obj) {
            var value = obj[this.name];
            if (!isUndefined.check(value))
              return value;
            if (this.defaultFn)
              value = this.defaultFn.call(obj);
            return value;
          };
          Type.def = function(typeName) {
            isString.assert(typeName);
            return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new Def(typeName);
          };
          var defCache = Object.create(null);
          function Def(typeName) {
            var self = this;
            assert.ok(self instanceof Def);
            Object.defineProperties(self, {
              typeName: {value: typeName},
              baseNames: {value: []},
              ownFields: {value: Object.create(null)},
              allSupertypes: {value: Object.create(null)},
              supertypeList: {value: []},
              allFields: {value: Object.create(null)},
              fieldNames: {value: []},
              type: {value: new Type(function(value, deep) {
                  return self.check(value, deep);
                }, typeName)}
            });
          }
          Def.fromValue = function(value) {
            if (value && typeof value === "object") {
              var type = value.type;
              if (typeof type === "string" && hasOwn.call(defCache, type)) {
                var d = defCache[type];
                if (d.finalized) {
                  return d;
                }
              }
            }
            return null;
          };
          var Dp = Def.prototype;
          Dp.isSupertypeOf = function(that) {
            if (that instanceof Def) {
              assert.strictEqual(this.finalized, true);
              assert.strictEqual(that.finalized, true);
              return hasOwn.call(that.allSupertypes, this.typeName);
            } else {
              assert.ok(false, that + " is not a Def");
            }
          };
          exports.getSupertypeNames = function(typeName) {
            assert.ok(hasOwn.call(defCache, typeName));
            var d = defCache[typeName];
            assert.strictEqual(d.finalized, true);
            return d.supertypeList.slice(1);
          };
          exports.computeSupertypeLookupTable = function(candidates) {
            var table = {};
            var typeNames = Object.keys(defCache);
            var typeNameCount = typeNames.length;
            for (var i = 0; i < typeNameCount; ++i) {
              var typeName = typeNames[i];
              var d = defCache[typeName];
              assert.strictEqual(d.finalized, true, typeName);
              for (var j = 0; j < d.supertypeList.length; ++j) {
                var superTypeName = d.supertypeList[j];
                if (hasOwn.call(candidates, superTypeName)) {
                  table[typeName] = superTypeName;
                  break;
                }
              }
            }
            return table;
          };
          Dp.checkAllFields = function(value, deep) {
            var allFields = this.allFields;
            assert.strictEqual(this.finalized, true, this.typeName);
            function checkFieldByName(name) {
              var field = allFields[name];
              var type = field.type;
              var child = field.getValue(value);
              return type.check(child, deep);
            }
            return isObject.check(value) && Object.keys(allFields).every(checkFieldByName);
          };
          Dp.check = function(value, deep) {
            assert.strictEqual(this.finalized, true, "prematurely checking unfinalized type " + this.typeName);
            if (!isObject.check(value))
              return false;
            var vDef = Def.fromValue(value);
            if (!vDef) {
              if (this.typeName === "SourceLocation" || this.typeName === "Position") {
                return this.checkAllFields(value, deep);
              }
              return false;
            }
            if (deep && vDef === this)
              return this.checkAllFields(value, deep);
            if (!this.isSupertypeOf(vDef))
              return false;
            if (!deep)
              return true;
            return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
          };
          Dp.bases = function() {
            var args = slice.call(arguments);
            var bases = this.baseNames;
            if (this.finalized) {
              assert.deepEqual(args, bases);
              return this;
            }
            args.forEach(function(baseName) {
              isString.assert(baseName);
              if (bases.indexOf(baseName) < 0)
                bases.push(baseName);
            });
            return this;
          };
          Object.defineProperty(Dp, "buildable", {value: false});
          var builders = {};
          exports.builders = builders;
          var nodePrototype = {};
          exports.defineMethod = function(name, func) {
            var old = nodePrototype[name];
            if (isUndefined.check(func)) {
              delete nodePrototype[name];
            } else {
              isFunction.assert(func);
              Object.defineProperty(nodePrototype, name, {
                enumerable: true,
                configurable: true,
                value: func
              });
            }
            return old;
          };
          var isArrayOfString = isString.arrayOf();
          Dp.build = function() {
            var self = this;
            var newBuildParams = slice.call(arguments);
            isArrayOfString.assert(newBuildParams);
            Object.defineProperty(self, "buildParams", {
              value: newBuildParams,
              writable: false,
              enumerable: false,
              configurable: true
            });
            if (self.buildable) {
              return self;
            }
            self.field("type", String, function() {
              return self.typeName;
            });
            Object.defineProperty(self, "buildable", {value: true});
            Object.defineProperty(builders, getBuilderName(self.typeName), {
              enumerable: true,
              value: function() {
                var args = arguments;
                var argc = args.length;
                var built = Object.create(nodePrototype);
                assert.ok(self.finalized, "attempting to instantiate unfinalized type " + self.typeName);
                function add(param, i) {
                  if (hasOwn.call(built, param))
                    return;
                  var all = self.allFields;
                  assert.ok(hasOwn.call(all, param), param);
                  var field = all[param];
                  var type = field.type;
                  var value;
                  if (isNumber.check(i) && i < argc) {
                    value = args[i];
                  } else if (field.defaultFn) {
                    value = field.defaultFn.call(built);
                  } else {
                    var message = "no value or default function given for field " + JSON.stringify(param) + " of " + self.typeName + "(" + self.buildParams.map(function(name) {
                      return all[name];
                    }).join(", ") + ")";
                    assert.ok(false, message);
                  }
                  if (!type.check(value)) {
                    assert.ok(false, shallowStringify(value) + " does not match field " + field + " of type " + self.typeName);
                  }
                  built[param] = value;
                }
                self.buildParams.forEach(function(param, i) {
                  add(param, i);
                });
                Object.keys(self.allFields).forEach(function(param) {
                  add(param);
                });
                assert.strictEqual(built.type, self.typeName);
                return built;
              }
            });
            return self;
          };
          function getBuilderName(typeName) {
            return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
              var len = upperCasePrefix.length;
              switch (len) {
                case 0:
                  return "";
                case 1:
                  return upperCasePrefix.toLowerCase();
                default:
                  return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
              }
            });
          }
          exports.getBuilderName = getBuilderName;
          function getStatementBuilderName(typeName) {
            typeName = getBuilderName(typeName);
            return typeName.replace(/(Expression)?$/, "Statement");
          }
          exports.getStatementBuilderName = getStatementBuilderName;
          Dp.field = function(name, type, defaultFn, hidden) {
            if (this.finalized) {
              console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName));
              return this;
            }
            this.ownFields[name] = new Field(name, type, defaultFn, hidden);
            return this;
          };
          var namedTypes = {};
          exports.namedTypes = namedTypes;
          function getFieldNames(object) {
            var d = Def.fromValue(object);
            if (d) {
              return d.fieldNames.slice(0);
            }
            if ("type" in object) {
              assert.ok(false, "did not recognize object of type " + JSON.stringify(object.type));
            }
            return Object.keys(object);
          }
          exports.getFieldNames = getFieldNames;
          function getFieldValue(object, fieldName) {
            var d = Def.fromValue(object);
            if (d) {
              var field = d.allFields[fieldName];
              if (field) {
                return field.getValue(object);
              }
            }
            return object[fieldName];
          }
          exports.getFieldValue = getFieldValue;
          exports.eachField = function(object, callback, context) {
            getFieldNames(object).forEach(function(name) {
              callback.call(this, name, getFieldValue(object, name));
            }, context);
          };
          exports.someField = function(object, callback, context) {
            return getFieldNames(object).some(function(name) {
              return callback.call(this, name, getFieldValue(object, name));
            }, context);
          };
          Object.defineProperty(Dp, "finalized", {value: false});
          Dp.finalize = function() {
            var self = this;
            if (!self.finalized) {
              var allFields = self.allFields;
              var allSupertypes = self.allSupertypes;
              self.baseNames.forEach(function(name) {
                var def = defCache[name];
                if (def instanceof Def) {
                  def.finalize();
                  extend(allFields, def.allFields);
                  extend(allSupertypes, def.allSupertypes);
                } else {
                  var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(self.typeName);
                  assert.ok(false, message);
                }
              });
              extend(allFields, self.ownFields);
              allSupertypes[self.typeName] = self;
              self.fieldNames.length = 0;
              for (var fieldName in allFields) {
                if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {
                  self.fieldNames.push(fieldName);
                }
              }
              Object.defineProperty(namedTypes, self.typeName, {
                enumerable: true,
                value: self.type
              });
              Object.defineProperty(self, "finalized", {value: true});
              populateSupertypeList(self.typeName, self.supertypeList);
              if (self.buildable && self.supertypeList.lastIndexOf("Expression") >= 0) {
                wrapExpressionBuilderWithStatement(self.typeName);
              }
            }
          };
          function wrapExpressionBuilderWithStatement(typeName) {
            var wrapperName = getStatementBuilderName(typeName);
            if (builders[wrapperName])
              return;
            var wrapped = builders[getBuilderName(typeName)];
            if (!wrapped)
              return;
            builders[wrapperName] = function() {
              return builders.expressionStatement(wrapped.apply(builders, arguments));
            };
          }
          function populateSupertypeList(typeName, list) {
            list.length = 0;
            list.push(typeName);
            var lastSeen = Object.create(null);
            for (var pos = 0; pos < list.length; ++pos) {
              typeName = list[pos];
              var d = defCache[typeName];
              assert.strictEqual(d.finalized, true);
              if (hasOwn.call(lastSeen, typeName)) {
                delete list[lastSeen[typeName]];
              }
              lastSeen[typeName] = pos;
              list.push.apply(list, d.baseNames);
            }
            for (var to = 0,
                from = to,
                len = list.length; from < len; ++from) {
              if (hasOwn.call(list, from)) {
                list[to++] = list[from];
              }
            }
            list.length = to;
          }
          function extend(into, from) {
            Object.keys(from).forEach(function(name) {
              into[name] = from[name];
            });
            return into;
          }
          ;
          exports.finalize = function() {
            Object.keys(defCache).forEach(function(name) {
              defCache[name].finalize();
            });
          };
        }, {"assert": 2}],
        593: [function(require, module, exports) {
          var types = require("./lib/types");
          require("./def/core");
          require("./def/es6");
          require("./def/es7");
          require("./def/mozilla");
          require("./def/e4x");
          require("./def/fb-harmony");
          require("./def/esprima");
          require("./def/babel");
          types.finalize();
          exports.Type = types.Type;
          exports.builtInTypes = types.builtInTypes;
          exports.namedTypes = types.namedTypes;
          exports.builders = types.builders;
          exports.defineMethod = types.defineMethod;
          exports.getFieldNames = types.getFieldNames;
          exports.getFieldValue = types.getFieldValue;
          exports.eachField = types.eachField;
          exports.someField = types.someField;
          exports.getSupertypeNames = types.getSupertypeNames;
          exports.astNodesAreEquivalent = require("./lib/equiv");
          exports.finalize = types.finalize;
          exports.NodePath = require("./lib/node-path");
          exports.PathVisitor = require("./lib/path-visitor");
          exports.visit = exports.PathVisitor.visit;
        }, {
          "./def/babel": 578,
          "./def/core": 579,
          "./def/e4x": 580,
          "./def/es6": 581,
          "./def/es7": 582,
          "./def/esprima": 583,
          "./def/fb-harmony": 584,
          "./def/mozilla": 585,
          "./lib/equiv": 586,
          "./lib/node-path": 587,
          "./lib/path-visitor": 588,
          "./lib/types": 592
        }],
        594: [function(require, module, exports) {
          (function(process) {
            var Stream = require('stream');
            exports = module.exports = through;
            through.through = through;
            function through(write, end, opts) {
              write = write || function(data) {
                this.queue(data);
              };
              end = end || function() {
                this.queue(null);
              };
              var ended = false,
                  destroyed = false,
                  buffer = [],
                  _ended = false;
              var stream = new Stream();
              stream.readable = stream.writable = true;
              stream.paused = false;
              stream.autoDestroy = !(opts && opts.autoDestroy === false);
              stream.write = function(data) {
                write.call(this, data);
                return !stream.paused;
              };
              function drain() {
                while (buffer.length && !stream.paused) {
                  var data = buffer.shift();
                  if (null === data)
                    return stream.emit('end');
                  else
                    stream.emit('data', data);
                }
              }
              stream.queue = stream.push = function(data) {
                if (_ended)
                  return stream;
                if (data === null)
                  _ended = true;
                buffer.push(data);
                drain();
                return stream;
              };
              stream.on('end', function() {
                stream.readable = false;
                if (!stream.writable && stream.autoDestroy)
                  process.nextTick(function() {
                    stream.destroy();
                  });
              });
              function _end() {
                stream.writable = false;
                end.call(stream);
                if (!stream.readable && stream.autoDestroy)
                  stream.destroy();
              }
              stream.end = function(data) {
                if (ended)
                  return;
                ended = true;
                if (arguments.length)
                  stream.write(data);
                _end();
                return stream;
              };
              stream.destroy = function() {
                if (destroyed)
                  return;
                destroyed = true;
                ended = true;
                buffer.length = 0;
                stream.writable = stream.readable = false;
                stream.emit('close');
                return stream;
              };
              stream.pause = function() {
                if (stream.paused)
                  return;
                stream.paused = true;
                return stream;
              };
              stream.resume = function() {
                if (stream.paused) {
                  stream.paused = false;
                  stream.emit('resume');
                }
                drain();
                if (!stream.paused)
                  stream.emit('drain');
                return stream;
              };
              return stream;
            }
          }).call(this, require('_process'));
        }, {
          "_process": 12,
          "stream": 26
        }],
        595: [function(require, module, exports) {
          (function(process, global) {
            !(function(global) {
              "use strict";
              var hasOwn = Object.prototype.hasOwnProperty;
              var undefined;
              var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator || "@@iterator";
              var inModule = typeof module === "object";
              var runtime = global.regeneratorRuntime;
              if (runtime) {
                if (inModule) {
                  module.exports = runtime;
                }
                return;
              }
              runtime = global.regeneratorRuntime = inModule ? module.exports : {};
              function wrap(innerFn, outerFn, self, tryLocsList) {
                var generator = Object.create((outerFn || Generator).prototype);
                generator._invoke = makeInvokeMethod(innerFn, self || null, new Context(tryLocsList || []));
                return generator;
              }
              runtime.wrap = wrap;
              function tryCatch(fn, obj, arg) {
                try {
                  return {
                    type: "normal",
                    arg: fn.call(obj, arg)
                  };
                } catch (err) {
                  return {
                    type: "throw",
                    arg: err
                  };
                }
              }
              var GenStateSuspendedStart = "suspendedStart";
              var GenStateSuspendedYield = "suspendedYield";
              var GenStateExecuting = "executing";
              var GenStateCompleted = "completed";
              var ContinueSentinel = {};
              function Generator() {}
              function GeneratorFunction() {}
              function GeneratorFunctionPrototype() {}
              var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
              GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
              GeneratorFunctionPrototype.constructor = GeneratorFunction;
              GeneratorFunction.displayName = "GeneratorFunction";
              function defineIteratorMethods(prototype) {
                ["next", "throw", "return"].forEach(function(method) {
                  prototype[method] = function(arg) {
                    return this._invoke(method, arg);
                  };
                });
              }
              runtime.isGeneratorFunction = function(genFun) {
                var ctor = typeof genFun === "function" && genFun.constructor;
                return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
              };
              runtime.mark = function(genFun) {
                genFun.__proto__ = GeneratorFunctionPrototype;
                genFun.prototype = Object.create(Gp);
                return genFun;
              };
              runtime.awrap = function(arg) {
                return new AwaitArgument(arg);
              };
              function AwaitArgument(arg) {
                this.arg = arg;
              }
              function AsyncIterator(generator) {
                function invoke(method, arg) {
                  var result = generator[method](arg);
                  var value = result.value;
                  return value instanceof AwaitArgument ? Promise.resolve(value.arg).then(invokeNext, invokeThrow) : Promise.resolve(value).then(function(unwrapped) {
                    result.value = unwrapped;
                    return result;
                  });
                }
                if (typeof process === "object" && process.domain) {
                  invoke = process.domain.bind(invoke);
                }
                var invokeNext = invoke.bind(generator, "next");
                var invokeThrow = invoke.bind(generator, "throw");
                var invokeReturn = invoke.bind(generator, "return");
                var previousPromise;
                function enqueue(method, arg) {
                  var enqueueResult = previousPromise ? previousPromise.then(function() {
                    return invoke(method, arg);
                  }) : new Promise(function(resolve) {
                    resolve(invoke(method, arg));
                  });
                  previousPromise = enqueueResult["catch"](function(ignored) {});
                  return enqueueResult;
                }
                this._invoke = enqueue;
              }
              defineIteratorMethods(AsyncIterator.prototype);
              runtime.async = function(innerFn, outerFn, self, tryLocsList) {
                var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
                return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                  return result.done ? result.value : iter.next();
                });
              };
              function makeInvokeMethod(innerFn, self, context) {
                var state = GenStateSuspendedStart;
                return function invoke(method, arg) {
                  if (state === GenStateExecuting) {
                    throw new Error("Generator is already running");
                  }
                  if (state === GenStateCompleted) {
                    if (method === "throw") {
                      throw arg;
                    }
                    return doneResult();
                  }
                  while (true) {
                    var delegate = context.delegate;
                    if (delegate) {
                      if (method === "return" || (method === "throw" && delegate.iterator[method] === undefined)) {
                        context.delegate = null;
                        var returnMethod = delegate.iterator["return"];
                        if (returnMethod) {
                          var record = tryCatch(returnMethod, delegate.iterator, arg);
                          if (record.type === "throw") {
                            method = "throw";
                            arg = record.arg;
                            continue;
                          }
                        }
                        if (method === "return") {
                          continue;
                        }
                      }
                      var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);
                      if (record.type === "throw") {
                        context.delegate = null;
                        method = "throw";
                        arg = record.arg;
                        continue;
                      }
                      method = "next";
                      arg = undefined;
                      var info = record.arg;
                      if (info.done) {
                        context[delegate.resultName] = info.value;
                        context.next = delegate.nextLoc;
                      } else {
                        state = GenStateSuspendedYield;
                        return info;
                      }
                      context.delegate = null;
                    }
                    if (method === "next") {
                      if (state === GenStateSuspendedYield) {
                        context.sent = arg;
                      } else {
                        context.sent = undefined;
                      }
                    } else if (method === "throw") {
                      if (state === GenStateSuspendedStart) {
                        state = GenStateCompleted;
                        throw arg;
                      }
                      if (context.dispatchException(arg)) {
                        method = "next";
                        arg = undefined;
                      }
                    } else if (method === "return") {
                      context.abrupt("return", arg);
                    }
                    state = GenStateExecuting;
                    var record = tryCatch(innerFn, self, context);
                    if (record.type === "normal") {
                      state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                      var info = {
                        value: record.arg,
                        done: context.done
                      };
                      if (record.arg === ContinueSentinel) {
                        if (context.delegate && method === "next") {
                          arg = undefined;
                        }
                      } else {
                        return info;
                      }
                    } else if (record.type === "throw") {
                      state = GenStateCompleted;
                      method = "throw";
                      arg = record.arg;
                    }
                  }
                };
              }
              defineIteratorMethods(Gp);
              Gp[iteratorSymbol] = function() {
                return this;
              };
              Gp.toString = function() {
                return "[object Generator]";
              };
              function pushTryEntry(locs) {
                var entry = {tryLoc: locs[0]};
                if (1 in locs) {
                  entry.catchLoc = locs[1];
                }
                if (2 in locs) {
                  entry.finallyLoc = locs[2];
                  entry.afterLoc = locs[3];
                }
                this.tryEntries.push(entry);
              }
              function resetTryEntry(entry) {
                var record = entry.completion || {};
                record.type = "normal";
                delete record.arg;
                entry.completion = record;
              }
              function Context(tryLocsList) {
                this.tryEntries = [{tryLoc: "root"}];
                tryLocsList.forEach(pushTryEntry, this);
                this.reset(true);
              }
              runtime.keys = function(object) {
                var keys = [];
                for (var key in object) {
                  keys.push(key);
                }
                keys.reverse();
                return function next() {
                  while (keys.length) {
                    var key = keys.pop();
                    if (key in object) {
                      next.value = key;
                      next.done = false;
                      return next;
                    }
                  }
                  next.done = true;
                  return next;
                };
              };
              function values(iterable) {
                if (iterable) {
                  var iteratorMethod = iterable[iteratorSymbol];
                  if (iteratorMethod) {
                    return iteratorMethod.call(iterable);
                  }
                  if (typeof iterable.next === "function") {
                    return iterable;
                  }
                  if (!isNaN(iterable.length)) {
                    var i = -1,
                        next = function next() {
                          while (++i < iterable.length) {
                            if (hasOwn.call(iterable, i)) {
                              next.value = iterable[i];
                              next.done = false;
                              return next;
                            }
                          }
                          next.value = undefined;
                          next.done = true;
                          return next;
                        };
                    return next.next = next;
                  }
                }
                return {next: doneResult};
              }
              runtime.values = values;
              function doneResult() {
                return {
                  value: undefined,
                  done: true
                };
              }
              Context.prototype = {
                constructor: Context,
                reset: function(skipTempReset) {
                  this.prev = 0;
                  this.next = 0;
                  this.sent = undefined;
                  this.done = false;
                  this.delegate = null;
                  this.tryEntries.forEach(resetTryEntry);
                  if (!skipTempReset) {
                    for (var name in this) {
                      if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                        this[name] = undefined;
                      }
                    }
                  }
                },
                stop: function() {
                  this.done = true;
                  var rootEntry = this.tryEntries[0];
                  var rootRecord = rootEntry.completion;
                  if (rootRecord.type === "throw") {
                    throw rootRecord.arg;
                  }
                  return this.rval;
                },
                dispatchException: function(exception) {
                  if (this.done) {
                    throw exception;
                  }
                  var context = this;
                  function handle(loc, caught) {
                    record.type = "throw";
                    record.arg = exception;
                    context.next = loc;
                    return !!caught;
                  }
                  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    var record = entry.completion;
                    if (entry.tryLoc === "root") {
                      return handle("end");
                    }
                    if (entry.tryLoc <= this.prev) {
                      var hasCatch = hasOwn.call(entry, "catchLoc");
                      var hasFinally = hasOwn.call(entry, "finallyLoc");
                      if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) {
                          return handle(entry.catchLoc, true);
                        } else if (this.prev < entry.finallyLoc) {
                          return handle(entry.finallyLoc);
                        }
                      } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) {
                          return handle(entry.catchLoc, true);
                        }
                      } else if (hasFinally) {
                        if (this.prev < entry.finallyLoc) {
                          return handle(entry.finallyLoc);
                        }
                      } else {
                        throw new Error("try statement without catch or finally");
                      }
                    }
                  }
                },
                abrupt: function(type, arg) {
                  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                      var finallyEntry = entry;
                      break;
                    }
                  }
                  if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                    finallyEntry = null;
                  }
                  var record = finallyEntry ? finallyEntry.completion : {};
                  record.type = type;
                  record.arg = arg;
                  if (finallyEntry) {
                    this.next = finallyEntry.finallyLoc;
                  } else {
                    this.complete(record);
                  }
                  return ContinueSentinel;
                },
                complete: function(record, afterLoc) {
                  if (record.type === "throw") {
                    throw record.arg;
                  }
                  if (record.type === "break" || record.type === "continue") {
                    this.next = record.arg;
                  } else if (record.type === "return") {
                    this.rval = record.arg;
                    this.next = "end";
                  } else if (record.type === "normal" && afterLoc) {
                    this.next = afterLoc;
                  }
                },
                finish: function(finallyLoc) {
                  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.finallyLoc === finallyLoc) {
                      this.complete(entry.completion, entry.afterLoc);
                      resetTryEntry(entry);
                      return ContinueSentinel;
                    }
                  }
                },
                "catch": function(tryLoc) {
                  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.tryLoc === tryLoc) {
                      var record = entry.completion;
                      if (record.type === "throw") {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                      }
                      return thrown;
                    }
                  }
                  throw new Error("illegal catch attempt");
                },
                delegateYield: function(iterable, resultName, nextLoc) {
                  this.delegate = {
                    iterator: values(iterable),
                    resultName: resultName,
                    nextLoc: nextLoc
                  };
                  return ContinueSentinel;
                }
              };
            })(typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this);
          }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {"_process": 12}],
        596: [function(require, module, exports) {
          var regenerate = require('regenerate');
          exports.REGULAR = {
            'd': regenerate().addRange(0x30, 0x39),
            'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF),
            's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),
            'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF),
            'w': regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),
            'W': regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)
          };
          exports.UNICODE = {
            'd': regenerate().addRange(0x30, 0x39),
            'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF),
            's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),
            'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF),
            'w': regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),
            'W': regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)
          };
          exports.UNICODE_IGNORE_CASE = {
            'd': regenerate().addRange(0x30, 0x39),
            'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF),
            's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),
            'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF),
            'w': regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),
            'W': regenerate(0x4B, 0x53, 0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)
          };
        }, {"regenerate": 598}],
        597: [function(require, module, exports) {
          module.exports = {
            "75": 8490,
            "83": 383,
            "107": 8490,
            "115": 383,
            "181": 924,
            "197": 8491,
            "383": 83,
            "452": 453,
            "453": 452,
            "455": 456,
            "456": 455,
            "458": 459,
            "459": 458,
            "497": 498,
            "498": 497,
            "837": 8126,
            "914": 976,
            "917": 1013,
            "920": 1012,
            "921": 8126,
            "922": 1008,
            "924": 181,
            "928": 982,
            "929": 1009,
            "931": 962,
            "934": 981,
            "937": 8486,
            "962": 931,
            "976": 914,
            "977": 1012,
            "981": 934,
            "982": 928,
            "1008": 922,
            "1009": 929,
            "1012": [920, 977],
            "1013": 917,
            "7776": 7835,
            "7835": 7776,
            "8126": [837, 921],
            "8486": 937,
            "8490": 75,
            "8491": 197,
            "66560": 66600,
            "66561": 66601,
            "66562": 66602,
            "66563": 66603,
            "66564": 66604,
            "66565": 66605,
            "66566": 66606,
            "66567": 66607,
            "66568": 66608,
            "66569": 66609,
            "66570": 66610,
            "66571": 66611,
            "66572": 66612,
            "66573": 66613,
            "66574": 66614,
            "66575": 66615,
            "66576": 66616,
            "66577": 66617,
            "66578": 66618,
            "66579": 66619,
            "66580": 66620,
            "66581": 66621,
            "66582": 66622,
            "66583": 66623,
            "66584": 66624,
            "66585": 66625,
            "66586": 66626,
            "66587": 66627,
            "66588": 66628,
            "66589": 66629,
            "66590": 66630,
            "66591": 66631,
            "66592": 66632,
            "66593": 66633,
            "66594": 66634,
            "66595": 66635,
            "66596": 66636,
            "66597": 66637,
            "66598": 66638,
            "66599": 66639,
            "66600": 66560,
            "66601": 66561,
            "66602": 66562,
            "66603": 66563,
            "66604": 66564,
            "66605": 66565,
            "66606": 66566,
            "66607": 66567,
            "66608": 66568,
            "66609": 66569,
            "66610": 66570,
            "66611": 66571,
            "66612": 66572,
            "66613": 66573,
            "66614": 66574,
            "66615": 66575,
            "66616": 66576,
            "66617": 66577,
            "66618": 66578,
            "66619": 66579,
            "66620": 66580,
            "66621": 66581,
            "66622": 66582,
            "66623": 66583,
            "66624": 66584,
            "66625": 66585,
            "66626": 66586,
            "66627": 66587,
            "66628": 66588,
            "66629": 66589,
            "66630": 66590,
            "66631": 66591,
            "66632": 66592,
            "66633": 66593,
            "66634": 66594,
            "66635": 66595,
            "66636": 66596,
            "66637": 66597,
            "66638": 66598,
            "66639": 66599,
            "68736": 68800,
            "68737": 68801,
            "68738": 68802,
            "68739": 68803,
            "68740": 68804,
            "68741": 68805,
            "68742": 68806,
            "68743": 68807,
            "68744": 68808,
            "68745": 68809,
            "68746": 68810,
            "68747": 68811,
            "68748": 68812,
            "68749": 68813,
            "68750": 68814,
            "68751": 68815,
            "68752": 68816,
            "68753": 68817,
            "68754": 68818,
            "68755": 68819,
            "68756": 68820,
            "68757": 68821,
            "68758": 68822,
            "68759": 68823,
            "68760": 68824,
            "68761": 68825,
            "68762": 68826,
            "68763": 68827,
            "68764": 68828,
            "68765": 68829,
            "68766": 68830,
            "68767": 68831,
            "68768": 68832,
            "68769": 68833,
            "68770": 68834,
            "68771": 68835,
            "68772": 68836,
            "68773": 68837,
            "68774": 68838,
            "68775": 68839,
            "68776": 68840,
            "68777": 68841,
            "68778": 68842,
            "68779": 68843,
            "68780": 68844,
            "68781": 68845,
            "68782": 68846,
            "68783": 68847,
            "68784": 68848,
            "68785": 68849,
            "68786": 68850,
            "68800": 68736,
            "68801": 68737,
            "68802": 68738,
            "68803": 68739,
            "68804": 68740,
            "68805": 68741,
            "68806": 68742,
            "68807": 68743,
            "68808": 68744,
            "68809": 68745,
            "68810": 68746,
            "68811": 68747,
            "68812": 68748,
            "68813": 68749,
            "68814": 68750,
            "68815": 68751,
            "68816": 68752,
            "68817": 68753,
            "68818": 68754,
            "68819": 68755,
            "68820": 68756,
            "68821": 68757,
            "68822": 68758,
            "68823": 68759,
            "68824": 68760,
            "68825": 68761,
            "68826": 68762,
            "68827": 68763,
            "68828": 68764,
            "68829": 68765,
            "68830": 68766,
            "68831": 68767,
            "68832": 68768,
            "68833": 68769,
            "68834": 68770,
            "68835": 68771,
            "68836": 68772,
            "68837": 68773,
            "68838": 68774,
            "68839": 68775,
            "68840": 68776,
            "68841": 68777,
            "68842": 68778,
            "68843": 68779,
            "68844": 68780,
            "68845": 68781,
            "68846": 68782,
            "68847": 68783,
            "68848": 68784,
            "68849": 68785,
            "68850": 68786,
            "71840": 71872,
            "71841": 71873,
            "71842": 71874,
            "71843": 71875,
            "71844": 71876,
            "71845": 71877,
            "71846": 71878,
            "71847": 71879,
            "71848": 71880,
            "71849": 71881,
            "71850": 71882,
            "71851": 71883,
            "71852": 71884,
            "71853": 71885,
            "71854": 71886,
            "71855": 71887,
            "71856": 71888,
            "71857": 71889,
            "71858": 71890,
            "71859": 71891,
            "71860": 71892,
            "71861": 71893,
            "71862": 71894,
            "71863": 71895,
            "71864": 71896,
            "71865": 71897,
            "71866": 71898,
            "71867": 71899,
            "71868": 71900,
            "71869": 71901,
            "71870": 71902,
            "71871": 71903,
            "71872": 71840,
            "71873": 71841,
            "71874": 71842,
            "71875": 71843,
            "71876": 71844,
            "71877": 71845,
            "71878": 71846,
            "71879": 71847,
            "71880": 71848,
            "71881": 71849,
            "71882": 71850,
            "71883": 71851,
            "71884": 71852,
            "71885": 71853,
            "71886": 71854,
            "71887": 71855,
            "71888": 71856,
            "71889": 71857,
            "71890": 71858,
            "71891": 71859,
            "71892": 71860,
            "71893": 71861,
            "71894": 71862,
            "71895": 71863,
            "71896": 71864,
            "71897": 71865,
            "71898": 71866,
            "71899": 71867,
            "71900": 71868,
            "71901": 71869,
            "71902": 71870,
            "71903": 71871
          };
        }, {}],
        598: [function(require, module, exports) {
          (function(global) {
            ;
            (function(root) {
              var freeExports = typeof exports == 'object' && exports;
              var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
              var freeGlobal = typeof global == 'object' && global;
              if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                root = freeGlobal;
              }
              var ERRORS = {
                'rangeOrder': 'A range\u2019s `stop` value must be greater than or equal ' + 'to the `start` value.',
                'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'
              };
              var HIGH_SURROGATE_MIN = 0xD800;
              var HIGH_SURROGATE_MAX = 0xDBFF;
              var LOW_SURROGATE_MIN = 0xDC00;
              var LOW_SURROGATE_MAX = 0xDFFF;
              var regexNull = /\\x00([^0123456789]|$)/g;
              var object = {};
              var hasOwnProperty = object.hasOwnProperty;
              var extend = function(destination, source) {
                var key;
                for (key in source) {
                  if (hasOwnProperty.call(source, key)) {
                    destination[key] = source[key];
                  }
                }
                return destination;
              };
              var forEach = function(array, callback) {
                var index = -1;
                var length = array.length;
                while (++index < length) {
                  callback(array[index], index);
                }
              };
              var toString = object.toString;
              var isArray = function(value) {
                return toString.call(value) == '[object Array]';
              };
              var isNumber = function(value) {
                return typeof value == 'number' || toString.call(value) == '[object Number]';
              };
              var zeroes = '0000';
              var pad = function(number, totalCharacters) {
                var string = String(number);
                return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
              };
              var hex = function(number) {
                return Number(number).toString(16).toUpperCase();
              };
              var slice = [].slice;
              var dataFromCodePoints = function(codePoints) {
                var index = -1;
                var length = codePoints.length;
                var max = length - 1;
                var result = [];
                var isStart = true;
                var tmp;
                var previous = 0;
                while (++index < length) {
                  tmp = codePoints[index];
                  if (isStart) {
                    result.push(tmp);
                    previous = tmp;
                    isStart = false;
                  } else {
                    if (tmp == previous + 1) {
                      if (index != max) {
                        previous = tmp;
                        continue;
                      } else {
                        isStart = true;
                        result.push(tmp + 1);
                      }
                    } else {
                      result.push(previous + 1, tmp);
                      previous = tmp;
                    }
                  }
                }
                if (!isStart) {
                  result.push(tmp + 1);
                }
                return result;
              };
              var dataRemove = function(data, codePoint) {
                var index = 0;
                var start;
                var end;
                var length = data.length;
                while (index < length) {
                  start = data[index];
                  end = data[index + 1];
                  if (codePoint >= start && codePoint < end) {
                    if (codePoint == start) {
                      if (end == start + 1) {
                        data.splice(index, 2);
                        return data;
                      } else {
                        data[index] = codePoint + 1;
                        return data;
                      }
                    } else if (codePoint == end - 1) {
                      data[index + 1] = codePoint;
                      return data;
                    } else {
                      data.splice(index, 2, start, codePoint, codePoint + 1, end);
                      return data;
                    }
                  }
                  index += 2;
                }
                return data;
              };
              var dataRemoveRange = function(data, rangeStart, rangeEnd) {
                if (rangeEnd < rangeStart) {
                  throw Error(ERRORS.rangeOrder);
                }
                var index = 0;
                var start;
                var end;
                while (index < data.length) {
                  start = data[index];
                  end = data[index + 1] - 1;
                  if (start > rangeEnd) {
                    return data;
                  }
                  if (rangeStart <= start && rangeEnd >= end) {
                    data.splice(index, 2);
                    continue;
                  }
                  if (rangeStart >= start && rangeEnd < end) {
                    if (rangeStart == start) {
                      data[index] = rangeEnd + 1;
                      data[index + 1] = end + 1;
                      return data;
                    }
                    data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
                    return data;
                  }
                  if (rangeStart >= start && rangeStart <= end) {
                    data[index + 1] = rangeStart;
                  } else if (rangeEnd >= start && rangeEnd <= end) {
                    data[index] = rangeEnd + 1;
                    return data;
                  }
                  index += 2;
                }
                return data;
              };
              var dataAdd = function(data, codePoint) {
                var index = 0;
                var start;
                var end;
                var lastIndex = null;
                var length = data.length;
                if (codePoint < 0x0 || codePoint > 0x10FFFF) {
                  throw RangeError(ERRORS.codePointRange);
                }
                while (index < length) {
                  start = data[index];
                  end = data[index + 1];
                  if (codePoint >= start && codePoint < end) {
                    return data;
                  }
                  if (codePoint == start - 1) {
                    data[index] = codePoint;
                    return data;
                  }
                  if (start > codePoint) {
                    data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);
                    return data;
                  }
                  if (codePoint == end) {
                    if (codePoint + 1 == data[index + 2]) {
                      data.splice(index, 4, start, data[index + 3]);
                      return data;
                    }
                    data[index + 1] = codePoint + 1;
                    return data;
                  }
                  lastIndex = index;
                  index += 2;
                }
                data.push(codePoint, codePoint + 1);
                return data;
              };
              var dataAddData = function(dataA, dataB) {
                var index = 0;
                var start;
                var end;
                var data = dataA.slice();
                var length = dataB.length;
                while (index < length) {
                  start = dataB[index];
                  end = dataB[index + 1] - 1;
                  if (start == end) {
                    data = dataAdd(data, start);
                  } else {
                    data = dataAddRange(data, start, end);
                  }
                  index += 2;
                }
                return data;
              };
              var dataRemoveData = function(dataA, dataB) {
                var index = 0;
                var start;
                var end;
                var data = dataA.slice();
                var length = dataB.length;
                while (index < length) {
                  start = dataB[index];
                  end = dataB[index + 1] - 1;
                  if (start == end) {
                    data = dataRemove(data, start);
                  } else {
                    data = dataRemoveRange(data, start, end);
                  }
                  index += 2;
                }
                return data;
              };
              var dataAddRange = function(data, rangeStart, rangeEnd) {
                if (rangeEnd < rangeStart) {
                  throw Error(ERRORS.rangeOrder);
                }
                if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {
                  throw RangeError(ERRORS.codePointRange);
                }
                var index = 0;
                var start;
                var end;
                var added = false;
                var length = data.length;
                while (index < length) {
                  start = data[index];
                  end = data[index + 1];
                  if (added) {
                    if (start == rangeEnd + 1) {
                      data.splice(index - 1, 2);
                      return data;
                    }
                    if (start > rangeEnd) {
                      return data;
                    }
                    if (start >= rangeStart && start <= rangeEnd) {
                      if (end > rangeStart && end - 1 <= rangeEnd) {
                        data.splice(index, 2);
                        index -= 2;
                      } else {
                        data.splice(index - 1, 2);
                        index -= 2;
                      }
                    }
                  } else if (start == rangeEnd + 1) {
                    data[index] = rangeStart;
                    return data;
                  } else if (start > rangeEnd) {
                    data.splice(index, 0, rangeStart, rangeEnd + 1);
                    return data;
                  } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
                    return data;
                  } else if ((rangeStart >= start && rangeStart < end) || end == rangeStart) {
                    data[index + 1] = rangeEnd + 1;
                    added = true;
                  } else if (rangeStart <= start && rangeEnd + 1 >= end) {
                    data[index] = rangeStart;
                    data[index + 1] = rangeEnd + 1;
                    added = true;
                  }
                  index += 2;
                }
                if (!added) {
                  data.push(rangeStart, rangeEnd + 1);
                }
                return data;
              };
              var dataContains = function(data, codePoint) {
                var index = 0;
                var length = data.length;
                var start = data[index];
                var end = data[length - 1];
                if (length >= 2) {
                  if (codePoint < start || codePoint > end) {
                    return false;
                  }
                }
                while (index < length) {
                  start = data[index];
                  end = data[index + 1];
                  if (codePoint >= start && codePoint < end) {
                    return true;
                  }
                  index += 2;
                }
                return false;
              };
              var dataIntersection = function(data, codePoints) {
                var index = 0;
                var length = codePoints.length;
                var codePoint;
                var result = [];
                while (index < length) {
                  codePoint = codePoints[index];
                  if (dataContains(data, codePoint)) {
                    result.push(codePoint);
                  }
                  ++index;
                }
                return dataFromCodePoints(result);
              };
              var dataIsEmpty = function(data) {
                return !data.length;
              };
              var dataIsSingleton = function(data) {
                return data.length == 2 && data[0] + 1 == data[1];
              };
              var dataToArray = function(data) {
                var index = 0;
                var start;
                var end;
                var result = [];
                var length = data.length;
                while (index < length) {
                  start = data[index];
                  end = data[index + 1];
                  while (start < end) {
                    result.push(start);
                    ++start;
                  }
                  index += 2;
                }
                return result;
              };
              var floor = Math.floor;
              var highSurrogate = function(codePoint) {
                return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);
              };
              var lowSurrogate = function(codePoint) {
                return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);
              };
              var stringFromCharCode = String.fromCharCode;
              var codePointToString = function(codePoint) {
                var string;
                if (codePoint == 0x09) {
                  string = '\\t';
                } else if (codePoint == 0x0A) {
                  string = '\\n';
                } else if (codePoint == 0x0C) {
                  string = '\\f';
                } else if (codePoint == 0x0D) {
                  string = '\\r';
                } else if (codePoint == 0x5C) {
                  string = '\\\\';
                } else if (codePoint == 0x24 || (codePoint >= 0x28 && codePoint <= 0x2B) || codePoint == 0x2D || codePoint == 0x2E || codePoint == 0x3F || (codePoint >= 0x5B && codePoint <= 0x5E) || (codePoint >= 0x7B && codePoint <= 0x7D)) {
                  string = '\\' + stringFromCharCode(codePoint);
                } else if (codePoint >= 0x20 && codePoint <= 0x7E) {
                  string = stringFromCharCode(codePoint);
                } else if (codePoint <= 0xFF) {
                  string = '\\x' + pad(hex(codePoint), 2);
                } else {
                  string = '\\u' + pad(hex(codePoint), 4);
                }
                return string;
              };
              var symbolToCodePoint = function(symbol) {
                var length = symbol.length;
                var first = symbol.charCodeAt(0);
                var second;
                if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {
                  second = symbol.charCodeAt(1);
                  return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;
                }
                return first;
              };
              var createBMPCharacterClasses = function(data) {
                var result = '';
                var index = 0;
                var start;
                var end;
                var length = data.length;
                if (dataIsSingleton(data)) {
                  return codePointToString(data[0]);
                }
                while (index < length) {
                  start = data[index];
                  end = data[index + 1] - 1;
                  if (start == end) {
                    result += codePointToString(start);
                  } else if (start + 1 == end) {
                    result += codePointToString(start) + codePointToString(end);
                  } else {
                    result += codePointToString(start) + '-' + codePointToString(end);
                  }
                  index += 2;
                }
                return '[' + result + ']';
              };
              var splitAtBMP = function(data) {
                var loneHighSurrogates = [];
                var loneLowSurrogates = [];
                var bmp = [];
                var astral = [];
                var index = 0;
                var start;
                var end;
                var length = data.length;
                while (index < length) {
                  start = data[index];
                  end = data[index + 1] - 1;
                  if (start < HIGH_SURROGATE_MIN) {
                    if (end < HIGH_SURROGATE_MIN) {
                      bmp.push(start, end + 1);
                    }
                    if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
                      bmp.push(start, HIGH_SURROGATE_MIN);
                      loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
                    }
                    if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
                      bmp.push(start, HIGH_SURROGATE_MIN);
                      loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
                      loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
                    }
                    if (end > LOW_SURROGATE_MAX) {
                      bmp.push(start, HIGH_SURROGATE_MIN);
                      loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
                      loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
                      if (end <= 0xFFFF) {
                        bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
                      } else {
                        bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                        astral.push(0xFFFF + 1, end + 1);
                      }
                    }
                  } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
                    if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
                      loneHighSurrogates.push(start, end + 1);
                    }
                    if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
                      loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
                      loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
                    }
                    if (end > LOW_SURROGATE_MAX) {
                      loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
                      loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
                      if (end <= 0xFFFF) {
                        bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
                      } else {
                        bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                        astral.push(0xFFFF + 1, end + 1);
                      }
                    }
                  } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
                    if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
                      loneLowSurrogates.push(start, end + 1);
                    }
                    if (end > LOW_SURROGATE_MAX) {
                      loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);
                      if (end <= 0xFFFF) {
                        bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
                      } else {
                        bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                        astral.push(0xFFFF + 1, end + 1);
                      }
                    }
                  } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {
                    if (end <= 0xFFFF) {
                      bmp.push(start, end + 1);
                    } else {
                      bmp.push(start, 0xFFFF + 1);
                      astral.push(0xFFFF + 1, end + 1);
                    }
                  } else {
                    astral.push(start, end + 1);
                  }
                  index += 2;
                }
                return {
                  'loneHighSurrogates': loneHighSurrogates,
                  'loneLowSurrogates': loneLowSurrogates,
                  'bmp': bmp,
                  'astral': astral
                };
              };
              var optimizeSurrogateMappings = function(surrogateMappings) {
                var result = [];
                var tmpLow = [];
                var addLow = false;
                var mapping;
                var nextMapping;
                var highSurrogates;
                var lowSurrogates;
                var nextHighSurrogates;
                var nextLowSurrogates;
                var index = -1;
                var length = surrogateMappings.length;
                while (++index < length) {
                  mapping = surrogateMappings[index];
                  nextMapping = surrogateMappings[index + 1];
                  if (!nextMapping) {
                    result.push(mapping);
                    continue;
                  }
                  highSurrogates = mapping[0];
                  lowSurrogates = mapping[1];
                  nextHighSurrogates = nextMapping[0];
                  nextLowSurrogates = nextMapping[1];
                  tmpLow = lowSurrogates;
                  while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
                    if (dataIsSingleton(nextLowSurrogates)) {
                      tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
                    } else {
                      tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);
                    }
                    ++index;
                    mapping = surrogateMappings[index];
                    highSurrogates = mapping[0];
                    lowSurrogates = mapping[1];
                    nextMapping = surrogateMappings[index + 1];
                    nextHighSurrogates = nextMapping && nextMapping[0];
                    nextLowSurrogates = nextMapping && nextMapping[1];
                    addLow = true;
                  }
                  result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);
                  addLow = false;
                }
                return optimizeByLowSurrogates(result);
              };
              var optimizeByLowSurrogates = function(surrogateMappings) {
                if (surrogateMappings.length == 1) {
                  return surrogateMappings;
                }
                var index = -1;
                var innerIndex = -1;
                while (++index < surrogateMappings.length) {
                  var mapping = surrogateMappings[index];
                  var lowSurrogates = mapping[1];
                  var lowSurrogateStart = lowSurrogates[0];
                  var lowSurrogateEnd = lowSurrogates[1];
                  innerIndex = index;
                  while (++innerIndex < surrogateMappings.length) {
                    var otherMapping = surrogateMappings[innerIndex];
                    var otherLowSurrogates = otherMapping[1];
                    var otherLowSurrogateStart = otherLowSurrogates[0];
                    var otherLowSurrogateEnd = otherLowSurrogates[1];
                    if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd) {
                      if (dataIsSingleton(otherMapping[0])) {
                        mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
                      } else {
                        mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);
                      }
                      surrogateMappings.splice(innerIndex, 1);
                      --innerIndex;
                    }
                  }
                }
                return surrogateMappings;
              };
              var surrogateSet = function(data) {
                if (!data.length) {
                  return [];
                }
                var index = 0;
                var start;
                var end;
                var startHigh;
                var startLow;
                var prevStartHigh = 0;
                var prevEndHigh = 0;
                var tmpLow = [];
                var endHigh;
                var endLow;
                var surrogateMappings = [];
                var length = data.length;
                var dataHigh = [];
                while (index < length) {
                  start = data[index];
                  end = data[index + 1] - 1;
                  startHigh = highSurrogate(start);
                  startLow = lowSurrogate(start);
                  endHigh = highSurrogate(end);
                  endLow = lowSurrogate(end);
                  var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
                  var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
                  var complete = false;
                  if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
                    surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);
                    complete = true;
                  } else {
                    surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);
                  }
                  if (!complete && startHigh + 1 < endHigh) {
                    if (endsWithHighestLowSurrogate) {
                      surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
                      complete = true;
                    } else {
                      surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);
                    }
                  }
                  if (!complete) {
                    surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
                  }
                  prevStartHigh = startHigh;
                  prevEndHigh = endHigh;
                  index += 2;
                }
                return optimizeSurrogateMappings(surrogateMappings);
              };
              var createSurrogateCharacterClasses = function(surrogateMappings) {
                var result = [];
                forEach(surrogateMappings, function(surrogateMapping) {
                  var highSurrogates = surrogateMapping[0];
                  var lowSurrogates = surrogateMapping[1];
                  result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));
                });
                return result.join('|');
              };
              var createCharacterClassesFromData = function(data, bmpOnly) {
                var result = [];
                var parts = splitAtBMP(data);
                var loneHighSurrogates = parts.loneHighSurrogates;
                var loneLowSurrogates = parts.loneLowSurrogates;
                var bmp = parts.bmp;
                var astral = parts.astral;
                var hasAstral = !dataIsEmpty(parts.astral);
                var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
                var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
                var surrogateMappings = surrogateSet(astral);
                if (bmpOnly) {
                  bmp = dataAddData(bmp, loneHighSurrogates);
                  hasLoneHighSurrogates = false;
                  bmp = dataAddData(bmp, loneLowSurrogates);
                  hasLoneLowSurrogates = false;
                }
                if (!dataIsEmpty(bmp)) {
                  result.push(createBMPCharacterClasses(bmp));
                }
                if (surrogateMappings.length) {
                  result.push(createSurrogateCharacterClasses(surrogateMappings));
                }
                if (hasLoneHighSurrogates) {
                  result.push(createBMPCharacterClasses(loneHighSurrogates) + '(?![\\uDC00-\\uDFFF])');
                }
                if (hasLoneLowSurrogates) {
                  result.push('(?:[^\\uD800-\\uDBFF]|^)' + createBMPCharacterClasses(loneLowSurrogates));
                }
                return result.join('|');
              };
              var regenerate = function(value) {
                if (arguments.length > 1) {
                  value = slice.call(arguments);
                }
                if (this instanceof regenerate) {
                  this.data = [];
                  return value ? this.add(value) : this;
                }
                return (new regenerate).add(value);
              };
              regenerate.version = '1.2.0';
              var proto = regenerate.prototype;
              extend(proto, {
                'add': function(value) {
                  var $this = this;
                  if (value == null) {
                    return $this;
                  }
                  if (value instanceof regenerate) {
                    $this.data = dataAddData($this.data, value.data);
                    return $this;
                  }
                  if (arguments.length > 1) {
                    value = slice.call(arguments);
                  }
                  if (isArray(value)) {
                    forEach(value, function(item) {
                      $this.add(item);
                    });
                    return $this;
                  }
                  $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));
                  return $this;
                },
                'remove': function(value) {
                  var $this = this;
                  if (value == null) {
                    return $this;
                  }
                  if (value instanceof regenerate) {
                    $this.data = dataRemoveData($this.data, value.data);
                    return $this;
                  }
                  if (arguments.length > 1) {
                    value = slice.call(arguments);
                  }
                  if (isArray(value)) {
                    forEach(value, function(item) {
                      $this.remove(item);
                    });
                    return $this;
                  }
                  $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));
                  return $this;
                },
                'addRange': function(start, end) {
                  var $this = this;
                  $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));
                  return $this;
                },
                'removeRange': function(start, end) {
                  var $this = this;
                  var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
                  var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
                  $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);
                  return $this;
                },
                'intersection': function(argument) {
                  var $this = this;
                  var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
                  $this.data = dataIntersection($this.data, array);
                  return $this;
                },
                'contains': function(codePoint) {
                  return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));
                },
                'clone': function() {
                  var set = new regenerate;
                  set.data = this.data.slice(0);
                  return set;
                },
                'toString': function(options) {
                  var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false);
                  return result.replace(regexNull, '\\0$1');
                },
                'toRegExp': function(flags) {
                  return RegExp(this.toString(), flags || '');
                },
                'valueOf': function() {
                  return dataToArray(this.data);
                }
              });
              proto.toArray = proto.valueOf;
              if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                define(function() {
                  return regenerate;
                });
              } else if (freeExports && !freeExports.nodeType) {
                if (freeModule) {
                  freeModule.exports = regenerate;
                } else {
                  freeExports.regenerate = regenerate;
                }
              } else {
                root.regenerate = regenerate;
              }
            }(this));
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        599: [function(require, module, exports) {
          (function(global) {
            ;
            (function() {
              'use strict';
              var objectTypes = {
                'function': true,
                'object': true
              };
              var root = (objectTypes[typeof window] && window) || this;
              var oldRoot = root;
              var freeExports = objectTypes[typeof exports] && exports;
              var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
              var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
              if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
                root = freeGlobal;
              }
              var stringFromCharCode = String.fromCharCode;
              var floor = Math.floor;
              function fromCodePoint() {
                var MAX_SIZE = 0x4000;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index = -1;
                var length = arguments.length;
                if (!length) {
                  return '';
                }
                var result = '';
                while (++index < length) {
                  var codePoint = Number(arguments[index]);
                  if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
                    throw RangeError('Invalid code point: ' + codePoint);
                  }
                  if (codePoint <= 0xFFFF) {
                    codeUnits.push(codePoint);
                  } else {
                    codePoint -= 0x10000;
                    highSurrogate = (codePoint >> 10) + 0xD800;
                    lowSurrogate = (codePoint % 0x400) + 0xDC00;
                    codeUnits.push(highSurrogate, lowSurrogate);
                  }
                  if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                    result += stringFromCharCode.apply(null, codeUnits);
                    codeUnits.length = 0;
                  }
                }
                return result;
              }
              function assertType(type, expected) {
                if (expected.indexOf('|') == -1) {
                  if (type == expected) {
                    return;
                  }
                  throw Error('Invalid node type: ' + type);
                }
                expected = assertType.hasOwnProperty(expected) ? assertType[expected] : (assertType[expected] = RegExp('^(?:' + expected + ')$'));
                if (expected.test(type)) {
                  return;
                }
                throw Error('Invalid node type: ' + type);
              }
              function generate(node) {
                var type = node.type;
                if (generate.hasOwnProperty(type) && typeof generate[type] == 'function') {
                  return generate[type](node);
                }
                throw Error('Invalid node type: ' + type);
              }
              function generateAlternative(node) {
                assertType(node.type, 'alternative');
                var terms = node.body,
                    length = terms ? terms.length : 0;
                if (length == 1) {
                  return generateTerm(terms[0]);
                } else {
                  var i = -1,
                      result = '';
                  while (++i < length) {
                    result += generateTerm(terms[i]);
                  }
                  return result;
                }
              }
              function generateAnchor(node) {
                assertType(node.type, 'anchor');
                switch (node.kind) {
                  case 'start':
                    return '^';
                  case 'end':
                    return '$';
                  case 'boundary':
                    return '\\b';
                  case 'not-boundary':
                    return '\\B';
                  default:
                    throw Error('Invalid assertion');
                }
              }
              function generateAtom(node) {
                assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');
                return generate(node);
              }
              function generateCharacterClass(node) {
                assertType(node.type, 'characterClass');
                var classRanges = node.body,
                    length = classRanges ? classRanges.length : 0;
                var i = -1,
                    result = '[';
                if (node.negative) {
                  result += '^';
                }
                while (++i < length) {
                  result += generateClassAtom(classRanges[i]);
                }
                result += ']';
                return result;
              }
              function generateCharacterClassEscape(node) {
                assertType(node.type, 'characterClassEscape');
                return '\\' + node.value;
              }
              function generateCharacterClassRange(node) {
                assertType(node.type, 'characterClassRange');
                var min = node.min,
                    max = node.max;
                if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
                  throw Error('Invalid character class range');
                }
                return generateClassAtom(min) + '-' + generateClassAtom(max);
              }
              function generateClassAtom(node) {
                assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');
                return generate(node);
              }
              function generateDisjunction(node) {
                assertType(node.type, 'disjunction');
                var body = node.body,
                    length = body ? body.length : 0;
                if (length == 0) {
                  throw Error('No body');
                } else if (length == 1) {
                  return generate(body[0]);
                } else {
                  var i = -1,
                      result = '';
                  while (++i < length) {
                    if (i != 0) {
                      result += '|';
                    }
                    result += generate(body[i]);
                  }
                  return result;
                }
              }
              function generateDot(node) {
                assertType(node.type, 'dot');
                return '.';
              }
              function generateGroup(node) {
                assertType(node.type, 'group');
                var result = '(';
                switch (node.behavior) {
                  case 'normal':
                    break;
                  case 'ignore':
                    result += '?:';
                    break;
                  case 'lookahead':
                    result += '?=';
                    break;
                  case 'negativeLookahead':
                    result += '?!';
                    break;
                  default:
                    throw Error('Invalid behaviour: ' + node.behaviour);
                }
                var body = node.body,
                    length = body ? body.length : 0;
                if (length == 1) {
                  result += generate(body[0]);
                } else {
                  var i = -1;
                  while (++i < length) {
                    result += generate(body[i]);
                  }
                }
                result += ')';
                return result;
              }
              function generateQuantifier(node) {
                assertType(node.type, 'quantifier');
                var quantifier = '',
                    min = node.min,
                    max = node.max;
                switch (max) {
                  case undefined:
                  case null:
                    switch (min) {
                      case 0:
                        quantifier = '*';
                        break;
                      case 1:
                        quantifier = '+';
                        break;
                      default:
                        quantifier = '{' + min + ',}';
                        break;
                    }
                    break;
                  default:
                    if (min == max) {
                      quantifier = '{' + min + '}';
                    } else if (min == 0 && max == 1) {
                      quantifier = '?';
                    } else {
                      quantifier = '{' + min + ',' + max + '}';
                    }
                    break;
                }
                if (!node.greedy) {
                  quantifier += '?';
                }
                return generateAtom(node.body[0]) + quantifier;
              }
              function generateReference(node) {
                assertType(node.type, 'reference');
                return '\\' + node.matchIndex;
              }
              function generateTerm(node) {
                assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value');
                return generate(node);
              }
              function generateValue(node) {
                assertType(node.type, 'value');
                var kind = node.kind,
                    codePoint = node.codePoint;
                switch (kind) {
                  case 'controlLetter':
                    return '\\c' + fromCodePoint(codePoint + 64);
                  case 'hexadecimalEscape':
                    return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);
                  case 'identifier':
                    return '\\' + fromCodePoint(codePoint);
                  case 'null':
                    return '\\' + codePoint;
                  case 'octal':
                    return '\\' + codePoint.toString(8);
                  case 'singleEscape':
                    switch (codePoint) {
                      case 0x0008:
                        return '\\b';
                      case 0x009:
                        return '\\t';
                      case 0x00A:
                        return '\\n';
                      case 0x00B:
                        return '\\v';
                      case 0x00C:
                        return '\\f';
                      case 0x00D:
                        return '\\r';
                      default:
                        throw Error('Invalid codepoint: ' + codePoint);
                    }
                  case 'symbol':
                    return fromCodePoint(codePoint);
                  case 'unicodeEscape':
                    return '\\u' + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);
                  case 'unicodeCodePointEscape':
                    return '\\u{' + codePoint.toString(16).toUpperCase() + '}';
                  default:
                    throw Error('Unsupported node kind: ' + kind);
                }
              }
              generate.alternative = generateAlternative;
              generate.anchor = generateAnchor;
              generate.characterClass = generateCharacterClass;
              generate.characterClassEscape = generateCharacterClassEscape;
              generate.characterClassRange = generateCharacterClassRange;
              generate.disjunction = generateDisjunction;
              generate.dot = generateDot;
              generate.group = generateGroup;
              generate.quantifier = generateQuantifier;
              generate.reference = generateReference;
              generate.value = generateValue;
              if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                define(function() {
                  return {'generate': generate};
                });
              } else if (freeExports && freeModule) {
                freeExports.generate = generate;
              } else {
                root.regjsgen = {'generate': generate};
              }
            }.call(this));
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        600: [function(require, module, exports) {
          (function() {
            function parse(str, flags) {
              function addRaw(node) {
                node.raw = str.substring(node.range[0], node.range[1]);
                return node;
              }
              function updateRawStart(node, start) {
                node.range[0] = start;
                return addRaw(node);
              }
              function createAnchor(kind, rawLength) {
                return addRaw({
                  type: 'anchor',
                  kind: kind,
                  range: [pos - rawLength, pos]
                });
              }
              function createValue(kind, codePoint, from, to) {
                return addRaw({
                  type: 'value',
                  kind: kind,
                  codePoint: codePoint,
                  range: [from, to]
                });
              }
              function createEscaped(kind, codePoint, value, fromOffset) {
                fromOffset = fromOffset || 0;
                return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
              }
              function createCharacter(matches) {
                var _char = matches[0];
                var first = _char.charCodeAt(0);
                if (hasUnicodeFlag) {
                  var second;
                  if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
                    second = lookahead().charCodeAt(0);
                    if (second >= 0xDC00 && second <= 0xDFFF) {
                      pos++;
                      return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);
                    }
                  }
                }
                return createValue('symbol', first, pos - 1, pos);
              }
              function createDisjunction(alternatives, from, to) {
                return addRaw({
                  type: 'disjunction',
                  body: alternatives,
                  range: [from, to]
                });
              }
              function createDot() {
                return addRaw({
                  type: 'dot',
                  range: [pos - 1, pos]
                });
              }
              function createCharacterClassEscape(value) {
                return addRaw({
                  type: 'characterClassEscape',
                  value: value,
                  range: [pos - 2, pos]
                });
              }
              function createReference(matchIndex) {
                return addRaw({
                  type: 'reference',
                  matchIndex: parseInt(matchIndex, 10),
                  range: [pos - 1 - matchIndex.length, pos]
                });
              }
              function createGroup(behavior, disjunction, from, to) {
                return addRaw({
                  type: 'group',
                  behavior: behavior,
                  body: disjunction,
                  range: [from, to]
                });
              }
              function createQuantifier(min, max, from, to) {
                if (to == null) {
                  from = pos - 1;
                  to = pos;
                }
                return addRaw({
                  type: 'quantifier',
                  min: min,
                  max: max,
                  greedy: true,
                  body: null,
                  range: [from, to]
                });
              }
              function createAlternative(terms, from, to) {
                return addRaw({
                  type: 'alternative',
                  body: terms,
                  range: [from, to]
                });
              }
              function createCharacterClass(classRanges, negative, from, to) {
                return addRaw({
                  type: 'characterClass',
                  body: classRanges,
                  negative: negative,
                  range: [from, to]
                });
              }
              function createClassRange(min, max, from, to) {
                if (min.codePoint > max.codePoint) {
                  bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
                }
                return addRaw({
                  type: 'characterClassRange',
                  min: min,
                  max: max,
                  range: [from, to]
                });
              }
              function flattenBody(body) {
                if (body.type === 'alternative') {
                  return body.body;
                } else {
                  return [body];
                }
              }
              function isEmpty(obj) {
                return obj.type === 'empty';
              }
              function incr(amount) {
                amount = (amount || 1);
                var res = str.substring(pos, pos + amount);
                pos += (amount || 1);
                return res;
              }
              function skip(value) {
                if (!match(value)) {
                  bail('character', value);
                }
              }
              function match(value) {
                if (str.indexOf(value, pos) === pos) {
                  return incr(value.length);
                }
              }
              function lookahead() {
                return str[pos];
              }
              function current(value) {
                return str.indexOf(value, pos) === pos;
              }
              function next(value) {
                return str[pos + 1] === value;
              }
              function matchReg(regExp) {
                var subStr = str.substring(pos);
                var res = subStr.match(regExp);
                if (res) {
                  res.range = [];
                  res.range[0] = pos;
                  incr(res[0].length);
                  res.range[1] = pos;
                }
                return res;
              }
              function parseDisjunction() {
                var res = [],
                    from = pos;
                res.push(parseAlternative());
                while (match('|')) {
                  res.push(parseAlternative());
                }
                if (res.length === 1) {
                  return res[0];
                }
                return createDisjunction(res, from, pos);
              }
              function parseAlternative() {
                var res = [],
                    from = pos;
                var term;
                while (term = parseTerm()) {
                  res.push(term);
                }
                if (res.length === 1) {
                  return res[0];
                }
                return createAlternative(res, from, pos);
              }
              function parseTerm() {
                if (pos >= str.length || current('|') || current(')')) {
                  return null;
                }
                var anchor = parseAnchor();
                if (anchor) {
                  return anchor;
                }
                var atom = parseAtom();
                if (!atom) {
                  bail('Expected atom');
                }
                var quantifier = parseQuantifier() || false;
                if (quantifier) {
                  quantifier.body = flattenBody(atom);
                  updateRawStart(quantifier, atom.range[0]);
                  return quantifier;
                }
                return atom;
              }
              function parseGroup(matchA, typeA, matchB, typeB) {
                var type = null,
                    from = pos;
                if (match(matchA)) {
                  type = typeA;
                } else if (match(matchB)) {
                  type = typeB;
                } else {
                  return false;
                }
                var body = parseDisjunction();
                if (!body) {
                  bail('Expected disjunction');
                }
                skip(')');
                var group = createGroup(type, flattenBody(body), from, pos);
                if (type == 'normal') {
                  if (firstIteration) {
                    closedCaptureCounter++;
                  }
                }
                return group;
              }
              function parseAnchor() {
                var res,
                    from = pos;
                if (match('^')) {
                  return createAnchor('start', 1);
                } else if (match('$')) {
                  return createAnchor('end', 1);
                } else if (match('\\b')) {
                  return createAnchor('boundary', 2);
                } else if (match('\\B')) {
                  return createAnchor('not-boundary', 2);
                } else {
                  return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
                }
              }
              function parseQuantifier() {
                var res,
                    from = pos;
                var quantifier;
                var min,
                    max;
                if (match('*')) {
                  quantifier = createQuantifier(0);
                } else if (match('+')) {
                  quantifier = createQuantifier(1);
                } else if (match('?')) {
                  quantifier = createQuantifier(0, 1);
                } else if (res = matchReg(/^\{([0-9]+)\}/)) {
                  min = parseInt(res[1], 10);
                  quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
                } else if (res = matchReg(/^\{([0-9]+),\}/)) {
                  min = parseInt(res[1], 10);
                  quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
                } else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
                  min = parseInt(res[1], 10);
                  max = parseInt(res[2], 10);
                  if (min > max) {
                    bail('numbers out of order in {} quantifier', '', from, pos);
                  }
                  quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
                }
                if (quantifier) {
                  if (match('?')) {
                    quantifier.greedy = false;
                    quantifier.range[1] += 1;
                  }
                }
                return quantifier;
              }
              function parseAtom() {
                var res;
                if (res = matchReg(/^[^^$\\.*+?(){[|]/)) {
                  return createCharacter(res);
                } else if (match('.')) {
                  return createDot();
                } else if (match('\\')) {
                  res = parseAtomEscape();
                  if (!res) {
                    bail('atomEscape');
                  }
                  return res;
                } else if (res = parseCharacterClass()) {
                  return res;
                } else {
                  return parseGroup('(?:', 'ignore', '(', 'normal');
                }
              }
              function parseUnicodeSurrogatePairEscape(firstEscape) {
                if (hasUnicodeFlag) {
                  var first,
                      second;
                  if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\') && next('u')) {
                    var prevPos = pos;
                    pos++;
                    var secondEscape = parseClassEscape();
                    if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
                      firstEscape.range[1] = secondEscape.range[1];
                      firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                      firstEscape.type = 'value';
                      firstEscape.kind = 'unicodeCodePointEscape';
                      addRaw(firstEscape);
                    } else {
                      pos = prevPos;
                    }
                  }
                }
                return firstEscape;
              }
              function parseClassEscape() {
                return parseAtomEscape(true);
              }
              function parseAtomEscape(insideCharacterClass) {
                var res,
                    from = pos;
                res = parseDecimalEscape();
                if (res) {
                  return res;
                }
                if (insideCharacterClass) {
                  if (match('b')) {
                    return createEscaped('singleEscape', 0x0008, '\\b');
                  } else if (match('B')) {
                    bail('\\B not possible inside of CharacterClass', '', from);
                  }
                }
                res = parseCharacterEscape();
                return res;
              }
              function parseDecimalEscape() {
                var res,
                    match;
                if (res = matchReg(/^(?!0)\d+/)) {
                  match = res[0];
                  var refIdx = parseInt(res[0], 10);
                  if (refIdx <= closedCaptureCounter) {
                    return createReference(res[0]);
                  } else {
                    backrefDenied.push(refIdx);
                    incr(-res[0].length);
                    if (res = matchReg(/^[0-7]{1,3}/)) {
                      return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
                    } else {
                      res = createCharacter(matchReg(/^[89]/));
                      return updateRawStart(res, res.range[0] - 1);
                    }
                  }
                } else if (res = matchReg(/^[0-7]{1,3}/)) {
                  match = res[0];
                  if (/^0{1,3}$/.test(match)) {
                    return createEscaped('null', 0x0000, '0', match.length + 1);
                  } else {
                    return createEscaped('octal', parseInt(match, 8), match, 1);
                  }
                } else if (res = matchReg(/^[dDsSwW]/)) {
                  return createCharacterClassEscape(res[0]);
                }
                return false;
              }
              function parseCharacterEscape() {
                var res;
                if (res = matchReg(/^[fnrtv]/)) {
                  var codePoint = 0;
                  switch (res[0]) {
                    case 't':
                      codePoint = 0x009;
                      break;
                    case 'n':
                      codePoint = 0x00A;
                      break;
                    case 'v':
                      codePoint = 0x00B;
                      break;
                    case 'f':
                      codePoint = 0x00C;
                      break;
                    case 'r':
                      codePoint = 0x00D;
                      break;
                  }
                  return createEscaped('singleEscape', codePoint, '\\' + res[0]);
                } else if (res = matchReg(/^c([a-zA-Z])/)) {
                  return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
                } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
                  return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
                } else if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
                  return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));
                } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
                  return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
                } else {
                  return parseIdentityEscape();
                }
              }
              function isIdentifierPart(ch) {
                var NonAsciiIdentifierPart = new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]');
                return (ch === 36) || (ch === 95) || (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122) || (ch >= 48 && ch <= 57) || (ch === 92) || ((ch >= 0x80) && NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
              }
              function parseIdentityEscape() {
                var ZWJ = '\u200C';
                var ZWNJ = '\u200D';
                var tmp;
                if (!isIdentifierPart(lookahead())) {
                  tmp = incr();
                  return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
                }
                if (match(ZWJ)) {
                  return createEscaped('identifier', 0x200C, ZWJ);
                } else if (match(ZWNJ)) {
                  return createEscaped('identifier', 0x200D, ZWNJ);
                }
                return null;
              }
              function parseCharacterClass() {
                var res,
                    from = pos;
                if (res = matchReg(/^\[\^/)) {
                  res = parseClassRanges();
                  skip(']');
                  return createCharacterClass(res, true, from, pos);
                } else if (match('[')) {
                  res = parseClassRanges();
                  skip(']');
                  return createCharacterClass(res, false, from, pos);
                }
                return null;
              }
              function parseClassRanges() {
                var res;
                if (current(']')) {
                  return [];
                } else {
                  res = parseNonemptyClassRanges();
                  if (!res) {
                    bail('nonEmptyClassRanges');
                  }
                  return res;
                }
              }
              function parseHelperClassRanges(atom) {
                var from,
                    to,
                    res;
                if (current('-') && !next(']')) {
                  skip('-');
                  res = parseClassAtom();
                  if (!res) {
                    bail('classAtom');
                  }
                  to = pos;
                  var classRanges = parseClassRanges();
                  if (!classRanges) {
                    bail('classRanges');
                  }
                  from = atom.range[0];
                  if (classRanges.type === 'empty') {
                    return [createClassRange(atom, res, from, to)];
                  }
                  return [createClassRange(atom, res, from, to)].concat(classRanges);
                }
                res = parseNonemptyClassRangesNoDash();
                if (!res) {
                  bail('nonEmptyClassRangesNoDash');
                }
                return [atom].concat(res);
              }
              function parseNonemptyClassRanges() {
                var atom = parseClassAtom();
                if (!atom) {
                  bail('classAtom');
                }
                if (current(']')) {
                  return [atom];
                }
                return parseHelperClassRanges(atom);
              }
              function parseNonemptyClassRangesNoDash() {
                var res = parseClassAtom();
                if (!res) {
                  bail('classAtom');
                }
                if (current(']')) {
                  return res;
                }
                return parseHelperClassRanges(res);
              }
              function parseClassAtom() {
                if (match('-')) {
                  return createCharacter('-');
                } else {
                  return parseClassAtomNoDash();
                }
              }
              function parseClassAtomNoDash() {
                var res;
                if (res = matchReg(/^[^\\\]-]/)) {
                  return createCharacter(res[0]);
                } else if (match('\\')) {
                  res = parseClassEscape();
                  if (!res) {
                    bail('classEscape');
                  }
                  return parseUnicodeSurrogatePairEscape(res);
                }
              }
              function bail(message, details, from, to) {
                from = from == null ? pos : from;
                to = to == null ? from : to;
                var contextStart = Math.max(0, from - 10);
                var contextEnd = Math.min(to + 10, str.length);
                var context = '    ' + str.substring(contextStart, contextEnd);
                var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';
                throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
              }
              var backrefDenied = [];
              var closedCaptureCounter = 0;
              var firstIteration = true;
              var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
              var pos = 0;
              str = String(str);
              if (str === '') {
                str = '(?:)';
              }
              var result = parseDisjunction();
              if (result.range[1] !== str.length) {
                bail('Could not parse entire input - got stuck', '', result.range[1]);
              }
              for (var i = 0; i < backrefDenied.length; i++) {
                if (backrefDenied[i] <= closedCaptureCounter) {
                  pos = 0;
                  firstIteration = false;
                  return parseDisjunction();
                }
              }
              return result;
            }
            var regjsparser = {parse: parse};
            if (typeof module !== 'undefined' && module.exports) {
              module.exports = regjsparser;
            } else {
              window.regjsparser = regjsparser;
            }
          }());
        }, {}],
        601: [function(require, module, exports) {
          var generate = require('regjsgen').generate;
          var parse = require('regjsparser').parse;
          var regenerate = require('regenerate');
          var iuMappings = require('./data/iu-mappings.json');
          var ESCAPE_SETS = require('./data/character-class-escape-sets.js');
          function getCharacterClassEscapeSet(character) {
            if (unicode) {
              if (ignoreCase) {
                return ESCAPE_SETS.UNICODE_IGNORE_CASE[character];
              }
              return ESCAPE_SETS.UNICODE[character];
            }
            return ESCAPE_SETS.REGULAR[character];
          }
          var object = {};
          var hasOwnProperty = object.hasOwnProperty;
          function has(object, property) {
            return hasOwnProperty.call(object, property);
          }
          var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
          var BMP_SET = regenerate().addRange(0x0, 0xFFFF);
          var DOT_SET_UNICODE = UNICODE_SET.clone().remove(0x000A, 0x000D, 0x2028, 0x2029);
          var DOT_SET = DOT_SET_UNICODE.clone().intersection(BMP_SET);
          regenerate.prototype.iuAddRange = function(min, max) {
            var $this = this;
            do {
              var folded = caseFold(min);
              if (folded) {
                $this.add(folded);
              }
            } while (++min <= max);
            return $this;
          };
          function assign(target, source) {
            for (var key in source) {
              target[key] = source[key];
            }
          }
          function update(item, pattern) {
            if (!pattern) {
              return;
            }
            var tree = parse(pattern, '');
            switch (tree.type) {
              case 'characterClass':
              case 'group':
              case 'value':
                break;
              default:
                tree = wrap(tree, pattern);
            }
            assign(item, tree);
          }
          function wrap(tree, pattern) {
            return {
              'type': 'group',
              'behavior': 'ignore',
              'body': [tree],
              'raw': '(?:' + pattern + ')'
            };
          }
          function caseFold(codePoint) {
            return has(iuMappings, codePoint) ? iuMappings[codePoint] : false;
          }
          var ignoreCase = false;
          var unicode = false;
          function processCharacterClass(characterClassItem) {
            var set = regenerate();
            var body = characterClassItem.body.forEach(function(item) {
              switch (item.type) {
                case 'value':
                  set.add(item.codePoint);
                  if (ignoreCase && unicode) {
                    var folded = caseFold(item.codePoint);
                    if (folded) {
                      set.add(folded);
                    }
                  }
                  break;
                case 'characterClassRange':
                  var min = item.min.codePoint;
                  var max = item.max.codePoint;
                  set.addRange(min, max);
                  if (ignoreCase && unicode) {
                    set.iuAddRange(min, max);
                  }
                  break;
                case 'characterClassEscape':
                  set.add(getCharacterClassEscapeSet(item.value));
                  break;
                default:
                  throw Error('Unknown term type: ' + item.type);
              }
            });
            if (characterClassItem.negative) {
              set = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set);
            }
            update(characterClassItem, set.toString());
            return characterClassItem;
          }
          function processTerm(item) {
            switch (item.type) {
              case 'dot':
                update(item, (unicode ? DOT_SET_UNICODE : DOT_SET).toString());
                break;
              case 'characterClass':
                item = processCharacterClass(item);
                break;
              case 'characterClassEscape':
                update(item, getCharacterClassEscapeSet(item.value).toString());
                break;
              case 'alternative':
              case 'disjunction':
              case 'group':
              case 'quantifier':
                item.body = item.body.map(processTerm);
                break;
              case 'value':
                var codePoint = item.codePoint;
                var set = regenerate(codePoint);
                if (ignoreCase && unicode) {
                  var folded = caseFold(codePoint);
                  if (folded) {
                    set.add(folded);
                  }
                }
                update(item, set.toString());
                break;
              case 'anchor':
              case 'empty':
              case 'group':
              case 'reference':
                break;
              default:
                throw Error('Unknown term type: ' + item.type);
            }
            return item;
          }
          ;
          module.exports = function(pattern, flags) {
            var tree = parse(pattern, flags);
            ignoreCase = flags ? flags.indexOf('i') > -1 : false;
            unicode = flags ? flags.indexOf('u') > -1 : false;
            assign(tree, processTerm(tree));
            return generate(tree);
          };
        }, {
          "./data/character-class-escape-sets.js": 596,
          "./data/iu-mappings.json": 597,
          "regenerate": 598,
          "regjsgen": 599,
          "regjsparser": 600
        }],
        602: [function(require, module, exports) {
          'use strict';
          var isFinite = require('is-finite');
          module.exports = function(str, n) {
            if (typeof str !== 'string') {
              throw new TypeError('Expected a string as the first argument');
            }
            if (n < 0 || !isFinite(n)) {
              throw new TypeError('Expected a finite positive number');
            }
            var ret = '';
            do {
              if (n & 1) {
                ret += str;
              }
              str += str;
            } while (n = n >> 1);
            return ret;
          };
        }, {"is-finite": 603}],
        603: [function(require, module, exports) {
          arguments[4][416][0].apply(exports, arguments);
        }, {
          "dup": 416,
          "number-is-nan": 604
        }],
        604: [function(require, module, exports) {
          arguments[4][417][0].apply(exports, arguments);
        }, {"dup": 417}],
        605: [function(require, module, exports) {
          'use strict';
          module.exports = /^#!.*/;
        }, {}],
        606: [function(require, module, exports) {
          'use strict';
          module.exports = function(str) {
            var isExtendedLengthPath = /^\\\\\?\\/.test(str);
            var hasNonAscii = /[^\x00-\x80]+/.test(str);
            if (isExtendedLengthPath || hasNonAscii) {
              return str;
            }
            return str.replace(/\\/g, '/');
          };
        }, {}],
        607: [function(require, module, exports) {
          exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
          exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
          exports.SourceNode = require('./source-map/source-node').SourceNode;
        }, {
          "./source-map/source-map-consumer": 614,
          "./source-map/source-map-generator": 615,
          "./source-map/source-node": 616
        }],
        608: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            var util = require('./util');
            function ArraySet() {
              this._array = [];
              this._set = {};
            }
            ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
              var set = new ArraySet();
              for (var i = 0,
                  len = aArray.length; i < len; i++) {
                set.add(aArray[i], aAllowDuplicates);
              }
              return set;
            };
            ArraySet.prototype.size = function ArraySet_size() {
              return Object.getOwnPropertyNames(this._set).length;
            };
            ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
              var isDuplicate = this.has(aStr);
              var idx = this._array.length;
              if (!isDuplicate || aAllowDuplicates) {
                this._array.push(aStr);
              }
              if (!isDuplicate) {
                this._set[util.toSetString(aStr)] = idx;
              }
            };
            ArraySet.prototype.has = function ArraySet_has(aStr) {
              return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));
            };
            ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
              if (this.has(aStr)) {
                return this._set[util.toSetString(aStr)];
              }
              throw new Error('"' + aStr + '" is not in the set.');
            };
            ArraySet.prototype.at = function ArraySet_at(aIdx) {
              if (aIdx >= 0 && aIdx < this._array.length) {
                return this._array[aIdx];
              }
              throw new Error('No element indexed by ' + aIdx);
            };
            ArraySet.prototype.toArray = function ArraySet_toArray() {
              return this._array.slice();
            };
            exports.ArraySet = ArraySet;
          });
        }, {
          "./util": 617,
          "amdefine": 618
        }],
        609: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            var base64 = require('./base64');
            var VLQ_BASE_SHIFT = 5;
            var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
            var VLQ_BASE_MASK = VLQ_BASE - 1;
            var VLQ_CONTINUATION_BIT = VLQ_BASE;
            function toVLQSigned(aValue) {
              return aValue < 0 ? ((-aValue) << 1) + 1 : (aValue << 1) + 0;
            }
            function fromVLQSigned(aValue) {
              var isNegative = (aValue & 1) === 1;
              var shifted = aValue >> 1;
              return isNegative ? -shifted : shifted;
            }
            exports.encode = function base64VLQ_encode(aValue) {
              var encoded = "";
              var digit;
              var vlq = toVLQSigned(aValue);
              do {
                digit = vlq & VLQ_BASE_MASK;
                vlq >>>= VLQ_BASE_SHIFT;
                if (vlq > 0) {
                  digit |= VLQ_CONTINUATION_BIT;
                }
                encoded += base64.encode(digit);
              } while (vlq > 0);
              return encoded;
            };
            exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
              var strLen = aStr.length;
              var result = 0;
              var shift = 0;
              var continuation,
                  digit;
              do {
                if (aIndex >= strLen) {
                  throw new Error("Expected more digits in base 64 VLQ value.");
                }
                digit = base64.decode(aStr.charCodeAt(aIndex++));
                if (digit === -1) {
                  throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
                }
                continuation = !!(digit & VLQ_CONTINUATION_BIT);
                digit &= VLQ_BASE_MASK;
                result = result + (digit << shift);
                shift += VLQ_BASE_SHIFT;
              } while (continuation);
              aOutParam.value = fromVLQSigned(result);
              aOutParam.rest = aIndex;
            };
          });
        }, {
          "./base64": 610,
          "amdefine": 618
        }],
        610: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
            exports.encode = function(number) {
              if (0 <= number && number < intToCharMap.length) {
                return intToCharMap[number];
              }
              throw new TypeError("Must be between 0 and 63: " + aNumber);
            };
            exports.decode = function(charCode) {
              var bigA = 65;
              var bigZ = 90;
              var littleA = 97;
              var littleZ = 122;
              var zero = 48;
              var nine = 57;
              var plus = 43;
              var slash = 47;
              var littleOffset = 26;
              var numberOffset = 52;
              if (bigA <= charCode && charCode <= bigZ) {
                return (charCode - bigA);
              }
              if (littleA <= charCode && charCode <= littleZ) {
                return (charCode - littleA + littleOffset);
              }
              if (zero <= charCode && charCode <= nine) {
                return (charCode - zero + numberOffset);
              }
              if (charCode == plus) {
                return 62;
              }
              if (charCode == slash) {
                return 63;
              }
              return -1;
            };
          });
        }, {"amdefine": 618}],
        611: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            exports.GREATEST_LOWER_BOUND = 1;
            exports.LEAST_UPPER_BOUND = 2;
            function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
              var mid = Math.floor((aHigh - aLow) / 2) + aLow;
              var cmp = aCompare(aNeedle, aHaystack[mid], true);
              if (cmp === 0) {
                return mid;
              } else if (cmp > 0) {
                if (aHigh - mid > 1) {
                  return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
                }
                if (aBias == exports.LEAST_UPPER_BOUND) {
                  return aHigh < aHaystack.length ? aHigh : -1;
                } else {
                  return mid;
                }
              } else {
                if (mid - aLow > 1) {
                  return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
                }
                if (aBias == exports.LEAST_UPPER_BOUND) {
                  return mid;
                } else {
                  return aLow < 0 ? -1 : aLow;
                }
              }
            }
            exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
              if (aHaystack.length === 0) {
                return -1;
              }
              var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
              if (index < 0) {
                return -1;
              }
              while (index - 1 >= 0) {
                if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                  break;
                }
                --index;
              }
              return index;
            };
          });
        }, {"amdefine": 618}],
        612: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            var util = require('./util');
            function generatedPositionAfter(mappingA, mappingB) {
              var lineA = mappingA.generatedLine;
              var lineB = mappingB.generatedLine;
              var columnA = mappingA.generatedColumn;
              var columnB = mappingB.generatedColumn;
              return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
            }
            function MappingList() {
              this._array = [];
              this._sorted = true;
              this._last = {
                generatedLine: -1,
                generatedColumn: 0
              };
            }
            MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
              this._array.forEach(aCallback, aThisArg);
            };
            MappingList.prototype.add = function MappingList_add(aMapping) {
              var mapping;
              if (generatedPositionAfter(this._last, aMapping)) {
                this._last = aMapping;
                this._array.push(aMapping);
              } else {
                this._sorted = false;
                this._array.push(aMapping);
              }
            };
            MappingList.prototype.toArray = function MappingList_toArray() {
              if (!this._sorted) {
                this._array.sort(util.compareByGeneratedPositionsInflated);
                this._sorted = true;
              }
              return this._array;
            };
            exports.MappingList = MappingList;
          });
        }, {
          "./util": 617,
          "amdefine": 618
        }],
        613: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            function swap(ary, x, y) {
              var temp = ary[x];
              ary[x] = ary[y];
              ary[y] = temp;
            }
            function randomIntInRange(low, high) {
              return Math.round(low + (Math.random() * (high - low)));
            }
            function doQuickSort(ary, comparator, p, r) {
              if (p < r) {
                var pivotIndex = randomIntInRange(p, r);
                var i = p - 1;
                swap(ary, pivotIndex, r);
                var pivot = ary[r];
                for (var j = p; j < r; j++) {
                  if (comparator(ary[j], pivot) <= 0) {
                    i += 1;
                    swap(ary, i, j);
                  }
                }
                swap(ary, i + 1, j);
                var q = i + 1;
                doQuickSort(ary, comparator, p, q - 1);
                doQuickSort(ary, comparator, q + 1, r);
              }
            }
            exports.quickSort = function(ary, comparator) {
              doQuickSort(ary, comparator, 0, ary.length - 1);
            };
          });
        }, {"amdefine": 618}],
        614: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            var util = require('./util');
            var binarySearch = require('./binary-search');
            var ArraySet = require('./array-set').ArraySet;
            var base64VLQ = require('./base64-vlq');
            var quickSort = require('./quick-sort').quickSort;
            function SourceMapConsumer(aSourceMap) {
              var sourceMap = aSourceMap;
              if (typeof aSourceMap === 'string') {
                sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
              }
              return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
            }
            SourceMapConsumer.fromSourceMap = function(aSourceMap) {
              return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
            };
            SourceMapConsumer.prototype._version = 3;
            SourceMapConsumer.prototype.__generatedMappings = null;
            Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {get: function() {
                if (!this.__generatedMappings) {
                  this._parseMappings(this._mappings, this.sourceRoot);
                }
                return this.__generatedMappings;
              }});
            SourceMapConsumer.prototype.__originalMappings = null;
            Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {get: function() {
                if (!this.__originalMappings) {
                  this._parseMappings(this._mappings, this.sourceRoot);
                }
                return this.__originalMappings;
              }});
            SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
              var c = aStr.charAt(index);
              return c === ";" || c === ",";
            };
            SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
              throw new Error("Subclasses must implement _parseMappings");
            };
            SourceMapConsumer.GENERATED_ORDER = 1;
            SourceMapConsumer.ORIGINAL_ORDER = 2;
            SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
            SourceMapConsumer.LEAST_UPPER_BOUND = 2;
            SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
              var context = aContext || null;
              var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
              var mappings;
              switch (order) {
                case SourceMapConsumer.GENERATED_ORDER:
                  mappings = this._generatedMappings;
                  break;
                case SourceMapConsumer.ORIGINAL_ORDER:
                  mappings = this._originalMappings;
                  break;
                default:
                  throw new Error("Unknown order of iteration.");
              }
              var sourceRoot = this.sourceRoot;
              mappings.map(function(mapping) {
                var source = mapping.source === null ? null : this._sources.at(mapping.source);
                if (source != null && sourceRoot != null) {
                  source = util.join(sourceRoot, source);
                }
                return {
                  source: source,
                  generatedLine: mapping.generatedLine,
                  generatedColumn: mapping.generatedColumn,
                  originalLine: mapping.originalLine,
                  originalColumn: mapping.originalColumn,
                  name: mapping.name === null ? null : this._names.at(mapping.name)
                };
              }, this).forEach(aCallback, context);
            };
            SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
              var line = util.getArg(aArgs, 'line');
              var needle = {
                source: util.getArg(aArgs, 'source'),
                originalLine: line,
                originalColumn: util.getArg(aArgs, 'column', 0)
              };
              if (this.sourceRoot != null) {
                needle.source = util.relative(this.sourceRoot, needle.source);
              }
              if (!this._sources.has(needle.source)) {
                return [];
              }
              needle.source = this._sources.indexOf(needle.source);
              var mappings = [];
              var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
              if (index >= 0) {
                var mapping = this._originalMappings[index];
                if (aArgs.column === undefined) {
                  var originalLine = mapping.originalLine;
                  while (mapping && mapping.originalLine === originalLine) {
                    mappings.push({
                      line: util.getArg(mapping, 'generatedLine', null),
                      column: util.getArg(mapping, 'generatedColumn', null),
                      lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                    });
                    mapping = this._originalMappings[++index];
                  }
                } else {
                  var originalColumn = mapping.originalColumn;
                  while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
                    mappings.push({
                      line: util.getArg(mapping, 'generatedLine', null),
                      column: util.getArg(mapping, 'generatedColumn', null),
                      lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                    });
                    mapping = this._originalMappings[++index];
                  }
                }
              }
              return mappings;
            };
            exports.SourceMapConsumer = SourceMapConsumer;
            function BasicSourceMapConsumer(aSourceMap) {
              var sourceMap = aSourceMap;
              if (typeof aSourceMap === 'string') {
                sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
              }
              var version = util.getArg(sourceMap, 'version');
              var sources = util.getArg(sourceMap, 'sources');
              var names = util.getArg(sourceMap, 'names', []);
              var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
              var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
              var mappings = util.getArg(sourceMap, 'mappings');
              var file = util.getArg(sourceMap, 'file', null);
              if (version != this._version) {
                throw new Error('Unsupported version: ' + version);
              }
              sources = sources.map(util.normalize);
              this._names = ArraySet.fromArray(names, true);
              this._sources = ArraySet.fromArray(sources, true);
              this.sourceRoot = sourceRoot;
              this.sourcesContent = sourcesContent;
              this._mappings = mappings;
              this.file = file;
            }
            BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
            BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
            BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
              var smc = Object.create(BasicSourceMapConsumer.prototype);
              var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
              var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
              smc.sourceRoot = aSourceMap._sourceRoot;
              smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
              smc.file = aSourceMap._file;
              var generatedMappings = aSourceMap._mappings.toArray().slice();
              var destGeneratedMappings = smc.__generatedMappings = [];
              var destOriginalMappings = smc.__originalMappings = [];
              for (var i = 0,
                  length = generatedMappings.length; i < length; i++) {
                var srcMapping = generatedMappings[i];
                var destMapping = new Mapping;
                destMapping.generatedLine = srcMapping.generatedLine;
                destMapping.generatedColumn = srcMapping.generatedColumn;
                if (srcMapping.source) {
                  destMapping.source = sources.indexOf(srcMapping.source);
                  destMapping.originalLine = srcMapping.originalLine;
                  destMapping.originalColumn = srcMapping.originalColumn;
                  if (srcMapping.name) {
                    destMapping.name = names.indexOf(srcMapping.name);
                  }
                  destOriginalMappings.push(destMapping);
                }
                destGeneratedMappings.push(destMapping);
              }
              quickSort(smc.__originalMappings, util.compareByOriginalPositions);
              return smc;
            };
            BasicSourceMapConsumer.prototype._version = 3;
            Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {get: function() {
                return this._sources.toArray().map(function(s) {
                  return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
                }, this);
              }});
            function Mapping() {
              this.generatedLine = 0;
              this.generatedColumn = 0;
              this.source = null;
              this.originalLine = null;
              this.originalColumn = null;
              this.name = null;
            }
            BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
              var generatedLine = 1;
              var previousGeneratedColumn = 0;
              var previousOriginalLine = 0;
              var previousOriginalColumn = 0;
              var previousSource = 0;
              var previousName = 0;
              var length = aStr.length;
              var index = 0;
              var cachedSegments = {};
              var temp = {};
              var originalMappings = [];
              var generatedMappings = [];
              var mapping,
                  str,
                  segment,
                  end,
                  value;
              while (index < length) {
                if (aStr.charAt(index) === ';') {
                  generatedLine++;
                  index++;
                  previousGeneratedColumn = 0;
                } else if (aStr.charAt(index) === ',') {
                  index++;
                } else {
                  mapping = new Mapping();
                  mapping.generatedLine = generatedLine;
                  for (end = index; end < length; end++) {
                    if (this._charIsMappingSeparator(aStr, end)) {
                      break;
                    }
                  }
                  str = aStr.slice(index, end);
                  segment = cachedSegments[str];
                  if (segment) {
                    index += str.length;
                  } else {
                    segment = [];
                    while (index < end) {
                      base64VLQ.decode(aStr, index, temp);
                      value = temp.value;
                      index = temp.rest;
                      segment.push(value);
                    }
                    if (segment.length === 2) {
                      throw new Error('Found a source, but no line and column');
                    }
                    if (segment.length === 3) {
                      throw new Error('Found a source and line, but no column');
                    }
                    cachedSegments[str] = segment;
                  }
                  mapping.generatedColumn = previousGeneratedColumn + segment[0];
                  previousGeneratedColumn = mapping.generatedColumn;
                  if (segment.length > 1) {
                    mapping.source = previousSource + segment[1];
                    previousSource += segment[1];
                    mapping.originalLine = previousOriginalLine + segment[2];
                    previousOriginalLine = mapping.originalLine;
                    mapping.originalLine += 1;
                    mapping.originalColumn = previousOriginalColumn + segment[3];
                    previousOriginalColumn = mapping.originalColumn;
                    if (segment.length > 4) {
                      mapping.name = previousName + segment[4];
                      previousName += segment[4];
                    }
                  }
                  generatedMappings.push(mapping);
                  if (typeof mapping.originalLine === 'number') {
                    originalMappings.push(mapping);
                  }
                }
              }
              quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
              this.__generatedMappings = generatedMappings;
              quickSort(originalMappings, util.compareByOriginalPositions);
              this.__originalMappings = originalMappings;
            };
            BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
              if (aNeedle[aLineName] <= 0) {
                throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
              }
              if (aNeedle[aColumnName] < 0) {
                throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
              }
              return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
            };
            BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
              for (var index = 0; index < this._generatedMappings.length; ++index) {
                var mapping = this._generatedMappings[index];
                if (index + 1 < this._generatedMappings.length) {
                  var nextMapping = this._generatedMappings[index + 1];
                  if (mapping.generatedLine === nextMapping.generatedLine) {
                    mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                    continue;
                  }
                }
                mapping.lastGeneratedColumn = Infinity;
              }
            };
            BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
              var needle = {
                generatedLine: util.getArg(aArgs, 'line'),
                generatedColumn: util.getArg(aArgs, 'column')
              };
              var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
              if (index >= 0) {
                var mapping = this._generatedMappings[index];
                if (mapping.generatedLine === needle.generatedLine) {
                  var source = util.getArg(mapping, 'source', null);
                  if (source !== null) {
                    source = this._sources.at(source);
                    if (this.sourceRoot != null) {
                      source = util.join(this.sourceRoot, source);
                    }
                  }
                  var name = util.getArg(mapping, 'name', null);
                  if (name !== null) {
                    name = this._names.at(name);
                  }
                  return {
                    source: source,
                    line: util.getArg(mapping, 'originalLine', null),
                    column: util.getArg(mapping, 'originalColumn', null),
                    name: name
                  };
                }
              }
              return {
                source: null,
                line: null,
                column: null,
                name: null
              };
            };
            BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
              if (!this.sourcesContent) {
                return false;
              }
              return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
                return sc == null;
              });
            };
            BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
              if (!this.sourcesContent) {
                return null;
              }
              if (this.sourceRoot != null) {
                aSource = util.relative(this.sourceRoot, aSource);
              }
              if (this._sources.has(aSource)) {
                return this.sourcesContent[this._sources.indexOf(aSource)];
              }
              var url;
              if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
                var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
                if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
                  return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
                }
                if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
                  return this.sourcesContent[this._sources.indexOf("/" + aSource)];
                }
              }
              if (nullOnMissing) {
                return null;
              } else {
                throw new Error('"' + aSource + '" is not in the SourceMap.');
              }
            };
            BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
              var source = util.getArg(aArgs, 'source');
              if (this.sourceRoot != null) {
                source = util.relative(this.sourceRoot, source);
              }
              if (!this._sources.has(source)) {
                return {
                  line: null,
                  column: null,
                  lastColumn: null
                };
              }
              source = this._sources.indexOf(source);
              var needle = {
                source: source,
                originalLine: util.getArg(aArgs, 'line'),
                originalColumn: util.getArg(aArgs, 'column')
              };
              var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
              if (index >= 0) {
                var mapping = this._originalMappings[index];
                if (mapping.source === needle.source) {
                  return {
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                  };
                }
              }
              return {
                line: null,
                column: null,
                lastColumn: null
              };
            };
            exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
            function IndexedSourceMapConsumer(aSourceMap) {
              var sourceMap = aSourceMap;
              if (typeof aSourceMap === 'string') {
                sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
              }
              var version = util.getArg(sourceMap, 'version');
              var sections = util.getArg(sourceMap, 'sections');
              if (version != this._version) {
                throw new Error('Unsupported version: ' + version);
              }
              this._sources = new ArraySet();
              this._names = new ArraySet();
              var lastOffset = {
                line: -1,
                column: 0
              };
              this._sections = sections.map(function(s) {
                if (s.url) {
                  throw new Error('Support for url field in sections not implemented.');
                }
                var offset = util.getArg(s, 'offset');
                var offsetLine = util.getArg(offset, 'line');
                var offsetColumn = util.getArg(offset, 'column');
                if (offsetLine < lastOffset.line || (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
                  throw new Error('Section offsets must be ordered and non-overlapping.');
                }
                lastOffset = offset;
                return {
                  generatedOffset: {
                    generatedLine: offsetLine + 1,
                    generatedColumn: offsetColumn + 1
                  },
                  consumer: new SourceMapConsumer(util.getArg(s, 'map'))
                };
              });
            }
            IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
            IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
            IndexedSourceMapConsumer.prototype._version = 3;
            Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {get: function() {
                var sources = [];
                for (var i = 0; i < this._sections.length; i++) {
                  for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
                    sources.push(this._sections[i].consumer.sources[j]);
                  }
                }
                ;
                return sources;
              }});
            IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
              var needle = {
                generatedLine: util.getArg(aArgs, 'line'),
                generatedColumn: util.getArg(aArgs, 'column')
              };
              var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {
                var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
                if (cmp) {
                  return cmp;
                }
                return (needle.generatedColumn - section.generatedOffset.generatedColumn);
              });
              var section = this._sections[sectionIndex];
              if (!section) {
                return {
                  source: null,
                  line: null,
                  column: null,
                  name: null
                };
              }
              return section.consumer.originalPositionFor({
                line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
                column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                bias: aArgs.bias
              });
            };
            IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
              return this._sections.every(function(s) {
                return s.consumer.hasContentsOfAllSources();
              });
            };
            IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
              for (var i = 0; i < this._sections.length; i++) {
                var section = this._sections[i];
                var content = section.consumer.sourceContentFor(aSource, true);
                if (content) {
                  return content;
                }
              }
              if (nullOnMissing) {
                return null;
              } else {
                throw new Error('"' + aSource + '" is not in the SourceMap.');
              }
            };
            IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
              for (var i = 0; i < this._sections.length; i++) {
                var section = this._sections[i];
                if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
                  continue;
                }
                var generatedPosition = section.consumer.generatedPositionFor(aArgs);
                if (generatedPosition) {
                  var ret = {
                    line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                    column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
                  };
                  return ret;
                }
              }
              return {
                line: null,
                column: null
              };
            };
            IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
              this.__generatedMappings = [];
              this.__originalMappings = [];
              for (var i = 0; i < this._sections.length; i++) {
                var section = this._sections[i];
                var sectionMappings = section.consumer._generatedMappings;
                for (var j = 0; j < sectionMappings.length; j++) {
                  var mapping = sectionMappings[i];
                  var source = section.consumer._sources.at(mapping.source);
                  if (section.consumer.sourceRoot !== null) {
                    source = util.join(section.consumer.sourceRoot, source);
                  }
                  this._sources.add(source);
                  source = this._sources.indexOf(source);
                  var name = section.consumer._names.at(mapping.name);
                  this._names.add(name);
                  name = this._names.indexOf(name);
                  var adjustedMapping = {
                    source: source,
                    generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
                    generatedColumn: mapping.column + (section.generatedOffset.generatedLine === mapping.generatedLine) ? section.generatedOffset.generatedColumn - 1 : 0,
                    originalLine: mapping.originalLine,
                    originalColumn: mapping.originalColumn,
                    name: name
                  };
                  this.__generatedMappings.push(adjustedMapping);
                  if (typeof adjustedMapping.originalLine === 'number') {
                    this.__originalMappings.push(adjustedMapping);
                  }
                }
                ;
              }
              ;
              quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
              quickSort(this.__originalMappings, util.compareByOriginalPositions);
            };
            exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
          });
        }, {
          "./array-set": 608,
          "./base64-vlq": 609,
          "./binary-search": 611,
          "./quick-sort": 613,
          "./util": 617,
          "amdefine": 618
        }],
        615: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            var base64VLQ = require('./base64-vlq');
            var util = require('./util');
            var ArraySet = require('./array-set').ArraySet;
            var MappingList = require('./mapping-list').MappingList;
            function SourceMapGenerator(aArgs) {
              if (!aArgs) {
                aArgs = {};
              }
              this._file = util.getArg(aArgs, 'file', null);
              this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
              this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
              this._sources = new ArraySet();
              this._names = new ArraySet();
              this._mappings = new MappingList();
              this._sourcesContents = null;
            }
            SourceMapGenerator.prototype._version = 3;
            SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
              var sourceRoot = aSourceMapConsumer.sourceRoot;
              var generator = new SourceMapGenerator({
                file: aSourceMapConsumer.file,
                sourceRoot: sourceRoot
              });
              aSourceMapConsumer.eachMapping(function(mapping) {
                var newMapping = {generated: {
                    line: mapping.generatedLine,
                    column: mapping.generatedColumn
                  }};
                if (mapping.source != null) {
                  newMapping.source = mapping.source;
                  if (sourceRoot != null) {
                    newMapping.source = util.relative(sourceRoot, newMapping.source);
                  }
                  newMapping.original = {
                    line: mapping.originalLine,
                    column: mapping.originalColumn
                  };
                  if (mapping.name != null) {
                    newMapping.name = mapping.name;
                  }
                }
                generator.addMapping(newMapping);
              });
              aSourceMapConsumer.sources.forEach(function(sourceFile) {
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (content != null) {
                  generator.setSourceContent(sourceFile, content);
                }
              });
              return generator;
            };
            SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
              var generated = util.getArg(aArgs, 'generated');
              var original = util.getArg(aArgs, 'original', null);
              var source = util.getArg(aArgs, 'source', null);
              var name = util.getArg(aArgs, 'name', null);
              if (!this._skipValidation) {
                this._validateMapping(generated, original, source, name);
              }
              if (source != null && !this._sources.has(source)) {
                this._sources.add(source);
              }
              if (name != null && !this._names.has(name)) {
                this._names.add(name);
              }
              this._mappings.add({
                generatedLine: generated.line,
                generatedColumn: generated.column,
                originalLine: original != null && original.line,
                originalColumn: original != null && original.column,
                source: source,
                name: name
              });
            };
            SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
              var source = aSourceFile;
              if (this._sourceRoot != null) {
                source = util.relative(this._sourceRoot, source);
              }
              if (aSourceContent != null) {
                if (!this._sourcesContents) {
                  this._sourcesContents = {};
                }
                this._sourcesContents[util.toSetString(source)] = aSourceContent;
              } else if (this._sourcesContents) {
                delete this._sourcesContents[util.toSetString(source)];
                if (Object.keys(this._sourcesContents).length === 0) {
                  this._sourcesContents = null;
                }
              }
            };
            SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
              var sourceFile = aSourceFile;
              if (aSourceFile == null) {
                if (aSourceMapConsumer.file == null) {
                  throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
                }
                sourceFile = aSourceMapConsumer.file;
              }
              var sourceRoot = this._sourceRoot;
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              var newSources = new ArraySet();
              var newNames = new ArraySet();
              this._mappings.unsortedForEach(function(mapping) {
                if (mapping.source === sourceFile && mapping.originalLine != null) {
                  var original = aSourceMapConsumer.originalPositionFor({
                    line: mapping.originalLine,
                    column: mapping.originalColumn
                  });
                  if (original.source != null) {
                    mapping.source = original.source;
                    if (aSourceMapPath != null) {
                      mapping.source = util.join(aSourceMapPath, mapping.source);
                    }
                    if (sourceRoot != null) {
                      mapping.source = util.relative(sourceRoot, mapping.source);
                    }
                    mapping.originalLine = original.line;
                    mapping.originalColumn = original.column;
                    if (original.name != null) {
                      mapping.name = original.name;
                    }
                  }
                }
                var source = mapping.source;
                if (source != null && !newSources.has(source)) {
                  newSources.add(source);
                }
                var name = mapping.name;
                if (name != null && !newNames.has(name)) {
                  newNames.add(name);
                }
              }, this);
              this._sources = newSources;
              this._names = newNames;
              aSourceMapConsumer.sources.forEach(function(sourceFile) {
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (content != null) {
                  if (aSourceMapPath != null) {
                    sourceFile = util.join(aSourceMapPath, sourceFile);
                  }
                  if (sourceRoot != null) {
                    sourceFile = util.relative(sourceRoot, sourceFile);
                  }
                  this.setSourceContent(sourceFile, content);
                }
              }, this);
            };
            SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
              if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
                return;
              } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
                return;
              } else {
                throw new Error('Invalid mapping: ' + JSON.stringify({
                  generated: aGenerated,
                  source: aSource,
                  original: aOriginal,
                  name: aName
                }));
              }
            };
            SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
              var previousGeneratedColumn = 0;
              var previousGeneratedLine = 1;
              var previousOriginalColumn = 0;
              var previousOriginalLine = 0;
              var previousName = 0;
              var previousSource = 0;
              var result = '';
              var mapping;
              var mappings = this._mappings.toArray();
              for (var i = 0,
                  len = mappings.length; i < len; i++) {
                mapping = mappings[i];
                if (mapping.generatedLine !== previousGeneratedLine) {
                  previousGeneratedColumn = 0;
                  while (mapping.generatedLine !== previousGeneratedLine) {
                    result += ';';
                    previousGeneratedLine++;
                  }
                } else {
                  if (i > 0) {
                    if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                      continue;
                    }
                    result += ',';
                  }
                }
                result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
                previousGeneratedColumn = mapping.generatedColumn;
                if (mapping.source != null) {
                  result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);
                  previousSource = this._sources.indexOf(mapping.source);
                  result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
                  previousOriginalLine = mapping.originalLine - 1;
                  result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
                  previousOriginalColumn = mapping.originalColumn;
                  if (mapping.name != null) {
                    result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);
                    previousName = this._names.indexOf(mapping.name);
                  }
                }
              }
              return result;
            };
            SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
              return aSources.map(function(source) {
                if (!this._sourcesContents) {
                  return null;
                }
                if (aSourceRoot != null) {
                  source = util.relative(aSourceRoot, source);
                }
                var key = util.toSetString(source);
                return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
              }, this);
            };
            SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
              var map = {
                version: this._version,
                sources: this._sources.toArray(),
                names: this._names.toArray(),
                mappings: this._serializeMappings()
              };
              if (this._file != null) {
                map.file = this._file;
              }
              if (this._sourceRoot != null) {
                map.sourceRoot = this._sourceRoot;
              }
              if (this._sourcesContents) {
                map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
              }
              return map;
            };
            SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
              return JSON.stringify(this.toJSON());
            };
            exports.SourceMapGenerator = SourceMapGenerator;
          });
        }, {
          "./array-set": 608,
          "./base64-vlq": 609,
          "./mapping-list": 612,
          "./util": 617,
          "amdefine": 618
        }],
        616: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
            var util = require('./util');
            var REGEX_NEWLINE = /(\r?\n)/;
            var NEWLINE_CODE = 10;
            var isSourceNode = "$$$isSourceNode$$$";
            function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
              this.children = [];
              this.sourceContents = {};
              this.line = aLine == null ? null : aLine;
              this.column = aColumn == null ? null : aColumn;
              this.source = aSource == null ? null : aSource;
              this.name = aName == null ? null : aName;
              this[isSourceNode] = true;
              if (aChunks != null)
                this.add(aChunks);
            }
            SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
              var node = new SourceNode();
              var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
              var shiftNextLine = function() {
                var lineContents = remainingLines.shift();
                var newLine = remainingLines.shift() || "";
                return lineContents + newLine;
              };
              var lastGeneratedLine = 1,
                  lastGeneratedColumn = 0;
              var lastMapping = null;
              aSourceMapConsumer.eachMapping(function(mapping) {
                if (lastMapping !== null) {
                  if (lastGeneratedLine < mapping.generatedLine) {
                    var code = "";
                    addMappingWithCode(lastMapping, shiftNextLine());
                    lastGeneratedLine++;
                    lastGeneratedColumn = 0;
                  } else {
                    var nextLine = remainingLines[0];
                    var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                    remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                    lastGeneratedColumn = mapping.generatedColumn;
                    addMappingWithCode(lastMapping, code);
                    lastMapping = mapping;
                    return;
                  }
                }
                while (lastGeneratedLine < mapping.generatedLine) {
                  node.add(shiftNextLine());
                  lastGeneratedLine++;
                }
                if (lastGeneratedColumn < mapping.generatedColumn) {
                  var nextLine = remainingLines[0];
                  node.add(nextLine.substr(0, mapping.generatedColumn));
                  remainingLines[0] = nextLine.substr(mapping.generatedColumn);
                  lastGeneratedColumn = mapping.generatedColumn;
                }
                lastMapping = mapping;
              }, this);
              if (remainingLines.length > 0) {
                if (lastMapping) {
                  addMappingWithCode(lastMapping, shiftNextLine());
                }
                node.add(remainingLines.join(""));
              }
              aSourceMapConsumer.sources.forEach(function(sourceFile) {
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (content != null) {
                  if (aRelativePath != null) {
                    sourceFile = util.join(aRelativePath, sourceFile);
                  }
                  node.setSourceContent(sourceFile, content);
                }
              });
              return node;
              function addMappingWithCode(mapping, code) {
                if (mapping === null || mapping.source === undefined) {
                  node.add(code);
                } else {
                  var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
                  node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
                }
              }
            };
            SourceNode.prototype.add = function SourceNode_add(aChunk) {
              if (Array.isArray(aChunk)) {
                aChunk.forEach(function(chunk) {
                  this.add(chunk);
                }, this);
              } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
                if (aChunk) {
                  this.children.push(aChunk);
                }
              } else {
                throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
              }
              return this;
            };
            SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
              if (Array.isArray(aChunk)) {
                for (var i = aChunk.length - 1; i >= 0; i--) {
                  this.prepend(aChunk[i]);
                }
              } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
                this.children.unshift(aChunk);
              } else {
                throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
              }
              return this;
            };
            SourceNode.prototype.walk = function SourceNode_walk(aFn) {
              var chunk;
              for (var i = 0,
                  len = this.children.length; i < len; i++) {
                chunk = this.children[i];
                if (chunk[isSourceNode]) {
                  chunk.walk(aFn);
                } else {
                  if (chunk !== '') {
                    aFn(chunk, {
                      source: this.source,
                      line: this.line,
                      column: this.column,
                      name: this.name
                    });
                  }
                }
              }
            };
            SourceNode.prototype.join = function SourceNode_join(aSep) {
              var newChildren;
              var i;
              var len = this.children.length;
              if (len > 0) {
                newChildren = [];
                for (i = 0; i < len - 1; i++) {
                  newChildren.push(this.children[i]);
                  newChildren.push(aSep);
                }
                newChildren.push(this.children[i]);
                this.children = newChildren;
              }
              return this;
            };
            SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
              var lastChild = this.children[this.children.length - 1];
              if (lastChild[isSourceNode]) {
                lastChild.replaceRight(aPattern, aReplacement);
              } else if (typeof lastChild === 'string') {
                this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
              } else {
                this.children.push(''.replace(aPattern, aReplacement));
              }
              return this;
            };
            SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
              this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
            };
            SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
              for (var i = 0,
                  len = this.children.length; i < len; i++) {
                if (this.children[i][isSourceNode]) {
                  this.children[i].walkSourceContents(aFn);
                }
              }
              var sources = Object.keys(this.sourceContents);
              for (var i = 0,
                  len = sources.length; i < len; i++) {
                aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
              }
            };
            SourceNode.prototype.toString = function SourceNode_toString() {
              var str = "";
              this.walk(function(chunk) {
                str += chunk;
              });
              return str;
            };
            SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
              var generated = {
                code: "",
                line: 1,
                column: 0
              };
              var map = new SourceMapGenerator(aArgs);
              var sourceMappingActive = false;
              var lastOriginalSource = null;
              var lastOriginalLine = null;
              var lastOriginalColumn = null;
              var lastOriginalName = null;
              this.walk(function(chunk, original) {
                generated.code += chunk;
                if (original.source !== null && original.line !== null && original.column !== null) {
                  if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                    map.addMapping({
                      source: original.source,
                      original: {
                        line: original.line,
                        column: original.column
                      },
                      generated: {
                        line: generated.line,
                        column: generated.column
                      },
                      name: original.name
                    });
                  }
                  lastOriginalSource = original.source;
                  lastOriginalLine = original.line;
                  lastOriginalColumn = original.column;
                  lastOriginalName = original.name;
                  sourceMappingActive = true;
                } else if (sourceMappingActive) {
                  map.addMapping({generated: {
                      line: generated.line,
                      column: generated.column
                    }});
                  lastOriginalSource = null;
                  sourceMappingActive = false;
                }
                for (var idx = 0,
                    length = chunk.length; idx < length; idx++) {
                  if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                    generated.line++;
                    generated.column = 0;
                    if (idx + 1 === length) {
                      lastOriginalSource = null;
                      sourceMappingActive = false;
                    } else if (sourceMappingActive) {
                      map.addMapping({
                        source: original.source,
                        original: {
                          line: original.line,
                          column: original.column
                        },
                        generated: {
                          line: generated.line,
                          column: generated.column
                        },
                        name: original.name
                      });
                    }
                  } else {
                    generated.column++;
                  }
                }
              });
              this.walkSourceContents(function(sourceFile, sourceContent) {
                map.setSourceContent(sourceFile, sourceContent);
              });
              return {
                code: generated.code,
                map: map
              };
            };
            exports.SourceNode = SourceNode;
          });
        }, {
          "./source-map-generator": 615,
          "./util": 617,
          "amdefine": 618
        }],
        617: [function(require, module, exports) {
          if (typeof define !== 'function') {
            var define = require('amdefine')(module, require);
          }
          define(function(require, exports, module) {
            function getArg(aArgs, aName, aDefaultValue) {
              if (aName in aArgs) {
                return aArgs[aName];
              } else if (arguments.length === 3) {
                return aDefaultValue;
              } else {
                throw new Error('"' + aName + '" is a required argument.');
              }
            }
            exports.getArg = getArg;
            var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
            var dataUrlRegexp = /^data:.+\,.+$/;
            function urlParse(aUrl) {
              var match = aUrl.match(urlRegexp);
              if (!match) {
                return null;
              }
              return {
                scheme: match[1],
                auth: match[2],
                host: match[3],
                port: match[4],
                path: match[5]
              };
            }
            exports.urlParse = urlParse;
            function urlGenerate(aParsedUrl) {
              var url = '';
              if (aParsedUrl.scheme) {
                url += aParsedUrl.scheme + ':';
              }
              url += '//';
              if (aParsedUrl.auth) {
                url += aParsedUrl.auth + '@';
              }
              if (aParsedUrl.host) {
                url += aParsedUrl.host;
              }
              if (aParsedUrl.port) {
                url += ":" + aParsedUrl.port;
              }
              if (aParsedUrl.path) {
                url += aParsedUrl.path;
              }
              return url;
            }
            exports.urlGenerate = urlGenerate;
            function normalize(aPath) {
              var path = aPath;
              var url = urlParse(aPath);
              if (url) {
                if (!url.path) {
                  return aPath;
                }
                path = url.path;
              }
              var isAbsolute = (path.charAt(0) === '/');
              var parts = path.split(/\/+/);
              for (var part,
                  up = 0,
                  i = parts.length - 1; i >= 0; i--) {
                part = parts[i];
                if (part === '.') {
                  parts.splice(i, 1);
                } else if (part === '..') {
                  up++;
                } else if (up > 0) {
                  if (part === '') {
                    parts.splice(i + 1, up);
                    up = 0;
                  } else {
                    parts.splice(i, 2);
                    up--;
                  }
                }
              }
              path = parts.join('/');
              if (path === '') {
                path = isAbsolute ? '/' : '.';
              }
              if (url) {
                url.path = path;
                return urlGenerate(url);
              }
              return path;
            }
            exports.normalize = normalize;
            function join(aRoot, aPath) {
              if (aRoot === "") {
                aRoot = ".";
              }
              if (aPath === "") {
                aPath = ".";
              }
              var aPathUrl = urlParse(aPath);
              var aRootUrl = urlParse(aRoot);
              if (aRootUrl) {
                aRoot = aRootUrl.path || '/';
              }
              if (aPathUrl && !aPathUrl.scheme) {
                if (aRootUrl) {
                  aPathUrl.scheme = aRootUrl.scheme;
                }
                return urlGenerate(aPathUrl);
              }
              if (aPathUrl || aPath.match(dataUrlRegexp)) {
                return aPath;
              }
              if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
                aRootUrl.host = aPath;
                return urlGenerate(aRootUrl);
              }
              var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
              if (aRootUrl) {
                aRootUrl.path = joined;
                return urlGenerate(aRootUrl);
              }
              return joined;
            }
            exports.join = join;
            function relative(aRoot, aPath) {
              if (aRoot === "") {
                aRoot = ".";
              }
              aRoot = aRoot.replace(/\/$/, '');
              var level = 0;
              while (aPath.indexOf(aRoot + '/') !== 0) {
                var index = aRoot.lastIndexOf("/");
                if (index < 0) {
                  return aPath;
                }
                aRoot = aRoot.slice(0, index);
                if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                  return aPath;
                }
                ++level;
              }
              return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
            }
            exports.relative = relative;
            function toSetString(aStr) {
              return '$' + aStr;
            }
            exports.toSetString = toSetString;
            function fromSetString(aStr) {
              return aStr.substr(1);
            }
            exports.fromSetString = fromSetString;
            function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
              var cmp = mappingA.source - mappingB.source;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0 || onlyCompareOriginal) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              return mappingA.name - mappingB.name;
            }
            ;
            exports.compareByOriginalPositions = compareByOriginalPositions;
            function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
              var cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0 || onlyCompareGenerated) {
                return cmp;
              }
              cmp = mappingA.source - mappingB.source;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0) {
                return cmp;
              }
              return mappingA.name - mappingB.name;
            }
            ;
            exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
            function strcmp(aStr1, aStr2) {
              if (aStr1 === aStr2) {
                return 0;
              }
              if (aStr1 > aStr2) {
                return 1;
              }
              return -1;
            }
            function compareByGeneratedPositionsInflated(mappingA, mappingB) {
              var cmp = mappingA.generatedLine - mappingB.generatedLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.generatedColumn - mappingB.generatedColumn;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = strcmp(mappingA.source, mappingB.source);
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalLine - mappingB.originalLine;
              if (cmp !== 0) {
                return cmp;
              }
              cmp = mappingA.originalColumn - mappingB.originalColumn;
              if (cmp !== 0) {
                return cmp;
              }
              return strcmp(mappingA.name, mappingB.name);
            }
            ;
            exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
          });
        }, {"amdefine": 618}],
        618: [function(require, module, exports) {
          (function(process, __filename) {
            'use strict';
            function amdefine(module, requireFn) {
              'use strict';
              var defineCache = {},
                  loaderCache = {},
                  alreadyCalled = false,
                  path = require('path'),
                  makeRequire,
                  stringRequire;
              function trimDots(ary) {
                var i,
                    part;
                for (i = 0; ary[i]; i += 1) {
                  part = ary[i];
                  if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                  } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                      break;
                    } else if (i > 0) {
                      ary.splice(i - 1, 2);
                      i -= 2;
                    }
                  }
                }
              }
              function normalize(name, baseName) {
                var baseParts;
                if (name && name.charAt(0) === '.') {
                  if (baseName) {
                    baseParts = baseName.split('/');
                    baseParts = baseParts.slice(0, baseParts.length - 1);
                    baseParts = baseParts.concat(name.split('/'));
                    trimDots(baseParts);
                    name = baseParts.join('/');
                  }
                }
                return name;
              }
              function makeNormalize(relName) {
                return function(name) {
                  return normalize(name, relName);
                };
              }
              function makeLoad(id) {
                function load(value) {
                  loaderCache[id] = value;
                }
                load.fromText = function(id, text) {
                  throw new Error('amdefine does not implement load.fromText');
                };
                return load;
              }
              makeRequire = function(systemRequire, exports, module, relId) {
                function amdRequire(deps, callback) {
                  if (typeof deps === 'string') {
                    return stringRequire(systemRequire, exports, module, deps, relId);
                  } else {
                    deps = deps.map(function(depName) {
                      return stringRequire(systemRequire, exports, module, depName, relId);
                    });
                    if (callback) {
                      process.nextTick(function() {
                        callback.apply(null, deps);
                      });
                    }
                  }
                }
                amdRequire.toUrl = function(filePath) {
                  if (filePath.indexOf('.') === 0) {
                    return normalize(filePath, path.dirname(module.filename));
                  } else {
                    return filePath;
                  }
                };
                return amdRequire;
              };
              requireFn = requireFn || function req() {
                return module.require.apply(module, arguments);
              };
              function runFactory(id, deps, factory) {
                var r,
                    e,
                    m,
                    result;
                if (id) {
                  e = loaderCache[id] = {};
                  m = {
                    id: id,
                    uri: __filename,
                    exports: e
                  };
                  r = makeRequire(requireFn, e, m, id);
                } else {
                  if (alreadyCalled) {
                    throw new Error('amdefine with no module ID cannot be called more than once per file.');
                  }
                  alreadyCalled = true;
                  e = module.exports;
                  m = module;
                  r = makeRequire(requireFn, e, m, module.id);
                }
                if (deps) {
                  deps = deps.map(function(depName) {
                    return r(depName);
                  });
                }
                if (typeof factory === 'function') {
                  result = factory.apply(m.exports, deps);
                } else {
                  result = factory;
                }
                if (result !== undefined) {
                  m.exports = result;
                  if (id) {
                    loaderCache[id] = m.exports;
                  }
                }
              }
              stringRequire = function(systemRequire, exports, module, id, relId) {
                var index = id.indexOf('!'),
                    originalId = id,
                    prefix,
                    plugin;
                if (index === -1) {
                  id = normalize(id, relId);
                  if (id === 'require') {
                    return makeRequire(systemRequire, exports, module, relId);
                  } else if (id === 'exports') {
                    return exports;
                  } else if (id === 'module') {
                    return module;
                  } else if (loaderCache.hasOwnProperty(id)) {
                    return loaderCache[id];
                  } else if (defineCache[id]) {
                    runFactory.apply(null, defineCache[id]);
                    return loaderCache[id];
                  } else {
                    if (systemRequire) {
                      return systemRequire(originalId);
                    } else {
                      throw new Error('No module with ID: ' + id);
                    }
                  }
                } else {
                  prefix = id.substring(0, index);
                  id = id.substring(index + 1, id.length);
                  plugin = stringRequire(systemRequire, exports, module, prefix, relId);
                  if (plugin.normalize) {
                    id = plugin.normalize(id, makeNormalize(relId));
                  } else {
                    id = normalize(id, relId);
                  }
                  if (loaderCache[id]) {
                    return loaderCache[id];
                  } else {
                    plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
                    return loaderCache[id];
                  }
                }
              };
              function define(id, deps, factory) {
                if (Array.isArray(id)) {
                  factory = deps;
                  deps = id;
                  id = undefined;
                } else if (typeof id !== 'string') {
                  factory = id;
                  id = deps = undefined;
                }
                if (deps && !Array.isArray(deps)) {
                  factory = deps;
                  deps = undefined;
                }
                if (!deps) {
                  deps = ['require', 'exports', 'module'];
                }
                if (id) {
                  defineCache[id] = [id, deps, factory];
                } else {
                  runFactory(id, deps, factory);
                }
              }
              define.require = function(id) {
                if (loaderCache[id]) {
                  return loaderCache[id];
                }
                if (defineCache[id]) {
                  runFactory.apply(null, defineCache[id]);
                  return loaderCache[id];
                }
              };
              define.amd = {};
              return define;
            }
            module.exports = amdefine;
          }).call(this, require('_process'), "/node_modules/source-map/node_modules/amdefine/amdefine.js");
        }, {
          "_process": 12,
          "path": 11
        }],
        619: [function(require, module, exports) {
          'use strict';
          module.exports = function toFastProperties(obj) {
            function f() {}
            f.prototype = obj;
            new f();
            return;
            eval(obj);
          };
        }, {}],
        620: [function(require, module, exports) {
          'use strict';
          module.exports = function(str) {
            var tail = str.length;
            while (/[\s\uFEFF\u00A0]/.test(str[tail - 1])) {
              tail--;
            }
            return str.slice(0, tail);
          };
        }, {}],
        621: [function(require, module, exports) {
          (function(process) {
            var Module = require("module");
            var resolve = module.exports = function(loc, _require) {
              try {
                return (_require || require).resolve(loc);
              } catch (err) {
                return null;
              }
            };
            var relativeMod;
            resolve.relative = function(loc) {
              if (typeof Module === "object")
                return null;
              if (!relativeMod) {
                relativeMod = new Module;
                relativeMod.paths = Module._nodeModulePaths(process.cwd());
              }
              try {
                return Module._resolveFilename(loc, relativeMod);
              } catch (err) {
                return null;
              }
            };
          }).call(this, require('_process'));
        }, {
          "_process": 12,
          "module": 1
        }],
        622: [function(require, module, exports) {
          module.exports = {
            "name": "babel-core",
            "version": "5.8.25",
            "description": "A compiler for writing next generation JavaScript",
            "author": "Sebastian McKenzie <sebmck@gmail.com>",
            "homepage": "https://babeljs.io/",
            "license": "MIT",
            "repository": "babel/babel",
            "browser": {"./lib/api/register/node.js": "./lib/api/register/browser.js"},
            "keywords": ["6to5", "babel", "classes", "const", "es6", "harmony", "let", "modules", "transpile", "transpiler", "var"],
            "scripts": {
              "bench": "make bench",
              "test": "make test"
            },
            "dependencies": {
              "babel-plugin-constant-folding": "^1.0.1",
              "babel-plugin-dead-code-elimination": "^1.0.2",
              "babel-plugin-eval": "^1.0.1",
              "babel-plugin-inline-environment-variables": "^1.0.1",
              "babel-plugin-jscript": "^1.0.4",
              "babel-plugin-member-expression-literals": "^1.0.1",
              "babel-plugin-property-literals": "^1.0.1",
              "babel-plugin-proto-to-assign": "^1.0.3",
              "babel-plugin-react-constant-elements": "^1.0.3",
              "babel-plugin-react-display-name": "^1.0.3",
              "babel-plugin-remove-console": "^1.0.1",
              "babel-plugin-remove-debugger": "^1.0.1",
              "babel-plugin-runtime": "^1.0.7",
              "babel-plugin-undeclared-variables-check": "^1.0.2",
              "babel-plugin-undefined-to-void": "^1.1.6",
              "babylon": "^5.8.23",
              "bluebird": "^2.9.33",
              "chalk": "^1.0.0",
              "convert-source-map": "^1.1.0",
              "core-js": "^1.0.0",
              "debug": "^2.1.1",
              "detect-indent": "^3.0.0",
              "esutils": "^2.0.0",
              "fs-readdir-recursive": "^0.1.0",
              "globals": "^6.4.0",
              "home-or-tmp": "^1.0.0",
              "is-integer": "^1.0.4",
              "js-tokens": "1.0.1",
              "json5": "^0.4.0",
              "line-numbers": "0.2.0",
              "lodash": "^3.10.0",
              "minimatch": "^2.0.3",
              "output-file-sync": "^1.1.0",
              "path-exists": "^1.0.0",
              "path-is-absolute": "^1.0.0",
              "private": "^0.1.6",
              "regenerator": "0.8.35",
              "regexpu": "^1.1.2",
              "repeating": "^1.1.2",
              "resolve": "^1.1.6",
              "shebang-regex": "^1.0.0",
              "slash": "^1.0.0",
              "source-map": "^0.4.0",
              "source-map-support": "^0.2.10",
              "to-fast-properties": "^1.0.0",
              "trim-right": "^1.0.0",
              "try-resolve": "^1.0.0"
            }
          };
        }, {}],
        623: [function(require, module, exports) {
          module.exports = {
            "abstract-expression-call": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "CallExpression",
                      "callee": {
                        "type": "MemberExpression",
                        "object": {
                          "type": "Identifier",
                          "name": "PROPERTY"
                        },
                        "property": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "Symbol"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "referenceGet"
                          },
                          "computed": false
                        },
                        "computed": true
                      },
                      "arguments": [{
                        "type": "Identifier",
                        "name": "OBJECT"
                      }]
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "call"
                    },
                    "computed": false
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "OBJECT"
                  }]
                }
              }]
            },
            "abstract-expression-delete": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "PROPERTY"
                    },
                    "property": {
                      "type": "MemberExpression",
                      "object": {
                        "type": "Identifier",
                        "name": "Symbol"
                      },
                      "property": {
                        "type": "Identifier",
                        "name": "referenceDelete"
                      },
                      "computed": false
                    },
                    "computed": true
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "OBJECT"
                  }]
                }
              }]
            },
            "abstract-expression-get": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "PROPERTY"
                    },
                    "property": {
                      "type": "MemberExpression",
                      "object": {
                        "type": "Identifier",
                        "name": "Symbol"
                      },
                      "property": {
                        "type": "Identifier",
                        "name": "referenceGet"
                      },
                      "computed": false
                    },
                    "computed": true
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "OBJECT"
                  }]
                }
              }]
            },
            "abstract-expression-set": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "PROPERTY"
                    },
                    "property": {
                      "type": "MemberExpression",
                      "object": {
                        "type": "Identifier",
                        "name": "Symbol"
                      },
                      "property": {
                        "type": "Identifier",
                        "name": "referenceSet"
                      },
                      "computed": false
                    },
                    "computed": true
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "OBJECT"
                  }, {
                    "type": "Identifier",
                    "name": "VALUE"
                  }]
                }
              }]
            },
            "array-comprehension-container": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "VariableDeclaration",
                        "declarations": [{
                          "type": "VariableDeclarator",
                          "id": {
                            "type": "Identifier",
                            "name": "KEY"
                          },
                          "init": {
                            "type": "ArrayExpression",
                            "elements": []
                          }
                        }],
                        "kind": "var"
                      }, {
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "Identifier",
                          "name": "KEY"
                        }
                      }]
                    },
                    "parenthesizedExpression": true
                  },
                  "arguments": []
                }
              }]
            },
            "array-from": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "Array"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "from"
                    },
                    "computed": false
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "VALUE"
                  }]
                }
              }]
            },
            "array-push": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "KEY"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "push"
                    },
                    "computed": false
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "STATEMENT"
                  }]
                }
              }]
            },
            "call": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "OBJECT"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "call"
                    },
                    "computed": false
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "CONTEXT"
                  }]
                }
              }]
            },
            "class-decorator": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "AssignmentExpression",
                  "operator": "=",
                  "left": {
                    "type": "Identifier",
                    "name": "CLASS_REF"
                  },
                  "right": {
                    "type": "LogicalExpression",
                    "left": {
                      "type": "CallExpression",
                      "callee": {
                        "type": "Identifier",
                        "name": "DECORATOR"
                      },
                      "arguments": [{
                        "type": "Identifier",
                        "name": "CLASS_REF"
                      }]
                    },
                    "operator": "||",
                    "right": {
                      "type": "Identifier",
                      "name": "CLASS_REF"
                    }
                  }
                }
              }]
            },
            "class-derived-default-constructor": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "CallExpression",
                        "callee": {"type": "Super"},
                        "arguments": [{
                          "type": "SpreadElement",
                          "argument": {
                            "type": "Identifier",
                            "name": "arguments"
                          }
                        }]
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "default-parameter-assign": {
              "type": "Program",
              "body": [{
                "type": "IfStatement",
                "test": {
                  "type": "BinaryExpression",
                  "left": {
                    "type": "Identifier",
                    "name": "VARIABLE_NAME"
                  },
                  "operator": "===",
                  "right": {
                    "type": "Identifier",
                    "name": "undefined"
                  }
                },
                "consequent": {
                  "type": "ExpressionStatement",
                  "expression": {
                    "type": "AssignmentExpression",
                    "operator": "=",
                    "left": {
                      "type": "Identifier",
                      "name": "VARIABLE_NAME"
                    },
                    "right": {
                      "type": "Identifier",
                      "name": "DEFAULT_VALUE"
                    }
                  }
                },
                "alternate": null
              }]
            },
            "default-parameter": {
              "type": "Program",
              "body": [{
                "type": "VariableDeclaration",
                "declarations": [{
                  "type": "VariableDeclarator",
                  "id": {
                    "type": "Identifier",
                    "name": "VARIABLE_NAME"
                  },
                  "init": {
                    "type": "ConditionalExpression",
                    "test": {
                      "type": "LogicalExpression",
                      "left": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "ARGUMENTS"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "length"
                          },
                          "computed": false
                        },
                        "operator": "<=",
                        "right": {
                          "type": "Identifier",
                          "name": "ARGUMENT_KEY"
                        }
                      },
                      "operator": "||",
                      "right": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "ARGUMENTS"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "ARGUMENT_KEY"
                          },
                          "computed": true
                        },
                        "operator": "===",
                        "right": {
                          "type": "Identifier",
                          "name": "undefined"
                        }
                      }
                    },
                    "consequent": {
                      "type": "Identifier",
                      "name": "DEFAULT_VALUE"
                    },
                    "alternate": {
                      "type": "MemberExpression",
                      "object": {
                        "type": "Identifier",
                        "name": "ARGUMENTS"
                      },
                      "property": {
                        "type": "Identifier",
                        "name": "ARGUMENT_KEY"
                      },
                      "computed": true
                    }
                  }
                }],
                "kind": "let"
              }]
            },
            "exports-assign": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "AssignmentExpression",
                  "operator": "=",
                  "left": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "exports"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "KEY"
                    },
                    "computed": false
                  },
                  "right": {
                    "type": "Identifier",
                    "name": "VALUE"
                  }
                }
              }]
            },
            "exports-default-assign": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "AssignmentExpression",
                  "operator": "=",
                  "left": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "module"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "exports"
                    },
                    "computed": false
                  },
                  "right": {
                    "type": "Identifier",
                    "name": "VALUE"
                  }
                }
              }]
            },
            "exports-from-assign": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "Object"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "defineProperty"
                    },
                    "computed": false
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "exports"
                  }, {
                    "type": "Identifier",
                    "name": "ID"
                  }, {
                    "type": "ObjectExpression",
                    "properties": [{
                      "type": "Property",
                      "method": false,
                      "shorthand": false,
                      "computed": false,
                      "key": {
                        "type": "Identifier",
                        "name": "enumerable"
                      },
                      "value": {
                        "type": "Literal",
                        "value": true
                      },
                      "kind": "init"
                    }, {
                      "type": "Property",
                      "method": false,
                      "shorthand": false,
                      "computed": false,
                      "key": {
                        "type": "Identifier",
                        "name": "get"
                      },
                      "value": {
                        "type": "FunctionExpression",
                        "id": {
                          "type": "Identifier",
                          "name": "get"
                        },
                        "generator": false,
                        "expression": false,
                        "params": [],
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "Identifier",
                              "name": "INIT"
                            }
                          }]
                        }
                      },
                      "kind": "init"
                    }]
                  }]
                }
              }]
            },
            "exports-module-declaration-loose": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "AssignmentExpression",
                  "operator": "=",
                  "left": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "exports"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "__esModule"
                    },
                    "computed": false
                  },
                  "right": {
                    "type": "Literal",
                    "value": true
                  }
                }
              }]
            },
            "exports-module-declaration": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "Object"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "defineProperty"
                    },
                    "computed": false
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "exports"
                  }, {
                    "type": "Literal",
                    "value": "__esModule"
                  }, {
                    "type": "ObjectExpression",
                    "properties": [{
                      "type": "Property",
                      "method": false,
                      "shorthand": false,
                      "computed": false,
                      "key": {
                        "type": "Identifier",
                        "name": "value"
                      },
                      "value": {
                        "type": "Literal",
                        "value": true
                      },
                      "kind": "init"
                    }]
                  }]
                }
              }]
            },
            "for-of-array": {
              "type": "Program",
              "body": [{
                "type": "ForStatement",
                "init": {
                  "type": "VariableDeclaration",
                  "declarations": [{
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "KEY"
                    },
                    "init": {
                      "type": "Literal",
                      "value": 0
                    }
                  }],
                  "kind": "var"
                },
                "test": {
                  "type": "BinaryExpression",
                  "left": {
                    "type": "Identifier",
                    "name": "KEY"
                  },
                  "operator": "<",
                  "right": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "ARR"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "length"
                    },
                    "computed": false
                  }
                },
                "update": {
                  "type": "UpdateExpression",
                  "operator": "++",
                  "prefix": false,
                  "argument": {
                    "type": "Identifier",
                    "name": "KEY"
                  }
                },
                "body": {
                  "type": "ExpressionStatement",
                  "expression": {
                    "type": "Identifier",
                    "name": "BODY"
                  }
                }
              }]
            },
            "for-of-loose": {
              "type": "Program",
              "body": [{
                "type": "ForStatement",
                "init": {
                  "type": "VariableDeclaration",
                  "declarations": [{
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "LOOP_OBJECT"
                    },
                    "init": {
                      "type": "Identifier",
                      "name": "OBJECT"
                    }
                  }, {
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "IS_ARRAY"
                    },
                    "init": {
                      "type": "CallExpression",
                      "callee": {
                        "type": "MemberExpression",
                        "object": {
                          "type": "Identifier",
                          "name": "Array"
                        },
                        "property": {
                          "type": "Identifier",
                          "name": "isArray"
                        },
                        "computed": false
                      },
                      "arguments": [{
                        "type": "Identifier",
                        "name": "LOOP_OBJECT"
                      }]
                    }
                  }, {
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "INDEX"
                    },
                    "init": {
                      "type": "Literal",
                      "value": 0
                    }
                  }, {
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "LOOP_OBJECT"
                    },
                    "init": {
                      "type": "ConditionalExpression",
                      "test": {
                        "type": "Identifier",
                        "name": "IS_ARRAY"
                      },
                      "consequent": {
                        "type": "Identifier",
                        "name": "LOOP_OBJECT"
                      },
                      "alternate": {
                        "type": "CallExpression",
                        "callee": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "LOOP_OBJECT"
                          },
                          "property": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Symbol"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "iterator"
                            },
                            "computed": false
                          },
                          "computed": true
                        },
                        "arguments": []
                      }
                    }
                  }],
                  "kind": "var"
                },
                "test": null,
                "update": null,
                "body": {
                  "type": "BlockStatement",
                  "body": [{
                    "type": "VariableDeclaration",
                    "declarations": [{
                      "type": "VariableDeclarator",
                      "id": {
                        "type": "Identifier",
                        "name": "ID"
                      },
                      "init": null
                    }],
                    "kind": "var"
                  }, {
                    "type": "IfStatement",
                    "test": {
                      "type": "Identifier",
                      "name": "IS_ARRAY"
                    },
                    "consequent": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "IfStatement",
                        "test": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "Identifier",
                            "name": "INDEX"
                          },
                          "operator": ">=",
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "LOOP_OBJECT"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "length"
                            },
                            "computed": false
                          }
                        },
                        "consequent": {
                          "type": "BreakStatement",
                          "label": null
                        },
                        "alternate": null
                      }, {
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "AssignmentExpression",
                          "operator": "=",
                          "left": {
                            "type": "Identifier",
                            "name": "ID"
                          },
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "LOOP_OBJECT"
                            },
                            "property": {
                              "type": "UpdateExpression",
                              "operator": "++",
                              "prefix": false,
                              "argument": {
                                "type": "Identifier",
                                "name": "INDEX"
                              }
                            },
                            "computed": true
                          }
                        }
                      }]
                    },
                    "alternate": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "AssignmentExpression",
                          "operator": "=",
                          "left": {
                            "type": "Identifier",
                            "name": "INDEX"
                          },
                          "right": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "LOOP_OBJECT"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "next"
                              },
                              "computed": false
                            },
                            "arguments": []
                          }
                        }
                      }, {
                        "type": "IfStatement",
                        "test": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "INDEX"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "done"
                          },
                          "computed": false
                        },
                        "consequent": {
                          "type": "BreakStatement",
                          "label": null
                        },
                        "alternate": null
                      }, {
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "AssignmentExpression",
                          "operator": "=",
                          "left": {
                            "type": "Identifier",
                            "name": "ID"
                          },
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "INDEX"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "value"
                            },
                            "computed": false
                          }
                        }
                      }]
                    }
                  }]
                }
              }]
            },
            "for-of": {
              "type": "Program",
              "body": [{
                "type": "VariableDeclaration",
                "declarations": [{
                  "type": "VariableDeclarator",
                  "id": {
                    "type": "Identifier",
                    "name": "ITERATOR_COMPLETION"
                  },
                  "init": {
                    "type": "Literal",
                    "value": true
                  }
                }],
                "kind": "var"
              }, {
                "type": "VariableDeclaration",
                "declarations": [{
                  "type": "VariableDeclarator",
                  "id": {
                    "type": "Identifier",
                    "name": "ITERATOR_HAD_ERROR_KEY"
                  },
                  "init": {
                    "type": "Literal",
                    "value": false
                  }
                }],
                "kind": "var"
              }, {
                "type": "VariableDeclaration",
                "declarations": [{
                  "type": "VariableDeclarator",
                  "id": {
                    "type": "Identifier",
                    "name": "ITERATOR_ERROR_KEY"
                  },
                  "init": {
                    "type": "Identifier",
                    "name": "undefined"
                  }
                }],
                "kind": "var"
              }, {
                "type": "TryStatement",
                "block": {
                  "type": "BlockStatement",
                  "body": [{
                    "type": "ForStatement",
                    "init": {
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "ITERATOR_KEY"
                        },
                        "init": {
                          "type": "CallExpression",
                          "callee": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "OBJECT"
                            },
                            "property": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "Symbol"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "iterator"
                              },
                              "computed": false
                            },
                            "computed": true
                          },
                          "arguments": []
                        }
                      }, {
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "STEP_KEY"
                        },
                        "init": null
                      }],
                      "kind": "var"
                    },
                    "test": {
                      "type": "UnaryExpression",
                      "operator": "!",
                      "prefix": true,
                      "argument": {
                        "type": "AssignmentExpression",
                        "operator": "=",
                        "left": {
                          "type": "Identifier",
                          "name": "ITERATOR_COMPLETION"
                        },
                        "right": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "Identifier",
                              "name": "STEP_KEY"
                            },
                            "right": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "ITERATOR_KEY"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "next"
                                },
                                "computed": false
                              },
                              "arguments": []
                            },
                            "parenthesizedExpression": true
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "done"
                          },
                          "computed": false
                        },
                        "parenthesizedExpression": true
                      }
                    },
                    "update": {
                      "type": "AssignmentExpression",
                      "operator": "=",
                      "left": {
                        "type": "Identifier",
                        "name": "ITERATOR_COMPLETION"
                      },
                      "right": {
                        "type": "Literal",
                        "value": true
                      }
                    },
                    "body": {
                      "type": "BlockStatement",
                      "body": []
                    }
                  }]
                },
                "handler": {
                  "type": "CatchClause",
                  "param": {
                    "type": "Identifier",
                    "name": "err"
                  },
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "AssignmentExpression",
                        "operator": "=",
                        "left": {
                          "type": "Identifier",
                          "name": "ITERATOR_HAD_ERROR_KEY"
                        },
                        "right": {
                          "type": "Literal",
                          "value": true
                        }
                      }
                    }, {
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "AssignmentExpression",
                        "operator": "=",
                        "left": {
                          "type": "Identifier",
                          "name": "ITERATOR_ERROR_KEY"
                        },
                        "right": {
                          "type": "Identifier",
                          "name": "err"
                        }
                      }
                    }]
                  }
                },
                "guardedHandlers": [],
                "finalizer": {
                  "type": "BlockStatement",
                  "body": [{
                    "type": "TryStatement",
                    "block": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "IfStatement",
                        "test": {
                          "type": "LogicalExpression",
                          "left": {
                            "type": "UnaryExpression",
                            "operator": "!",
                            "prefix": true,
                            "argument": {
                              "type": "Identifier",
                              "name": "ITERATOR_COMPLETION"
                            }
                          },
                          "operator": "&&",
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "ITERATOR_KEY"
                            },
                            "property": {
                              "type": "Literal",
                              "value": "return"
                            },
                            "computed": true
                          }
                        },
                        "consequent": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ExpressionStatement",
                            "expression": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "ITERATOR_KEY"
                                },
                                "property": {
                                  "type": "Literal",
                                  "value": "return"
                                },
                                "computed": true
                              },
                              "arguments": []
                            }
                          }]
                        },
                        "alternate": null
                      }]
                    },
                    "handler": null,
                    "guardedHandlers": [],
                    "finalizer": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "IfStatement",
                        "test": {
                          "type": "Identifier",
                          "name": "ITERATOR_HAD_ERROR_KEY"
                        },
                        "consequent": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ThrowStatement",
                            "argument": {
                              "type": "Identifier",
                              "name": "ITERATOR_ERROR_KEY"
                            }
                          }]
                        },
                        "alternate": null
                      }]
                    }
                  }]
                }
              }]
            },
            "helper-async-to-generator": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "fn"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "FunctionExpression",
                        "id": null,
                        "generator": false,
                        "expression": false,
                        "params": [],
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "gen"
                              },
                              "init": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "MemberExpression",
                                  "object": {
                                    "type": "Identifier",
                                    "name": "fn"
                                  },
                                  "property": {
                                    "type": "Identifier",
                                    "name": "apply"
                                  },
                                  "computed": false
                                },
                                "arguments": [{"type": "ThisExpression"}, {
                                  "type": "Identifier",
                                  "name": "arguments"
                                }]
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "NewExpression",
                              "callee": {
                                "type": "Identifier",
                                "name": "Promise"
                              },
                              "arguments": [{
                                "type": "FunctionExpression",
                                "id": null,
                                "generator": false,
                                "expression": false,
                                "params": [{
                                  "type": "Identifier",
                                  "name": "resolve"
                                }, {
                                  "type": "Identifier",
                                  "name": "reject"
                                }],
                                "body": {
                                  "type": "BlockStatement",
                                  "body": [{
                                    "type": "VariableDeclaration",
                                    "declarations": [{
                                      "type": "VariableDeclarator",
                                      "id": {
                                        "type": "Identifier",
                                        "name": "callNext"
                                      },
                                      "init": {
                                        "type": "CallExpression",
                                        "callee": {
                                          "type": "MemberExpression",
                                          "object": {
                                            "type": "Identifier",
                                            "name": "step"
                                          },
                                          "property": {
                                            "type": "Identifier",
                                            "name": "bind"
                                          },
                                          "computed": false
                                        },
                                        "arguments": [{
                                          "type": "Literal",
                                          "value": null,
                                          "rawValue": null
                                        }, {
                                          "type": "Literal",
                                          "value": "next"
                                        }]
                                      }
                                    }],
                                    "kind": "var"
                                  }, {
                                    "type": "VariableDeclaration",
                                    "declarations": [{
                                      "type": "VariableDeclarator",
                                      "id": {
                                        "type": "Identifier",
                                        "name": "callThrow"
                                      },
                                      "init": {
                                        "type": "CallExpression",
                                        "callee": {
                                          "type": "MemberExpression",
                                          "object": {
                                            "type": "Identifier",
                                            "name": "step"
                                          },
                                          "property": {
                                            "type": "Identifier",
                                            "name": "bind"
                                          },
                                          "computed": false
                                        },
                                        "arguments": [{
                                          "type": "Literal",
                                          "value": null,
                                          "rawValue": null
                                        }, {
                                          "type": "Literal",
                                          "value": "throw"
                                        }]
                                      }
                                    }],
                                    "kind": "var"
                                  }, {
                                    "type": "FunctionDeclaration",
                                    "id": {
                                      "type": "Identifier",
                                      "name": "step"
                                    },
                                    "generator": false,
                                    "expression": false,
                                    "params": [{
                                      "type": "Identifier",
                                      "name": "key"
                                    }, {
                                      "type": "Identifier",
                                      "name": "arg"
                                    }],
                                    "body": {
                                      "type": "BlockStatement",
                                      "body": [{
                                        "type": "TryStatement",
                                        "block": {
                                          "type": "BlockStatement",
                                          "body": [{
                                            "type": "VariableDeclaration",
                                            "declarations": [{
                                              "type": "VariableDeclarator",
                                              "id": {
                                                "type": "Identifier",
                                                "name": "info"
                                              },
                                              "init": {
                                                "type": "CallExpression",
                                                "callee": {
                                                  "type": "MemberExpression",
                                                  "object": {
                                                    "type": "Identifier",
                                                    "name": "gen"
                                                  },
                                                  "property": {
                                                    "type": "Identifier",
                                                    "name": "key"
                                                  },
                                                  "computed": true
                                                },
                                                "arguments": [{
                                                  "type": "Identifier",
                                                  "name": "arg"
                                                }]
                                              }
                                            }],
                                            "kind": "var"
                                          }, {
                                            "type": "VariableDeclaration",
                                            "declarations": [{
                                              "type": "VariableDeclarator",
                                              "id": {
                                                "type": "Identifier",
                                                "name": "value"
                                              },
                                              "init": {
                                                "type": "MemberExpression",
                                                "object": {
                                                  "type": "Identifier",
                                                  "name": "info"
                                                },
                                                "property": {
                                                  "type": "Identifier",
                                                  "name": "value"
                                                },
                                                "computed": false
                                              }
                                            }],
                                            "kind": "var"
                                          }]
                                        },
                                        "handler": {
                                          "type": "CatchClause",
                                          "param": {
                                            "type": "Identifier",
                                            "name": "error"
                                          },
                                          "body": {
                                            "type": "BlockStatement",
                                            "body": [{
                                              "type": "ExpressionStatement",
                                              "expression": {
                                                "type": "CallExpression",
                                                "callee": {
                                                  "type": "Identifier",
                                                  "name": "reject"
                                                },
                                                "arguments": [{
                                                  "type": "Identifier",
                                                  "name": "error"
                                                }]
                                              }
                                            }, {
                                              "type": "ReturnStatement",
                                              "argument": null
                                            }]
                                          }
                                        },
                                        "guardedHandlers": [],
                                        "finalizer": null
                                      }, {
                                        "type": "IfStatement",
                                        "test": {
                                          "type": "MemberExpression",
                                          "object": {
                                            "type": "Identifier",
                                            "name": "info"
                                          },
                                          "property": {
                                            "type": "Identifier",
                                            "name": "done"
                                          },
                                          "computed": false
                                        },
                                        "consequent": {
                                          "type": "BlockStatement",
                                          "body": [{
                                            "type": "ExpressionStatement",
                                            "expression": {
                                              "type": "CallExpression",
                                              "callee": {
                                                "type": "Identifier",
                                                "name": "resolve"
                                              },
                                              "arguments": [{
                                                "type": "Identifier",
                                                "name": "value"
                                              }]
                                            }
                                          }]
                                        },
                                        "alternate": {
                                          "type": "BlockStatement",
                                          "body": [{
                                            "type": "ExpressionStatement",
                                            "expression": {
                                              "type": "CallExpression",
                                              "callee": {
                                                "type": "MemberExpression",
                                                "object": {
                                                  "type": "CallExpression",
                                                  "callee": {
                                                    "type": "MemberExpression",
                                                    "object": {
                                                      "type": "Identifier",
                                                      "name": "Promise"
                                                    },
                                                    "property": {
                                                      "type": "Identifier",
                                                      "name": "resolve"
                                                    },
                                                    "computed": false
                                                  },
                                                  "arguments": [{
                                                    "type": "Identifier",
                                                    "name": "value"
                                                  }]
                                                },
                                                "property": {
                                                  "type": "Identifier",
                                                  "name": "then"
                                                },
                                                "computed": false
                                              },
                                              "arguments": [{
                                                "type": "Identifier",
                                                "name": "callNext"
                                              }, {
                                                "type": "Identifier",
                                                "name": "callThrow"
                                              }]
                                            }
                                          }]
                                        }
                                      }]
                                    }
                                  }, {
                                    "type": "ExpressionStatement",
                                    "expression": {
                                      "type": "CallExpression",
                                      "callee": {
                                        "type": "Identifier",
                                        "name": "callNext"
                                      },
                                      "arguments": []
                                    }
                                  }]
                                }
                              }]
                            }
                          }]
                        }
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-bind": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "MemberExpression",
                  "object": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "Function"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "prototype"
                    },
                    "computed": false
                  },
                  "property": {
                    "type": "Identifier",
                    "name": "bind"
                  },
                  "computed": false
                }
              }]
            },
            "helper-class-call-check": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "instance"
                  }, {
                    "type": "Identifier",
                    "name": "Constructor"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "UnaryExpression",
                        "operator": "!",
                        "prefix": true,
                        "argument": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "Identifier",
                            "name": "instance"
                          },
                          "operator": "instanceof",
                          "right": {
                            "type": "Identifier",
                            "name": "Constructor"
                          },
                          "parenthesizedExpression": true
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ThrowStatement",
                          "argument": {
                            "type": "NewExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "TypeError"
                            },
                            "arguments": [{
                              "type": "Literal",
                              "value": "Cannot call a class as a function"
                            }]
                          }
                        }]
                      },
                      "alternate": null
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-create-class": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "FunctionDeclaration",
                        "id": {
                          "type": "Identifier",
                          "name": "defineProperties"
                        },
                        "generator": false,
                        "expression": false,
                        "params": [{
                          "type": "Identifier",
                          "name": "target"
                        }, {
                          "type": "Identifier",
                          "name": "props"
                        }],
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ForStatement",
                            "init": {
                              "type": "VariableDeclaration",
                              "declarations": [{
                                "type": "VariableDeclarator",
                                "id": {
                                  "type": "Identifier",
                                  "name": "i"
                                },
                                "init": {
                                  "type": "Literal",
                                  "value": 0
                                }
                              }],
                              "kind": "var"
                            },
                            "test": {
                              "type": "BinaryExpression",
                              "left": {
                                "type": "Identifier",
                                "name": "i"
                              },
                              "operator": "<",
                              "right": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "props"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "length"
                                },
                                "computed": false
                              }
                            },
                            "update": {
                              "type": "UpdateExpression",
                              "operator": "++",
                              "prefix": false,
                              "argument": {
                                "type": "Identifier",
                                "name": "i"
                              }
                            },
                            "body": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "VariableDeclaration",
                                "declarations": [{
                                  "type": "VariableDeclarator",
                                  "id": {
                                    "type": "Identifier",
                                    "name": "descriptor"
                                  },
                                  "init": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "props"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "i"
                                    },
                                    "computed": true
                                  }
                                }],
                                "kind": "var"
                              }, {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "AssignmentExpression",
                                  "operator": "=",
                                  "left": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "enumerable"
                                    },
                                    "computed": false
                                  },
                                  "right": {
                                    "type": "LogicalExpression",
                                    "left": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "descriptor"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "enumerable"
                                      },
                                      "computed": false
                                    },
                                    "operator": "||",
                                    "right": {
                                      "type": "Literal",
                                      "value": false
                                    }
                                  }
                                }
                              }, {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "AssignmentExpression",
                                  "operator": "=",
                                  "left": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "configurable"
                                    },
                                    "computed": false
                                  },
                                  "right": {
                                    "type": "Literal",
                                    "value": true
                                  }
                                }
                              }, {
                                "type": "IfStatement",
                                "test": {
                                  "type": "BinaryExpression",
                                  "left": {
                                    "type": "Literal",
                                    "value": "value"
                                  },
                                  "operator": "in",
                                  "right": {
                                    "type": "Identifier",
                                    "name": "descriptor"
                                  }
                                },
                                "consequent": {
                                  "type": "ExpressionStatement",
                                  "expression": {
                                    "type": "AssignmentExpression",
                                    "operator": "=",
                                    "left": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "descriptor"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "writable"
                                      },
                                      "computed": false
                                    },
                                    "right": {
                                      "type": "Literal",
                                      "value": true
                                    }
                                  }
                                },
                                "alternate": null
                              }, {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "Object"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "defineProperty"
                                    },
                                    "computed": false
                                  },
                                  "arguments": [{
                                    "type": "Identifier",
                                    "name": "target"
                                  }, {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "key"
                                    },
                                    "computed": false
                                  }, {
                                    "type": "Identifier",
                                    "name": "descriptor"
                                  }]
                                }
                              }]
                            }
                          }]
                        }
                      }, {
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "FunctionExpression",
                          "id": null,
                          "generator": false,
                          "expression": false,
                          "params": [{
                            "type": "Identifier",
                            "name": "Constructor"
                          }, {
                            "type": "Identifier",
                            "name": "protoProps"
                          }, {
                            "type": "Identifier",
                            "name": "staticProps"
                          }],
                          "body": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "IfStatement",
                              "test": {
                                "type": "Identifier",
                                "name": "protoProps"
                              },
                              "consequent": {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "Identifier",
                                    "name": "defineProperties"
                                  },
                                  "arguments": [{
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "Constructor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "prototype"
                                    },
                                    "computed": false
                                  }, {
                                    "type": "Identifier",
                                    "name": "protoProps"
                                  }]
                                }
                              },
                              "alternate": null
                            }, {
                              "type": "IfStatement",
                              "test": {
                                "type": "Identifier",
                                "name": "staticProps"
                              },
                              "consequent": {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "Identifier",
                                    "name": "defineProperties"
                                  },
                                  "arguments": [{
                                    "type": "Identifier",
                                    "name": "Constructor"
                                  }, {
                                    "type": "Identifier",
                                    "name": "staticProps"
                                  }]
                                }
                              },
                              "alternate": null
                            }, {
                              "type": "ReturnStatement",
                              "argument": {
                                "type": "Identifier",
                                "name": "Constructor"
                              }
                            }]
                          }
                        }
                      }]
                    },
                    "parenthesizedExpression": true
                  },
                  "arguments": []
                }
              }]
            },
            "helper-create-decorated-class": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "FunctionDeclaration",
                        "id": {
                          "type": "Identifier",
                          "name": "defineProperties"
                        },
                        "generator": false,
                        "expression": false,
                        "params": [{
                          "type": "Identifier",
                          "name": "target"
                        }, {
                          "type": "Identifier",
                          "name": "descriptors"
                        }, {
                          "type": "Identifier",
                          "name": "initializers"
                        }],
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ForStatement",
                            "init": {
                              "type": "VariableDeclaration",
                              "declarations": [{
                                "type": "VariableDeclarator",
                                "id": {
                                  "type": "Identifier",
                                  "name": "i"
                                },
                                "init": {
                                  "type": "Literal",
                                  "value": 0
                                }
                              }],
                              "kind": "var"
                            },
                            "test": {
                              "type": "BinaryExpression",
                              "left": {
                                "type": "Identifier",
                                "name": "i"
                              },
                              "operator": "<",
                              "right": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "descriptors"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "length"
                                },
                                "computed": false
                              }
                            },
                            "update": {
                              "type": "UpdateExpression",
                              "operator": "++",
                              "prefix": false,
                              "argument": {
                                "type": "Identifier",
                                "name": "i"
                              }
                            },
                            "body": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "VariableDeclaration",
                                "declarations": [{
                                  "type": "VariableDeclarator",
                                  "id": {
                                    "type": "Identifier",
                                    "name": "descriptor"
                                  },
                                  "init": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptors"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "i"
                                    },
                                    "computed": true
                                  }
                                }],
                                "kind": "var"
                              }, {
                                "type": "VariableDeclaration",
                                "declarations": [{
                                  "type": "VariableDeclarator",
                                  "id": {
                                    "type": "Identifier",
                                    "name": "decorators"
                                  },
                                  "init": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "decorators"
                                    },
                                    "computed": false
                                  }
                                }],
                                "kind": "var"
                              }, {
                                "type": "VariableDeclaration",
                                "declarations": [{
                                  "type": "VariableDeclarator",
                                  "id": {
                                    "type": "Identifier",
                                    "name": "key"
                                  },
                                  "init": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "key"
                                    },
                                    "computed": false
                                  }
                                }],
                                "kind": "var"
                              }, {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "UnaryExpression",
                                  "operator": "delete",
                                  "prefix": true,
                                  "argument": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor",
                                      "leadingComments": null
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "key"
                                    },
                                    "computed": false,
                                    "leadingComments": null
                                  },
                                  "leadingComments": null
                                }
                              }, {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "UnaryExpression",
                                  "operator": "delete",
                                  "prefix": true,
                                  "argument": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "decorators"
                                    },
                                    "computed": false
                                  }
                                }
                              }, {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "AssignmentExpression",
                                  "operator": "=",
                                  "left": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "enumerable"
                                    },
                                    "computed": false
                                  },
                                  "right": {
                                    "type": "LogicalExpression",
                                    "left": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "descriptor"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "enumerable"
                                      },
                                      "computed": false
                                    },
                                    "operator": "||",
                                    "right": {
                                      "type": "Literal",
                                      "value": false
                                    }
                                  }
                                }
                              }, {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "AssignmentExpression",
                                  "operator": "=",
                                  "left": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "configurable"
                                    },
                                    "computed": false
                                  },
                                  "right": {
                                    "type": "Literal",
                                    "value": true
                                  }
                                }
                              }, {
                                "type": "IfStatement",
                                "test": {
                                  "type": "LogicalExpression",
                                  "left": {
                                    "type": "BinaryExpression",
                                    "left": {
                                      "type": "Literal",
                                      "value": "value"
                                    },
                                    "operator": "in",
                                    "right": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    }
                                  },
                                  "operator": "||",
                                  "right": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "descriptor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "initializer"
                                    },
                                    "computed": false
                                  }
                                },
                                "consequent": {
                                  "type": "ExpressionStatement",
                                  "expression": {
                                    "type": "AssignmentExpression",
                                    "operator": "=",
                                    "left": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "descriptor"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "writable"
                                      },
                                      "computed": false
                                    },
                                    "right": {
                                      "type": "Literal",
                                      "value": true
                                    }
                                  }
                                },
                                "alternate": null
                              }, {
                                "type": "IfStatement",
                                "test": {
                                  "type": "Identifier",
                                  "name": "decorators"
                                },
                                "consequent": {
                                  "type": "BlockStatement",
                                  "body": [{
                                    "type": "ForStatement",
                                    "init": {
                                      "type": "VariableDeclaration",
                                      "declarations": [{
                                        "type": "VariableDeclarator",
                                        "id": {
                                          "type": "Identifier",
                                          "name": "f"
                                        },
                                        "init": {
                                          "type": "Literal",
                                          "value": 0
                                        }
                                      }],
                                      "kind": "var"
                                    },
                                    "test": {
                                      "type": "BinaryExpression",
                                      "left": {
                                        "type": "Identifier",
                                        "name": "f"
                                      },
                                      "operator": "<",
                                      "right": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "decorators"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "length"
                                        },
                                        "computed": false
                                      }
                                    },
                                    "update": {
                                      "type": "UpdateExpression",
                                      "operator": "++",
                                      "prefix": false,
                                      "argument": {
                                        "type": "Identifier",
                                        "name": "f"
                                      }
                                    },
                                    "body": {
                                      "type": "BlockStatement",
                                      "body": [{
                                        "type": "VariableDeclaration",
                                        "declarations": [{
                                          "type": "VariableDeclarator",
                                          "id": {
                                            "type": "Identifier",
                                            "name": "decorator"
                                          },
                                          "init": {
                                            "type": "MemberExpression",
                                            "object": {
                                              "type": "Identifier",
                                              "name": "decorators"
                                            },
                                            "property": {
                                              "type": "Identifier",
                                              "name": "f"
                                            },
                                            "computed": true
                                          }
                                        }],
                                        "kind": "var"
                                      }, {
                                        "type": "IfStatement",
                                        "test": {
                                          "type": "BinaryExpression",
                                          "left": {
                                            "type": "UnaryExpression",
                                            "operator": "typeof",
                                            "prefix": true,
                                            "argument": {
                                              "type": "Identifier",
                                              "name": "decorator"
                                            }
                                          },
                                          "operator": "===",
                                          "right": {
                                            "type": "Literal",
                                            "value": "function"
                                          }
                                        },
                                        "consequent": {
                                          "type": "BlockStatement",
                                          "body": [{
                                            "type": "ExpressionStatement",
                                            "expression": {
                                              "type": "AssignmentExpression",
                                              "operator": "=",
                                              "left": {
                                                "type": "Identifier",
                                                "name": "descriptor"
                                              },
                                              "right": {
                                                "type": "LogicalExpression",
                                                "left": {
                                                  "type": "CallExpression",
                                                  "callee": {
                                                    "type": "Identifier",
                                                    "name": "decorator"
                                                  },
                                                  "arguments": [{
                                                    "type": "Identifier",
                                                    "name": "target"
                                                  }, {
                                                    "type": "Identifier",
                                                    "name": "key"
                                                  }, {
                                                    "type": "Identifier",
                                                    "name": "descriptor"
                                                  }]
                                                },
                                                "operator": "||",
                                                "right": {
                                                  "type": "Identifier",
                                                  "name": "descriptor"
                                                }
                                              }
                                            }
                                          }]
                                        },
                                        "alternate": {
                                          "type": "BlockStatement",
                                          "body": [{
                                            "type": "ThrowStatement",
                                            "argument": {
                                              "type": "NewExpression",
                                              "callee": {
                                                "type": "Identifier",
                                                "name": "TypeError"
                                              },
                                              "arguments": [{
                                                "type": "BinaryExpression",
                                                "left": {
                                                  "type": "BinaryExpression",
                                                  "left": {
                                                    "type": "BinaryExpression",
                                                    "left": {
                                                      "type": "Literal",
                                                      "value": "The decorator for method "
                                                    },
                                                    "operator": "+",
                                                    "right": {
                                                      "type": "MemberExpression",
                                                      "object": {
                                                        "type": "Identifier",
                                                        "name": "descriptor"
                                                      },
                                                      "property": {
                                                        "type": "Identifier",
                                                        "name": "key"
                                                      },
                                                      "computed": false
                                                    }
                                                  },
                                                  "operator": "+",
                                                  "right": {
                                                    "type": "Literal",
                                                    "value": " is of the invalid type "
                                                  }
                                                },
                                                "operator": "+",
                                                "right": {
                                                  "type": "UnaryExpression",
                                                  "operator": "typeof",
                                                  "prefix": true,
                                                  "argument": {
                                                    "type": "Identifier",
                                                    "name": "decorator"
                                                  }
                                                }
                                              }]
                                            }
                                          }]
                                        }
                                      }]
                                    }
                                  }, {
                                    "type": "IfStatement",
                                    "test": {
                                      "type": "BinaryExpression",
                                      "left": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "descriptor"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "initializer"
                                        },
                                        "computed": false
                                      },
                                      "operator": "!==",
                                      "right": {
                                        "type": "Identifier",
                                        "name": "undefined"
                                      }
                                    },
                                    "consequent": {
                                      "type": "BlockStatement",
                                      "body": [{
                                        "type": "ExpressionStatement",
                                        "expression": {
                                          "type": "AssignmentExpression",
                                          "operator": "=",
                                          "left": {
                                            "type": "MemberExpression",
                                            "object": {
                                              "type": "Identifier",
                                              "name": "initializers"
                                            },
                                            "property": {
                                              "type": "Identifier",
                                              "name": "key"
                                            },
                                            "computed": true
                                          },
                                          "right": {
                                            "type": "Identifier",
                                            "name": "descriptor"
                                          }
                                        }
                                      }, {
                                        "type": "ContinueStatement",
                                        "label": null
                                      }]
                                    },
                                    "alternate": null
                                  }]
                                },
                                "alternate": null
                              }, {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "Object"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "defineProperty"
                                    },
                                    "computed": false
                                  },
                                  "arguments": [{
                                    "type": "Identifier",
                                    "name": "target"
                                  }, {
                                    "type": "Identifier",
                                    "name": "key"
                                  }, {
                                    "type": "Identifier",
                                    "name": "descriptor"
                                  }]
                                }
                              }]
                            }
                          }]
                        }
                      }, {
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "FunctionExpression",
                          "id": null,
                          "generator": false,
                          "expression": false,
                          "params": [{
                            "type": "Identifier",
                            "name": "Constructor"
                          }, {
                            "type": "Identifier",
                            "name": "protoProps"
                          }, {
                            "type": "Identifier",
                            "name": "staticProps"
                          }, {
                            "type": "Identifier",
                            "name": "protoInitializers"
                          }, {
                            "type": "Identifier",
                            "name": "staticInitializers"
                          }],
                          "body": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "IfStatement",
                              "test": {
                                "type": "Identifier",
                                "name": "protoProps"
                              },
                              "consequent": {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "Identifier",
                                    "name": "defineProperties"
                                  },
                                  "arguments": [{
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "Constructor"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "prototype"
                                    },
                                    "computed": false
                                  }, {
                                    "type": "Identifier",
                                    "name": "protoProps"
                                  }, {
                                    "type": "Identifier",
                                    "name": "protoInitializers"
                                  }]
                                }
                              },
                              "alternate": null
                            }, {
                              "type": "IfStatement",
                              "test": {
                                "type": "Identifier",
                                "name": "staticProps"
                              },
                              "consequent": {
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "Identifier",
                                    "name": "defineProperties"
                                  },
                                  "arguments": [{
                                    "type": "Identifier",
                                    "name": "Constructor"
                                  }, {
                                    "type": "Identifier",
                                    "name": "staticProps"
                                  }, {
                                    "type": "Identifier",
                                    "name": "staticInitializers"
                                  }]
                                }
                              },
                              "alternate": null
                            }, {
                              "type": "ReturnStatement",
                              "argument": {
                                "type": "Identifier",
                                "name": "Constructor"
                              }
                            }]
                          }
                        }
                      }]
                    },
                    "parenthesizedExpression": true
                  },
                  "arguments": []
                }
              }]
            },
            "helper-create-decorated-object": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "descriptors"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "target"
                        },
                        "init": {
                          "type": "ObjectExpression",
                          "properties": []
                        }
                      }],
                      "kind": "var"
                    }, {
                      "type": "ForStatement",
                      "init": {
                        "type": "VariableDeclaration",
                        "declarations": [{
                          "type": "VariableDeclarator",
                          "id": {
                            "type": "Identifier",
                            "name": "i"
                          },
                          "init": {
                            "type": "Literal",
                            "value": 0
                          }
                        }],
                        "kind": "var"
                      },
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "i"
                        },
                        "operator": "<",
                        "right": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "descriptors"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "length"
                          },
                          "computed": false
                        }
                      },
                      "update": {
                        "type": "UpdateExpression",
                        "operator": "++",
                        "prefix": false,
                        "argument": {
                          "type": "Identifier",
                          "name": "i"
                        }
                      },
                      "body": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "descriptor"
                            },
                            "init": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "descriptors"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "i"
                              },
                              "computed": true
                            }
                          }],
                          "kind": "var"
                        }, {
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "decorators"
                            },
                            "init": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "descriptor"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "decorators"
                              },
                              "computed": false
                            }
                          }],
                          "kind": "var"
                        }, {
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "key"
                            },
                            "init": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "descriptor"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "key"
                              },
                              "computed": false
                            }
                          }],
                          "kind": "var"
                        }, {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "UnaryExpression",
                            "operator": "delete",
                            "prefix": true,
                            "argument": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "descriptor",
                                "leadingComments": null
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "key"
                              },
                              "computed": false,
                              "leadingComments": null
                            },
                            "leadingComments": null
                          }
                        }, {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "UnaryExpression",
                            "operator": "delete",
                            "prefix": true,
                            "argument": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "descriptor"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "decorators"
                              },
                              "computed": false
                            }
                          }
                        }, {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "descriptor"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "enumerable"
                              },
                              "computed": false
                            },
                            "right": {
                              "type": "Literal",
                              "value": true
                            }
                          }
                        }, {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "descriptor"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "configurable"
                              },
                              "computed": false
                            },
                            "right": {
                              "type": "Literal",
                              "value": true
                            }
                          }
                        }, {
                          "type": "IfStatement",
                          "test": {
                            "type": "LogicalExpression",
                            "left": {
                              "type": "BinaryExpression",
                              "left": {
                                "type": "Literal",
                                "value": "value"
                              },
                              "operator": "in",
                              "right": {
                                "type": "Identifier",
                                "name": "descriptor"
                              }
                            },
                            "operator": "||",
                            "right": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "descriptor"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "initializer"
                              },
                              "computed": false
                            }
                          },
                          "consequent": {
                            "type": "ExpressionStatement",
                            "expression": {
                              "type": "AssignmentExpression",
                              "operator": "=",
                              "left": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "descriptor"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "writable"
                                },
                                "computed": false
                              },
                              "right": {
                                "type": "Literal",
                                "value": true
                              }
                            }
                          },
                          "alternate": null
                        }, {
                          "type": "IfStatement",
                          "test": {
                            "type": "Identifier",
                            "name": "decorators"
                          },
                          "consequent": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ForStatement",
                              "init": {
                                "type": "VariableDeclaration",
                                "declarations": [{
                                  "type": "VariableDeclarator",
                                  "id": {
                                    "type": "Identifier",
                                    "name": "f"
                                  },
                                  "init": {
                                    "type": "Literal",
                                    "value": 0
                                  }
                                }],
                                "kind": "var"
                              },
                              "test": {
                                "type": "BinaryExpression",
                                "left": {
                                  "type": "Identifier",
                                  "name": "f"
                                },
                                "operator": "<",
                                "right": {
                                  "type": "MemberExpression",
                                  "object": {
                                    "type": "Identifier",
                                    "name": "decorators"
                                  },
                                  "property": {
                                    "type": "Identifier",
                                    "name": "length"
                                  },
                                  "computed": false
                                }
                              },
                              "update": {
                                "type": "UpdateExpression",
                                "operator": "++",
                                "prefix": false,
                                "argument": {
                                  "type": "Identifier",
                                  "name": "f"
                                }
                              },
                              "body": {
                                "type": "BlockStatement",
                                "body": [{
                                  "type": "VariableDeclaration",
                                  "declarations": [{
                                    "type": "VariableDeclarator",
                                    "id": {
                                      "type": "Identifier",
                                      "name": "decorator"
                                    },
                                    "init": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "decorators"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "f"
                                      },
                                      "computed": true
                                    }
                                  }],
                                  "kind": "var"
                                }, {
                                  "type": "IfStatement",
                                  "test": {
                                    "type": "BinaryExpression",
                                    "left": {
                                      "type": "UnaryExpression",
                                      "operator": "typeof",
                                      "prefix": true,
                                      "argument": {
                                        "type": "Identifier",
                                        "name": "decorator"
                                      }
                                    },
                                    "operator": "===",
                                    "right": {
                                      "type": "Literal",
                                      "value": "function"
                                    }
                                  },
                                  "consequent": {
                                    "type": "BlockStatement",
                                    "body": [{
                                      "type": "ExpressionStatement",
                                      "expression": {
                                        "type": "AssignmentExpression",
                                        "operator": "=",
                                        "left": {
                                          "type": "Identifier",
                                          "name": "descriptor"
                                        },
                                        "right": {
                                          "type": "LogicalExpression",
                                          "left": {
                                            "type": "CallExpression",
                                            "callee": {
                                              "type": "Identifier",
                                              "name": "decorator"
                                            },
                                            "arguments": [{
                                              "type": "Identifier",
                                              "name": "target"
                                            }, {
                                              "type": "Identifier",
                                              "name": "key"
                                            }, {
                                              "type": "Identifier",
                                              "name": "descriptor"
                                            }]
                                          },
                                          "operator": "||",
                                          "right": {
                                            "type": "Identifier",
                                            "name": "descriptor"
                                          }
                                        }
                                      }
                                    }]
                                  },
                                  "alternate": {
                                    "type": "BlockStatement",
                                    "body": [{
                                      "type": "ThrowStatement",
                                      "argument": {
                                        "type": "NewExpression",
                                        "callee": {
                                          "type": "Identifier",
                                          "name": "TypeError"
                                        },
                                        "arguments": [{
                                          "type": "BinaryExpression",
                                          "left": {
                                            "type": "BinaryExpression",
                                            "left": {
                                              "type": "BinaryExpression",
                                              "left": {
                                                "type": "Literal",
                                                "value": "The decorator for method "
                                              },
                                              "operator": "+",
                                              "right": {
                                                "type": "MemberExpression",
                                                "object": {
                                                  "type": "Identifier",
                                                  "name": "descriptor"
                                                },
                                                "property": {
                                                  "type": "Identifier",
                                                  "name": "key"
                                                },
                                                "computed": false
                                              }
                                            },
                                            "operator": "+",
                                            "right": {
                                              "type": "Literal",
                                              "value": " is of the invalid type "
                                            }
                                          },
                                          "operator": "+",
                                          "right": {
                                            "type": "UnaryExpression",
                                            "operator": "typeof",
                                            "prefix": true,
                                            "argument": {
                                              "type": "Identifier",
                                              "name": "decorator"
                                            }
                                          }
                                        }]
                                      }
                                    }]
                                  }
                                }]
                              }
                            }]
                          },
                          "alternate": null
                        }, {
                          "type": "IfStatement",
                          "test": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "descriptor"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "initializer"
                            },
                            "computed": false
                          },
                          "consequent": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ExpressionStatement",
                              "expression": {
                                "type": "AssignmentExpression",
                                "operator": "=",
                                "left": {
                                  "type": "MemberExpression",
                                  "object": {
                                    "type": "Identifier",
                                    "name": "descriptor"
                                  },
                                  "property": {
                                    "type": "Identifier",
                                    "name": "value"
                                  },
                                  "computed": false
                                },
                                "right": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "descriptor"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "initializer"
                                      },
                                      "computed": false
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "call"
                                    },
                                    "computed": false
                                  },
                                  "arguments": [{
                                    "type": "Identifier",
                                    "name": "target"
                                  }]
                                }
                              }
                            }]
                          },
                          "alternate": null
                        }, {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "Object"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "defineProperty"
                              },
                              "computed": false
                            },
                            "arguments": [{
                              "type": "Identifier",
                              "name": "target"
                            }, {
                              "type": "Identifier",
                              "name": "key"
                            }, {
                              "type": "Identifier",
                              "name": "descriptor"
                            }]
                          }
                        }]
                      }
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Identifier",
                        "name": "target"
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-default-props": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "defaultProps"
                  }, {
                    "type": "Identifier",
                    "name": "props"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "Identifier",
                        "name": "defaultProps"
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ForInStatement",
                          "left": {
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "propName"
                              },
                              "init": null
                            }],
                            "kind": "var"
                          },
                          "right": {
                            "type": "Identifier",
                            "name": "defaultProps"
                          },
                          "body": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "IfStatement",
                              "test": {
                                "type": "BinaryExpression",
                                "left": {
                                  "type": "UnaryExpression",
                                  "operator": "typeof",
                                  "prefix": true,
                                  "argument": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "props"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "propName"
                                    },
                                    "computed": true
                                  }
                                },
                                "operator": "===",
                                "right": {
                                  "type": "Literal",
                                  "value": "undefined"
                                }
                              },
                              "consequent": {
                                "type": "BlockStatement",
                                "body": [{
                                  "type": "ExpressionStatement",
                                  "expression": {
                                    "type": "AssignmentExpression",
                                    "operator": "=",
                                    "left": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "props"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "propName"
                                      },
                                      "computed": true
                                    },
                                    "right": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "defaultProps"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "propName"
                                      },
                                      "computed": true
                                    }
                                  }
                                }]
                              },
                              "alternate": null
                            }]
                          }
                        }]
                      },
                      "alternate": null
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Identifier",
                        "name": "props"
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-defaults": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }, {
                    "type": "Identifier",
                    "name": "defaults"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "keys"
                        },
                        "init": {
                          "type": "CallExpression",
                          "callee": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Object"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "getOwnPropertyNames"
                            },
                            "computed": false
                          },
                          "arguments": [{
                            "type": "Identifier",
                            "name": "defaults"
                          }]
                        }
                      }],
                      "kind": "var"
                    }, {
                      "type": "ForStatement",
                      "init": {
                        "type": "VariableDeclaration",
                        "declarations": [{
                          "type": "VariableDeclarator",
                          "id": {
                            "type": "Identifier",
                            "name": "i"
                          },
                          "init": {
                            "type": "Literal",
                            "value": 0
                          }
                        }],
                        "kind": "var"
                      },
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "i"
                        },
                        "operator": "<",
                        "right": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "keys"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "length"
                          },
                          "computed": false
                        }
                      },
                      "update": {
                        "type": "UpdateExpression",
                        "operator": "++",
                        "prefix": false,
                        "argument": {
                          "type": "Identifier",
                          "name": "i"
                        }
                      },
                      "body": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "key"
                            },
                            "init": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "keys"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "i"
                              },
                              "computed": true
                            }
                          }],
                          "kind": "var"
                        }, {
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "value"
                            },
                            "init": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "Object"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "getOwnPropertyDescriptor"
                                },
                                "computed": false
                              },
                              "arguments": [{
                                "type": "Identifier",
                                "name": "defaults"
                              }, {
                                "type": "Identifier",
                                "name": "key"
                              }]
                            }
                          }],
                          "kind": "var"
                        }, {
                          "type": "IfStatement",
                          "test": {
                            "type": "LogicalExpression",
                            "left": {
                              "type": "LogicalExpression",
                              "left": {
                                "type": "Identifier",
                                "name": "value"
                              },
                              "operator": "&&",
                              "right": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "value"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "configurable"
                                },
                                "computed": false
                              }
                            },
                            "operator": "&&",
                            "right": {
                              "type": "BinaryExpression",
                              "left": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "obj"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "key"
                                },
                                "computed": true
                              },
                              "operator": "===",
                              "right": {
                                "type": "Identifier",
                                "name": "undefined"
                              }
                            }
                          },
                          "consequent": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ExpressionStatement",
                              "expression": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "MemberExpression",
                                  "object": {
                                    "type": "Identifier",
                                    "name": "Object"
                                  },
                                  "property": {
                                    "type": "Identifier",
                                    "name": "defineProperty"
                                  },
                                  "computed": false
                                },
                                "arguments": [{
                                  "type": "Identifier",
                                  "name": "obj"
                                }, {
                                  "type": "Identifier",
                                  "name": "key"
                                }, {
                                  "type": "Identifier",
                                  "name": "value"
                                }]
                              }
                            }]
                          },
                          "alternate": null
                        }]
                      }
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Identifier",
                        "name": "obj"
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-define-decorated-property-descriptor": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "target"
                  }, {
                    "type": "Identifier",
                    "name": "key"
                  }, {
                    "type": "Identifier",
                    "name": "descriptors"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "_descriptor"
                        },
                        "init": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "descriptors"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "key"
                          },
                          "computed": true
                        }
                      }],
                      "kind": "var"
                    }, {
                      "type": "IfStatement",
                      "test": {
                        "type": "UnaryExpression",
                        "operator": "!",
                        "prefix": true,
                        "argument": {
                          "type": "Identifier",
                          "name": "_descriptor"
                        }
                      },
                      "consequent": {
                        "type": "ReturnStatement",
                        "argument": null,
                        "leadingComments": null,
                        "trailingComments": null
                      },
                      "alternate": null
                    }, {
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "descriptor",
                          "leadingComments": null
                        },
                        "init": {
                          "type": "ObjectExpression",
                          "properties": []
                        },
                        "leadingComments": null
                      }],
                      "kind": "var"
                    }, {
                      "type": "ForInStatement",
                      "left": {
                        "type": "VariableDeclaration",
                        "declarations": [{
                          "type": "VariableDeclarator",
                          "id": {
                            "type": "Identifier",
                            "name": "_key"
                          },
                          "init": null
                        }],
                        "kind": "var"
                      },
                      "right": {
                        "type": "Identifier",
                        "name": "_descriptor"
                      },
                      "body": {
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "AssignmentExpression",
                          "operator": "=",
                          "left": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "descriptor"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "_key"
                            },
                            "computed": true
                          },
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "_descriptor"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "_key"
                            },
                            "computed": true
                          }
                        },
                        "trailingComments": null
                      }
                    }, {
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "AssignmentExpression",
                        "operator": "=",
                        "left": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "descriptor",
                            "leadingComments": null
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "value"
                          },
                          "computed": false,
                          "leadingComments": null
                        },
                        "right": {
                          "type": "ConditionalExpression",
                          "test": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "descriptor"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "initializer"
                            },
                            "computed": false
                          },
                          "consequent": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "descriptor"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "initializer"
                                },
                                "computed": false
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "call"
                              },
                              "computed": false
                            },
                            "arguments": [{
                              "type": "Identifier",
                              "name": "target"
                            }]
                          },
                          "alternate": {
                            "type": "Identifier",
                            "name": "undefined"
                          }
                        },
                        "leadingComments": null
                      }
                    }, {
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "CallExpression",
                        "callee": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "Object"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "defineProperty"
                          },
                          "computed": false
                        },
                        "arguments": [{
                          "type": "Identifier",
                          "name": "target"
                        }, {
                          "type": "Identifier",
                          "name": "key"
                        }, {
                          "type": "Identifier",
                          "name": "descriptor"
                        }]
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-define-property": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }, {
                    "type": "Identifier",
                    "name": "key"
                  }, {
                    "type": "Identifier",
                    "name": "value"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "key",
                          "leadingComments": null
                        },
                        "operator": "in",
                        "right": {
                          "type": "Identifier",
                          "name": "obj"
                        },
                        "leadingComments": null
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "Object"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "defineProperty"
                              },
                              "computed": false
                            },
                            "arguments": [{
                              "type": "Identifier",
                              "name": "obj"
                            }, {
                              "type": "Identifier",
                              "name": "key"
                            }, {
                              "type": "ObjectExpression",
                              "properties": [{
                                "type": "Property",
                                "method": false,
                                "shorthand": false,
                                "computed": false,
                                "key": {
                                  "type": "Identifier",
                                  "name": "value"
                                },
                                "value": {
                                  "type": "Identifier",
                                  "name": "value"
                                },
                                "kind": "init"
                              }, {
                                "type": "Property",
                                "method": false,
                                "shorthand": false,
                                "computed": false,
                                "key": {
                                  "type": "Identifier",
                                  "name": "enumerable"
                                },
                                "value": {
                                  "type": "Literal",
                                  "value": true
                                },
                                "kind": "init"
                              }, {
                                "type": "Property",
                                "method": false,
                                "shorthand": false,
                                "computed": false,
                                "key": {
                                  "type": "Identifier",
                                  "name": "configurable"
                                },
                                "value": {
                                  "type": "Literal",
                                  "value": true
                                },
                                "kind": "init"
                              }, {
                                "type": "Property",
                                "method": false,
                                "shorthand": false,
                                "computed": false,
                                "key": {
                                  "type": "Identifier",
                                  "name": "writable"
                                },
                                "value": {
                                  "type": "Literal",
                                  "value": true
                                },
                                "kind": "init"
                              }]
                            }]
                          }
                        }]
                      },
                      "alternate": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "obj"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "key"
                              },
                              "computed": true
                            },
                            "right": {
                              "type": "Identifier",
                              "name": "value"
                            }
                          }
                        }]
                      }
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Identifier",
                        "name": "obj"
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-extends": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "LogicalExpression",
                  "left": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "Object"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "assign"
                    },
                    "computed": false
                  },
                  "operator": "||",
                  "right": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [{
                      "type": "Identifier",
                      "name": "target"
                    }],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "ForStatement",
                        "init": {
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "i"
                            },
                            "init": {
                              "type": "Literal",
                              "value": 1
                            }
                          }],
                          "kind": "var"
                        },
                        "test": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "Identifier",
                            "name": "i"
                          },
                          "operator": "<",
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "arguments"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "length"
                            },
                            "computed": false
                          }
                        },
                        "update": {
                          "type": "UpdateExpression",
                          "operator": "++",
                          "prefix": false,
                          "argument": {
                            "type": "Identifier",
                            "name": "i"
                          }
                        },
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "source"
                              },
                              "init": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "arguments"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "i"
                                },
                                "computed": true
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "ForInStatement",
                            "left": {
                              "type": "VariableDeclaration",
                              "declarations": [{
                                "type": "VariableDeclarator",
                                "id": {
                                  "type": "Identifier",
                                  "name": "key"
                                },
                                "init": null
                              }],
                              "kind": "var"
                            },
                            "right": {
                              "type": "Identifier",
                              "name": "source"
                            },
                            "body": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "IfStatement",
                                "test": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "Object"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "prototype"
                                        },
                                        "computed": false
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "hasOwnProperty"
                                      },
                                      "computed": false
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "call"
                                    },
                                    "computed": false
                                  },
                                  "arguments": [{
                                    "type": "Identifier",
                                    "name": "source"
                                  }, {
                                    "type": "Identifier",
                                    "name": "key"
                                  }]
                                },
                                "consequent": {
                                  "type": "BlockStatement",
                                  "body": [{
                                    "type": "ExpressionStatement",
                                    "expression": {
                                      "type": "AssignmentExpression",
                                      "operator": "=",
                                      "left": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "target"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "key"
                                        },
                                        "computed": true
                                      },
                                      "right": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "source"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "key"
                                        },
                                        "computed": true
                                      }
                                    }
                                  }]
                                },
                                "alternate": null
                              }]
                            }
                          }]
                        }
                      }, {
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "Identifier",
                          "name": "target"
                        }
                      }]
                    }
                  }
                }
              }]
            },
            "helper-get": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": {
                    "type": "Identifier",
                    "name": "get"
                  },
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "object"
                  }, {
                    "type": "Identifier",
                    "name": "property"
                  }, {
                    "type": "Identifier",
                    "name": "receiver"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "object"
                        },
                        "operator": "===",
                        "right": {
                          "type": "Literal",
                          "value": null,
                          "rawValue": null
                        }
                      },
                      "consequent": {
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "AssignmentExpression",
                          "operator": "=",
                          "left": {
                            "type": "Identifier",
                            "name": "object"
                          },
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Function"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "prototype"
                            },
                            "computed": false
                          }
                        }
                      },
                      "alternate": null
                    }, {
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "desc"
                        },
                        "init": {
                          "type": "CallExpression",
                          "callee": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Object"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "getOwnPropertyDescriptor"
                            },
                            "computed": false
                          },
                          "arguments": [{
                            "type": "Identifier",
                            "name": "object"
                          }, {
                            "type": "Identifier",
                            "name": "property"
                          }]
                        }
                      }],
                      "kind": "var"
                    }, {
                      "type": "IfStatement",
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "desc"
                        },
                        "operator": "===",
                        "right": {
                          "type": "Identifier",
                          "name": "undefined"
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "parent"
                            },
                            "init": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "Object"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "getPrototypeOf"
                                },
                                "computed": false
                              },
                              "arguments": [{
                                "type": "Identifier",
                                "name": "object"
                              }]
                            }
                          }],
                          "kind": "var"
                        }, {
                          "type": "IfStatement",
                          "test": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "Identifier",
                              "name": "parent"
                            },
                            "operator": "===",
                            "right": {
                              "type": "Literal",
                              "value": null,
                              "rawValue": null
                            }
                          },
                          "consequent": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ReturnStatement",
                              "argument": {
                                "type": "Identifier",
                                "name": "undefined"
                              }
                            }]
                          },
                          "alternate": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ReturnStatement",
                              "argument": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "Identifier",
                                  "name": "get"
                                },
                                "arguments": [{
                                  "type": "Identifier",
                                  "name": "parent"
                                }, {
                                  "type": "Identifier",
                                  "name": "property"
                                }, {
                                  "type": "Identifier",
                                  "name": "receiver"
                                }]
                              }
                            }]
                          }
                        }]
                      },
                      "alternate": {
                        "type": "IfStatement",
                        "test": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "Literal",
                            "value": "value"
                          },
                          "operator": "in",
                          "right": {
                            "type": "Identifier",
                            "name": "desc"
                          }
                        },
                        "consequent": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "desc"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "value"
                              },
                              "computed": false
                            }
                          }]
                        },
                        "alternate": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "getter"
                              },
                              "init": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "desc"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "get"
                                },
                                "computed": false
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "IfStatement",
                            "test": {
                              "type": "BinaryExpression",
                              "left": {
                                "type": "Identifier",
                                "name": "getter"
                              },
                              "operator": "===",
                              "right": {
                                "type": "Identifier",
                                "name": "undefined"
                              }
                            },
                            "consequent": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "ReturnStatement",
                                "argument": {
                                  "type": "Identifier",
                                  "name": "undefined"
                                }
                              }]
                            },
                            "alternate": null
                          }, {
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "getter"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "call"
                                },
                                "computed": false
                              },
                              "arguments": [{
                                "type": "Identifier",
                                "name": "receiver"
                              }]
                            }
                          }]
                        }
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-has-own": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "MemberExpression",
                  "object": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "Object"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "prototype"
                    },
                    "computed": false
                  },
                  "property": {
                    "type": "Identifier",
                    "name": "hasOwnProperty"
                  },
                  "computed": false
                }
              }]
            },
            "helper-inherits": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "subClass"
                  }, {
                    "type": "Identifier",
                    "name": "superClass"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "LogicalExpression",
                        "left": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "UnaryExpression",
                            "operator": "typeof",
                            "prefix": true,
                            "argument": {
                              "type": "Identifier",
                              "name": "superClass"
                            }
                          },
                          "operator": "!==",
                          "right": {
                            "type": "Literal",
                            "value": "function"
                          }
                        },
                        "operator": "&&",
                        "right": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "Identifier",
                            "name": "superClass"
                          },
                          "operator": "!==",
                          "right": {
                            "type": "Literal",
                            "value": null,
                            "rawValue": null
                          }
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ThrowStatement",
                          "argument": {
                            "type": "NewExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "TypeError"
                            },
                            "arguments": [{
                              "type": "BinaryExpression",
                              "left": {
                                "type": "Literal",
                                "value": "Super expression must either be null or a function, not "
                              },
                              "operator": "+",
                              "right": {
                                "type": "UnaryExpression",
                                "operator": "typeof",
                                "prefix": true,
                                "argument": {
                                  "type": "Identifier",
                                  "name": "superClass"
                                }
                              }
                            }]
                          }
                        }]
                      },
                      "alternate": null
                    }, {
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "AssignmentExpression",
                        "operator": "=",
                        "left": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "subClass"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "prototype"
                          },
                          "computed": false
                        },
                        "right": {
                          "type": "CallExpression",
                          "callee": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Object"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "create"
                            },
                            "computed": false
                          },
                          "arguments": [{
                            "type": "LogicalExpression",
                            "left": {
                              "type": "Identifier",
                              "name": "superClass"
                            },
                            "operator": "&&",
                            "right": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "superClass"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "prototype"
                              },
                              "computed": false
                            }
                          }, {
                            "type": "ObjectExpression",
                            "properties": [{
                              "type": "Property",
                              "method": false,
                              "shorthand": false,
                              "computed": false,
                              "key": {
                                "type": "Identifier",
                                "name": "constructor"
                              },
                              "value": {
                                "type": "ObjectExpression",
                                "properties": [{
                                  "type": "Property",
                                  "method": false,
                                  "shorthand": false,
                                  "computed": false,
                                  "key": {
                                    "type": "Identifier",
                                    "name": "value"
                                  },
                                  "value": {
                                    "type": "Identifier",
                                    "name": "subClass"
                                  },
                                  "kind": "init"
                                }, {
                                  "type": "Property",
                                  "method": false,
                                  "shorthand": false,
                                  "computed": false,
                                  "key": {
                                    "type": "Identifier",
                                    "name": "enumerable"
                                  },
                                  "value": {
                                    "type": "Literal",
                                    "value": false
                                  },
                                  "kind": "init"
                                }, {
                                  "type": "Property",
                                  "method": false,
                                  "shorthand": false,
                                  "computed": false,
                                  "key": {
                                    "type": "Identifier",
                                    "name": "writable"
                                  },
                                  "value": {
                                    "type": "Literal",
                                    "value": true
                                  },
                                  "kind": "init"
                                }, {
                                  "type": "Property",
                                  "method": false,
                                  "shorthand": false,
                                  "computed": false,
                                  "key": {
                                    "type": "Identifier",
                                    "name": "configurable"
                                  },
                                  "value": {
                                    "type": "Literal",
                                    "value": true
                                  },
                                  "kind": "init"
                                }]
                              },
                              "kind": "init"
                            }]
                          }]
                        }
                      }
                    }, {
                      "type": "IfStatement",
                      "test": {
                        "type": "Identifier",
                        "name": "superClass"
                      },
                      "consequent": {
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "ConditionalExpression",
                          "test": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Object"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "setPrototypeOf"
                            },
                            "computed": false
                          },
                          "consequent": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "Object"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "setPrototypeOf"
                              },
                              "computed": false
                            },
                            "arguments": [{
                              "type": "Identifier",
                              "name": "subClass"
                            }, {
                              "type": "Identifier",
                              "name": "superClass"
                            }]
                          },
                          "alternate": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "subClass"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "__proto__"
                              },
                              "computed": false
                            },
                            "right": {
                              "type": "Identifier",
                              "name": "superClass"
                            }
                          }
                        }
                      },
                      "alternate": null
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-instanceof": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "left"
                  }, {
                    "type": "Identifier",
                    "name": "right"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "LogicalExpression",
                        "left": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "Identifier",
                            "name": "right"
                          },
                          "operator": "!=",
                          "right": {
                            "type": "Literal",
                            "value": null,
                            "rawValue": null
                          }
                        },
                        "operator": "&&",
                        "right": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "right"
                          },
                          "property": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Symbol"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "hasInstance"
                            },
                            "computed": false
                          },
                          "computed": true
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "right"
                              },
                              "property": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "Symbol"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "hasInstance"
                                },
                                "computed": false
                              },
                              "computed": true
                            },
                            "arguments": [{
                              "type": "Identifier",
                              "name": "left"
                            }]
                          }
                        }]
                      },
                      "alternate": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "Identifier",
                              "name": "left"
                            },
                            "operator": "instanceof",
                            "right": {
                              "type": "Identifier",
                              "name": "right"
                            }
                          }
                        }]
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-interop-export-wildcard": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }, {
                    "type": "Identifier",
                    "name": "defaults"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "newObj"
                        },
                        "init": {
                          "type": "CallExpression",
                          "callee": {
                            "type": "Identifier",
                            "name": "defaults"
                          },
                          "arguments": [{
                            "type": "ObjectExpression",
                            "properties": []
                          }, {
                            "type": "Identifier",
                            "name": "obj"
                          }]
                        }
                      }],
                      "kind": "var"
                    }, {
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "UnaryExpression",
                        "operator": "delete",
                        "prefix": true,
                        "argument": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "newObj"
                          },
                          "property": {
                            "type": "Literal",
                            "value": "default"
                          },
                          "computed": true
                        }
                      }
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Identifier",
                        "name": "newObj"
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-interop-require-default": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "ConditionalExpression",
                        "test": {
                          "type": "LogicalExpression",
                          "left": {
                            "type": "Identifier",
                            "name": "obj"
                          },
                          "operator": "&&",
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "obj"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "__esModule"
                            },
                            "computed": false
                          }
                        },
                        "consequent": {
                          "type": "Identifier",
                          "name": "obj"
                        },
                        "alternate": {
                          "type": "ObjectExpression",
                          "properties": [{
                            "type": "Property",
                            "method": false,
                            "shorthand": false,
                            "computed": false,
                            "key": {
                              "type": "Literal",
                              "value": "default"
                            },
                            "value": {
                              "type": "Identifier",
                              "name": "obj"
                            },
                            "kind": "init"
                          }]
                        }
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-interop-require-wildcard": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "LogicalExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "obj"
                        },
                        "operator": "&&",
                        "right": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "obj"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "__esModule"
                          },
                          "computed": false
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "Identifier",
                            "name": "obj"
                          }
                        }]
                      },
                      "alternate": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "newObj"
                            },
                            "init": {
                              "type": "ObjectExpression",
                              "properties": []
                            }
                          }],
                          "kind": "var"
                        }, {
                          "type": "IfStatement",
                          "test": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "Identifier",
                              "name": "obj"
                            },
                            "operator": "!=",
                            "right": {
                              "type": "Literal",
                              "value": null,
                              "rawValue": null
                            }
                          },
                          "consequent": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ForInStatement",
                              "left": {
                                "type": "VariableDeclaration",
                                "declarations": [{
                                  "type": "VariableDeclarator",
                                  "id": {
                                    "type": "Identifier",
                                    "name": "key"
                                  },
                                  "init": null
                                }],
                                "kind": "var"
                              },
                              "right": {
                                "type": "Identifier",
                                "name": "obj"
                              },
                              "body": {
                                "type": "BlockStatement",
                                "body": [{
                                  "type": "IfStatement",
                                  "test": {
                                    "type": "CallExpression",
                                    "callee": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "MemberExpression",
                                          "object": {
                                            "type": "Identifier",
                                            "name": "Object"
                                          },
                                          "property": {
                                            "type": "Identifier",
                                            "name": "prototype"
                                          },
                                          "computed": false
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "hasOwnProperty"
                                        },
                                        "computed": false
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "call"
                                      },
                                      "computed": false
                                    },
                                    "arguments": [{
                                      "type": "Identifier",
                                      "name": "obj"
                                    }, {
                                      "type": "Identifier",
                                      "name": "key"
                                    }]
                                  },
                                  "consequent": {
                                    "type": "ExpressionStatement",
                                    "expression": {
                                      "type": "AssignmentExpression",
                                      "operator": "=",
                                      "left": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "newObj"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "key"
                                        },
                                        "computed": true
                                      },
                                      "right": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "obj"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "key"
                                        },
                                        "computed": true
                                      }
                                    }
                                  },
                                  "alternate": null
                                }]
                              }
                            }]
                          },
                          "alternate": null
                        }, {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "newObj"
                              },
                              "property": {
                                "type": "Literal",
                                "value": "default"
                              },
                              "computed": true
                            },
                            "right": {
                              "type": "Identifier",
                              "name": "obj"
                            }
                          }
                        }, {
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "Identifier",
                            "name": "newObj"
                          }
                        }]
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-interop-require": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "ConditionalExpression",
                        "test": {
                          "type": "LogicalExpression",
                          "left": {
                            "type": "Identifier",
                            "name": "obj"
                          },
                          "operator": "&&",
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "obj"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "__esModule"
                            },
                            "computed": false
                          }
                        },
                        "consequent": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "obj"
                          },
                          "property": {
                            "type": "Literal",
                            "value": "default"
                          },
                          "computed": true
                        },
                        "alternate": {
                          "type": "Identifier",
                          "name": "obj"
                        }
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-new-arrow-check": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "innerThis"
                  }, {
                    "type": "Identifier",
                    "name": "boundThis"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "innerThis"
                        },
                        "operator": "!==",
                        "right": {
                          "type": "Identifier",
                          "name": "boundThis"
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ThrowStatement",
                          "argument": {
                            "type": "NewExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "TypeError"
                            },
                            "arguments": [{
                              "type": "Literal",
                              "value": "Cannot instantiate an arrow function"
                            }]
                          }
                        }]
                      },
                      "alternate": null
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-object-destructuring-empty": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "obj"
                        },
                        "operator": "==",
                        "right": {
                          "type": "Literal",
                          "value": null,
                          "rawValue": null
                        }
                      },
                      "consequent": {
                        "type": "ThrowStatement",
                        "argument": {
                          "type": "NewExpression",
                          "callee": {
                            "type": "Identifier",
                            "name": "TypeError"
                          },
                          "arguments": [{
                            "type": "Literal",
                            "value": "Cannot destructure undefined"
                          }]
                        }
                      },
                      "alternate": null
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-object-without-properties": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }, {
                    "type": "Identifier",
                    "name": "keys"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "target"
                        },
                        "init": {
                          "type": "ObjectExpression",
                          "properties": []
                        }
                      }],
                      "kind": "var"
                    }, {
                      "type": "ForInStatement",
                      "left": {
                        "type": "VariableDeclaration",
                        "declarations": [{
                          "type": "VariableDeclarator",
                          "id": {
                            "type": "Identifier",
                            "name": "i"
                          },
                          "init": null
                        }],
                        "kind": "var"
                      },
                      "right": {
                        "type": "Identifier",
                        "name": "obj"
                      },
                      "body": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "IfStatement",
                          "test": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "keys"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "indexOf"
                                },
                                "computed": false
                              },
                              "arguments": [{
                                "type": "Identifier",
                                "name": "i"
                              }]
                            },
                            "operator": ">=",
                            "right": {
                              "type": "Literal",
                              "value": 0
                            }
                          },
                          "consequent": {
                            "type": "ContinueStatement",
                            "label": null
                          },
                          "alternate": null
                        }, {
                          "type": "IfStatement",
                          "test": {
                            "type": "UnaryExpression",
                            "operator": "!",
                            "prefix": true,
                            "argument": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "MemberExpression",
                                  "object": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "Object"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "prototype"
                                    },
                                    "computed": false
                                  },
                                  "property": {
                                    "type": "Identifier",
                                    "name": "hasOwnProperty"
                                  },
                                  "computed": false
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "call"
                                },
                                "computed": false
                              },
                              "arguments": [{
                                "type": "Identifier",
                                "name": "obj"
                              }, {
                                "type": "Identifier",
                                "name": "i"
                              }]
                            }
                          },
                          "consequent": {
                            "type": "ContinueStatement",
                            "label": null
                          },
                          "alternate": null
                        }, {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "target"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "i"
                              },
                              "computed": true
                            },
                            "right": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "obj"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "i"
                              },
                              "computed": true
                            }
                          }
                        }]
                      }
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Identifier",
                        "name": "target"
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-self-global": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "ConditionalExpression",
                  "test": {
                    "type": "BinaryExpression",
                    "left": {
                      "type": "UnaryExpression",
                      "operator": "typeof",
                      "prefix": true,
                      "argument": {
                        "type": "Identifier",
                        "name": "global"
                      }
                    },
                    "operator": "===",
                    "right": {
                      "type": "Literal",
                      "value": "undefined"
                    }
                  },
                  "consequent": {
                    "type": "Identifier",
                    "name": "self"
                  },
                  "alternate": {
                    "type": "Identifier",
                    "name": "global"
                  }
                }
              }]
            },
            "helper-set": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": {
                    "type": "Identifier",
                    "name": "set"
                  },
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "object"
                  }, {
                    "type": "Identifier",
                    "name": "property"
                  }, {
                    "type": "Identifier",
                    "name": "value"
                  }, {
                    "type": "Identifier",
                    "name": "receiver"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "VariableDeclaration",
                      "declarations": [{
                        "type": "VariableDeclarator",
                        "id": {
                          "type": "Identifier",
                          "name": "desc"
                        },
                        "init": {
                          "type": "CallExpression",
                          "callee": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Object"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "getOwnPropertyDescriptor"
                            },
                            "computed": false
                          },
                          "arguments": [{
                            "type": "Identifier",
                            "name": "object"
                          }, {
                            "type": "Identifier",
                            "name": "property"
                          }]
                        }
                      }],
                      "kind": "var"
                    }, {
                      "type": "IfStatement",
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "desc"
                        },
                        "operator": "===",
                        "right": {
                          "type": "Identifier",
                          "name": "undefined"
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "VariableDeclaration",
                          "declarations": [{
                            "type": "VariableDeclarator",
                            "id": {
                              "type": "Identifier",
                              "name": "parent"
                            },
                            "init": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "Object"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "getPrototypeOf"
                                },
                                "computed": false
                              },
                              "arguments": [{
                                "type": "Identifier",
                                "name": "object"
                              }]
                            }
                          }],
                          "kind": "var"
                        }, {
                          "type": "IfStatement",
                          "test": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "Identifier",
                              "name": "parent"
                            },
                            "operator": "!==",
                            "right": {
                              "type": "Literal",
                              "value": null,
                              "rawValue": null
                            }
                          },
                          "consequent": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ExpressionStatement",
                              "expression": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "Identifier",
                                  "name": "set"
                                },
                                "arguments": [{
                                  "type": "Identifier",
                                  "name": "parent"
                                }, {
                                  "type": "Identifier",
                                  "name": "property"
                                }, {
                                  "type": "Identifier",
                                  "name": "value"
                                }, {
                                  "type": "Identifier",
                                  "name": "receiver"
                                }]
                              }
                            }]
                          },
                          "alternate": null
                        }]
                      },
                      "alternate": {
                        "type": "IfStatement",
                        "test": {
                          "type": "LogicalExpression",
                          "left": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "Literal",
                              "value": "value"
                            },
                            "operator": "in",
                            "right": {
                              "type": "Identifier",
                              "name": "desc"
                            }
                          },
                          "operator": "&&",
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "desc"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "writable"
                            },
                            "computed": false
                          }
                        },
                        "consequent": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ExpressionStatement",
                            "expression": {
                              "type": "AssignmentExpression",
                              "operator": "=",
                              "left": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "desc"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "value"
                                },
                                "computed": false
                              },
                              "right": {
                                "type": "Identifier",
                                "name": "value"
                              }
                            }
                          }]
                        },
                        "alternate": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "setter"
                              },
                              "init": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "desc"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "set"
                                },
                                "computed": false
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "IfStatement",
                            "test": {
                              "type": "BinaryExpression",
                              "left": {
                                "type": "Identifier",
                                "name": "setter"
                              },
                              "operator": "!==",
                              "right": {
                                "type": "Identifier",
                                "name": "undefined"
                              }
                            },
                            "consequent": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "setter"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "call"
                                    },
                                    "computed": false
                                  },
                                  "arguments": [{
                                    "type": "Identifier",
                                    "name": "receiver"
                                  }, {
                                    "type": "Identifier",
                                    "name": "value"
                                  }]
                                }
                              }]
                            },
                            "alternate": null
                          }]
                        }
                      }
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Identifier",
                        "name": "value"
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-slice": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "MemberExpression",
                  "object": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "Array"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "prototype"
                    },
                    "computed": false
                  },
                  "property": {
                    "type": "Identifier",
                    "name": "slice"
                  },
                  "computed": false
                }
              }]
            },
            "helper-sliced-to-array-loose": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "arr"
                  }, {
                    "type": "Identifier",
                    "name": "i"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "CallExpression",
                        "callee": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "Array"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "isArray"
                          },
                          "computed": false
                        },
                        "arguments": [{
                          "type": "Identifier",
                          "name": "arr"
                        }]
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "Identifier",
                            "name": "arr"
                          }
                        }]
                      },
                      "alternate": {
                        "type": "IfStatement",
                        "test": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Symbol"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "iterator"
                            },
                            "computed": false
                          },
                          "operator": "in",
                          "right": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "Object"
                            },
                            "arguments": [{
                              "type": "Identifier",
                              "name": "arr"
                            }]
                          }
                        },
                        "consequent": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "_arr"
                              },
                              "init": {
                                "type": "ArrayExpression",
                                "elements": []
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "ForStatement",
                            "init": {
                              "type": "VariableDeclaration",
                              "declarations": [{
                                "type": "VariableDeclarator",
                                "id": {
                                  "type": "Identifier",
                                  "name": "_iterator"
                                },
                                "init": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "arr"
                                    },
                                    "property": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "Symbol"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "iterator"
                                      },
                                      "computed": false
                                    },
                                    "computed": true
                                  },
                                  "arguments": []
                                }
                              }, {
                                "type": "VariableDeclarator",
                                "id": {
                                  "type": "Identifier",
                                  "name": "_step"
                                },
                                "init": null
                              }],
                              "kind": "var"
                            },
                            "test": {
                              "type": "UnaryExpression",
                              "operator": "!",
                              "prefix": true,
                              "argument": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "AssignmentExpression",
                                  "operator": "=",
                                  "left": {
                                    "type": "Identifier",
                                    "name": "_step"
                                  },
                                  "right": {
                                    "type": "CallExpression",
                                    "callee": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "_iterator"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "next"
                                      },
                                      "computed": false
                                    },
                                    "arguments": []
                                  },
                                  "parenthesizedExpression": true
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "done"
                                },
                                "computed": false
                              }
                            },
                            "update": null,
                            "body": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "ExpressionStatement",
                                "expression": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "_arr"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "push"
                                    },
                                    "computed": false
                                  },
                                  "arguments": [{
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "_step"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "value"
                                    },
                                    "computed": false
                                  }]
                                }
                              }, {
                                "type": "IfStatement",
                                "test": {
                                  "type": "LogicalExpression",
                                  "left": {
                                    "type": "Identifier",
                                    "name": "i"
                                  },
                                  "operator": "&&",
                                  "right": {
                                    "type": "BinaryExpression",
                                    "left": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "_arr"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "length"
                                      },
                                      "computed": false
                                    },
                                    "operator": "===",
                                    "right": {
                                      "type": "Identifier",
                                      "name": "i"
                                    }
                                  }
                                },
                                "consequent": {
                                  "type": "BreakStatement",
                                  "label": null
                                },
                                "alternate": null
                              }]
                            }
                          }, {
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "Identifier",
                              "name": "_arr"
                            }
                          }]
                        },
                        "alternate": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ThrowStatement",
                            "argument": {
                              "type": "NewExpression",
                              "callee": {
                                "type": "Identifier",
                                "name": "TypeError"
                              },
                              "arguments": [{
                                "type": "Literal",
                                "value": "Invalid attempt to destructure non-iterable instance"
                              }]
                            }
                          }]
                        }
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-sliced-to-array": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "FunctionDeclaration",
                        "id": {
                          "type": "Identifier",
                          "name": "sliceIterator",
                          "leadingComments": null
                        },
                        "generator": false,
                        "expression": false,
                        "params": [{
                          "type": "Identifier",
                          "name": "arr"
                        }, {
                          "type": "Identifier",
                          "name": "i"
                        }],
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "_arr",
                                "leadingComments": null
                              },
                              "init": {
                                "type": "ArrayExpression",
                                "elements": []
                              },
                              "leadingComments": null
                            }],
                            "kind": "var"
                          }, {
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "_n"
                              },
                              "init": {
                                "type": "Literal",
                                "value": true
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "_d"
                              },
                              "init": {
                                "type": "Literal",
                                "value": false
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "_e"
                              },
                              "init": {
                                "type": "Identifier",
                                "name": "undefined"
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "TryStatement",
                            "block": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "ForStatement",
                                "init": {
                                  "type": "VariableDeclaration",
                                  "declarations": [{
                                    "type": "VariableDeclarator",
                                    "id": {
                                      "type": "Identifier",
                                      "name": "_i"
                                    },
                                    "init": {
                                      "type": "CallExpression",
                                      "callee": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "arr"
                                        },
                                        "property": {
                                          "type": "MemberExpression",
                                          "object": {
                                            "type": "Identifier",
                                            "name": "Symbol"
                                          },
                                          "property": {
                                            "type": "Identifier",
                                            "name": "iterator"
                                          },
                                          "computed": false
                                        },
                                        "computed": true
                                      },
                                      "arguments": []
                                    }
                                  }, {
                                    "type": "VariableDeclarator",
                                    "id": {
                                      "type": "Identifier",
                                      "name": "_s"
                                    },
                                    "init": null
                                  }],
                                  "kind": "var"
                                },
                                "test": {
                                  "type": "UnaryExpression",
                                  "operator": "!",
                                  "prefix": true,
                                  "argument": {
                                    "type": "AssignmentExpression",
                                    "operator": "=",
                                    "left": {
                                      "type": "Identifier",
                                      "name": "_n"
                                    },
                                    "right": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "AssignmentExpression",
                                        "operator": "=",
                                        "left": {
                                          "type": "Identifier",
                                          "name": "_s"
                                        },
                                        "right": {
                                          "type": "CallExpression",
                                          "callee": {
                                            "type": "MemberExpression",
                                            "object": {
                                              "type": "Identifier",
                                              "name": "_i"
                                            },
                                            "property": {
                                              "type": "Identifier",
                                              "name": "next"
                                            },
                                            "computed": false
                                          },
                                          "arguments": []
                                        },
                                        "parenthesizedExpression": true
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "done"
                                      },
                                      "computed": false
                                    },
                                    "parenthesizedExpression": true
                                  }
                                },
                                "update": {
                                  "type": "AssignmentExpression",
                                  "operator": "=",
                                  "left": {
                                    "type": "Identifier",
                                    "name": "_n"
                                  },
                                  "right": {
                                    "type": "Literal",
                                    "value": true
                                  }
                                },
                                "body": {
                                  "type": "BlockStatement",
                                  "body": [{
                                    "type": "ExpressionStatement",
                                    "expression": {
                                      "type": "CallExpression",
                                      "callee": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "_arr"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "push"
                                        },
                                        "computed": false
                                      },
                                      "arguments": [{
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "_s"
                                        },
                                        "property": {
                                          "type": "Identifier",
                                          "name": "value"
                                        },
                                        "computed": false
                                      }]
                                    }
                                  }, {
                                    "type": "IfStatement",
                                    "test": {
                                      "type": "LogicalExpression",
                                      "left": {
                                        "type": "Identifier",
                                        "name": "i"
                                      },
                                      "operator": "&&",
                                      "right": {
                                        "type": "BinaryExpression",
                                        "left": {
                                          "type": "MemberExpression",
                                          "object": {
                                            "type": "Identifier",
                                            "name": "_arr"
                                          },
                                          "property": {
                                            "type": "Identifier",
                                            "name": "length"
                                          },
                                          "computed": false
                                        },
                                        "operator": "===",
                                        "right": {
                                          "type": "Identifier",
                                          "name": "i"
                                        }
                                      }
                                    },
                                    "consequent": {
                                      "type": "BreakStatement",
                                      "label": null
                                    },
                                    "alternate": null
                                  }]
                                }
                              }]
                            },
                            "handler": {
                              "type": "CatchClause",
                              "param": {
                                "type": "Identifier",
                                "name": "err"
                              },
                              "body": {
                                "type": "BlockStatement",
                                "body": [{
                                  "type": "ExpressionStatement",
                                  "expression": {
                                    "type": "AssignmentExpression",
                                    "operator": "=",
                                    "left": {
                                      "type": "Identifier",
                                      "name": "_d"
                                    },
                                    "right": {
                                      "type": "Literal",
                                      "value": true
                                    }
                                  }
                                }, {
                                  "type": "ExpressionStatement",
                                  "expression": {
                                    "type": "AssignmentExpression",
                                    "operator": "=",
                                    "left": {
                                      "type": "Identifier",
                                      "name": "_e"
                                    },
                                    "right": {
                                      "type": "Identifier",
                                      "name": "err"
                                    }
                                  }
                                }]
                              }
                            },
                            "guardedHandlers": [],
                            "finalizer": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "TryStatement",
                                "block": {
                                  "type": "BlockStatement",
                                  "body": [{
                                    "type": "IfStatement",
                                    "test": {
                                      "type": "LogicalExpression",
                                      "left": {
                                        "type": "UnaryExpression",
                                        "operator": "!",
                                        "prefix": true,
                                        "argument": {
                                          "type": "Identifier",
                                          "name": "_n"
                                        }
                                      },
                                      "operator": "&&",
                                      "right": {
                                        "type": "MemberExpression",
                                        "object": {
                                          "type": "Identifier",
                                          "name": "_i"
                                        },
                                        "property": {
                                          "type": "Literal",
                                          "value": "return"
                                        },
                                        "computed": true
                                      }
                                    },
                                    "consequent": {
                                      "type": "ExpressionStatement",
                                      "expression": {
                                        "type": "CallExpression",
                                        "callee": {
                                          "type": "MemberExpression",
                                          "object": {
                                            "type": "Identifier",
                                            "name": "_i"
                                          },
                                          "property": {
                                            "type": "Literal",
                                            "value": "return"
                                          },
                                          "computed": true
                                        },
                                        "arguments": []
                                      }
                                    },
                                    "alternate": null
                                  }]
                                },
                                "handler": null,
                                "guardedHandlers": [],
                                "finalizer": {
                                  "type": "BlockStatement",
                                  "body": [{
                                    "type": "IfStatement",
                                    "test": {
                                      "type": "Identifier",
                                      "name": "_d"
                                    },
                                    "consequent": {
                                      "type": "ThrowStatement",
                                      "argument": {
                                        "type": "Identifier",
                                        "name": "_e"
                                      }
                                    },
                                    "alternate": null
                                  }]
                                }
                              }]
                            }
                          }, {
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "Identifier",
                              "name": "_arr"
                            }
                          }]
                        }
                      }, {
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "FunctionExpression",
                          "id": null,
                          "generator": false,
                          "expression": false,
                          "params": [{
                            "type": "Identifier",
                            "name": "arr"
                          }, {
                            "type": "Identifier",
                            "name": "i"
                          }],
                          "body": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "IfStatement",
                              "test": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "MemberExpression",
                                  "object": {
                                    "type": "Identifier",
                                    "name": "Array"
                                  },
                                  "property": {
                                    "type": "Identifier",
                                    "name": "isArray"
                                  },
                                  "computed": false
                                },
                                "arguments": [{
                                  "type": "Identifier",
                                  "name": "arr"
                                }]
                              },
                              "consequent": {
                                "type": "BlockStatement",
                                "body": [{
                                  "type": "ReturnStatement",
                                  "argument": {
                                    "type": "Identifier",
                                    "name": "arr"
                                  }
                                }]
                              },
                              "alternate": {
                                "type": "IfStatement",
                                "test": {
                                  "type": "BinaryExpression",
                                  "left": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "Symbol"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "iterator"
                                    },
                                    "computed": false
                                  },
                                  "operator": "in",
                                  "right": {
                                    "type": "CallExpression",
                                    "callee": {
                                      "type": "Identifier",
                                      "name": "Object"
                                    },
                                    "arguments": [{
                                      "type": "Identifier",
                                      "name": "arr"
                                    }]
                                  }
                                },
                                "consequent": {
                                  "type": "BlockStatement",
                                  "body": [{
                                    "type": "ReturnStatement",
                                    "argument": {
                                      "type": "CallExpression",
                                      "callee": {
                                        "type": "Identifier",
                                        "name": "sliceIterator"
                                      },
                                      "arguments": [{
                                        "type": "Identifier",
                                        "name": "arr"
                                      }, {
                                        "type": "Identifier",
                                        "name": "i"
                                      }]
                                    }
                                  }]
                                },
                                "alternate": {
                                  "type": "BlockStatement",
                                  "body": [{
                                    "type": "ThrowStatement",
                                    "argument": {
                                      "type": "NewExpression",
                                      "callee": {
                                        "type": "Identifier",
                                        "name": "TypeError"
                                      },
                                      "arguments": [{
                                        "type": "Literal",
                                        "value": "Invalid attempt to destructure non-iterable instance"
                                      }]
                                    }
                                  }]
                                }
                              }
                            }]
                          }
                        }
                      }]
                    },
                    "parenthesizedExpression": true
                  },
                  "arguments": []
                }
              }]
            },
            "helper-tagged-template-literal-loose": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "strings"
                  }, {
                    "type": "Identifier",
                    "name": "raw"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "AssignmentExpression",
                        "operator": "=",
                        "left": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "strings"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "raw"
                          },
                          "computed": false
                        },
                        "right": {
                          "type": "Identifier",
                          "name": "raw"
                        }
                      }
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Identifier",
                        "name": "strings"
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-tagged-template-literal": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "strings"
                  }, {
                    "type": "Identifier",
                    "name": "raw"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "CallExpression",
                        "callee": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "Object"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "freeze"
                          },
                          "computed": false
                        },
                        "arguments": [{
                          "type": "CallExpression",
                          "callee": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Object"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "defineProperties"
                            },
                            "computed": false
                          },
                          "arguments": [{
                            "type": "Identifier",
                            "name": "strings"
                          }, {
                            "type": "ObjectExpression",
                            "properties": [{
                              "type": "Property",
                              "method": false,
                              "shorthand": false,
                              "computed": false,
                              "key": {
                                "type": "Identifier",
                                "name": "raw"
                              },
                              "value": {
                                "type": "ObjectExpression",
                                "properties": [{
                                  "type": "Property",
                                  "method": false,
                                  "shorthand": false,
                                  "computed": false,
                                  "key": {
                                    "type": "Identifier",
                                    "name": "value"
                                  },
                                  "value": {
                                    "type": "CallExpression",
                                    "callee": {
                                      "type": "MemberExpression",
                                      "object": {
                                        "type": "Identifier",
                                        "name": "Object"
                                      },
                                      "property": {
                                        "type": "Identifier",
                                        "name": "freeze"
                                      },
                                      "computed": false
                                    },
                                    "arguments": [{
                                      "type": "Identifier",
                                      "name": "raw"
                                    }]
                                  },
                                  "kind": "init"
                                }]
                              },
                              "kind": "init"
                            }]
                          }]
                        }]
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-temporal-assert-defined": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "val"
                  }, {
                    "type": "Identifier",
                    "name": "name"
                  }, {
                    "type": "Identifier",
                    "name": "undef"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "Identifier",
                          "name": "val"
                        },
                        "operator": "===",
                        "right": {
                          "type": "Identifier",
                          "name": "undef"
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ThrowStatement",
                          "argument": {
                            "type": "NewExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "ReferenceError"
                            },
                            "arguments": [{
                              "type": "BinaryExpression",
                              "left": {
                                "type": "Identifier",
                                "name": "name"
                              },
                              "operator": "+",
                              "right": {
                                "type": "Literal",
                                "value": " is not defined - temporal dead zone"
                              }
                            }]
                          }
                        }]
                      },
                      "alternate": null
                    }, {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "Literal",
                        "value": true
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-temporal-undefined": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "ObjectExpression",
                  "properties": [],
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-to-array": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "arr"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "ConditionalExpression",
                        "test": {
                          "type": "CallExpression",
                          "callee": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Array"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "isArray"
                            },
                            "computed": false
                          },
                          "arguments": [{
                            "type": "Identifier",
                            "name": "arr"
                          }]
                        },
                        "consequent": {
                          "type": "Identifier",
                          "name": "arr"
                        },
                        "alternate": {
                          "type": "CallExpression",
                          "callee": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "Array"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "from"
                            },
                            "computed": false
                          },
                          "arguments": [{
                            "type": "Identifier",
                            "name": "arr"
                          }]
                        }
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-to-consumable-array": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "arr"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "CallExpression",
                        "callee": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "Array"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "isArray"
                          },
                          "computed": false
                        },
                        "arguments": [{
                          "type": "Identifier",
                          "name": "arr"
                        }]
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ForStatement",
                          "init": {
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "i"
                              },
                              "init": {
                                "type": "Literal",
                                "value": 0
                              }
                            }, {
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "arr2"
                              },
                              "init": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "Identifier",
                                  "name": "Array"
                                },
                                "arguments": [{
                                  "type": "MemberExpression",
                                  "object": {
                                    "type": "Identifier",
                                    "name": "arr"
                                  },
                                  "property": {
                                    "type": "Identifier",
                                    "name": "length"
                                  },
                                  "computed": false
                                }]
                              }
                            }],
                            "kind": "var"
                          },
                          "test": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "Identifier",
                              "name": "i"
                            },
                            "operator": "<",
                            "right": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "arr"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "length"
                              },
                              "computed": false
                            }
                          },
                          "update": {
                            "type": "UpdateExpression",
                            "operator": "++",
                            "prefix": false,
                            "argument": {
                              "type": "Identifier",
                              "name": "i"
                            }
                          },
                          "body": {
                            "type": "ExpressionStatement",
                            "expression": {
                              "type": "AssignmentExpression",
                              "operator": "=",
                              "left": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "arr2"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "i"
                                },
                                "computed": true
                              },
                              "right": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "arr"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "i"
                                },
                                "computed": true
                              }
                            }
                          }
                        }, {
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "Identifier",
                            "name": "arr2"
                          }
                        }]
                      },
                      "alternate": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "Array"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "from"
                              },
                              "computed": false
                            },
                            "arguments": [{
                              "type": "Identifier",
                              "name": "arr"
                            }]
                          }
                        }]
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "helper-typeof-react-element": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "LogicalExpression",
                  "left": {
                    "type": "LogicalExpression",
                    "left": {
                      "type": "LogicalExpression",
                      "left": {
                        "type": "BinaryExpression",
                        "left": {
                          "type": "UnaryExpression",
                          "operator": "typeof",
                          "prefix": true,
                          "argument": {
                            "type": "Identifier",
                            "name": "Symbol"
                          }
                        },
                        "operator": "===",
                        "right": {
                          "type": "Literal",
                          "value": "function"
                        }
                      },
                      "operator": "&&",
                      "right": {
                        "type": "MemberExpression",
                        "object": {
                          "type": "Identifier",
                          "name": "Symbol"
                        },
                        "property": {
                          "type": "Literal",
                          "value": "for"
                        },
                        "computed": true
                      }
                    },
                    "operator": "&&",
                    "right": {
                      "type": "CallExpression",
                      "callee": {
                        "type": "MemberExpression",
                        "object": {
                          "type": "Identifier",
                          "name": "Symbol"
                        },
                        "property": {
                          "type": "Literal",
                          "value": "for"
                        },
                        "computed": true
                      },
                      "arguments": [{
                        "type": "Literal",
                        "value": "react.element"
                      }]
                    }
                  },
                  "operator": "||",
                  "right": {
                    "type": "Literal",
                    "value": 60103
                  }
                }
              }]
            },
            "helper-typeof": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "obj"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "ConditionalExpression",
                        "test": {
                          "type": "LogicalExpression",
                          "left": {
                            "type": "Identifier",
                            "name": "obj"
                          },
                          "operator": "&&",
                          "right": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "MemberExpression",
                              "object": {
                                "type": "Identifier",
                                "name": "obj"
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "constructor"
                              },
                              "computed": false
                            },
                            "operator": "===",
                            "right": {
                              "type": "Identifier",
                              "name": "Symbol"
                            }
                          }
                        },
                        "consequent": {
                          "type": "Literal",
                          "value": "symbol"
                        },
                        "alternate": {
                          "type": "UnaryExpression",
                          "operator": "typeof",
                          "prefix": true,
                          "argument": {
                            "type": "Identifier",
                            "name": "obj"
                          }
                        }
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            },
            "let-scoping-return": {
              "type": "Program",
              "body": [{
                "type": "IfStatement",
                "test": {
                  "type": "BinaryExpression",
                  "left": {
                    "type": "UnaryExpression",
                    "operator": "typeof",
                    "prefix": true,
                    "argument": {
                      "type": "Identifier",
                      "name": "RETURN"
                    }
                  },
                  "operator": "===",
                  "right": {
                    "type": "Literal",
                    "value": "object"
                  }
                },
                "consequent": {
                  "type": "ReturnStatement",
                  "argument": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "RETURN"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "v"
                    },
                    "computed": false
                  }
                },
                "alternate": null
              }]
            },
            "named-function": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "FunctionDeclaration",
                        "id": {
                          "type": "Identifier",
                          "name": "GET_OUTER_ID"
                        },
                        "generator": false,
                        "expression": false,
                        "params": [],
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "Identifier",
                              "name": "FUNCTION_ID"
                            }
                          }]
                        }
                      }, {
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "Identifier",
                          "name": "FUNCTION"
                        }
                      }]
                    },
                    "parenthesizedExpression": true
                  },
                  "arguments": []
                }
              }]
            },
            "property-method-assignment-wrapper-generator": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [{
                      "type": "Identifier",
                      "name": "FUNCTION_KEY"
                    }],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "FunctionDeclaration",
                        "id": {
                          "type": "Identifier",
                          "name": "FUNCTION_ID"
                        },
                        "generator": true,
                        "expression": false,
                        "params": [],
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "YieldExpression",
                              "delegate": true,
                              "argument": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "MemberExpression",
                                  "object": {
                                    "type": "Identifier",
                                    "name": "FUNCTION_KEY"
                                  },
                                  "property": {
                                    "type": "Identifier",
                                    "name": "apply"
                                  },
                                  "computed": false
                                },
                                "arguments": [{"type": "ThisExpression"}, {
                                  "type": "Identifier",
                                  "name": "arguments"
                                }]
                              }
                            }
                          }]
                        }
                      }, {
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "AssignmentExpression",
                          "operator": "=",
                          "left": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "FUNCTION_ID"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "toString"
                            },
                            "computed": false
                          },
                          "right": {
                            "type": "FunctionExpression",
                            "id": null,
                            "generator": false,
                            "expression": false,
                            "params": [],
                            "body": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "ReturnStatement",
                                "argument": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "FUNCTION_KEY"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "toString"
                                    },
                                    "computed": false
                                  },
                                  "arguments": []
                                }
                              }]
                            }
                          }
                        }
                      }, {
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "Identifier",
                          "name": "FUNCTION_ID"
                        }
                      }]
                    },
                    "parenthesizedExpression": true
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "FUNCTION"
                  }]
                }
              }]
            },
            "property-method-assignment-wrapper": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [{
                      "type": "Identifier",
                      "name": "FUNCTION_KEY"
                    }],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "FunctionDeclaration",
                        "id": {
                          "type": "Identifier",
                          "name": "FUNCTION_ID"
                        },
                        "generator": false,
                        "expression": false,
                        "params": [],
                        "body": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ReturnStatement",
                            "argument": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "FUNCTION_KEY"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "apply"
                                },
                                "computed": false
                              },
                              "arguments": [{"type": "ThisExpression"}, {
                                "type": "Identifier",
                                "name": "arguments"
                              }]
                            }
                          }]
                        }
                      }, {
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "AssignmentExpression",
                          "operator": "=",
                          "left": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "FUNCTION_ID"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "toString"
                            },
                            "computed": false
                          },
                          "right": {
                            "type": "FunctionExpression",
                            "id": null,
                            "generator": false,
                            "expression": false,
                            "params": [],
                            "body": {
                              "type": "BlockStatement",
                              "body": [{
                                "type": "ReturnStatement",
                                "argument": {
                                  "type": "CallExpression",
                                  "callee": {
                                    "type": "MemberExpression",
                                    "object": {
                                      "type": "Identifier",
                                      "name": "FUNCTION_KEY"
                                    },
                                    "property": {
                                      "type": "Identifier",
                                      "name": "toString"
                                    },
                                    "computed": false
                                  },
                                  "arguments": []
                                }
                              }]
                            }
                          }
                        }
                      }, {
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "Identifier",
                          "name": "FUNCTION_ID"
                        }
                      }]
                    },
                    "parenthesizedExpression": true
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "FUNCTION"
                  }]
                }
              }]
            },
            "prototype-identifier": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "MemberExpression",
                  "object": {
                    "type": "Identifier",
                    "name": "CLASS_NAME"
                  },
                  "property": {
                    "type": "Identifier",
                    "name": "prototype"
                  },
                  "computed": false
                }
              }]
            },
            "require-assign-key": {
              "type": "Program",
              "body": [{
                "type": "VariableDeclaration",
                "declarations": [{
                  "type": "VariableDeclarator",
                  "id": {
                    "type": "Identifier",
                    "name": "VARIABLE_NAME"
                  },
                  "init": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "CallExpression",
                      "callee": {
                        "type": "Identifier",
                        "name": "require"
                      },
                      "arguments": [{
                        "type": "Identifier",
                        "name": "MODULE_NAME"
                      }]
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "KEY"
                    },
                    "computed": false
                  }
                }],
                "kind": "var"
              }]
            },
            "require": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "Identifier",
                    "name": "require"
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "MODULE_NAME"
                  }]
                }
              }]
            },
            "rest": {
              "type": "Program",
              "body": [{
                "type": "ForStatement",
                "init": {
                  "type": "VariableDeclaration",
                  "declarations": [{
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "LEN"
                    },
                    "init": {
                      "type": "MemberExpression",
                      "object": {
                        "type": "Identifier",
                        "name": "ARGUMENTS"
                      },
                      "property": {
                        "type": "Identifier",
                        "name": "length"
                      },
                      "computed": false
                    }
                  }, {
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "ARRAY"
                    },
                    "init": {
                      "type": "CallExpression",
                      "callee": {
                        "type": "Identifier",
                        "name": "Array"
                      },
                      "arguments": [{
                        "type": "Identifier",
                        "name": "ARRAY_LEN"
                      }]
                    }
                  }, {
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "KEY"
                    },
                    "init": {
                      "type": "Identifier",
                      "name": "START"
                    }
                  }],
                  "kind": "var"
                },
                "test": {
                  "type": "BinaryExpression",
                  "left": {
                    "type": "Identifier",
                    "name": "KEY"
                  },
                  "operator": "<",
                  "right": {
                    "type": "Identifier",
                    "name": "LEN"
                  }
                },
                "update": {
                  "type": "UpdateExpression",
                  "operator": "++",
                  "prefix": false,
                  "argument": {
                    "type": "Identifier",
                    "name": "KEY"
                  }
                },
                "body": {
                  "type": "BlockStatement",
                  "body": [{
                    "type": "ExpressionStatement",
                    "expression": {
                      "type": "AssignmentExpression",
                      "operator": "=",
                      "left": {
                        "type": "MemberExpression",
                        "object": {
                          "type": "Identifier",
                          "name": "ARRAY"
                        },
                        "property": {
                          "type": "Identifier",
                          "name": "ARRAY_KEY"
                        },
                        "computed": true
                      },
                      "right": {
                        "type": "MemberExpression",
                        "object": {
                          "type": "Identifier",
                          "name": "ARGUMENTS"
                        },
                        "property": {
                          "type": "Identifier",
                          "name": "KEY"
                        },
                        "computed": true
                      }
                    }
                  }]
                }
              }]
            },
            "self-contained-helpers-head": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "AssignmentExpression",
                  "operator": "=",
                  "left": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "exports"
                    },
                    "property": {
                      "type": "Literal",
                      "value": "default"
                    },
                    "computed": true
                  },
                  "right": {
                    "type": "Identifier",
                    "name": "HELPER"
                  }
                }
              }, {
                "type": "ExpressionStatement",
                "expression": {
                  "type": "AssignmentExpression",
                  "operator": "=",
                  "left": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "exports"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "__esModule"
                    },
                    "computed": false
                  },
                  "right": {
                    "type": "Literal",
                    "value": true
                  }
                }
              }]
            },
            "system": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "System"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "register"
                    },
                    "computed": false
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "MODULE_NAME"
                  }, {
                    "type": "Identifier",
                    "name": "MODULE_DEPENDENCIES"
                  }, {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [{
                      "type": "Identifier",
                      "name": "EXPORT_IDENTIFIER"
                    }],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "ReturnStatement",
                        "argument": {
                          "type": "ObjectExpression",
                          "properties": [{
                            "type": "Property",
                            "method": false,
                            "shorthand": false,
                            "computed": false,
                            "key": {
                              "type": "Identifier",
                              "name": "setters"
                            },
                            "value": {
                              "type": "Identifier",
                              "name": "SETTERS"
                            },
                            "kind": "init"
                          }, {
                            "type": "Property",
                            "method": false,
                            "shorthand": false,
                            "computed": false,
                            "key": {
                              "type": "Identifier",
                              "name": "execute"
                            },
                            "value": {
                              "type": "Identifier",
                              "name": "EXECUTE"
                            },
                            "kind": "init"
                          }]
                        }
                      }]
                    }
                  }]
                }
              }]
            },
            "tail-call-body": {
              "type": "Program",
              "body": [{
                "type": "BlockStatement",
                "body": [{
                  "type": "VariableDeclaration",
                  "declarations": [{
                    "type": "VariableDeclarator",
                    "id": {
                      "type": "Identifier",
                      "name": "AGAIN_ID"
                    },
                    "init": {
                      "type": "Literal",
                      "value": true
                    }
                  }],
                  "kind": "var"
                }, {
                  "type": "LabeledStatement",
                  "body": {
                    "type": "WhileStatement",
                    "test": {
                      "type": "Identifier",
                      "name": "AGAIN_ID"
                    },
                    "body": {
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "Identifier",
                        "name": "BLOCK"
                      }
                    }
                  },
                  "label": {
                    "type": "Identifier",
                    "name": "FUNCTION_ID"
                  }
                }]
              }]
            },
            "test-exports": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "BinaryExpression",
                  "left": {
                    "type": "UnaryExpression",
                    "operator": "typeof",
                    "prefix": true,
                    "argument": {
                      "type": "Identifier",
                      "name": "exports"
                    }
                  },
                  "operator": "!==",
                  "right": {
                    "type": "Literal",
                    "value": "undefined"
                  }
                }
              }]
            },
            "test-module": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "BinaryExpression",
                  "left": {
                    "type": "UnaryExpression",
                    "operator": "typeof",
                    "prefix": true,
                    "argument": {
                      "type": "Identifier",
                      "name": "module"
                    }
                  },
                  "operator": "!==",
                  "right": {
                    "type": "Literal",
                    "value": "undefined"
                  }
                }
              }]
            },
            "umd-commonjs-strict": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "CallExpression",
                  "callee": {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [{
                      "type": "Identifier",
                      "name": "root"
                    }, {
                      "type": "Identifier",
                      "name": "factory"
                    }],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "IfStatement",
                        "test": {
                          "type": "LogicalExpression",
                          "left": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "UnaryExpression",
                              "operator": "typeof",
                              "prefix": true,
                              "argument": {
                                "type": "Identifier",
                                "name": "define"
                              }
                            },
                            "operator": "===",
                            "right": {
                              "type": "Literal",
                              "value": "function"
                            }
                          },
                          "operator": "&&",
                          "right": {
                            "type": "MemberExpression",
                            "object": {
                              "type": "Identifier",
                              "name": "define"
                            },
                            "property": {
                              "type": "Identifier",
                              "name": "amd"
                            },
                            "computed": false
                          }
                        },
                        "consequent": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ExpressionStatement",
                            "expression": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "Identifier",
                                "name": "define"
                              },
                              "arguments": [{
                                "type": "Identifier",
                                "name": "AMD_ARGUMENTS"
                              }, {
                                "type": "Identifier",
                                "name": "factory"
                              }]
                            }
                          }]
                        },
                        "alternate": {
                          "type": "IfStatement",
                          "test": {
                            "type": "BinaryExpression",
                            "left": {
                              "type": "UnaryExpression",
                              "operator": "typeof",
                              "prefix": true,
                              "argument": {
                                "type": "Identifier",
                                "name": "exports"
                              }
                            },
                            "operator": "===",
                            "right": {
                              "type": "Literal",
                              "value": "object"
                            }
                          },
                          "consequent": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ExpressionStatement",
                              "expression": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "Identifier",
                                  "name": "factory"
                                },
                                "arguments": [{
                                  "type": "Identifier",
                                  "name": "COMMON_ARGUMENTS"
                                }]
                              }
                            }]
                          },
                          "alternate": {
                            "type": "BlockStatement",
                            "body": [{
                              "type": "ExpressionStatement",
                              "expression": {
                                "type": "CallExpression",
                                "callee": {
                                  "type": "Identifier",
                                  "name": "factory"
                                },
                                "arguments": [{
                                  "type": "Identifier",
                                  "name": "BROWSER_ARGUMENTS"
                                }]
                              }
                            }]
                          }
                        }
                      }]
                    },
                    "parenthesizedExpression": true
                  },
                  "arguments": [{
                    "type": "Identifier",
                    "name": "UMD_ROOT"
                  }, {
                    "type": "FunctionExpression",
                    "id": null,
                    "generator": false,
                    "expression": false,
                    "params": [{
                      "type": "Identifier",
                      "name": "FACTORY_PARAMETERS"
                    }],
                    "body": {
                      "type": "BlockStatement",
                      "body": [{
                        "type": "ExpressionStatement",
                        "expression": {
                          "type": "Identifier",
                          "name": "FACTORY_BODY"
                        }
                      }]
                    }
                  }]
                }
              }]
            },
            "umd-runner-body": {
              "type": "Program",
              "body": [{
                "type": "ExpressionStatement",
                "expression": {
                  "type": "FunctionExpression",
                  "id": null,
                  "generator": false,
                  "expression": false,
                  "params": [{
                    "type": "Identifier",
                    "name": "global"
                  }, {
                    "type": "Identifier",
                    "name": "factory"
                  }],
                  "body": {
                    "type": "BlockStatement",
                    "body": [{
                      "type": "IfStatement",
                      "test": {
                        "type": "LogicalExpression",
                        "left": {
                          "type": "BinaryExpression",
                          "left": {
                            "type": "UnaryExpression",
                            "operator": "typeof",
                            "prefix": true,
                            "argument": {
                              "type": "Identifier",
                              "name": "define"
                            }
                          },
                          "operator": "===",
                          "right": {
                            "type": "Literal",
                            "value": "function"
                          }
                        },
                        "operator": "&&",
                        "right": {
                          "type": "MemberExpression",
                          "object": {
                            "type": "Identifier",
                            "name": "define"
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "amd"
                          },
                          "computed": false
                        }
                      },
                      "consequent": {
                        "type": "BlockStatement",
                        "body": [{
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "define"
                            },
                            "arguments": [{
                              "type": "Identifier",
                              "name": "AMD_ARGUMENTS"
                            }, {
                              "type": "Identifier",
                              "name": "factory"
                            }]
                          }
                        }]
                      },
                      "alternate": {
                        "type": "IfStatement",
                        "test": {
                          "type": "Identifier",
                          "name": "COMMON_TEST"
                        },
                        "consequent": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "ExpressionStatement",
                            "expression": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "Identifier",
                                "name": "factory"
                              },
                              "arguments": [{
                                "type": "Identifier",
                                "name": "COMMON_ARGUMENTS"
                              }]
                            }
                          }]
                        },
                        "alternate": {
                          "type": "BlockStatement",
                          "body": [{
                            "type": "VariableDeclaration",
                            "declarations": [{
                              "type": "VariableDeclarator",
                              "id": {
                                "type": "Identifier",
                                "name": "mod"
                              },
                              "init": {
                                "type": "ObjectExpression",
                                "properties": [{
                                  "type": "Property",
                                  "method": false,
                                  "shorthand": false,
                                  "computed": false,
                                  "key": {
                                    "type": "Identifier",
                                    "name": "exports"
                                  },
                                  "value": {
                                    "type": "ObjectExpression",
                                    "properties": []
                                  },
                                  "kind": "init"
                                }]
                              }
                            }],
                            "kind": "var"
                          }, {
                            "type": "ExpressionStatement",
                            "expression": {
                              "type": "CallExpression",
                              "callee": {
                                "type": "Identifier",
                                "name": "factory"
                              },
                              "arguments": [{
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "mod"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "exports"
                                },
                                "computed": false
                              }, {
                                "type": "Identifier",
                                "name": "BROWSER_ARGUMENTS"
                              }]
                            }
                          }, {
                            "type": "ExpressionStatement",
                            "expression": {
                              "type": "AssignmentExpression",
                              "operator": "=",
                              "left": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "global"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "GLOBAL_ARG"
                                },
                                "computed": false
                              },
                              "right": {
                                "type": "MemberExpression",
                                "object": {
                                  "type": "Identifier",
                                  "name": "mod"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "exports"
                                },
                                "computed": false
                              }
                            }
                          }]
                        }
                      }
                    }]
                  },
                  "parenthesizedExpression": true
                }
              }]
            }
          };
        }, {}],
        624: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.parse = parse;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _parser = require("./parser");
          var _parser2 = _interopRequireDefault(_parser);
          require("./parser/util");
          require("./parser/statement");
          require("./parser/lval");
          require("./parser/expression");
          require("./parser/node");
          require("./parser/location");
          require("./parser/comments");
          var _tokenizerTypes = require("./tokenizer/types");
          require("./tokenizer");
          require("./tokenizer/context");
          var _pluginsFlow = require("./plugins/flow");
          var _pluginsFlow2 = _interopRequireDefault(_pluginsFlow);
          var _pluginsJsx = require("./plugins/jsx");
          var _pluginsJsx2 = _interopRequireDefault(_pluginsJsx);
          _parser.plugins.flow = _pluginsFlow2["default"];
          _parser.plugins.jsx = _pluginsJsx2["default"];
          function parse(input, options) {
            return new _parser2["default"](options, input).parse();
          }
          exports.tokTypes = _tokenizerTypes.types;
        }, {
          "./parser": 628,
          "./parser/comments": 626,
          "./parser/expression": 627,
          "./parser/location": 629,
          "./parser/lval": 630,
          "./parser/node": 631,
          "./parser/statement": 632,
          "./parser/util": 633,
          "./plugins/flow": 634,
          "./plugins/jsx": 635,
          "./tokenizer": 638,
          "./tokenizer/context": 637,
          "./tokenizer/types": 640
        }],
        625: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.getOptions = getOptions;
          var defaultOptions = {
            sourceType: "script",
            allowReserved: true,
            allowReturnOutsideFunction: false,
            allowImportExportEverywhere: false,
            plugins: {},
            features: {},
            strictMode: null
          };
          exports.defaultOptions = defaultOptions;
          function getOptions(opts) {
            var options = {};
            for (var key in defaultOptions) {
              options[key] = opts && key in opts ? opts[key] : defaultOptions[key];
            }
            return options;
          }
        }, {}],
        626: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          function last(stack) {
            return stack[stack.length - 1];
          }
          var pp = _index2["default"].prototype;
          pp.addComment = function(comment) {
            this.state.trailingComments.push(comment);
            this.state.leadingComments.push(comment);
          };
          pp.processComment = function(node) {
            if (node.type === "Program" && node.body.length > 0)
              return;
            var stack = this.state.commentStack;
            var lastChild,
                trailingComments,
                i;
            if (this.state.trailingComments.length > 0) {
              if (this.state.trailingComments[0].start >= node.end) {
                trailingComments = this.state.trailingComments;
                this.state.trailingComments = [];
              } else {
                this.state.trailingComments.length = 0;
              }
            } else {
              var lastInStack = last(stack);
              if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
                trailingComments = lastInStack.trailingComments;
                lastInStack.trailingComments = null;
              }
            }
            while (stack.length > 0 && last(stack).start >= node.start) {
              lastChild = stack.pop();
            }
            if (lastChild) {
              if (lastChild.leadingComments) {
                if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {
                  node.leadingComments = lastChild.leadingComments;
                  lastChild.leadingComments = null;
                } else {
                  for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
                    if (lastChild.leadingComments[i].end <= node.start) {
                      node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                      break;
                    }
                  }
                }
              }
            } else if (this.state.leadingComments.length > 0) {
              if (last(this.state.leadingComments).end <= node.start) {
                node.leadingComments = this.state.leadingComments;
                this.state.leadingComments = [];
              } else {
                for (i = 0; i < this.state.leadingComments.length; i++) {
                  if (this.state.leadingComments[i].end > node.start) {
                    break;
                  }
                }
                node.leadingComments = this.state.leadingComments.slice(0, i);
                if (node.leadingComments.length === 0) {
                  node.leadingComments = null;
                }
                trailingComments = this.state.leadingComments.slice(i);
                if (trailingComments.length === 0) {
                  trailingComments = null;
                }
              }
            }
            if (trailingComments) {
              if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
                node.innerComments = trailingComments;
              } else {
                node.trailingComments = trailingComments;
              }
            }
            stack.push(node);
          };
        }, {"./index": 628}],
        627: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _tokenizerTypes = require("../tokenizer/types");
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          var _utilIdentifier = require("../util/identifier");
          var pp = _index2["default"].prototype;
          pp.checkPropClash = function(prop, propHash) {
            if (prop.computed || prop.method || prop.shorthand)
              return;
            var key = prop.key,
                name = undefined;
            switch (key.type) {
              case "Identifier":
                name = key.name;
                break;
              case "Literal":
                name = String(key.value);
                break;
              default:
                return;
            }
            var kind = prop.kind;
            if (name === "__proto__" && kind === "init") {
              if (propHash.proto)
                this.raise(key.start, "Redefinition of __proto__ property");
              propHash.proto = true;
            }
          };
          pp.parseExpression = function(noIn, refShorthandDefaultPos) {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
            if (this.match(_tokenizerTypes.types.comma)) {
              var node = this.startNodeAt(startPos, startLoc);
              node.expressions = [expr];
              while (this.eat(_tokenizerTypes.types.comma)) {
                node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
              }
              this.toReferencedList(node.expressions);
              return this.finishNode(node, "SequenceExpression");
            }
            return expr;
          };
          pp.parseMaybeAssign = function(noIn, refShorthandDefaultPos, afterLeftParse) {
            if (this.match(_tokenizerTypes.types._yield) && this.state.inGenerator) {
              return this.parseYield();
            }
            var failOnShorthandAssign = undefined;
            if (!refShorthandDefaultPos) {
              refShorthandDefaultPos = {start: 0};
              failOnShorthandAssign = true;
            } else {
              failOnShorthandAssign = false;
            }
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            if (this.match(_tokenizerTypes.types.parenL) || this.match(_tokenizerTypes.types.name)) {
              this.state.potentialArrowAt = this.state.start;
            }
            var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);
            if (afterLeftParse)
              left = afterLeftParse.call(this, left, startPos, startLoc);
            if (this.state.type.isAssign) {
              var node = this.startNodeAt(startPos, startLoc);
              node.operator = this.state.value;
              node.left = this.match(_tokenizerTypes.types.eq) ? this.toAssignable(left) : left;
              refShorthandDefaultPos.start = 0;
              this.checkLVal(left);
              if (left.parenthesizedExpression) {
                var errorMsg = undefined;
                if (left.type === "ObjectPattern") {
                  errorMsg = "`({a}) = 0` use `({a} = 0)`";
                } else if (left.type === "ArrayPattern") {
                  errorMsg = "`([a]) = 0` use `([a] = 0)`";
                }
                if (errorMsg) {
                  this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
                }
              }
              this.next();
              node.right = this.parseMaybeAssign(noIn);
              return this.finishNode(node, "AssignmentExpression");
            } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
              this.unexpected(refShorthandDefaultPos.start);
            }
            return left;
          };
          pp.parseMaybeConditional = function(noIn, refShorthandDefaultPos) {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
            if (refShorthandDefaultPos && refShorthandDefaultPos.start)
              return expr;
            if (this.eat(_tokenizerTypes.types.question)) {
              var node = this.startNodeAt(startPos, startLoc);
              node.test = expr;
              node.consequent = this.parseMaybeAssign();
              this.expect(_tokenizerTypes.types.colon);
              node.alternate = this.parseMaybeAssign(noIn);
              return this.finishNode(node, "ConditionalExpression");
            }
            return expr;
          };
          pp.parseExprOps = function(noIn, refShorthandDefaultPos) {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            var expr = this.parseMaybeUnary(refShorthandDefaultPos);
            if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
              return expr;
            } else {
              return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
            }
          };
          pp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
            var prec = this.state.type.binop;
            if (prec != null && (!noIn || !this.match(_tokenizerTypes.types._in))) {
              if (prec > minPrec) {
                var node = this.startNodeAt(leftStartPos, leftStartLoc);
                node.left = left;
                node.operator = this.state.value;
                var op = this.state.type;
                this.next();
                var startPos = this.state.start,
                    startLoc = this.state.startLoc;
                node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
                this.finishNode(node, op === _tokenizerTypes.types.logicalOR || op === _tokenizerTypes.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
              }
            }
            return left;
          };
          pp.parseMaybeUnary = function(refShorthandDefaultPos) {
            if (this.state.type.prefix) {
              var node = this.startNode(),
                  update = this.match(_tokenizerTypes.types.incDec);
              node.operator = this.state.value;
              node.prefix = true;
              this.next();
              node.argument = this.parseMaybeUnary();
              if (refShorthandDefaultPos && refShorthandDefaultPos.start)
                this.unexpected(refShorthandDefaultPos.start);
              if (update) {
                this.checkLVal(node.argument);
              } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
                this.raise(node.start, "Deleting local variable in strict mode");
              }
              return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
            }
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            var expr = this.parseExprSubscripts(refShorthandDefaultPos);
            if (refShorthandDefaultPos && refShorthandDefaultPos.start)
              return expr;
            while (this.state.type.postfix && !this.canInsertSemicolon()) {
              var node = this.startNodeAt(startPos, startLoc);
              node.operator = this.state.value;
              node.prefix = false;
              node.argument = expr;
              this.checkLVal(expr);
              this.next();
              expr = this.finishNode(node, "UpdateExpression");
            }
            return expr;
          };
          pp.parseExprSubscripts = function(refShorthandDefaultPos) {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            var expr = this.parseExprAtom(refShorthandDefaultPos);
            if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
              return expr;
            } else {
              return this.parseSubscripts(expr, startPos, startLoc);
            }
          };
          pp.parseSubscripts = function(base, startPos, startLoc, noCalls) {
            for (; ; ) {
              if (!noCalls && this.eat(_tokenizerTypes.types.doubleColon)) {
                var node = this.startNodeAt(startPos, startLoc);
                node.object = base;
                node.callee = this.parseNoCallExpr();
                return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
              } else if (this.eat(_tokenizerTypes.types.dot)) {
                var node = this.startNodeAt(startPos, startLoc);
                node.object = base;
                node.property = this.parseIdent(true);
                node.computed = false;
                base = this.finishNode(node, "MemberExpression");
              } else if (this.eat(_tokenizerTypes.types.bracketL)) {
                var node = this.startNodeAt(startPos, startLoc);
                node.object = base;
                node.property = this.parseExpression();
                node.computed = true;
                this.expect(_tokenizerTypes.types.bracketR);
                base = this.finishNode(node, "MemberExpression");
              } else if (!noCalls && this.match(_tokenizerTypes.types.parenL)) {
                var possibleAsync = base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
                this.next();
                var node = this.startNodeAt(startPos, startLoc);
                node.callee = base;
                node.arguments = this.parseExprList(_tokenizerTypes.types.parenR, this.options.features["es7.trailingFunctionCommas"]);
                base = this.finishNode(node, "CallExpression");
                if (possibleAsync && (this.match(_tokenizerTypes.types.colon) || this.match(_tokenizerTypes.types.arrow))) {
                  base = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
                } else {
                  this.toReferencedList(node.arguments);
                }
              } else if (this.match(_tokenizerTypes.types.backQuote)) {
                var node = this.startNodeAt(startPos, startLoc);
                node.tag = base;
                node.quasi = this.parseTemplate();
                base = this.finishNode(node, "TaggedTemplateExpression");
              } else {
                return base;
              }
            }
          };
          pp.parseAsyncArrowFromCallExpression = function(node, call) {
            if (!this.options.features["es7.asyncFunctions"])
              this.unexpected();
            this.expect(_tokenizerTypes.types.arrow);
            return this.parseArrowExpression(node, call.arguments, true);
          };
          pp.parseNoCallExpr = function() {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
          };
          pp.parseExprAtom = function(refShorthandDefaultPos) {
            var node = undefined,
                canBeArrow = this.state.potentialArrowAt === this.state.start;
            switch (this.state.type) {
              case _tokenizerTypes.types._super:
                if (!this.state.inFunction)
                  this.raise(this.state.start, "'super' outside of function or class");
              case _tokenizerTypes.types._this:
                var type = this.match(_tokenizerTypes.types._this) ? "ThisExpression" : "Super";
                node = this.startNode();
                this.next();
                return this.finishNode(node, type);
              case _tokenizerTypes.types._yield:
                if (this.state.inGenerator)
                  this.unexpected();
              case _tokenizerTypes.types._do:
                if (this.options.features["es7.doExpressions"]) {
                  var _node = this.startNode();
                  this.next();
                  var oldInFunction = this.state.inFunction;
                  var oldLabels = this.state.labels;
                  this.state.labels = [];
                  this.state.inFunction = false;
                  _node.body = this.parseBlock();
                  this.state.inFunction = oldInFunction;
                  this.state.labels = oldLabels;
                  return this.finishNode(_node, "DoExpression");
                }
              case _tokenizerTypes.types.name:
                node = this.startNode();
                var id = this.parseIdent(true);
                if (this.options.features["es7.asyncFunctions"]) {
                  if (id.name === "await") {
                    if (this.inAsync)
                      return this.parseAwait(node);
                  } else if (id.name === "async" && this.match(_tokenizerTypes.types._function) && !this.canInsertSemicolon()) {
                    this.next();
                    return this.parseFunction(node, false, false, true);
                  } else if (canBeArrow && id.name === "async" && this.match(_tokenizerTypes.types.name)) {
                    var params = [this.parseIdent()];
                    this.expect(_tokenizerTypes.types.arrow);
                    return this.parseArrowExpression(node, params, true);
                  }
                }
                if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokenizerTypes.types.arrow)) {
                  return this.parseArrowExpression(node, [id]);
                }
                return id;
              case _tokenizerTypes.types.regexp:
                var value = this.state.value;
                node = this.parseLiteral(value.value);
                node.regex = {
                  pattern: value.pattern,
                  flags: value.flags
                };
                return node;
              case _tokenizerTypes.types.num:
              case _tokenizerTypes.types.string:
                return this.parseLiteral(this.state.value);
              case _tokenizerTypes.types._null:
              case _tokenizerTypes.types._true:
              case _tokenizerTypes.types._false:
                node = this.startNode();
                node.rawValue = node.value = this.match(_tokenizerTypes.types._null) ? null : this.match(_tokenizerTypes.types._true);
                node.raw = this.state.type.keyword;
                this.next();
                return this.finishNode(node, "Literal");
              case _tokenizerTypes.types.parenL:
                return this.parseParenAndDistinguishExpression(null, null, canBeArrow);
              case _tokenizerTypes.types.bracketL:
                node = this.startNode();
                this.next();
                if (this.options.features["es7.comprehensions"] && this.match(_tokenizerTypes.types._for)) {
                  return this.parseComprehension(node, false);
                }
                node.elements = this.parseExprList(_tokenizerTypes.types.bracketR, true, true, refShorthandDefaultPos);
                this.toReferencedList(node.elements);
                return this.finishNode(node, "ArrayExpression");
              case _tokenizerTypes.types.braceL:
                return this.parseObj(false, refShorthandDefaultPos);
              case _tokenizerTypes.types._function:
                node = this.startNode();
                this.next();
                return this.parseFunction(node, false);
              case _tokenizerTypes.types.at:
                this.parseDecorators();
              case _tokenizerTypes.types._class:
                node = this.startNode();
                this.takeDecorators(node);
                return this.parseClass(node, false);
              case _tokenizerTypes.types._new:
                return this.parseNew();
              case _tokenizerTypes.types.backQuote:
                return this.parseTemplate();
              case _tokenizerTypes.types.doubleColon:
                node = this.startNode();
                this.next();
                node.object = null;
                var callee = node.callee = this.parseNoCallExpr();
                if (callee.type === "MemberExpression") {
                  return this.finishNode(node, "BindExpression");
                } else {
                  this.raise(callee.start, "Binding should be performed on object property.");
                }
              default:
                this.unexpected();
            }
          };
          pp.parseLiteral = function(value) {
            var node = this.startNode();
            node.rawValue = node.value = value;
            node.raw = this.input.slice(this.state.start, this.state.end);
            this.next();
            return this.finishNode(node, "Literal");
          };
          pp.parseParenExpression = function() {
            this.expect(_tokenizerTypes.types.parenL);
            var val = this.parseExpression();
            this.expect(_tokenizerTypes.types.parenR);
            return val;
          };
          pp.parseParenAndDistinguishExpression = function(startPos, startLoc, canBeArrow, isAsync) {
            startPos = startPos || this.state.start;
            startLoc = startLoc || this.state.startLoc;
            var val = undefined;
            this.next();
            if (this.options.features["es7.comprehensions"] && this.match(_tokenizerTypes.types._for)) {
              return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
            }
            var innerStartPos = this.state.start,
                innerStartLoc = this.state.startLoc;
            var exprList = [],
                first = true;
            var refShorthandDefaultPos = {start: 0},
                spreadStart = undefined,
                innerParenStart = undefined,
                optionalCommaStart = undefined;
            while (!this.match(_tokenizerTypes.types.parenR)) {
              if (first) {
                first = false;
              } else {
                this.expect(_tokenizerTypes.types.comma);
                if (this.match(_tokenizerTypes.types.parenR) && this.options.features["es7.trailingFunctionCommas"]) {
                  optionalCommaStart = this.state.start;
                  break;
                }
              }
              if (this.match(_tokenizerTypes.types.ellipsis)) {
                var spreadNodeStartPos = this.state.start,
                    spreadNodeStartLoc = this.state.startLoc;
                spreadStart = this.state.start;
                exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartLoc, spreadNodeStartPos));
                break;
              } else {
                if (this.match(_tokenizerTypes.types.parenL) && !innerParenStart) {
                  innerParenStart = this.state.start;
                }
                exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem));
              }
            }
            var innerEndPos = this.state.start;
            var innerEndLoc = this.state.startLoc;
            this.expect(_tokenizerTypes.types.parenR);
            if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokenizerTypes.types.arrow)) {
              if (innerParenStart)
                this.unexpected(innerParenStart);
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, isAsync);
            }
            if (!exprList.length) {
              if (isAsync) {
                return;
              } else {
                this.unexpected(this.state.lastTokStart);
              }
            }
            if (optionalCommaStart)
              this.unexpected(optionalCommaStart);
            if (spreadStart)
              this.unexpected(spreadStart);
            if (refShorthandDefaultPos.start)
              this.unexpected(refShorthandDefaultPos.start);
            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartPos, innerStartLoc);
              val.expressions = exprList;
              this.toReferencedList(val.expressions);
              this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
              val = exprList[0];
            }
            val.parenthesizedExpression = true;
            return val;
          };
          pp.parseParenItem = function(node) {
            return node;
          };
          pp.parseNew = function() {
            var node = this.startNode();
            var meta = this.parseIdent(true);
            if (this.eat(_tokenizerTypes.types.dot)) {
              node.meta = meta;
              node.property = this.parseIdent(true);
              if (node.property.name !== "target") {
                this.raise(node.property.start, "The only valid meta property for new is new.target");
              }
              return this.finishNode(node, "MetaProperty");
            }
            node.callee = this.parseNoCallExpr();
            if (this.eat(_tokenizerTypes.types.parenL)) {
              node.arguments = this.parseExprList(_tokenizerTypes.types.parenR, this.options.features["es7.trailingFunctionCommas"]);
              this.toReferencedList(node.arguments);
            } else {
              node.arguments = [];
            }
            return this.finishNode(node, "NewExpression");
          };
          pp.parseTemplateElement = function() {
            var elem = this.startNode();
            elem.value = {
              raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
              cooked: this.state.value
            };
            this.next();
            elem.tail = this.match(_tokenizerTypes.types.backQuote);
            return this.finishNode(elem, "TemplateElement");
          };
          pp.parseTemplate = function() {
            var node = this.startNode();
            this.next();
            node.expressions = [];
            var curElt = this.parseTemplateElement();
            node.quasis = [curElt];
            while (!curElt.tail) {
              this.expect(_tokenizerTypes.types.dollarBraceL);
              node.expressions.push(this.parseExpression());
              this.expect(_tokenizerTypes.types.braceR);
              node.quasis.push(curElt = this.parseTemplateElement());
            }
            this.next();
            return this.finishNode(node, "TemplateLiteral");
          };
          pp.parseObj = function(isPattern, refShorthandDefaultPos) {
            var node = this.startNode(),
                first = true,
                propHash = Object.create(null);
            node.properties = [];
            var decorators = [];
            this.next();
            while (!this.eat(_tokenizerTypes.types.braceR)) {
              if (first) {
                first = false;
              } else {
                this.expect(_tokenizerTypes.types.comma);
                if (this.eat(_tokenizerTypes.types.braceR))
                  break;
              }
              while (this.match(_tokenizerTypes.types.at)) {
                decorators.push(this.parseDecorator());
              }
              var prop = this.startNode(),
                  isGenerator = false,
                  isAsync = false,
                  startPos = undefined,
                  startLoc = undefined;
              if (decorators.length) {
                prop.decorators = decorators;
                decorators = [];
              }
              if (this.options.features["es7.objectRestSpread"] && this.match(_tokenizerTypes.types.ellipsis)) {
                prop = this.parseSpread();
                prop.type = "SpreadProperty";
                node.properties.push(prop);
                continue;
              }
              prop.method = false;
              prop.shorthand = false;
              if (isPattern || refShorthandDefaultPos) {
                startPos = this.state.start;
                startLoc = this.state.startLoc;
              }
              if (!isPattern) {
                isGenerator = this.eat(_tokenizerTypes.types.star);
              }
              if (!isPattern && this.options.features["es7.asyncFunctions"] && this.isContextual("async")) {
                if (isGenerator)
                  this.unexpected();
                var asyncId = this.parseIdent();
                if (this.match(_tokenizerTypes.types.colon) || this.match(_tokenizerTypes.types.parenL) || this.match(_tokenizerTypes.types.braceR)) {
                  prop.key = asyncId;
                } else {
                  isAsync = true;
                  this.parsePropertyName(prop);
                }
              } else {
                this.parsePropertyName(prop);
              }
              this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
              this.checkPropClash(prop, propHash);
              node.properties.push(this.finishNode(prop, "Property"));
            }
            if (decorators.length) {
              this.raise(this.state.start, "You have trailing decorators with no property");
            }
            return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
          };
          pp.parseObjPropValue = function(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
            if (this.eat(_tokenizerTypes.types.colon)) {
              prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
              prop.kind = "init";
            } else if (this.match(_tokenizerTypes.types.parenL)) {
              if (isPattern)
                this.unexpected();
              prop.kind = "init";
              prop.method = true;
              prop.value = this.parseMethod(isGenerator, isAsync);
            } else if (!prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (!this.match(_tokenizerTypes.types.comma) && !this.match(_tokenizerTypes.types.braceR))) {
              if (isGenerator || isAsync || isPattern)
                this.unexpected();
              prop.kind = prop.key.name;
              this.parsePropertyName(prop);
              prop.value = this.parseMethod(false);
              var paramCount = prop.kind === "get" ? 0 : 1;
              if (prop.value.params.length !== paramCount) {
                var start = prop.value.start;
                if (prop.kind === "get")
                  this.raise(start, "getter should have no params");
                else
                  this.raise(start, "setter should have exactly one param");
              }
            } else if (!prop.computed && prop.key.type === "Identifier") {
              prop.kind = "init";
              if (isPattern) {
                if (this.isKeyword(prop.key.name) || this.strict && (_utilIdentifier.reservedWords.strictBind(prop.key.name) || _utilIdentifier.reservedWords.strict(prop.key.name)) || !this.options.allowReserved && this.isReservedWord(prop.key.name))
                  this.raise(prop.key.start, "Binding " + prop.key.name);
                prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
              } else if (this.match(_tokenizerTypes.types.eq) && refShorthandDefaultPos) {
                if (!refShorthandDefaultPos.start)
                  refShorthandDefaultPos.start = this.state.start;
                prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
              } else {
                prop.value = prop.key.__clone();
              }
              prop.shorthand = true;
            } else {
              this.unexpected();
            }
          };
          pp.parsePropertyName = function(prop) {
            if (this.eat(_tokenizerTypes.types.bracketL)) {
              prop.computed = true;
              prop.key = this.parseMaybeAssign();
              this.expect(_tokenizerTypes.types.bracketR);
              return prop.key;
            } else {
              prop.computed = false;
              return prop.key = this.match(_tokenizerTypes.types.num) || this.match(_tokenizerTypes.types.string) ? this.parseExprAtom() : this.parseIdent(true);
            }
          };
          pp.initFunction = function(node, isAsync) {
            node.id = null;
            node.generator = false;
            node.expression = false;
            if (this.options.features["es7.asyncFunctions"]) {
              node.async = !!isAsync;
            }
          };
          pp.parseMethod = function(isGenerator, isAsync) {
            var node = this.startNode();
            this.initFunction(node, isAsync);
            this.expect(_tokenizerTypes.types.parenL);
            node.params = this.parseBindingList(_tokenizerTypes.types.parenR, false, this.options.features["es7.trailingFunctionCommas"]);
            node.generator = isGenerator;
            this.parseFunctionBody(node);
            return this.finishNode(node, "FunctionExpression");
          };
          pp.parseArrowExpression = function(node, params, isAsync) {
            this.initFunction(node, isAsync);
            node.params = this.toAssignableList(params, true);
            this.parseFunctionBody(node, true);
            return this.finishNode(node, "ArrowFunctionExpression");
          };
          pp.parseFunctionBody = function(node, allowExpression) {
            var isExpression = allowExpression && !this.match(_tokenizerTypes.types.braceL);
            var oldInAsync = this.inAsync;
            this.inAsync = node.async;
            if (isExpression) {
              node.body = this.parseMaybeAssign();
              node.expression = true;
            } else {
              var oldInFunc = this.state.inFunction,
                  oldInGen = this.state.inGenerator,
                  oldLabels = this.state.labels;
              this.state.inFunction = true;
              this.state.inGenerator = node.generator;
              this.state.labels = [];
              node.body = this.parseBlock(true);
              node.expression = false;
              this.state.inFunction = oldInFunc;
              this.state.inGenerator = oldInGen;
              this.state.labels = oldLabels;
            }
            this.inAsync = oldInAsync;
            if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
              var nameHash = Object.create(null),
                  oldStrict = this.strict;
              this.strict = true;
              if (node.id) {
                this.checkLVal(node.id, true);
              }
              var _arr = node.params;
              for (var _i = 0; _i < _arr.length; _i++) {
                var param = _arr[_i];
                this.checkLVal(param, true, nameHash);
              }
              this.strict = oldStrict;
            }
          };
          pp.parseExprList = function(close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
            var elts = [],
                first = true;
            while (!this.eat(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(_tokenizerTypes.types.comma);
                if (allowTrailingComma && this.eat(close))
                  break;
              }
              elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
            }
            return elts;
          };
          pp.parseExprListItem = function(allowEmpty, refShorthandDefaultPos) {
            var elt = undefined;
            if (allowEmpty && this.match(_tokenizerTypes.types.comma)) {
              elt = null;
            } else if (this.match(_tokenizerTypes.types.ellipsis)) {
              elt = this.parseSpread(refShorthandDefaultPos);
            } else {
              elt = this.parseMaybeAssign(false, refShorthandDefaultPos);
            }
            return elt;
          };
          pp.parseIdent = function(liberal) {
            var node = this.startNode();
            if (this.match(_tokenizerTypes.types.name)) {
              if (!liberal && (!this.options.allowReserved && this.isReservedWord(this.state.value) || this.strict && _utilIdentifier.reservedWords.strict(this.state.value)))
                this.raise(this.state.start, "The keyword '" + this.state.value + "' is reserved");
              node.name = this.state.value;
            } else if (liberal && this.state.type.keyword) {
              node.name = this.state.type.keyword;
            } else {
              this.unexpected();
            }
            this.next();
            return this.finishNode(node, "Identifier");
          };
          pp.parseAwait = function(node) {
            if (this.eat(_tokenizerTypes.types.semi) || this.canInsertSemicolon()) {
              this.unexpected();
            }
            node.all = this.eat(_tokenizerTypes.types.star);
            node.argument = this.parseMaybeUnary();
            return this.finishNode(node, "AwaitExpression");
          };
          pp.parseYield = function() {
            var node = this.startNode();
            this.next();
            if (this.match(_tokenizerTypes.types.semi) || this.canInsertSemicolon() || !this.match(_tokenizerTypes.types.star) && !this.state.type.startsExpr) {
              node.delegate = false;
              node.argument = null;
            } else {
              node.delegate = this.eat(_tokenizerTypes.types.star);
              node.argument = this.parseMaybeAssign();
            }
            return this.finishNode(node, "YieldExpression");
          };
          pp.parseComprehension = function(node, isGenerator) {
            node.blocks = [];
            while (this.match(_tokenizerTypes.types._for)) {
              var block = this.startNode();
              this.next();
              this.expect(_tokenizerTypes.types.parenL);
              block.left = this.parseBindingAtom();
              this.checkLVal(block.left, true);
              this.expectContextual("of");
              block.right = this.parseExpression();
              this.expect(_tokenizerTypes.types.parenR);
              node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
            }
            node.filter = this.eat(_tokenizerTypes.types._if) ? this.parseParenExpression() : null;
            node.body = this.parseExpression();
            this.expect(isGenerator ? _tokenizerTypes.types.parenR : _tokenizerTypes.types.bracketR);
            node.generator = isGenerator;
            return this.finishNode(node, "ComprehensionExpression");
          };
        }, {
          "../tokenizer/types": 640,
          "../util/identifier": 641,
          "./index": 628
        }],
        628: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }});
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _utilIdentifier = require("../util/identifier");
          var _options = require("../options");
          var _tokenizer = require("../tokenizer");
          var _tokenizer2 = _interopRequireDefault(_tokenizer);
          var plugins = {};
          exports.plugins = plugins;
          var Parser = (function(_Tokenizer) {
            _inherits(Parser, _Tokenizer);
            function Parser(options, input) {
              _classCallCheck(this, Parser);
              _Tokenizer.call(this, input);
              this.options = _options.getOptions(options);
              this.isKeyword = _utilIdentifier.isKeyword;
              this.isReservedWord = _utilIdentifier.reservedWords[6];
              this.input = input;
              this.loadPlugins(this.options.plugins);
              this.inModule = this.options.sourceType === "module";
              this.strict = this.options.strictMode === false ? false : this.inModule;
              if (this.state.pos === 0 && this.input[0] === "#" && this.input[1] === "!") {
                this.skipLineComment(2);
              }
            }
            Parser.prototype.extend = function extend(name, f) {
              this[name] = f(this[name]);
            };
            Parser.prototype.loadPlugins = function loadPlugins(plugins) {
              for (var _name in plugins) {
                var plugin = exports.plugins[_name];
                if (!plugin)
                  throw new Error("Plugin '" + _name + "' not found");
                plugin(this, plugins[_name]);
              }
            };
            Parser.prototype.parse = function parse() {
              var file = this.startNode();
              var program = this.startNode();
              this.nextToken();
              return this.parseTopLevel(file, program);
            };
            return Parser;
          })(_tokenizer2["default"]);
          exports["default"] = Parser;
        }, {
          "../options": 625,
          "../tokenizer": 638,
          "../util/identifier": 641
        }],
        629: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _utilLocation = require("../util/location");
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          var pp = _index2["default"].prototype;
          pp.raise = function(pos, message) {
            var loc = _utilLocation.getLineInfo(this.input, pos);
            message += " (" + loc.line + ":" + loc.column + ")";
            var err = new SyntaxError(message);
            err.pos = pos;
            err.loc = loc;
            throw err;
          };
        }, {
          "../util/location": 642,
          "./index": 628
        }],
        630: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _tokenizerTypes = require("../tokenizer/types");
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          var _utilIdentifier = require("../util/identifier");
          var pp = _index2["default"].prototype;
          pp.toAssignable = function(node, isBinding) {
            if (node) {
              switch (node.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                  break;
                case "ObjectExpression":
                  node.type = "ObjectPattern";
                  var _arr = node.properties;
                  for (var _i = 0; _i < _arr.length; _i++) {
                    var prop = _arr[_i];
                    if (prop.type === "SpreadProperty")
                      continue;
                    if (prop.kind !== "init")
                      this.raise(prop.key.start, "Object pattern can't contain getter or setter");
                    this.toAssignable(prop.value, isBinding);
                  }
                  break;
                case "ArrayExpression":
                  node.type = "ArrayPattern";
                  this.toAssignableList(node.elements, isBinding);
                  break;
                case "AssignmentExpression":
                  if (node.operator === "=") {
                    node.type = "AssignmentPattern";
                    delete node.operator;
                  } else {
                    this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
                  }
                  break;
                case "MemberExpression":
                  if (!isBinding)
                    break;
                default:
                  this.raise(node.start, "Assigning to rvalue");
              }
            }
            return node;
          };
          pp.toAssignableList = function(exprList, isBinding) {
            var end = exprList.length;
            if (end) {
              var last = exprList[end - 1];
              if (last && last.type === "RestElement") {
                --end;
              } else if (last && last.type === "SpreadElement") {
                last.type = "RestElement";
                var arg = last.argument;
                this.toAssignable(arg, isBinding);
                if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
                  this.unexpected(arg.start);
                }
                --end;
              }
            }
            for (var i = 0; i < end; i++) {
              var elt = exprList[i];
              if (elt)
                this.toAssignable(elt, isBinding);
            }
            return exprList;
          };
          pp.toReferencedList = function(exprList) {
            return exprList;
          };
          pp.parseSpread = function(refShorthandDefaultPos) {
            var node = this.startNode();
            this.next();
            node.argument = this.parseMaybeAssign(refShorthandDefaultPos);
            return this.finishNode(node, "SpreadElement");
          };
          pp.parseRest = function() {
            var node = this.startNode();
            this.next();
            node.argument = this.match(_tokenizerTypes.types.name) || this.match(_tokenizerTypes.types.bracketL) ? this.parseBindingAtom() : this.unexpected();
            return this.finishNode(node, "RestElement");
          };
          pp.parseBindingAtom = function() {
            switch (this.state.type) {
              case _tokenizerTypes.types.name:
                return this.parseIdent();
              case _tokenizerTypes.types.bracketL:
                var node = this.startNode();
                this.next();
                node.elements = this.parseBindingList(_tokenizerTypes.types.bracketR, true, true);
                return this.finishNode(node, "ArrayPattern");
              case _tokenizerTypes.types.braceL:
                return this.parseObj(true);
              default:
                this.unexpected();
            }
          };
          pp.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
            var elts = [],
                first = true;
            while (!this.eat(close)) {
              if (first)
                first = false;
              else
                this.expect(_tokenizerTypes.types.comma);
              if (allowEmpty && this.match(_tokenizerTypes.types.comma)) {
                elts.push(null);
              } else if (allowTrailingComma && this.eat(close)) {
                break;
              } else if (this.match(_tokenizerTypes.types.ellipsis)) {
                elts.push(this.parseAssignableListItemTypes(this.parseRest()));
                this.expect(close);
                break;
              } else {
                var left = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(left);
                elts.push(this.parseMaybeDefault(null, null, left));
              }
            }
            return elts;
          };
          pp.parseAssignableListItemTypes = function(param) {
            return param;
          };
          pp.parseMaybeDefault = function(startPos, startLoc, left) {
            startLoc = startLoc || this.state.startLoc;
            startPos = startPos || this.state.start;
            left = left || this.parseBindingAtom();
            if (!this.eat(_tokenizerTypes.types.eq))
              return left;
            var node = this.startNodeAt(startPos, startLoc);
            node.left = left;
            node.right = this.parseMaybeAssign();
            return this.finishNode(node, "AssignmentPattern");
          };
          pp.checkLVal = function(expr, isBinding, checkClashes) {
            switch (expr.type) {
              case "Identifier":
                if (this.strict && (_utilIdentifier.reservedWords.strictBind(expr.name) || _utilIdentifier.reservedWords.strict(expr.name)))
                  this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
                if (checkClashes) {
                  if (checkClashes[expr.name]) {
                    this.raise(expr.start, "Argument name clash in strict mode");
                  } else {
                    checkClashes[expr.name] = true;
                  }
                }
                break;
              case "MemberExpression":
                if (isBinding)
                  this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
                break;
              case "ObjectPattern":
                var _arr2 = expr.properties;
                for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                  var prop = _arr2[_i2];
                  if (prop.type === "Property")
                    prop = prop.value;
                  this.checkLVal(prop, isBinding, checkClashes);
                }
                break;
              case "ArrayPattern":
                var _arr3 = expr.elements;
                for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                  var elem = _arr3[_i3];
                  if (elem)
                    this.checkLVal(elem, isBinding, checkClashes);
                }
                break;
              case "AssignmentPattern":
                this.checkLVal(expr.left, isBinding, checkClashes);
                break;
              case "SpreadProperty":
              case "RestElement":
                this.checkLVal(expr.argument, isBinding, checkClashes);
                break;
              default:
                this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
            }
          };
        }, {
          "../tokenizer/types": 640,
          "../util/identifier": 641,
          "./index": 628
        }],
        631: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          var _utilLocation = require("../util/location");
          var pp = _index2["default"].prototype;
          var Node = (function() {
            function Node(parser, pos, loc) {
              _classCallCheck(this, Node);
              this.type = "";
              this.start = pos;
              this.end = 0;
              this.loc = new _utilLocation.SourceLocation(loc);
            }
            Node.prototype.__clone = function __clone() {
              var node2 = new Node();
              for (var key in this)
                node2[key] = this[key];
              return node2;
            };
            return Node;
          })();
          exports.Node = Node;
          pp.startNode = function() {
            return new Node(this, this.state.start, this.state.startLoc);
          };
          pp.startNodeAt = function(pos, loc) {
            return new Node(this, pos, loc);
          };
          function finishNodeAt(node, type, pos, loc) {
            node.type = type;
            node.end = pos;
            node.loc.end = loc;
            this.processComment(node);
            return node;
          }
          pp.finishNode = function(node, type) {
            return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
          };
          pp.finishNodeAt = function(node, type, pos, loc) {
            return finishNodeAt.call(this, node, type, pos, loc);
          };
        }, {
          "../util/location": 642,
          "./index": 628
        }],
        632: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _tokenizerTypes = require("../tokenizer/types");
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          var _utilWhitespace = require("../util/whitespace");
          var pp = _index2["default"].prototype;
          pp.parseTopLevel = function(file, program) {
            program.sourceType = this.options.sourceType;
            program.body = [];
            var first = true;
            while (!this.match(_tokenizerTypes.types.eof)) {
              var stmt = this.parseStatement(true, true);
              program.body.push(stmt);
              if (first) {
                if (this.isUseStrict(stmt))
                  this.setStrict(true);
                first = false;
              }
            }
            this.next();
            file.program = this.finishNode(program, "Program");
            file.comments = this.state.comments;
            file.tokens = this.state.tokens;
            return this.finishNode(file, "File");
          };
          var loopLabel = {kind: "loop"},
              switchLabel = {kind: "switch"};
          pp.parseStatement = function(declaration, topLevel) {
            if (this.match(_tokenizerTypes.types.at)) {
              this.parseDecorators(true);
            }
            var starttype = this.state.type,
                node = this.startNode();
            switch (starttype) {
              case _tokenizerTypes.types._break:
              case _tokenizerTypes.types._continue:
                return this.parseBreakContinueStatement(node, starttype.keyword);
              case _tokenizerTypes.types._debugger:
                return this.parseDebuggerStatement(node);
              case _tokenizerTypes.types._do:
                return this.parseDoStatement(node);
              case _tokenizerTypes.types._for:
                return this.parseForStatement(node);
              case _tokenizerTypes.types._function:
                if (!declaration)
                  this.unexpected();
                return this.parseFunctionStatement(node);
              case _tokenizerTypes.types._class:
                if (!declaration)
                  this.unexpected();
                this.takeDecorators(node);
                return this.parseClass(node, true);
              case _tokenizerTypes.types._if:
                return this.parseIfStatement(node);
              case _tokenizerTypes.types._return:
                return this.parseReturnStatement(node);
              case _tokenizerTypes.types._switch:
                return this.parseSwitchStatement(node);
              case _tokenizerTypes.types._throw:
                return this.parseThrowStatement(node);
              case _tokenizerTypes.types._try:
                return this.parseTryStatement(node);
              case _tokenizerTypes.types._let:
              case _tokenizerTypes.types._const:
                if (!declaration)
                  this.unexpected();
              case _tokenizerTypes.types._var:
                return this.parseVarStatement(node, starttype);
              case _tokenizerTypes.types._while:
                return this.parseWhileStatement(node);
              case _tokenizerTypes.types._with:
                return this.parseWithStatement(node);
              case _tokenizerTypes.types.braceL:
                return this.parseBlock();
              case _tokenizerTypes.types.semi:
                return this.parseEmptyStatement(node);
              case _tokenizerTypes.types._export:
              case _tokenizerTypes.types._import:
                if (!this.options.allowImportExportEverywhere) {
                  if (!topLevel)
                    this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
                  if (!this.inModule)
                    this.raise(this.state.start, "'import' and 'export' may appear only with 'sourceType: module'");
                }
                return starttype === _tokenizerTypes.types._import ? this.parseImport(node) : this.parseExport(node);
              case _tokenizerTypes.types.name:
                if (this.options.features["es7.asyncFunctions"] && this.state.value === "async") {
                  var state = this.state.clone();
                  this.next();
                  if (this.match(_tokenizerTypes.types._function) && !this.canInsertSemicolon()) {
                    this.expect(_tokenizerTypes.types._function);
                    return this.parseFunction(node, true, false, true);
                  } else {
                    this.state = state;
                  }
                }
              default:
                var maybeName = this.state.value,
                    expr = this.parseExpression();
                if (starttype === _tokenizerTypes.types.name && expr.type === "Identifier" && this.eat(_tokenizerTypes.types.colon)) {
                  return this.parseLabeledStatement(node, maybeName, expr);
                } else {
                  return this.parseExpressionStatement(node, expr);
                }
            }
          };
          pp.takeDecorators = function(node) {
            if (this.state.decorators.length) {
              node.decorators = this.state.decorators;
              this.state.decorators = [];
            }
          };
          pp.parseDecorators = function(allowExport) {
            while (this.match(_tokenizerTypes.types.at)) {
              this.state.decorators.push(this.parseDecorator());
            }
            if (allowExport && this.match(_tokenizerTypes.types._export)) {
              return;
            }
            if (!this.match(_tokenizerTypes.types._class)) {
              this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
            }
          };
          pp.parseDecorator = function() {
            if (!this.options.features["es7.decorators"]) {
              this.unexpected();
            }
            var node = this.startNode();
            this.next();
            node.expression = this.parseMaybeAssign();
            return this.finishNode(node, "Decorator");
          };
          pp.parseBreakContinueStatement = function(node, keyword) {
            var isBreak = keyword === "break";
            this.next();
            if (this.eat(_tokenizerTypes.types.semi) || this.canInsertSemicolon()) {
              node.label = null;
            } else if (!this.match(_tokenizerTypes.types.name)) {
              this.unexpected();
            } else {
              node.label = this.parseIdent();
              this.semicolon();
            }
            for (var i = 0; i < this.state.labels.length; ++i) {
              var lab = this.state.labels[i];
              if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === "loop"))
                  break;
                if (node.label && isBreak)
                  break;
              }
            }
            if (i === this.state.labels.length)
              this.raise(node.start, "Unsyntactic " + keyword);
            return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
          };
          pp.parseDebuggerStatement = function(node) {
            this.next();
            this.semicolon();
            return this.finishNode(node, "DebuggerStatement");
          };
          pp.parseDoStatement = function(node) {
            this.next();
            this.state.labels.push(loopLabel);
            node.body = this.parseStatement(false);
            this.state.labels.pop();
            this.expect(_tokenizerTypes.types._while);
            node.test = this.parseParenExpression();
            this.eat(_tokenizerTypes.types.semi);
            return this.finishNode(node, "DoWhileStatement");
          };
          pp.parseForStatement = function(node) {
            this.next();
            this.state.labels.push(loopLabel);
            this.expect(_tokenizerTypes.types.parenL);
            if (this.match(_tokenizerTypes.types.semi)) {
              return this.parseFor(node, null);
            }
            if (this.match(_tokenizerTypes.types._var) || this.match(_tokenizerTypes.types._let) || this.match(_tokenizerTypes.types._const)) {
              var _init = this.startNode(),
                  varKind = this.state.type;
              this.next();
              this.parseVar(_init, true, varKind);
              this.finishNode(_init, "VariableDeclaration");
              if ((this.match(_tokenizerTypes.types._in) || this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokenizerTypes.types._var && _init.declarations[0].init))
                return this.parseForIn(node, _init);
              return this.parseFor(node, _init);
            }
            var refShorthandDefaultPos = {start: 0};
            var init = this.parseExpression(true, refShorthandDefaultPos);
            if (this.match(_tokenizerTypes.types._in) || this.isContextual("of")) {
              this.toAssignable(init);
              this.checkLVal(init);
              return this.parseForIn(node, init);
            } else if (refShorthandDefaultPos.start) {
              this.unexpected(refShorthandDefaultPos.start);
            }
            return this.parseFor(node, init);
          };
          pp.parseFunctionStatement = function(node) {
            this.next();
            return this.parseFunction(node, true);
          };
          pp.parseIfStatement = function(node) {
            this.next();
            node.test = this.parseParenExpression();
            node.consequent = this.parseStatement(false);
            node.alternate = this.eat(_tokenizerTypes.types._else) ? this.parseStatement(false) : null;
            return this.finishNode(node, "IfStatement");
          };
          pp.parseReturnStatement = function(node) {
            if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
              this.raise(this.state.start, "'return' outside of function");
            }
            this.next();
            if (this.eat(_tokenizerTypes.types.semi) || this.canInsertSemicolon()) {
              node.argument = null;
            } else {
              node.argument = this.parseExpression();
              this.semicolon();
            }
            return this.finishNode(node, "ReturnStatement");
          };
          pp.parseSwitchStatement = function(node) {
            this.next();
            node.discriminant = this.parseParenExpression();
            node.cases = [];
            this.expect(_tokenizerTypes.types.braceL);
            this.state.labels.push(switchLabel);
            for (var cur,
                sawDefault; !this.match(_tokenizerTypes.types.braceR); ) {
              if (this.match(_tokenizerTypes.types._case) || this.match(_tokenizerTypes.types._default)) {
                var isCase = this.match(_tokenizerTypes.types._case);
                if (cur)
                  this.finishNode(cur, "SwitchCase");
                node.cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                if (isCase) {
                  cur.test = this.parseExpression();
                } else {
                  if (sawDefault)
                    this.raise(this.state.lastTokStart, "Multiple default clauses");
                  sawDefault = true;
                  cur.test = null;
                }
                this.expect(_tokenizerTypes.types.colon);
              } else {
                if (!cur)
                  this.unexpected();
                cur.consequent.push(this.parseStatement(true));
              }
            }
            if (cur)
              this.finishNode(cur, "SwitchCase");
            this.next();
            this.state.labels.pop();
            return this.finishNode(node, "SwitchStatement");
          };
          pp.parseThrowStatement = function(node) {
            this.next();
            if (_utilWhitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start)))
              this.raise(this.state.lastTokEnd, "Illegal newline after throw");
            node.argument = this.parseExpression();
            this.semicolon();
            return this.finishNode(node, "ThrowStatement");
          };
          var empty = [];
          pp.parseTryStatement = function(node) {
            this.next();
            node.block = this.parseBlock();
            node.handler = null;
            if (this.match(_tokenizerTypes.types._catch)) {
              var clause = this.startNode();
              this.next();
              this.expect(_tokenizerTypes.types.parenL);
              clause.param = this.parseBindingAtom();
              this.checkLVal(clause.param, true);
              this.expect(_tokenizerTypes.types.parenR);
              clause.body = this.parseBlock();
              node.handler = this.finishNode(clause, "CatchClause");
            }
            node.guardedHandlers = empty;
            node.finalizer = this.eat(_tokenizerTypes.types._finally) ? this.parseBlock() : null;
            if (!node.handler && !node.finalizer) {
              this.raise(node.start, "Missing catch or finally clause");
            }
            return this.finishNode(node, "TryStatement");
          };
          pp.parseVarStatement = function(node, kind) {
            this.next();
            this.parseVar(node, false, kind);
            this.semicolon();
            return this.finishNode(node, "VariableDeclaration");
          };
          pp.parseWhileStatement = function(node) {
            this.next();
            node.test = this.parseParenExpression();
            this.state.labels.push(loopLabel);
            node.body = this.parseStatement(false);
            this.state.labels.pop();
            return this.finishNode(node, "WhileStatement");
          };
          pp.parseWithStatement = function(node) {
            if (this.strict)
              this.raise(this.state.start, "'with' in strict mode");
            this.next();
            node.object = this.parseParenExpression();
            node.body = this.parseStatement(false);
            return this.finishNode(node, "WithStatement");
          };
          pp.parseEmptyStatement = function(node) {
            this.next();
            return this.finishNode(node, "EmptyStatement");
          };
          pp.parseLabeledStatement = function(node, maybeName, expr) {
            var _arr = this.state.labels;
            for (var _i = 0; _i < _arr.length; _i++) {
              var label = _arr[_i];
              if (label.name === maybeName) {
                this.raise(expr.start, "Label '" + maybeName + "' is already declared");
              }
            }
            var kind = this.state.type.isLoop ? "loop" : this.match(_tokenizerTypes.types._switch) ? "switch" : null;
            for (var i = this.state.labels.length - 1; i >= 0; i--) {
              var label = this.state.labels[i];
              if (label.statementStart === node.start) {
                label.statementStart = this.state.start;
                label.kind = kind;
              } else {
                break;
              }
            }
            this.state.labels.push({
              name: maybeName,
              kind: kind,
              statementStart: this.state.start
            });
            node.body = this.parseStatement(true);
            this.state.labels.pop();
            node.label = expr;
            return this.finishNode(node, "LabeledStatement");
          };
          pp.parseExpressionStatement = function(node, expr) {
            node.expression = expr;
            this.semicolon();
            return this.finishNode(node, "ExpressionStatement");
          };
          pp.parseBlock = function(allowStrict) {
            var node = this.startNode(),
                first = true,
                oldStrict = undefined;
            node.body = [];
            this.expect(_tokenizerTypes.types.braceL);
            while (!this.eat(_tokenizerTypes.types.braceR)) {
              var stmt = this.parseStatement(true);
              node.body.push(stmt);
              if (first && allowStrict && this.isUseStrict(stmt)) {
                oldStrict = this.strict;
                this.setStrict(this.strict = true);
              }
              first = false;
            }
            if (oldStrict === false)
              this.setStrict(false);
            return this.finishNode(node, "BlockStatement");
          };
          pp.parseFor = function(node, init) {
            node.init = init;
            this.expect(_tokenizerTypes.types.semi);
            node.test = this.match(_tokenizerTypes.types.semi) ? null : this.parseExpression();
            this.expect(_tokenizerTypes.types.semi);
            node.update = this.match(_tokenizerTypes.types.parenR) ? null : this.parseExpression();
            this.expect(_tokenizerTypes.types.parenR);
            node.body = this.parseStatement(false);
            this.state.labels.pop();
            return this.finishNode(node, "ForStatement");
          };
          pp.parseForIn = function(node, init) {
            var type = this.match(_tokenizerTypes.types._in) ? "ForInStatement" : "ForOfStatement";
            this.next();
            node.left = init;
            node.right = this.parseExpression();
            this.expect(_tokenizerTypes.types.parenR);
            node.body = this.parseStatement(false);
            this.state.labels.pop();
            return this.finishNode(node, type);
          };
          pp.parseVar = function(node, isFor, kind) {
            node.declarations = [];
            node.kind = kind.keyword;
            for (; ; ) {
              var decl = this.startNode();
              this.parseVarHead(decl);
              if (this.eat(_tokenizerTypes.types.eq)) {
                decl.init = this.parseMaybeAssign(isFor);
              } else if (kind === _tokenizerTypes.types._const && !(this.match(_tokenizerTypes.types._in) || this.isContextual("of"))) {
                this.unexpected();
              } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(_tokenizerTypes.types._in) || this.isContextual("of")))) {
                this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
              } else {
                decl.init = null;
              }
              node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
              if (!this.eat(_tokenizerTypes.types.comma))
                break;
            }
            return node;
          };
          pp.parseVarHead = function(decl) {
            decl.id = this.parseBindingAtom();
            this.checkLVal(decl.id, true);
          };
          pp.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
            this.initFunction(node, isAsync);
            node.generator = this.eat(_tokenizerTypes.types.star);
            if (isStatement || this.match(_tokenizerTypes.types.name)) {
              node.id = this.parseIdent();
            }
            this.parseFunctionParams(node);
            this.parseFunctionBody(node, allowExpressionBody);
            return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
          };
          pp.parseFunctionParams = function(node) {
            this.expect(_tokenizerTypes.types.parenL);
            node.params = this.parseBindingList(_tokenizerTypes.types.parenR, false, this.options.features["es7.trailingFunctionCommas"]);
          };
          pp.parseClass = function(node, isStatement) {
            this.next();
            this.parseClassId(node, isStatement);
            this.parseClassSuper(node);
            var classBody = this.startNode();
            var hadConstructor = false;
            classBody.body = [];
            this.expect(_tokenizerTypes.types.braceL);
            var decorators = [];
            while (!this.eat(_tokenizerTypes.types.braceR)) {
              if (this.eat(_tokenizerTypes.types.semi))
                continue;
              if (this.match(_tokenizerTypes.types.at)) {
                decorators.push(this.parseDecorator());
                continue;
              }
              var method = this.startNode();
              if (decorators.length) {
                method.decorators = decorators;
                decorators = [];
              }
              var isMaybeStatic = this.match(_tokenizerTypes.types.name) && this.state.value === "static";
              var isGenerator = this.eat(_tokenizerTypes.types.star),
                  isAsync = false;
              this.parsePropertyName(method);
              method["static"] = isMaybeStatic && !this.match(_tokenizerTypes.types.parenL);
              if (method["static"]) {
                if (isGenerator)
                  this.unexpected();
                isGenerator = this.eat(_tokenizerTypes.types.star);
                this.parsePropertyName(method);
              }
              if (!isGenerator && method.key.type === "Identifier" && !method.computed && this.isClassProperty()) {
                classBody.body.push(this.parseClassProperty(method));
                continue;
              }
              if (this.options.features["es7.asyncFunctions"] && !this.match(_tokenizerTypes.types.parenL) && !method.computed && method.key.type === "Identifier" && method.key.name === "async") {
                isAsync = true;
                this.parsePropertyName(method);
              }
              var isGetSet = false;
              method.kind = "method";
              if (!method.computed) {
                var key = method.key;
                if (!isAsync && !isGenerator && key.type === "Identifier" && !this.match(_tokenizerTypes.types.parenL) && (key.name === "get" || key.name === "set")) {
                  isGetSet = true;
                  method.kind = key.name;
                  key = this.parsePropertyName(method);
                }
                if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
                  if (hadConstructor)
                    this.raise(key.start, "Duplicate constructor in the same class");
                  if (isGetSet)
                    this.raise(key.start, "Constructor can't have get/set modifier");
                  if (isGenerator)
                    this.raise(key.start, "Constructor can't be a generator");
                  if (isAsync)
                    this.raise(key.start, "Constructor can't be an async function");
                  method.kind = "constructor";
                  hadConstructor = true;
                }
              }
              if (method.kind === "constructor" && method.decorators) {
                this.raise(method.start, "You can't attach decorators to a class constructor");
              }
              this.parseClassMethod(classBody, method, isGenerator, isAsync);
              if (isGetSet) {
                var paramCount = method.kind === "get" ? 0 : 1;
                if (method.value.params.length !== paramCount) {
                  var start = method.value.start;
                  if (method.kind === "get") {
                    this.raise(start, "getter should have no params");
                  } else {
                    this.raise(start, "setter should have exactly one param");
                  }
                }
              }
            }
            if (decorators.length) {
              this.raise(this.state.start, "You have trailing decorators with no method");
            }
            node.body = this.finishNode(classBody, "ClassBody");
            return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
          };
          pp.isClassProperty = function() {
            return this.match(_tokenizerTypes.types.eq) || (this.match(_tokenizerTypes.types.semi) || this.canInsertSemicolon());
          };
          pp.parseClassProperty = function(node) {
            if (this.match(_tokenizerTypes.types.eq)) {
              if (!this.options.features["es7.classProperties"])
                this.unexpected();
              this.next();
              node.value = this.parseMaybeAssign();
            } else {
              node.value = null;
            }
            this.semicolon();
            return this.finishNode(node, "ClassProperty");
          };
          pp.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
            method.value = this.parseMethod(isGenerator, isAsync);
            classBody.body.push(this.finishNode(method, "MethodDefinition"));
          };
          pp.parseClassId = function(node, isStatement) {
            node.id = this.match(_tokenizerTypes.types.name) ? this.parseIdent() : isStatement ? this.unexpected() : null;
          };
          pp.parseClassSuper = function(node) {
            node.superClass = this.eat(_tokenizerTypes.types._extends) ? this.parseExprSubscripts() : null;
          };
          pp.parseExport = function(node) {
            this.next();
            if (this.match(_tokenizerTypes.types.star)) {
              var specifier = this.startNode();
              this.next();
              if (this.options.features["es7.exportExtensions"] && this.eatContextual("as")) {
                specifier.exported = this.parseIdent();
                node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
                this.parseExportSpecifiersMaybe(node);
                this.parseExportFrom(node, true);
              } else {
                this.parseExportFrom(node, true);
                return this.finishNode(node, "ExportAllDeclaration");
              }
            } else if (this.options.features["es7.exportExtensions"] && this.isExportDefaultSpecifier()) {
              var specifier = this.startNode();
              specifier.exported = this.parseIdent(true);
              node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
              if (this.match(_tokenizerTypes.types.comma) && this.lookahead().type === _tokenizerTypes.types.star) {
                this.expect(_tokenizerTypes.types.comma);
                var _specifier = this.startNode();
                this.expect(_tokenizerTypes.types.star);
                this.expectContextual("as");
                _specifier.exported = this.parseIdent();
                node.specifiers.push(this.finishNode(_specifier, "ExportNamespaceSpecifier"));
              } else {
                this.parseExportSpecifiersMaybe(node);
              }
              this.parseExportFrom(node, true);
            } else if (this.eat(_tokenizerTypes.types._default)) {
              var possibleDeclaration = this.match(_tokenizerTypes.types._function) || this.match(_tokenizerTypes.types._class);
              var expr = this.parseMaybeAssign();
              var needsSemi = true;
              if (possibleDeclaration) {
                needsSemi = false;
                if (expr.id) {
                  expr.type = expr.type === "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
                }
              }
              node.declaration = expr;
              if (needsSemi)
                this.semicolon();
              this.checkExport(node);
              return this.finishNode(node, "ExportDefaultDeclaration");
            } else if (this.state.type.keyword || this.shouldParseExportDeclaration()) {
              node.specifiers = [];
              node.source = null;
              node.declaration = this.parseExportDeclaration(node);
            } else {
              node.declaration = null;
              node.specifiers = this.parseExportSpecifiers();
              this.parseExportFrom(node);
            }
            this.checkExport(node);
            return this.finishNode(node, "ExportNamedDeclaration");
          };
          pp.parseExportDeclaration = function() {
            return this.parseStatement(true);
          };
          pp.isExportDefaultSpecifier = function() {
            if (this.match(_tokenizerTypes.types.name)) {
              return this.state.value !== "type" && this.state.value !== "async";
            }
            if (!this.match(_tokenizerTypes.types._default)) {
              return false;
            }
            var lookahead = this.lookahead();
            return lookahead.type === _tokenizerTypes.types.comma || lookahead.type === _tokenizerTypes.types.name && lookahead.value === "from";
          };
          pp.parseExportSpecifiersMaybe = function(node) {
            if (this.eat(_tokenizerTypes.types.comma)) {
              node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
            }
          };
          pp.parseExportFrom = function(node, expect) {
            if (this.eatContextual("from")) {
              node.source = this.match(_tokenizerTypes.types.string) ? this.parseExprAtom() : this.unexpected();
              this.checkExport(node);
            } else {
              if (expect) {
                this.unexpected();
              } else {
                node.source = null;
              }
            }
            this.semicolon();
          };
          pp.shouldParseExportDeclaration = function() {
            return this.options.features["es7.asyncFunctions"] && this.isContextual("async");
          };
          pp.checkExport = function(node) {
            if (this.state.decorators.length) {
              var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
              if (!node.declaration || !isClass) {
                this.raise(node.start, "You can only use decorators on an export when exporting a class");
              }
              this.takeDecorators(node.declaration);
            }
          };
          pp.parseExportSpecifiers = function() {
            var nodes = [],
                first = true;
            this.expect(_tokenizerTypes.types.braceL);
            while (!this.eat(_tokenizerTypes.types.braceR)) {
              if (first) {
                first = false;
              } else {
                this.expect(_tokenizerTypes.types.comma);
                if (this.eat(_tokenizerTypes.types.braceR))
                  break;
              }
              var node = this.startNode();
              node.local = this.parseIdent(this.match(_tokenizerTypes.types._default));
              node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local.__clone();
              nodes.push(this.finishNode(node, "ExportSpecifier"));
            }
            return nodes;
          };
          pp.parseImport = function(node) {
            this.next();
            if (this.match(_tokenizerTypes.types.string)) {
              node.specifiers = [];
              node.source = this.parseExprAtom();
            } else {
              node.specifiers = [];
              this.parseImportSpecifiers(node);
              this.expectContextual("from");
              node.source = this.match(_tokenizerTypes.types.string) ? this.parseExprAtom() : this.unexpected();
            }
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          };
          pp.parseImportSpecifiers = function(node) {
            var first = true;
            if (this.match(_tokenizerTypes.types.name)) {
              var startPos = this.state.start,
                  startLoc = this.state.startLoc;
              node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdent(), startPos, startLoc));
              if (!this.eat(_tokenizerTypes.types.comma))
                return;
            }
            if (this.match(_tokenizerTypes.types.star)) {
              var specifier = this.startNode();
              this.next();
              this.expectContextual("as");
              specifier.local = this.parseIdent();
              this.checkLVal(specifier.local, true);
              node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
              return;
            }
            this.expect(_tokenizerTypes.types.braceL);
            while (!this.eat(_tokenizerTypes.types.braceR)) {
              if (first) {
                first = false;
              } else {
                this.expect(_tokenizerTypes.types.comma);
                if (this.eat(_tokenizerTypes.types.braceR))
                  break;
              }
              var specifier = this.startNode();
              specifier.imported = this.parseIdent(true);
              specifier.local = this.eatContextual("as") ? this.parseIdent() : specifier.imported.__clone();
              this.checkLVal(specifier.local, true);
              node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
            }
          };
          pp.parseImportSpecifierDefault = function(id, startPos, startLoc) {
            var node = this.startNodeAt(startPos, startLoc);
            node.local = id;
            this.checkLVal(node.local, true);
            return this.finishNode(node, "ImportDefaultSpecifier");
          };
        }, {
          "../tokenizer/types": 640,
          "../util/whitespace": 643,
          "./index": 628
        }],
        633: [function(require, module, exports) {
          "use strict";
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _tokenizerTypes = require("../tokenizer/types");
          var _index = require("./index");
          var _index2 = _interopRequireDefault(_index);
          var _utilWhitespace = require("../util/whitespace");
          var pp = _index2["default"].prototype;
          pp.isUseStrict = function(stmt) {
            return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
          };
          pp.isRelational = function(op) {
            return this.match(_tokenizerTypes.types.relational) && this.state.value === op;
          };
          pp.expectRelational = function(op) {
            if (this.isRelational(op)) {
              this.next();
            } else {
              this.unexpected();
            }
          };
          pp.isContextual = function(name) {
            return this.match(_tokenizerTypes.types.name) && this.state.value === name;
          };
          pp.eatContextual = function(name) {
            return this.state.value === name && this.eat(_tokenizerTypes.types.name);
          };
          pp.expectContextual = function(name) {
            if (!this.eatContextual(name))
              this.unexpected();
          };
          pp.canInsertSemicolon = function() {
            return this.match(_tokenizerTypes.types.eof) || this.match(_tokenizerTypes.types.braceR) || _utilWhitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
          };
          pp.semicolon = function() {
            if (!this.eat(_tokenizerTypes.types.semi) && !this.canInsertSemicolon())
              this.unexpected();
          };
          pp.expect = function(type) {
            return this.eat(type) || this.unexpected();
          };
          pp.unexpected = function(pos) {
            this.raise(pos != null ? pos : this.state.start, "Unexpected token");
          };
        }, {
          "../tokenizer/types": 640,
          "../util/whitespace": 643,
          "./index": 628
        }],
        634: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _tokenizerTypes = require("../tokenizer/types");
          var _parser = require("../parser");
          var _parser2 = _interopRequireDefault(_parser);
          var pp = _parser2["default"].prototype;
          pp.flowParseTypeInitialiser = function(tok) {
            var oldInType = this.state.inType;
            this.state.inType = true;
            this.expect(tok || _tokenizerTypes.types.colon);
            var type = this.flowParseType();
            this.state.inType = oldInType;
            return type;
          };
          pp.flowParseDeclareClass = function(node) {
            this.next();
            this.flowParseInterfaceish(node, true);
            return this.finishNode(node, "DeclareClass");
          };
          pp.flowParseDeclareFunction = function(node) {
            this.next();
            var id = node.id = this.parseIdent();
            var typeNode = this.startNode();
            var typeContainer = this.startNode();
            if (this.isRelational("<")) {
              typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              typeNode.typeParameters = null;
            }
            this.expect(_tokenizerTypes.types.parenL);
            var tmp = this.flowParseFunctionTypeParams();
            typeNode.params = tmp.params;
            typeNode.rest = tmp.rest;
            this.expect(_tokenizerTypes.types.parenR);
            typeNode.returnType = this.flowParseTypeInitialiser();
            typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
            id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
            this.finishNode(id, id.type);
            this.semicolon();
            return this.finishNode(node, "DeclareFunction");
          };
          pp.flowParseDeclare = function(node) {
            if (this.match(_tokenizerTypes.types._class)) {
              return this.flowParseDeclareClass(node);
            } else if (this.match(_tokenizerTypes.types._function)) {
              return this.flowParseDeclareFunction(node);
            } else if (this.match(_tokenizerTypes.types._var)) {
              return this.flowParseDeclareVariable(node);
            } else if (this.isContextual("module")) {
              return this.flowParseDeclareModule(node);
            } else {
              this.unexpected();
            }
          };
          pp.flowParseDeclareVariable = function(node) {
            this.next();
            node.id = this.flowParseTypeAnnotatableIdentifier();
            this.semicolon();
            return this.finishNode(node, "DeclareVariable");
          };
          pp.flowParseDeclareModule = function(node) {
            this.next();
            if (this.match(_tokenizerTypes.types.string)) {
              node.id = this.parseExprAtom();
            } else {
              node.id = this.parseIdent();
            }
            var bodyNode = node.body = this.startNode();
            var body = bodyNode.body = [];
            this.expect(_tokenizerTypes.types.braceL);
            while (!this.match(_tokenizerTypes.types.braceR)) {
              var node2 = this.startNode();
              this.next();
              body.push(this.flowParseDeclare(node2));
            }
            this.expect(_tokenizerTypes.types.braceR);
            this.finishNode(bodyNode, "BlockStatement");
            return this.finishNode(node, "DeclareModule");
          };
          pp.flowParseInterfaceish = function(node, allowStatic) {
            node.id = this.parseIdent();
            if (this.isRelational("<")) {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              node.typeParameters = null;
            }
            node["extends"] = [];
            if (this.eat(_tokenizerTypes.types._extends)) {
              do {
                node["extends"].push(this.flowParseInterfaceExtends());
              } while (this.eat(_tokenizerTypes.types.comma));
            }
            node.body = this.flowParseObjectType(allowStatic);
          };
          pp.flowParseInterfaceExtends = function() {
            var node = this.startNode();
            node.id = this.parseIdent();
            if (this.isRelational("<")) {
              node.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node.typeParameters = null;
            }
            return this.finishNode(node, "InterfaceExtends");
          };
          pp.flowParseInterface = function(node) {
            this.flowParseInterfaceish(node, false);
            return this.finishNode(node, "InterfaceDeclaration");
          };
          pp.flowParseTypeAlias = function(node) {
            node.id = this.parseIdent();
            if (this.isRelational("<")) {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
            } else {
              node.typeParameters = null;
            }
            node.right = this.flowParseTypeInitialiser(_tokenizerTypes.types.eq);
            this.semicolon();
            return this.finishNode(node, "TypeAlias");
          };
          pp.flowParseTypeParameterDeclaration = function() {
            var node = this.startNode();
            node.params = [];
            this.expectRelational("<");
            while (!this.isRelational(">")) {
              node.params.push(this.flowParseTypeAnnotatableIdentifier());
              if (!this.isRelational(">")) {
                this.expect(_tokenizerTypes.types.comma);
              }
            }
            this.expectRelational(">");
            return this.finishNode(node, "TypeParameterDeclaration");
          };
          pp.flowParseTypeParameterInstantiation = function() {
            var node = this.startNode(),
                oldInType = this.state.inType;
            node.params = [];
            this.state.inType = true;
            this.expectRelational("<");
            while (!this.isRelational(">")) {
              node.params.push(this.flowParseType());
              if (!this.isRelational(">")) {
                this.expect(_tokenizerTypes.types.comma);
              }
            }
            this.expectRelational(">");
            this.state.inType = oldInType;
            return this.finishNode(node, "TypeParameterInstantiation");
          };
          pp.flowParseObjectPropertyKey = function() {
            return this.match(_tokenizerTypes.types.num) || this.match(_tokenizerTypes.types.string) ? this.parseExprAtom() : this.parseIdent(true);
          };
          pp.flowParseObjectTypeIndexer = function(node, isStatic) {
            node["static"] = isStatic;
            this.expect(_tokenizerTypes.types.bracketL);
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
            this.expect(_tokenizerTypes.types.bracketR);
            node.value = this.flowParseTypeInitialiser();
            this.flowObjectTypeSemicolon();
            return this.finishNode(node, "ObjectTypeIndexer");
          };
          pp.flowParseObjectTypeMethodish = function(node) {
            node.params = [];
            node.rest = null;
            node.typeParameters = null;
            if (this.isRelational("<")) {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
            }
            this.expect(_tokenizerTypes.types.parenL);
            while (this.match(_tokenizerTypes.types.name)) {
              node.params.push(this.flowParseFunctionTypeParam());
              if (!this.match(_tokenizerTypes.types.parenR)) {
                this.expect(_tokenizerTypes.types.comma);
              }
            }
            if (this.eat(_tokenizerTypes.types.ellipsis)) {
              node.rest = this.flowParseFunctionTypeParam();
            }
            this.expect(_tokenizerTypes.types.parenR);
            node.returnType = this.flowParseTypeInitialiser();
            return this.finishNode(node, "FunctionTypeAnnotation");
          };
          pp.flowParseObjectTypeMethod = function(startPos, startLoc, isStatic, key) {
            var node = this.startNodeAt(startPos, startLoc);
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
            node["static"] = isStatic;
            node.key = key;
            node.optional = false;
            this.flowObjectTypeSemicolon();
            return this.finishNode(node, "ObjectTypeProperty");
          };
          pp.flowParseObjectTypeCallProperty = function(node, isStatic) {
            var valueNode = this.startNode();
            node["static"] = isStatic;
            node.value = this.flowParseObjectTypeMethodish(valueNode);
            this.flowObjectTypeSemicolon();
            return this.finishNode(node, "ObjectTypeCallProperty");
          };
          pp.flowParseObjectType = function(allowStatic) {
            var nodeStart = this.startNode();
            var node;
            var propertyKey;
            var isStatic;
            nodeStart.callProperties = [];
            nodeStart.properties = [];
            nodeStart.indexers = [];
            this.expect(_tokenizerTypes.types.braceL);
            while (!this.match(_tokenizerTypes.types.braceR)) {
              var optional = false;
              var startPos = this.state.start,
                  startLoc = this.state.startLoc;
              node = this.startNode();
              if (allowStatic && this.isContextual("static")) {
                this.next();
                isStatic = true;
              }
              if (this.match(_tokenizerTypes.types.bracketL)) {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic));
              } else if (this.match(_tokenizerTypes.types.parenL) || this.isRelational("<")) {
                nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, allowStatic));
              } else {
                if (isStatic && this.match(_tokenizerTypes.types.colon)) {
                  propertyKey = this.parseIdent();
                } else {
                  propertyKey = this.flowParseObjectPropertyKey();
                }
                if (this.isRelational("<") || this.match(_tokenizerTypes.types.parenL)) {
                  nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
                } else {
                  if (this.eat(_tokenizerTypes.types.question)) {
                    optional = true;
                  }
                  node.key = propertyKey;
                  node.value = this.flowParseTypeInitialiser();
                  node.optional = optional;
                  node["static"] = isStatic;
                  this.flowObjectTypeSemicolon();
                  nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
                }
              }
            }
            this.expect(_tokenizerTypes.types.braceR);
            return this.finishNode(nodeStart, "ObjectTypeAnnotation");
          };
          pp.flowObjectTypeSemicolon = function() {
            if (!this.eat(_tokenizerTypes.types.semi) && !this.eat(_tokenizerTypes.types.comma) && !this.match(_tokenizerTypes.types.braceR)) {
              this.unexpected();
            }
          };
          pp.flowParseGenericType = function(startPos, startLoc, id) {
            var node = this.startNodeAt(startPos, startLoc);
            node.typeParameters = null;
            node.id = id;
            while (this.eat(_tokenizerTypes.types.dot)) {
              var node2 = this.startNodeAt(startPos, startLoc);
              node2.qualification = node.id;
              node2.id = this.parseIdent();
              node.id = this.finishNode(node2, "QualifiedTypeIdentifier");
            }
            if (this.isRelational("<")) {
              node.typeParameters = this.flowParseTypeParameterInstantiation();
            }
            return this.finishNode(node, "GenericTypeAnnotation");
          };
          pp.flowParseTypeofType = function() {
            var node = this.startNode();
            this.expect(_tokenizerTypes.types._typeof);
            node.argument = this.flowParsePrimaryType();
            return this.finishNode(node, "TypeofTypeAnnotation");
          };
          pp.flowParseTupleType = function() {
            var node = this.startNode();
            node.types = [];
            this.expect(_tokenizerTypes.types.bracketL);
            while (this.state.pos < this.input.length && !this.match(_tokenizerTypes.types.bracketR)) {
              node.types.push(this.flowParseType());
              if (this.match(_tokenizerTypes.types.bracketR))
                break;
              this.expect(_tokenizerTypes.types.comma);
            }
            this.expect(_tokenizerTypes.types.bracketR);
            return this.finishNode(node, "TupleTypeAnnotation");
          };
          pp.flowParseFunctionTypeParam = function() {
            var optional = false;
            var node = this.startNode();
            node.name = this.parseIdent();
            if (this.eat(_tokenizerTypes.types.question)) {
              optional = true;
            }
            node.optional = optional;
            node.typeAnnotation = this.flowParseTypeInitialiser();
            return this.finishNode(node, "FunctionTypeParam");
          };
          pp.flowParseFunctionTypeParams = function() {
            var ret = {
              params: [],
              rest: null
            };
            while (this.match(_tokenizerTypes.types.name)) {
              ret.params.push(this.flowParseFunctionTypeParam());
              if (!this.match(_tokenizerTypes.types.parenR)) {
                this.expect(_tokenizerTypes.types.comma);
              }
            }
            if (this.eat(_tokenizerTypes.types.ellipsis)) {
              ret.rest = this.flowParseFunctionTypeParam();
            }
            return ret;
          };
          pp.flowIdentToTypeAnnotation = function(startPos, startLoc, node, id) {
            switch (id.name) {
              case "any":
                return this.finishNode(node, "AnyTypeAnnotation");
              case "void":
                return this.finishNode(node, "VoidTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(node, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(node, "MixedTypeAnnotation");
              case "number":
                return this.finishNode(node, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(node, "StringTypeAnnotation");
              default:
                return this.flowParseGenericType(startPos, startLoc, id);
            }
          };
          pp.flowParsePrimaryType = function() {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            var node = this.startNode();
            var tmp;
            var type;
            var isGroupedType = false;
            switch (this.state.type) {
              case _tokenizerTypes.types.name:
                return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdent());
              case _tokenizerTypes.types.braceL:
                return this.flowParseObjectType();
              case _tokenizerTypes.types.bracketL:
                return this.flowParseTupleType();
              case _tokenizerTypes.types.relational:
                if (this.state.value === "<") {
                  node.typeParameters = this.flowParseTypeParameterDeclaration();
                  this.expect(_tokenizerTypes.types.parenL);
                  tmp = this.flowParseFunctionTypeParams();
                  node.params = tmp.params;
                  node.rest = tmp.rest;
                  this.expect(_tokenizerTypes.types.parenR);
                  this.expect(_tokenizerTypes.types.arrow);
                  node.returnType = this.flowParseType();
                  return this.finishNode(node, "FunctionTypeAnnotation");
                }
              case _tokenizerTypes.types.parenL:
                this.next();
                if (!this.match(_tokenizerTypes.types.parenR) && !this.match(_tokenizerTypes.types.ellipsis)) {
                  if (this.match(_tokenizerTypes.types.name)) {
                    var token = this.lookahead().type;
                    isGroupedType = token !== _tokenizerTypes.types.question && token !== _tokenizerTypes.types.colon;
                  } else {
                    isGroupedType = true;
                  }
                }
                if (isGroupedType) {
                  type = this.flowParseType();
                  this.expect(_tokenizerTypes.types.parenR);
                  if (this.eat(_tokenizerTypes.types.arrow)) {
                    this.raise(node, "Unexpected token =>. It looks like " + "you are trying to write a function type, but you ended up " + "writing a grouped type followed by an =>, which is a syntax " + "error. Remember, function type parameters are named so function " + "types look like (name1: type1, name2: type2) => returnType. You " + "probably wrote (type1) => returnType");
                  }
                  return type;
                }
                tmp = this.flowParseFunctionTypeParams();
                node.params = tmp.params;
                node.rest = tmp.rest;
                this.expect(_tokenizerTypes.types.parenR);
                this.expect(_tokenizerTypes.types.arrow);
                node.returnType = this.flowParseType();
                node.typeParameters = null;
                return this.finishNode(node, "FunctionTypeAnnotation");
              case _tokenizerTypes.types.string:
                node.rawValue = node.value = this.state.value;
                node.raw = this.input.slice(this.state.start, this.state.end);
                this.next();
                return this.finishNode(node, "StringLiteralTypeAnnotation");
              case _tokenizerTypes.types._true:
              case _tokenizerTypes.types._false:
                node.value = this.match(_tokenizerTypes.types._true);
                this.next();
                return this.finishNode(node, "BooleanLiteralTypeAnnotation");
              case _tokenizerTypes.types.num:
                node.rawValue = node.value = this.state.value;
                node.raw = this.input.slice(this.state.start, this.state.end);
                this.next();
                return this.finishNode(node, "NumberLiteralTypeAnnotation");
              default:
                if (this.state.type.keyword === "typeof") {
                  return this.flowParseTypeofType();
                }
            }
            this.unexpected();
          };
          pp.flowParsePostfixType = function() {
            var node = this.startNode();
            var type = node.elementType = this.flowParsePrimaryType();
            if (this.match(_tokenizerTypes.types.bracketL)) {
              this.expect(_tokenizerTypes.types.bracketL);
              this.expect(_tokenizerTypes.types.bracketR);
              return this.finishNode(node, "ArrayTypeAnnotation");
            } else {
              return type;
            }
          };
          pp.flowParsePrefixType = function() {
            var node = this.startNode();
            if (this.eat(_tokenizerTypes.types.question)) {
              node.typeAnnotation = this.flowParsePrefixType();
              return this.finishNode(node, "NullableTypeAnnotation");
            } else {
              return this.flowParsePostfixType();
            }
          };
          pp.flowParseIntersectionType = function() {
            var node = this.startNode();
            var type = this.flowParsePrefixType();
            node.types = [type];
            while (this.eat(_tokenizerTypes.types.bitwiseAND)) {
              node.types.push(this.flowParsePrefixType());
            }
            return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
          };
          pp.flowParseUnionType = function() {
            var node = this.startNode();
            var type = this.flowParseIntersectionType();
            node.types = [type];
            while (this.eat(_tokenizerTypes.types.bitwiseOR)) {
              node.types.push(this.flowParseIntersectionType());
            }
            return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
          };
          pp.flowParseType = function() {
            var oldInType = this.state.inType;
            this.state.inType = true;
            var type = this.flowParseUnionType();
            this.state.inType = oldInType;
            return type;
          };
          pp.flowParseTypeAnnotation = function() {
            var node = this.startNode();
            node.typeAnnotation = this.flowParseTypeInitialiser();
            return this.finishNode(node, "TypeAnnotation");
          };
          pp.flowParseTypeAnnotatableIdentifier = function(requireTypeAnnotation, canBeOptionalParam) {
            var ident = this.parseIdent();
            var isOptionalParam = false;
            if (canBeOptionalParam && this.eat(_tokenizerTypes.types.question)) {
              this.expect(_tokenizerTypes.types.question);
              isOptionalParam = true;
            }
            if (requireTypeAnnotation || this.match(_tokenizerTypes.types.colon)) {
              ident.typeAnnotation = this.flowParseTypeAnnotation();
              this.finishNode(ident, ident.type);
            }
            if (isOptionalParam) {
              ident.optional = true;
              this.finishNode(ident, ident.type);
            }
            return ident;
          };
          exports["default"] = function(instance) {
            instance.extend("parseFunctionBody", function(inner) {
              return function(node, allowExpression) {
                if (this.match(_tokenizerTypes.types.colon) && !allowExpression) {
                  node.returnType = this.flowParseTypeAnnotation();
                }
                return inner.call(this, node, allowExpression);
              };
            });
            instance.extend("parseStatement", function(inner) {
              return function(declaration, topLevel) {
                if (this.strict && this.match(_tokenizerTypes.types.name) && this.state.value === "interface") {
                  var node = this.startNode();
                  this.next();
                  return this.flowParseInterface(node);
                } else {
                  return inner.call(this, declaration, topLevel);
                }
              };
            });
            instance.extend("parseExpressionStatement", function(inner) {
              return function(node, expr) {
                if (expr.type === "Identifier") {
                  if (expr.name === "declare") {
                    if (this.match(_tokenizerTypes.types._class) || this.match(_tokenizerTypes.types.name) || this.match(_tokenizerTypes.types._function) || this.match(_tokenizerTypes.types._var)) {
                      return this.flowParseDeclare(node);
                    }
                  } else if (this.match(_tokenizerTypes.types.name)) {
                    if (expr.name === "interface") {
                      return this.flowParseInterface(node);
                    } else if (expr.name === "type") {
                      return this.flowParseTypeAlias(node);
                    }
                  }
                }
                return inner.call(this, node, expr);
              };
            });
            instance.extend("shouldParseExportDeclaration", function(inner) {
              return function() {
                return this.isContextual("type") || inner.call(this);
              };
            });
            instance.extend("parseParenItem", function() {
              return function(node, startLoc, startPos, forceArrow) {
                if (this.match(_tokenizerTypes.types.colon)) {
                  var typeCastNode = this.startNodeAt(startLoc, startPos);
                  typeCastNode.expression = node;
                  typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
                  if (forceArrow && !this.match(_tokenizerTypes.types.arrow)) {
                    this.unexpected();
                  }
                  if (this.eat(_tokenizerTypes.types.arrow)) {
                    var func = this.parseArrowExpression(this.startNodeAt(startLoc, startPos), [node]);
                    func.returnType = typeCastNode.typeAnnotation;
                    return func;
                  } else {
                    return this.finishNode(typeCastNode, "TypeCastExpression");
                  }
                } else {
                  return node;
                }
              };
            });
            instance.extend("parseExport", function(inner) {
              return function(node) {
                node = inner.call(this, node);
                if (node.type === "ExportNamedDeclaration") {
                  node.exportKind = node.exportKind || "value";
                }
                return node;
              };
            });
            instance.extend("parseExportDeclaration", function(inner) {
              return function(node) {
                if (this.isContextual("type")) {
                  node.exportKind = "type";
                  var declarationNode = this.startNode();
                  this.next();
                  if (this.match(_tokenizerTypes.types.braceL)) {
                    node.specifiers = this.parseExportSpecifiers();
                    this.parseExportFrom(node);
                    return null;
                  } else {
                    return this.flowParseTypeAlias(declarationNode);
                  }
                } else {
                  return inner.call(this, node);
                }
              };
            });
            instance.extend("parseClassId", function(inner) {
              return function(node, isStatement) {
                inner.call(this, node, isStatement);
                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration();
                }
              };
            });
            instance.extend("isKeyword", function(inner) {
              return function(name) {
                if (this.state.inType && name === "void") {
                  return false;
                } else {
                  return inner.call(this, name);
                }
              };
            });
            instance.extend("readToken", function(inner) {
              return function(code) {
                if (this.state.inType && (code === 62 || code === 60)) {
                  return this.finishOp(_tokenizerTypes.types.relational, 1);
                } else {
                  return inner.call(this, code);
                }
              };
            });
            instance.extend("jsx_readToken", function(inner) {
              return function() {
                if (!this.state.inType)
                  return inner.call(this);
              };
            });
            function typeCastToParameter(node) {
              node.expression.typeAnnotation = node.typeAnnotation;
              return node.expression;
            }
            instance.extend("toAssignableList", function(inner) {
              return function(exprList, isBinding) {
                for (var i = 0; i < exprList.length; i++) {
                  var expr = exprList[i];
                  if (expr && expr.type === "TypeCastExpression") {
                    exprList[i] = typeCastToParameter(expr);
                  }
                }
                return inner.call(this, exprList, isBinding);
              };
            });
            instance.extend("toReferencedList", function() {
              return function(exprList) {
                for (var i = 0; i < exprList.length; i++) {
                  var expr = exprList[i];
                  if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
                    this.raise(expr.start, "Unexpected type cast");
                  }
                }
                return exprList;
              };
            });
            instance.extend("parseExprListItem", function(inner) {
              return function(allowEmpty, refShorthandDefaultPos) {
                var container = this.startNode();
                var node = inner.call(this, allowEmpty, refShorthandDefaultPos);
                if (this.match(_tokenizerTypes.types.colon)) {
                  container._exprListItem = true;
                  container.expression = node;
                  container.typeAnnotation = this.flowParseTypeAnnotation();
                  return this.finishNode(container, "TypeCastExpression");
                } else {
                  return node;
                }
              };
            });
            instance.extend("parseClassProperty", function(inner) {
              return function(node) {
                if (this.match(_tokenizerTypes.types.colon)) {
                  node.typeAnnotation = this.flowParseTypeAnnotation();
                }
                return inner.call(this, node);
              };
            });
            instance.extend("isClassProperty", function(inner) {
              return function() {
                return this.match(_tokenizerTypes.types.colon) || inner.call(this);
              };
            });
            instance.extend("parseClassMethod", function() {
              return function(classBody, method, isGenerator, isAsync) {
                var typeParameters;
                if (this.isRelational("<")) {
                  typeParameters = this.flowParseTypeParameterDeclaration();
                }
                method.value = this.parseMethod(isGenerator, isAsync);
                method.value.typeParameters = typeParameters;
                classBody.body.push(this.finishNode(method, "MethodDefinition"));
              };
            });
            instance.extend("parseClassSuper", function(inner) {
              return function(node, isStatement) {
                inner.call(this, node, isStatement);
                if (node.superClass && this.isRelational("<")) {
                  node.superTypeParameters = this.flowParseTypeParameterInstantiation();
                }
                if (this.isContextual("implements")) {
                  this.next();
                  var implemented = node["implements"] = [];
                  do {
                    var _node = this.startNode();
                    _node.id = this.parseIdent();
                    if (this.isRelational("<")) {
                      _node.typeParameters = this.flowParseTypeParameterInstantiation();
                    } else {
                      _node.typeParameters = null;
                    }
                    implemented.push(this.finishNode(_node, "ClassImplements"));
                  } while (this.eat(_tokenizerTypes.types.comma));
                }
              };
            });
            instance.extend("parseObjPropValue", function(inner) {
              return function(prop) {
                var typeParameters;
                if (this.isRelational("<")) {
                  typeParameters = this.flowParseTypeParameterDeclaration();
                  if (!this.match(_tokenizerTypes.types.parenL))
                    this.unexpected();
                }
                inner.apply(this, arguments);
                if (typeParameters) {
                  prop.value.typeParameters = typeParameters;
                }
              };
            });
            instance.extend("parseAssignableListItemTypes", function() {
              return function(param) {
                if (this.eat(_tokenizerTypes.types.question)) {
                  param.optional = true;
                }
                if (this.match(_tokenizerTypes.types.colon)) {
                  param.typeAnnotation = this.flowParseTypeAnnotation();
                }
                this.finishNode(param, param.type);
                return param;
              };
            });
            instance.extend("parseImportSpecifiers", function(inner) {
              return function(node) {
                node.importKind = "value";
                var kind = this.match(_tokenizerTypes.types._typeof) ? "typeof" : this.isContextual("type") ? "type" : null;
                if (kind) {
                  var lh = this.lookahead();
                  if (lh.type === _tokenizerTypes.types.name && lh.value !== "from" || lh.type === _tokenizerTypes.types.braceL || lh.type === _tokenizerTypes.types.star) {
                    this.next();
                    node.importKind = kind;
                  }
                }
                inner.call(this, node);
              };
            });
            instance.extend("parseFunctionParams", function(inner) {
              return function(node) {
                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration();
                }
                inner.call(this, node);
              };
            });
            instance.extend("parseVarHead", function(inner) {
              return function(decl) {
                inner.call(this, decl);
                if (this.match(_tokenizerTypes.types.colon)) {
                  decl.id.typeAnnotation = this.flowParseTypeAnnotation();
                  this.finishNode(decl.id, decl.id.type);
                }
              };
            });
            instance.extend("parseAsyncArrowFromCallExpression", function(inner) {
              return function(node, call) {
                if (this.match(_tokenizerTypes.types.colon)) {
                  node.returnType = this.flowParseTypeAnnotation();
                }
                return inner.call(this, node, call);
              };
            });
            instance.extend("parseParenAndDistinguishExpression", function(inner) {
              return function(startPos, startLoc, canBeArrow, isAsync) {
                startPos = startPos || this.state.start;
                startLoc = startLoc || this.state.startLoc;
                if (this.lookahead().type === _tokenizerTypes.types.parenR) {
                  this.expect(_tokenizerTypes.types.parenL);
                  this.expect(_tokenizerTypes.types.parenR);
                  var node = this.startNodeAt(startPos, startLoc);
                  if (this.match(_tokenizerTypes.types.colon))
                    node.returnType = this.flowParseTypeAnnotation();
                  this.expect(_tokenizerTypes.types.arrow);
                  return this.parseArrowExpression(node, [], isAsync);
                } else {
                  var node = inner.call(this, startPos, startLoc, canBeArrow, isAsync);
                  if (this.match(_tokenizerTypes.types.colon)) {
                    var state = this.state.clone();
                    try {
                      return this.parseParenItem(node, startPos, startLoc, true);
                    } catch (err) {
                      if (err instanceof SyntaxError) {
                        this.state = state;
                        return node;
                      } else {
                        throw err;
                      }
                    }
                  } else {
                    return node;
                  }
                }
              };
            });
          };
          module.exports = exports["default"];
        }, {
          "../parser": 628,
          "../tokenizer/types": 640
        }],
        635: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          var _xhtml = require("./xhtml");
          var _xhtml2 = _interopRequireDefault(_xhtml);
          var _tokenizerTypes = require("../../tokenizer/types");
          var _tokenizerContext = require("../../tokenizer/context");
          var _parser = require("../../parser");
          var _parser2 = _interopRequireDefault(_parser);
          var _utilIdentifier = require("../../util/identifier");
          var _utilWhitespace = require("../../util/whitespace");
          var HEX_NUMBER = /^[\da-fA-F]+$/;
          var DECIMAL_NUMBER = /^\d+$/;
          _tokenizerContext.types.j_oTag = new _tokenizerContext.TokContext("<tag", false);
          _tokenizerContext.types.j_cTag = new _tokenizerContext.TokContext("</tag", false);
          _tokenizerContext.types.j_expr = new _tokenizerContext.TokContext("<tag>...</tag>", true, true);
          _tokenizerTypes.types.jsxName = new _tokenizerTypes.TokenType("jsxName");
          _tokenizerTypes.types.jsxText = new _tokenizerTypes.TokenType("jsxText", {beforeExpr: true});
          _tokenizerTypes.types.jsxTagStart = new _tokenizerTypes.TokenType("jsxTagStart");
          _tokenizerTypes.types.jsxTagEnd = new _tokenizerTypes.TokenType("jsxTagEnd");
          _tokenizerTypes.types.jsxTagStart.updateContext = function() {
            this.state.context.push(_tokenizerContext.types.j_expr);
            this.state.context.push(_tokenizerContext.types.j_oTag);
            this.state.exprAllowed = false;
          };
          _tokenizerTypes.types.jsxTagEnd.updateContext = function(prevType) {
            var out = this.state.context.pop();
            if (out === _tokenizerContext.types.j_oTag && prevType === _tokenizerTypes.types.slash || out === _tokenizerContext.types.j_cTag) {
              this.state.context.pop();
              this.state.exprAllowed = this.curContext() === _tokenizerContext.types.j_expr;
            } else {
              this.state.exprAllowed = true;
            }
          };
          var pp = _parser2["default"].prototype;
          pp.jsxReadToken = function() {
            var out = "",
                chunkStart = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.input.length) {
                this.raise(this.state.start, "Unterminated JSX contents");
              }
              var ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    if (ch === 60 && this.state.exprAllowed) {
                      ++this.state.pos;
                      return this.finishToken(_tokenizerTypes.types.jsxTagStart);
                    }
                    return this.getTokenFromCode(ch);
                  }
                  out += this.input.slice(chunkStart, this.state.pos);
                  return this.finishToken(_tokenizerTypes.types.jsxText, out);
                case 38:
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadEntity();
                  chunkStart = this.state.pos;
                  break;
                default:
                  if (_utilWhitespace.isNewLine(ch)) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadNewLine(true);
                    chunkStart = this.state.pos;
                  } else {
                    ++this.state.pos;
                  }
              }
            }
          };
          pp.jsxReadNewLine = function(normalizeCRLF) {
            var ch = this.input.charCodeAt(this.state.pos);
            var out;
            ++this.state.pos;
            if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
              out = normalizeCRLF ? "\n" : "\r\n";
            } else {
              out = String.fromCharCode(ch);
            }
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            return out;
          };
          pp.jsxReadString = function(quote) {
            var out = "",
                chunkStart = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.input.length) {
                this.raise(this.state.start, "Unterminated string constant");
              }
              var ch = this.input.charCodeAt(this.state.pos);
              if (ch === quote)
                break;
              if (ch === 38) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
              } else if (_utilWhitespace.isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(false);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
            }
            out += this.input.slice(chunkStart, this.state.pos++);
            return this.finishToken(_tokenizerTypes.types.string, out);
          };
          pp.jsxReadEntity = function() {
            var str = "",
                count = 0,
                entity;
            var ch = this.input[this.state.pos];
            var startPos = ++this.state.pos;
            while (this.state.pos < this.input.length && count++ < 10) {
              ch = this.input[this.state.pos++];
              if (ch === ";") {
                if (str[0] === "#") {
                  if (str[1] === "x") {
                    str = str.substr(2);
                    if (HEX_NUMBER.test(str))
                      entity = String.fromCharCode(parseInt(str, 16));
                  } else {
                    str = str.substr(1);
                    if (DECIMAL_NUMBER.test(str))
                      entity = String.fromCharCode(parseInt(str, 10));
                  }
                } else {
                  entity = _xhtml2["default"][str];
                }
                break;
              }
              str += ch;
            }
            if (!entity) {
              this.state.pos = startPos;
              return "&";
            }
            return entity;
          };
          pp.jsxReadWord = function() {
            var ch,
                start = this.state.pos;
            do {
              ch = this.input.charCodeAt(++this.state.pos);
            } while (_utilIdentifier.isIdentifierChar(ch) || ch === 45);
            return this.finishToken(_tokenizerTypes.types.jsxName, this.input.slice(start, this.state.pos));
          };
          function getQualifiedJSXName(object) {
            if (object.type === "JSXIdentifier") {
              return object.name;
            }
            if (object.type === "JSXNamespacedName") {
              return object.namespace.name + ":" + object.name.name;
            }
            if (object.type === "JSXMemberExpression") {
              return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
            }
          }
          pp.jsxParseIdentifier = function() {
            var node = this.startNode();
            if (this.match(_tokenizerTypes.types.jsxName)) {
              node.name = this.state.value;
            } else if (this.state.type.keyword) {
              node.name = this.state.type.keyword;
            } else {
              this.unexpected();
            }
            this.next();
            return this.finishNode(node, "JSXIdentifier");
          };
          pp.jsxParseNamespacedName = function() {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            var name = this.jsxParseIdentifier();
            if (!this.eat(_tokenizerTypes.types.colon))
              return name;
            var node = this.startNodeAt(startPos, startLoc);
            node.namespace = name;
            node.name = this.jsxParseIdentifier();
            return this.finishNode(node, "JSXNamespacedName");
          };
          pp.jsxParseElementName = function() {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            var node = this.jsxParseNamespacedName();
            while (this.eat(_tokenizerTypes.types.dot)) {
              var newNode = this.startNodeAt(startPos, startLoc);
              newNode.object = node;
              newNode.property = this.jsxParseIdentifier();
              node = this.finishNode(newNode, "JSXMemberExpression");
            }
            return node;
          };
          pp.jsxParseAttributeValue = function() {
            var node;
            switch (this.state.type) {
              case _tokenizerTypes.types.braceL:
                node = this.jsxParseExpressionContainer();
                if (node.expression.type === "JSXEmptyExpression") {
                  this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
                } else {
                  return node;
                }
              case _tokenizerTypes.types.jsxTagStart:
              case _tokenizerTypes.types.string:
                node = this.parseExprAtom();
                node.rawValue = null;
                return node;
              default:
                this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
            }
          };
          pp.jsxParseEmptyExpression = function() {
            var tmp = this.state.start;
            this.state.start = this.state.lastTokEnd;
            this.state.lastTokEnd = tmp;
            tmp = this.state.startLoc;
            this.state.startLoc = this.state.lastTokEndLoc;
            this.state.lastTokEndLoc = tmp;
            return this.finishNode(this.startNode(), "JSXEmptyExpression");
          };
          pp.jsxParseExpressionContainer = function() {
            var node = this.startNode();
            this.next();
            if (this.match(_tokenizerTypes.types.braceR)) {
              node.expression = this.jsxParseEmptyExpression();
            } else {
              node.expression = this.parseExpression();
            }
            this.expect(_tokenizerTypes.types.braceR);
            return this.finishNode(node, "JSXExpressionContainer");
          };
          pp.jsxParseAttribute = function() {
            var node = this.startNode();
            if (this.eat(_tokenizerTypes.types.braceL)) {
              this.expect(_tokenizerTypes.types.ellipsis);
              node.argument = this.parseMaybeAssign();
              this.expect(_tokenizerTypes.types.braceR);
              return this.finishNode(node, "JSXSpreadAttribute");
            }
            node.name = this.jsxParseNamespacedName();
            node.value = this.eat(_tokenizerTypes.types.eq) ? this.jsxParseAttributeValue() : null;
            return this.finishNode(node, "JSXAttribute");
          };
          pp.jsxParseOpeningElementAt = function(startPos, startLoc) {
            var node = this.startNodeAt(startPos, startLoc);
            node.attributes = [];
            node.name = this.jsxParseElementName();
            while (!this.match(_tokenizerTypes.types.slash) && !this.match(_tokenizerTypes.types.jsxTagEnd)) {
              node.attributes.push(this.jsxParseAttribute());
            }
            node.selfClosing = this.eat(_tokenizerTypes.types.slash);
            this.expect(_tokenizerTypes.types.jsxTagEnd);
            return this.finishNode(node, "JSXOpeningElement");
          };
          pp.jsxParseClosingElementAt = function(startPos, startLoc) {
            var node = this.startNodeAt(startPos, startLoc);
            node.name = this.jsxParseElementName();
            this.expect(_tokenizerTypes.types.jsxTagEnd);
            return this.finishNode(node, "JSXClosingElement");
          };
          pp.jsxParseElementAt = function(startPos, startLoc) {
            var node = this.startNodeAt(startPos, startLoc);
            var children = [];
            var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
            var closingElement = null;
            if (!openingElement.selfClosing) {
              contents: for (; ; ) {
                switch (this.state.type) {
                  case _tokenizerTypes.types.jsxTagStart:
                    startPos = this.state.start;
                    startLoc = this.state.startLoc;
                    this.next();
                    if (this.eat(_tokenizerTypes.types.slash)) {
                      closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                      break contents;
                    }
                    children.push(this.jsxParseElementAt(startPos, startLoc));
                    break;
                  case _tokenizerTypes.types.jsxText:
                    children.push(this.parseExprAtom());
                    break;
                  case _tokenizerTypes.types.braceL:
                    children.push(this.jsxParseExpressionContainer());
                    break;
                  default:
                    this.unexpected();
                }
              }
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
              }
            }
            node.openingElement = openingElement;
            node.closingElement = closingElement;
            node.children = children;
            if (this.match(_tokenizerTypes.types.relational) && this.state.value === "<") {
              this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
            }
            return this.finishNode(node, "JSXElement");
          };
          pp.jsxParseElement = function() {
            var startPos = this.state.start,
                startLoc = this.state.startLoc;
            this.next();
            return this.jsxParseElementAt(startPos, startLoc);
          };
          exports["default"] = function(instance) {
            instance.extend("parseExprAtom", function(inner) {
              return function(refShortHandDefaultPos) {
                if (this.match(_tokenizerTypes.types.jsxText)) {
                  var node = this.parseLiteral(this.state.value);
                  node.rawValue = null;
                  return node;
                } else if (this.match(_tokenizerTypes.types.jsxTagStart)) {
                  return this.jsxParseElement();
                } else {
                  return inner.call(this, refShortHandDefaultPos);
                }
              };
            });
            instance.extend("readToken", function(inner) {
              return function(code) {
                var context = this.curContext();
                if (context === _tokenizerContext.types.j_expr) {
                  return this.jsxReadToken();
                }
                if (context === _tokenizerContext.types.j_oTag || context === _tokenizerContext.types.j_cTag) {
                  if (_utilIdentifier.isIdentifierStart(code)) {
                    return this.jsxReadWord();
                  }
                  if (code === 62) {
                    ++this.state.pos;
                    return this.finishToken(_tokenizerTypes.types.jsxTagEnd);
                  }
                  if ((code === 34 || code === 39) && context === _tokenizerContext.types.j_oTag) {
                    return this.jsxReadString(code);
                  }
                }
                if (code === 60 && this.state.exprAllowed) {
                  ++this.state.pos;
                  return this.finishToken(_tokenizerTypes.types.jsxTagStart);
                }
                return inner.call(this, code);
              };
            });
            instance.extend("updateContext", function(inner) {
              return function(prevType) {
                if (this.match(_tokenizerTypes.types.braceL)) {
                  var curContext = this.curContext();
                  if (curContext === _tokenizerContext.types.j_oTag) {
                    this.state.context.push(_tokenizerContext.types.b_expr);
                  } else if (curContext === _tokenizerContext.types.j_expr) {
                    this.state.context.push(_tokenizerContext.types.b_tmpl);
                  } else {
                    inner.call(this, prevType);
                  }
                  this.state.exprAllowed = true;
                } else if (this.match(_tokenizerTypes.types.slash) && prevType === _tokenizerTypes.types.jsxTagStart) {
                  this.state.context.length -= 2;
                  this.state.context.push(_tokenizerContext.types.j_cTag);
                  this.state.exprAllowed = false;
                } else {
                  return inner.call(this, prevType);
                }
              };
            });
          };
          module.exports = exports["default"];
        }, {
          "../../parser": 628,
          "../../tokenizer/context": 637,
          "../../tokenizer/types": 640,
          "../../util/identifier": 641,
          "../../util/whitespace": 643,
          "./xhtml": 636
        }],
        636: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports["default"] = {
            quot: "\"",
            amp: "&",
            apos: "'",
            lt: "<",
            gt: ">",
            nbsp: " ",
            iexcl: "¡",
            cent: "¢",
            pound: "£",
            curren: "¤",
            yen: "¥",
            brvbar: "¦",
            sect: "§",
            uml: "¨",
            copy: "©",
            ordf: "ª",
            laquo: "«",
            not: "¬",
            shy: "­",
            reg: "®",
            macr: "¯",
            deg: "°",
            plusmn: "±",
            sup2: "²",
            sup3: "³",
            acute: "´",
            micro: "µ",
            para: "¶",
            middot: "·",
            cedil: "¸",
            sup1: "¹",
            ordm: "º",
            raquo: "»",
            frac14: "¼",
            frac12: "½",
            frac34: "¾",
            iquest: "¿",
            Agrave: "À",
            Aacute: "Á",
            Acirc: "Â",
            Atilde: "Ã",
            Auml: "Ä",
            Aring: "Å",
            AElig: "Æ",
            Ccedil: "Ç",
            Egrave: "È",
            Eacute: "É",
            Ecirc: "Ê",
            Euml: "Ë",
            Igrave: "Ì",
            Iacute: "Í",
            Icirc: "Î",
            Iuml: "Ï",
            ETH: "Ð",
            Ntilde: "Ñ",
            Ograve: "Ò",
            Oacute: "Ó",
            Ocirc: "Ô",
            Otilde: "Õ",
            Ouml: "Ö",
            times: "×",
            Oslash: "Ø",
            Ugrave: "Ù",
            Uacute: "Ú",
            Ucirc: "Û",
            Uuml: "Ü",
            Yacute: "Ý",
            THORN: "Þ",
            szlig: "ß",
            agrave: "à",
            aacute: "á",
            acirc: "â",
            atilde: "ã",
            auml: "ä",
            aring: "å",
            aelig: "æ",
            ccedil: "ç",
            egrave: "è",
            eacute: "é",
            ecirc: "ê",
            euml: "ë",
            igrave: "ì",
            iacute: "í",
            icirc: "î",
            iuml: "ï",
            eth: "ð",
            ntilde: "ñ",
            ograve: "ò",
            oacute: "ó",
            ocirc: "ô",
            otilde: "õ",
            ouml: "ö",
            divide: "÷",
            oslash: "ø",
            ugrave: "ù",
            uacute: "ú",
            ucirc: "û",
            uuml: "ü",
            yacute: "ý",
            thorn: "þ",
            yuml: "ÿ",
            OElig: "Œ",
            oelig: "œ",
            Scaron: "Š",
            scaron: "š",
            Yuml: "Ÿ",
            fnof: "ƒ",
            circ: "ˆ",
            tilde: "˜",
            Alpha: "Α",
            Beta: "Β",
            Gamma: "Γ",
            Delta: "Δ",
            Epsilon: "Ε",
            Zeta: "Ζ",
            Eta: "Η",
            Theta: "Θ",
            Iota: "Ι",
            Kappa: "Κ",
            Lambda: "Λ",
            Mu: "Μ",
            Nu: "Ν",
            Xi: "Ξ",
            Omicron: "Ο",
            Pi: "Π",
            Rho: "Ρ",
            Sigma: "Σ",
            Tau: "Τ",
            Upsilon: "Υ",
            Phi: "Φ",
            Chi: "Χ",
            Psi: "Ψ",
            Omega: "Ω",
            alpha: "α",
            beta: "β",
            gamma: "γ",
            delta: "δ",
            epsilon: "ε",
            zeta: "ζ",
            eta: "η",
            theta: "θ",
            iota: "ι",
            kappa: "κ",
            lambda: "λ",
            mu: "μ",
            nu: "ν",
            xi: "ξ",
            omicron: "ο",
            pi: "π",
            rho: "ρ",
            sigmaf: "ς",
            sigma: "σ",
            tau: "τ",
            upsilon: "υ",
            phi: "φ",
            chi: "χ",
            psi: "ψ",
            omega: "ω",
            thetasym: "ϑ",
            upsih: "ϒ",
            piv: "ϖ",
            ensp: " ",
            emsp: " ",
            thinsp: " ",
            zwnj: "‌",
            zwj: "‍",
            lrm: "‎",
            rlm: "‏",
            ndash: "–",
            mdash: "—",
            lsquo: "‘",
            rsquo: "’",
            sbquo: "‚",
            ldquo: "“",
            rdquo: "”",
            bdquo: "„",
            dagger: "†",
            Dagger: "‡",
            bull: "•",
            hellip: "…",
            permil: "‰",
            prime: "′",
            Prime: "″",
            lsaquo: "‹",
            rsaquo: "›",
            oline: "‾",
            frasl: "⁄",
            euro: "€",
            image: "ℑ",
            weierp: "℘",
            real: "ℜ",
            trade: "™",
            alefsym: "ℵ",
            larr: "←",
            uarr: "↑",
            rarr: "→",
            darr: "↓",
            harr: "↔",
            crarr: "↵",
            lArr: "⇐",
            uArr: "⇑",
            rArr: "⇒",
            dArr: "⇓",
            hArr: "⇔",
            forall: "∀",
            part: "∂",
            exist: "∃",
            empty: "∅",
            nabla: "∇",
            isin: "∈",
            notin: "∉",
            ni: "∋",
            prod: "∏",
            sum: "∑",
            minus: "−",
            lowast: "∗",
            radic: "√",
            prop: "∝",
            infin: "∞",
            ang: "∠",
            and: "∧",
            or: "∨",
            cap: "∩",
            cup: "∪",
            "int": "∫",
            there4: "∴",
            sim: "∼",
            cong: "≅",
            asymp: "≈",
            ne: "≠",
            equiv: "≡",
            le: "≤",
            ge: "≥",
            sub: "⊂",
            sup: "⊃",
            nsub: "⊄",
            sube: "⊆",
            supe: "⊇",
            oplus: "⊕",
            otimes: "⊗",
            perp: "⊥",
            sdot: "⋅",
            lceil: "⌈",
            rceil: "⌉",
            lfloor: "⌊",
            rfloor: "⌋",
            lang: "〈",
            rang: "〉",
            loz: "◊",
            spades: "♠",
            clubs: "♣",
            hearts: "♥",
            diams: "♦"
          };
          module.exports = exports["default"];
        }, {}],
        637: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _types = require("./types");
          var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
            _classCallCheck(this, TokContext);
            this.token = token;
            this.isExpr = !!isExpr;
            this.preserveSpace = !!preserveSpace;
            this.override = override;
          };
          exports.TokContext = TokContext;
          var types = {
            b_stat: new TokContext("{", false),
            b_expr: new TokContext("{", true),
            b_tmpl: new TokContext("${", true),
            p_stat: new TokContext("(", false),
            p_expr: new TokContext("(", true),
            q_tmpl: new TokContext("`", true, true, function(p) {
              return p.readTmplToken();
            }),
            f_expr: new TokContext("function", true)
          };
          exports.types = types;
          _types.types.parenR.updateContext = _types.types.braceR.updateContext = function() {
            if (this.state.context.length === 1) {
              this.state.exprAllowed = true;
              return;
            }
            var out = this.state.context.pop();
            if (out === types.b_stat && this.curContext() === types.f_expr) {
              this.state.context.pop();
              this.state.exprAllowed = false;
            } else if (out === types.b_tmpl) {
              this.state.exprAllowed = true;
            } else {
              this.state.exprAllowed = !out.isExpr;
            }
          };
          _types.types.braceL.updateContext = function(prevType) {
            this.state.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
            this.state.exprAllowed = true;
          };
          _types.types.dollarBraceL.updateContext = function() {
            this.state.context.push(types.b_tmpl);
            this.state.exprAllowed = true;
          };
          _types.types.parenL.updateContext = function(prevType) {
            var statementParens = prevType === _types.types._if || prevType === _types.types._for || prevType === _types.types._with || prevType === _types.types._while;
            this.state.context.push(statementParens ? types.p_stat : types.p_expr);
            this.state.exprAllowed = true;
          };
          _types.types.incDec.updateContext = function() {};
          _types.types._function.updateContext = function() {
            if (this.curContext() !== types.b_stat) {
              this.state.context.push(types.f_expr);
            }
            this.state.exprAllowed = false;
          };
          _types.types.backQuote.updateContext = function() {
            if (this.curContext() === types.q_tmpl) {
              this.state.context.pop();
            } else {
              this.state.context.push(types.q_tmpl);
            }
            this.state.exprAllowed = false;
          };
        }, {"./types": 640}],
        638: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {"default": obj};
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _utilIdentifier = require("../util/identifier");
          var _types = require("./types");
          var _context = require("./context");
          var _utilLocation = require("../util/location");
          var _utilWhitespace = require("../util/whitespace");
          var _state = require("./state");
          var _state2 = _interopRequireDefault(_state);
          var Token = function Token(state) {
            _classCallCheck(this, Token);
            this.type = state.type;
            this.value = state.value;
            this.start = state.start;
            this.end = state.end;
            this.loc = new _utilLocation.SourceLocation(state.startLoc, state.endLoc);
          };
          ;
          exports.Token = Token;
          var isRhino = typeof Packages === "object" && Object.prototype.toString.call(Packages) === "[object JavaPackage]";
          function tryCreateRegexp(src, flags, throwErrorStart) {
            try {
              return new RegExp(src, flags);
            } catch (e) {
              if (throwErrorStart !== undefined) {
                if (e instanceof SyntaxError)
                  this.raise(throwErrorStart, "Error parsing regular expression: " + e.message);
                this.raise(e);
              }
            }
          }
          var regexpUnicodeSupport = !!tryCreateRegexp("￿", "u");
          function codePointToString(code) {
            if (code <= 0xFFFF)
              return String.fromCharCode(code);
            return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00);
          }
          var Tokenizer = (function() {
            function Tokenizer(input) {
              _classCallCheck(this, Tokenizer);
              this.state = new _state2["default"]();
              this.state.init(input);
            }
            Tokenizer.prototype.next = function next() {
              this.state.tokens.push(new Token(this.state));
              this.state.lastTokEnd = this.state.end;
              this.state.lastTokStart = this.state.start;
              this.state.lastTokEndLoc = this.state.endLoc;
              this.state.lastTokStartLoc = this.state.startLoc;
              this.nextToken();
            };
            Tokenizer.prototype.eat = function eat(type) {
              if (this.match(type)) {
                this.next();
                return true;
              } else {
                return false;
              }
            };
            Tokenizer.prototype.match = function match(type) {
              return this.state.type === type;
            };
            Tokenizer.prototype.lookahead = function lookahead() {
              var old = this.state;
              this.state = old.clone();
              this.next();
              var curr = this.state.clone();
              this.state = old;
              return curr;
            };
            Tokenizer.prototype.setStrict = function setStrict(strict) {
              this.strict = strict;
              if (!this.match(_types.types.num) && !this.match(_types.types.string))
                return;
              this.state.pos = this.state.start;
              while (this.state.pos < this.state.lineStart) {
                this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
                --this.state.curLine;
              }
              this.nextToken();
            };
            Tokenizer.prototype.curContext = function curContext() {
              return this.state.context[this.state.context.length - 1];
            };
            Tokenizer.prototype.nextToken = function nextToken() {
              var curContext = this.curContext();
              if (!curContext || !curContext.preserveSpace)
                this.skipSpace();
              this.state.start = this.state.pos;
              this.state.startLoc = this.state.curPosition();
              if (this.state.pos >= this.input.length)
                return this.finishToken(_types.types.eof);
              if (curContext.override) {
                return curContext.override(this);
              } else {
                return this.readToken(this.fullCharCodeAtPos());
              }
            };
            Tokenizer.prototype.readToken = function readToken(code) {
              if (_utilIdentifier.isIdentifierStart(code, true) || code === 92)
                return this.readWord();
              return this.getTokenFromCode(code);
            };
            Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {
              var code = this.input.charCodeAt(this.state.pos);
              if (code <= 0xd7ff || code >= 0xe000)
                return code;
              var next = this.input.charCodeAt(this.state.pos + 1);
              return (code << 10) + next - 0x35fdc00;
            };
            Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
              var comment = {
                type: block ? "CommentBlock" : "CommentLine",
                value: text,
                start: start,
                end: end,
                loc: new _utilLocation.SourceLocation(startLoc, endLoc),
                range: [start, end]
              };
              this.state.tokens.push(comment);
              this.state.comments.push(comment);
              this.addComment(comment);
            };
            Tokenizer.prototype.skipBlockComment = function skipBlockComment() {
              var startLoc = this.state.curPosition();
              var start = this.state.pos,
                  end = this.input.indexOf("*/", this.state.pos += 2);
              if (end === -1)
                this.raise(this.state.pos - 2, "Unterminated comment");
              this.state.pos = end + 2;
              _utilWhitespace.lineBreakG.lastIndex = start;
              var match = undefined;
              while ((match = _utilWhitespace.lineBreakG.exec(this.input)) && match.index < this.state.pos) {
                ++this.state.curLine;
                this.state.lineStart = match.index + match[0].length;
              }
              this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
            };
            Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {
              var start = this.state.pos;
              var startLoc = this.state.curPosition();
              var ch = this.input.charCodeAt(this.state.pos += startSkip);
              while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
                ++this.state.pos;
                ch = this.input.charCodeAt(this.state.pos);
              }
              this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
            };
            Tokenizer.prototype.skipSpace = function skipSpace() {
              loop: while (this.state.pos < this.input.length) {
                var ch = this.input.charCodeAt(this.state.pos);
                switch (ch) {
                  case 32:
                  case 160:
                    ++this.state.pos;
                    break;
                  case 13:
                    if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                      ++this.state.pos;
                    }
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos;
                    ++this.state.curLine;
                    this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42:
                        this.skipBlockComment();
                        break;
                      case 47:
                        this.skipLineComment(2);
                        break;
                      default:
                        break loop;
                    }
                    break;
                  default:
                    if (ch > 8 && ch < 14 || ch >= 5760 && _utilWhitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                      ++this.state.pos;
                    } else {
                      break loop;
                    }
                }
              }
            };
            Tokenizer.prototype.finishToken = function finishToken(type, val) {
              this.state.end = this.state.pos;
              this.state.endLoc = this.state.curPosition();
              var prevType = this.state.type;
              this.state.type = type;
              this.state.value = val;
              this.updateContext(prevType);
            };
            Tokenizer.prototype.readToken_dot = function readToken_dot() {
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (next >= 48 && next <= 57) {
                return this.readNumber(true);
              }
              var next2 = this.input.charCodeAt(this.state.pos + 2);
              if (next === 46 && next2 === 46) {
                this.state.pos += 3;
                return this.finishToken(_types.types.ellipsis);
              } else {
                ++this.state.pos;
                return this.finishToken(_types.types.dot);
              }
            };
            Tokenizer.prototype.readToken_slash = function readToken_slash() {
              if (this.state.exprAllowed) {
                ++this.state.pos;
                return this.readRegexp();
              }
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 61) {
                return this.finishOp(_types.types.assign, 2);
              } else {
                return this.finishOp(_types.types.slash, 1);
              }
            };
            Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {
              var type = code === 42 ? _types.types.star : _types.types.modulo;
              var width = 1;
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 42 && this.options.features["es7.exponentiationOperator"]) {
                width++;
                next = this.input.charCodeAt(this.state.pos + 2);
                type = _types.types.exponent;
              }
              if (next === 61) {
                width++;
                type = _types.types.assign;
              }
              return this.finishOp(type, width);
            };
            Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (next === code)
                return this.finishOp(code === 124 ? _types.types.logicalOR : _types.types.logicalAND, 2);
              if (next === 61)
                return this.finishOp(_types.types.assign, 2);
              return this.finishOp(code === 124 ? _types.types.bitwiseOR : _types.types.bitwiseAND, 1);
            };
            Tokenizer.prototype.readToken_caret = function readToken_caret() {
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 61) {
                return this.finishOp(_types.types.assign, 2);
              } else {
                return this.finishOp(_types.types.bitwiseXOR, 1);
              }
            };
            Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (next === code) {
                if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && _utilWhitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
                  this.skipLineComment(3);
                  this.skipSpace();
                  return this.nextToken();
                }
                return this.finishOp(_types.types.incDec, 2);
              }
              if (next === 61) {
                return this.finishOp(_types.types.assign, 2);
              } else {
                return this.finishOp(_types.types.plusMin, 1);
              }
            };
            Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {
              var next = this.input.charCodeAt(this.state.pos + 1);
              var size = 1;
              if (next === code) {
                size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
                if (this.input.charCodeAt(this.state.pos + size) === 61)
                  return this.finishOp(_types.types.assign, size + 1);
                return this.finishOp(_types.types.bitShift, size);
              }
              if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
                if (this.inModule)
                  this.unexpected();
                this.skipLineComment(4);
                this.skipSpace();
                return this.nextToken();
              }
              if (next === 61) {
                size = this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2;
              }
              return this.finishOp(_types.types.relational, size);
            };
            Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 61)
                return this.finishOp(_types.types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
              if (code === 61 && next === 62) {
                this.state.pos += 2;
                return this.finishToken(_types.types.arrow);
              }
              return this.finishOp(code === 61 ? _types.types.eq : _types.types.prefix, 1);
            };
            Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {
              switch (code) {
                case 46:
                  return this.readToken_dot();
                case 40:
                  ++this.state.pos;
                  return this.finishToken(_types.types.parenL);
                case 41:
                  ++this.state.pos;
                  return this.finishToken(_types.types.parenR);
                case 59:
                  ++this.state.pos;
                  return this.finishToken(_types.types.semi);
                case 44:
                  ++this.state.pos;
                  return this.finishToken(_types.types.comma);
                case 91:
                  ++this.state.pos;
                  return this.finishToken(_types.types.bracketL);
                case 93:
                  ++this.state.pos;
                  return this.finishToken(_types.types.bracketR);
                case 123:
                  ++this.state.pos;
                  return this.finishToken(_types.types.braceL);
                case 125:
                  ++this.state.pos;
                  return this.finishToken(_types.types.braceR);
                case 58:
                  if (this.options.features["es7.functionBind"] && this.input.charCodeAt(this.state.pos + 1) === 58) {
                    return this.finishOp(_types.types.doubleColon, 2);
                  } else {
                    ++this.state.pos;
                    return this.finishToken(_types.types.colon);
                  }
                case 63:
                  ++this.state.pos;
                  return this.finishToken(_types.types.question);
                case 64:
                  ++this.state.pos;
                  return this.finishToken(_types.types.at);
                case 96:
                  ++this.state.pos;
                  return this.finishToken(_types.types.backQuote);
                case 48:
                  var next = this.input.charCodeAt(this.state.pos + 1);
                  if (next === 120 || next === 88)
                    return this.readRadixNumber(16);
                  if (next === 111 || next === 79)
                    return this.readRadixNumber(8);
                  if (next === 98 || next === 66)
                    return this.readRadixNumber(2);
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  return this.readNumber(false);
                case 34:
                case 39:
                  return this.readString(code);
                case 47:
                  return this.readToken_slash();
                case 37:
                case 42:
                  return this.readToken_mult_modulo(code);
                case 124:
                case 38:
                  return this.readToken_pipe_amp(code);
                case 94:
                  return this.readToken_caret();
                case 43:
                case 45:
                  return this.readToken_plus_min(code);
                case 60:
                case 62:
                  return this.readToken_lt_gt(code);
                case 61:
                case 33:
                  return this.readToken_eq_excl(code);
                case 126:
                  return this.finishOp(_types.types.prefix, 1);
              }
              this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
            };
            Tokenizer.prototype.finishOp = function finishOp(type, size) {
              var str = this.input.slice(this.state.pos, this.state.pos + size);
              this.state.pos += size;
              return this.finishToken(type, str);
            };
            Tokenizer.prototype.readRegexp = function readRegexp() {
              var _this = this;
              var escaped = undefined,
                  inClass = undefined,
                  start = this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.input.length)
                  this.raise(start, "Unterminated regular expression");
                var ch = this.input.charAt(this.state.pos);
                if (_utilWhitespace.lineBreak.test(ch)) {
                  this.raise(start, "Unterminated regular expression");
                }
                if (escaped) {
                  escaped = false;
                } else {
                  if (ch === "[") {
                    inClass = true;
                  } else if (ch === "]" && inClass) {
                    inClass = false;
                  } else if (ch === "/" && !inClass) {
                    break;
                  }
                  escaped = ch === "\\";
                }
                ++this.state.pos;
              }
              var content = this.input.slice(start, this.state.pos);
              ++this.state.pos;
              var mods = this.readWord1();
              var tmp = content;
              if (mods) {
                var validFlags = /^[gmsiyu]*$/;
                if (!validFlags.test(mods))
                  this.raise(start, "Invalid regular expression flag");
                if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
                  tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function(match, code, offset) {
                    code = Number("0x" + code);
                    if (code > 0x10FFFF)
                      _this.raise(start + offset + 3, "Code point out of bounds");
                    return "x";
                  });
                  tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
                }
              }
              var value = null;
              if (!isRhino) {
                tryCreateRegexp.call(this, tmp, undefined, start);
                value = tryCreateRegexp.call(this, content, mods);
              }
              return this.finishToken(_types.types.regexp, {
                pattern: content,
                flags: mods,
                value: value
              });
            };
            Tokenizer.prototype.readInt = function readInt(radix, len) {
              var start = this.state.pos,
                  total = 0;
              for (var i = 0,
                  e = len == null ? Infinity : len; i < e; ++i) {
                var code = this.input.charCodeAt(this.state.pos),
                    val = undefined;
                if (code >= 97) {
                  val = code - 97 + 10;
                } else if (code >= 65) {
                  val = code - 65 + 10;
                } else if (code >= 48 && code <= 57) {
                  val = code - 48;
                } else {
                  val = Infinity;
                }
                if (val >= radix)
                  break;
                ++this.state.pos;
                total = total * radix + val;
              }
              if (this.state.pos === start || len != null && this.state.pos - start !== len)
                return null;
              return total;
            };
            Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {
              this.state.pos += 2;
              var val = this.readInt(radix);
              if (val == null)
                this.raise(this.state.start + 2, "Expected number in radix " + radix);
              if (_utilIdentifier.isIdentifierStart(this.fullCharCodeAtPos()))
                this.raise(this.state.pos, "Identifier directly after number");
              return this.finishToken(_types.types.num, val);
            };
            Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {
              var start = this.state.pos,
                  isFloat = false,
                  octal = this.input.charCodeAt(this.state.pos) === 48;
              if (!startsWithDot && this.readInt(10) === null)
                this.raise(start, "Invalid number");
              var next = this.input.charCodeAt(this.state.pos);
              if (next === 46) {
                ++this.state.pos;
                this.readInt(10);
                isFloat = true;
                next = this.input.charCodeAt(this.state.pos);
              }
              if (next === 69 || next === 101) {
                next = this.input.charCodeAt(++this.state.pos);
                if (next === 43 || next === 45)
                  ++this.state.pos;
                if (this.readInt(10) === null)
                  this.raise(start, "Invalid number");
                isFloat = true;
              }
              if (_utilIdentifier.isIdentifierStart(this.fullCharCodeAtPos()))
                this.raise(this.state.pos, "Identifier directly after number");
              var str = this.input.slice(start, this.state.pos),
                  val = undefined;
              if (isFloat) {
                val = parseFloat(str);
              } else if (!octal || str.length === 1) {
                val = parseInt(str, 10);
              } else if (/[89]/.test(str) || this.strict) {
                this.raise(start, "Invalid number");
              } else {
                val = parseInt(str, 8);
              }
              return this.finishToken(_types.types.num, val);
            };
            Tokenizer.prototype.readCodePoint = function readCodePoint() {
              var ch = this.input.charCodeAt(this.state.pos),
                  code = undefined;
              if (ch === 123) {
                var codePos = ++this.state.pos;
                code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos);
                ++this.state.pos;
                if (code > 0x10FFFF)
                  this.raise(codePos, "Code point out of bounds");
              } else {
                code = this.readHexChar(4);
              }
              return code;
            };
            Tokenizer.prototype.readString = function readString(quote) {
              var out = "",
                  chunkStart = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.input.length)
                  this.raise(this.state.start, "Unterminated string constant");
                var ch = this.input.charCodeAt(this.state.pos);
                if (ch === quote)
                  break;
                if (ch === 92) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.readEscapedChar(false);
                  chunkStart = this.state.pos;
                } else {
                  if (_utilWhitespace.isNewLine(ch))
                    this.raise(this.state.start, "Unterminated string constant");
                  ++this.state.pos;
                }
              }
              out += this.input.slice(chunkStart, this.state.pos++);
              return this.finishToken(_types.types.string, out);
            };
            Tokenizer.prototype.readTmplToken = function readTmplToken() {
              var out = "",
                  chunkStart = this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.input.length)
                  this.raise(this.state.start, "Unterminated template");
                var ch = this.input.charCodeAt(this.state.pos);
                if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
                  if (this.state.pos === this.state.start && this.match(_types.types.template)) {
                    if (ch === 36) {
                      this.state.pos += 2;
                      return this.finishToken(_types.types.dollarBraceL);
                    } else {
                      ++this.state.pos;
                      return this.finishToken(_types.types.backQuote);
                    }
                  }
                  out += this.input.slice(chunkStart, this.state.pos);
                  return this.finishToken(_types.types.template, out);
                }
                if (ch === 92) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.readEscapedChar(true);
                  chunkStart = this.state.pos;
                } else if (_utilWhitespace.isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  ++this.state.pos;
                  switch (ch) {
                    case 13:
                      if (this.input.charCodeAt(this.state.pos) === 10)
                        ++this.state.pos;
                    case 10:
                      out += "\n";
                      break;
                    default:
                      out += String.fromCharCode(ch);
                      break;
                  }
                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
              }
            };
            Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {
              var ch = this.input.charCodeAt(++this.state.pos);
              ++this.state.pos;
              switch (ch) {
                case 110:
                  return "\n";
                case 114:
                  return "\r";
                case 120:
                  return String.fromCharCode(this.readHexChar(2));
                case 117:
                  return codePointToString(this.readCodePoint());
                case 116:
                  return "\t";
                case 98:
                  return "\b";
                case 118:
                  return "\u000b";
                case 102:
                  return "\f";
                case 13:
                  if (this.input.charCodeAt(this.state.pos) === 10)
                    ++this.state.pos;
                case 10:
                  this.state.lineStart = this.state.pos;
                  ++this.state.curLine;
                  return "";
                default:
                  if (ch >= 48 && ch <= 55) {
                    var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
                    var octal = parseInt(octalStr, 8);
                    if (octal > 255) {
                      octalStr = octalStr.slice(0, -1);
                      octal = parseInt(octalStr, 8);
                    }
                    if (octal > 0 && (this.strict || inTemplate)) {
                      this.raise(this.state.pos - 2, "Octal literal in strict mode");
                    }
                    this.state.pos += octalStr.length - 1;
                    return String.fromCharCode(octal);
                  }
                  return String.fromCharCode(ch);
              }
            };
            Tokenizer.prototype.readHexChar = function readHexChar(len) {
              var codePos = this.state.pos;
              var n = this.readInt(16, len);
              if (n === null)
                this.raise(codePos, "Bad character escape sequence");
              return n;
            };
            Tokenizer.prototype.readWord1 = function readWord1() {
              this.state.containsEsc = false;
              var word = "",
                  first = true,
                  chunkStart = this.state.pos;
              while (this.state.pos < this.input.length) {
                var ch = this.fullCharCodeAtPos();
                if (_utilIdentifier.isIdentifierChar(ch, true)) {
                  this.state.pos += ch <= 0xffff ? 1 : 2;
                } else if (ch === 92) {
                  this.state.containsEsc = true;
                  word += this.input.slice(chunkStart, this.state.pos);
                  var escStart = this.state.pos;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
                  }
                  ++this.state.pos;
                  var esc = this.readCodePoint();
                  if (!(first ? _utilIdentifier.isIdentifierStart : _utilIdentifier.isIdentifierChar)(esc, true)) {
                    this.raise(escStart, "Invalid Unicode escape");
                  }
                  word += codePointToString(esc);
                  chunkStart = this.state.pos;
                } else {
                  break;
                }
                first = false;
              }
              return word + this.input.slice(chunkStart, this.state.pos);
            };
            Tokenizer.prototype.readWord = function readWord() {
              var word = this.readWord1();
              var type = _types.types.name;
              if (!this.state.containsEsc && this.isKeyword(word))
                type = _types.keywords[word];
              return this.finishToken(type, word);
            };
            Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {
              if (prevType === _types.types.colon) {
                var _parent = this.curContext();
                if (_parent === _context.types.b_stat || _parent === _context.types.b_expr) {
                  return !_parent.isExpr;
                }
              }
              if (prevType === _types.types._return) {
                return _utilWhitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
              }
              if (prevType === _types.types._else || prevType === _types.types.semi || prevType === _types.types.eof || prevType === _types.types.parenR) {
                return true;
              }
              if (prevType === _types.types.braceL) {
                return this.curContext() === _context.types.b_stat;
              }
              return !this.state.exprAllowed;
            };
            Tokenizer.prototype.updateContext = function updateContext(prevType) {
              var update = undefined,
                  type = this.state.type;
              if (type.keyword && prevType === _types.types.dot) {
                this.state.exprAllowed = false;
              } else if (update = type.updateContext) {
                update.call(this, prevType);
              } else {
                this.state.exprAllowed = type.beforeExpr;
              }
            };
            return Tokenizer;
          })();
          exports["default"] = Tokenizer;
        }, {
          "../util/identifier": 641,
          "../util/location": 642,
          "../util/whitespace": 643,
          "./context": 637,
          "./state": 639,
          "./types": 640
        }],
        639: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _utilLocation = require("../util/location");
          var _context = require("./context");
          var _types = require("./types");
          var State = (function() {
            function State() {
              _classCallCheck(this, State);
            }
            State.prototype.init = function init(input) {
              this.input = input;
              this.potentialArrowAt = -1;
              this.inFunction = this.inGenerator = false;
              this.labels = [];
              this.decorators = [];
              this.tokens = [];
              this.comments = [];
              this.trailingComments = [];
              this.leadingComments = [];
              this.commentStack = [];
              this.pos = this.lineStart = 0;
              this.curLine = 1;
              this.type = _types.types.eof;
              this.value = null;
              this.start = this.end = this.pos;
              this.startLoc = this.endLoc = this.curPosition();
              this.lastTokEndLoc = this.lastTokStartLoc = null;
              this.lastTokStart = this.lastTokEnd = this.pos;
              this.context = [_context.types.b_stat];
              this.exprAllowed = true;
              this.containsEsc = false;
              return this;
            };
            State.prototype.curPosition = function curPosition() {
              return new _utilLocation.Position(this.curLine, this.pos - this.lineStart);
            };
            State.prototype.clone = function clone() {
              var state = new State();
              for (var key in this) {
                var val = this[key];
                if (Array.isArray(val))
                  val = val.slice();
                state[key] = val;
              }
              return state;
            };
            return State;
          })();
          exports["default"] = State;
          module.exports = exports["default"];
        }, {
          "../util/location": 642,
          "./context": 637,
          "./types": 640
        }],
        640: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var TokenType = function TokenType(label) {
            var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            _classCallCheck(this, TokenType);
            this.label = label;
            this.keyword = conf.keyword;
            this.beforeExpr = !!conf.beforeExpr;
            this.startsExpr = !!conf.startsExpr;
            this.rightAssociative = !!conf.rightAssociative;
            this.isLoop = !!conf.isLoop;
            this.isAssign = !!conf.isAssign;
            this.prefix = !!conf.prefix;
            this.postfix = !!conf.postfix;
            this.binop = conf.binop || null;
            this.updateContext = null;
          };
          exports.TokenType = TokenType;
          function binop(name, prec) {
            return new TokenType(name, {
              beforeExpr: true,
              binop: prec
            });
          }
          var beforeExpr = {beforeExpr: true},
              startsExpr = {startsExpr: true};
          var types = {
            num: new TokenType("num", startsExpr),
            regexp: new TokenType("regexp", startsExpr),
            string: new TokenType("string", startsExpr),
            name: new TokenType("name", startsExpr),
            eof: new TokenType("eof"),
            bracketL: new TokenType("[", {
              beforeExpr: true,
              startsExpr: true
            }),
            bracketR: new TokenType("]"),
            braceL: new TokenType("{", {
              beforeExpr: true,
              startsExpr: true
            }),
            braceR: new TokenType("}"),
            parenL: new TokenType("(", {
              beforeExpr: true,
              startsExpr: true
            }),
            parenR: new TokenType(")"),
            comma: new TokenType(",", beforeExpr),
            semi: new TokenType(";", beforeExpr),
            colon: new TokenType(":", beforeExpr),
            doubleColon: new TokenType("::", beforeExpr),
            dot: new TokenType("."),
            question: new TokenType("?", beforeExpr),
            arrow: new TokenType("=>", beforeExpr),
            template: new TokenType("template"),
            ellipsis: new TokenType("...", beforeExpr),
            backQuote: new TokenType("`", startsExpr),
            dollarBraceL: new TokenType("${", {
              beforeExpr: true,
              startsExpr: true
            }),
            at: new TokenType("@"),
            eq: new TokenType("=", {
              beforeExpr: true,
              isAssign: true
            }),
            assign: new TokenType("_=", {
              beforeExpr: true,
              isAssign: true
            }),
            incDec: new TokenType("++/--", {
              prefix: true,
              postfix: true,
              startsExpr: true
            }),
            prefix: new TokenType("prefix", {
              beforeExpr: true,
              prefix: true,
              startsExpr: true
            }),
            logicalOR: binop("||", 1),
            logicalAND: binop("&&", 2),
            bitwiseOR: binop("|", 3),
            bitwiseXOR: binop("^", 4),
            bitwiseAND: binop("&", 5),
            equality: binop("==/!=", 6),
            relational: binop("</>", 7),
            bitShift: binop("<</>>", 8),
            plusMin: new TokenType("+/-", {
              beforeExpr: true,
              binop: 9,
              prefix: true,
              startsExpr: true
            }),
            modulo: binop("%", 10),
            star: binop("*", 10),
            slash: binop("/", 10),
            exponent: new TokenType("**", {
              beforeExpr: true,
              binop: 11,
              rightAssociative: true
            })
          };
          exports.types = types;
          var keywords = {};
          exports.keywords = keywords;
          function kw(name) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            options.keyword = name;
            keywords[name] = types["_" + name] = new TokenType(name, options);
          }
          kw("break");
          kw("case", beforeExpr);
          kw("catch");
          kw("continue");
          kw("debugger");
          kw("default", beforeExpr);
          kw("do", {isLoop: true});
          kw("else", beforeExpr);
          kw("finally");
          kw("for", {isLoop: true});
          kw("function", startsExpr);
          kw("if");
          kw("return", beforeExpr);
          kw("switch");
          kw("throw", beforeExpr);
          kw("try");
          kw("var");
          kw("let");
          kw("const");
          kw("while", {isLoop: true});
          kw("with");
          kw("new", {
            beforeExpr: true,
            startsExpr: true
          });
          kw("this", startsExpr);
          kw("super", startsExpr);
          kw("class");
          kw("extends", beforeExpr);
          kw("export");
          kw("import");
          kw("yield", {
            beforeExpr: true,
            startsExpr: true
          });
          kw("null", startsExpr);
          kw("true", startsExpr);
          kw("false", startsExpr);
          kw("in", {
            beforeExpr: true,
            binop: 7
          });
          kw("instanceof", {
            beforeExpr: true,
            binop: 7
          });
          kw("typeof", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
          });
          kw("void", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
          });
          kw("delete", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
          });
        }, {}],
        641: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.isIdentifierStart = isIdentifierStart;
          exports.isIdentifierChar = isIdentifierChar;
          function makePredicate(words) {
            words = words.split(" ");
            return function(str) {
              return words.indexOf(str) >= 0;
            };
          }
          var reservedWords = {
            6: makePredicate("enum await"),
            strict: makePredicate("implements interface let package private protected public static yield"),
            strictBind: makePredicate("eval arguments")
          };
          exports.reservedWords = reservedWords;
          var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");
          exports.isKeyword = isKeyword;
          var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
          var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿";
          var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
          var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
          nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
          var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
          var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];
          function isInAstralSet(code, set) {
            var pos = 0x10000;
            for (var i = 0; i < set.length; i += 2) {
              pos += set[i];
              if (pos > code)
                return false;
              pos += set[i + 1];
              if (pos >= code)
                return true;
            }
          }
          function isIdentifierStart(code) {
            if (code < 65)
              return code === 36;
            if (code < 91)
              return true;
            if (code < 97)
              return code === 95;
            if (code < 123)
              return true;
            if (code <= 0xffff)
              return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
            return isInAstralSet(code, astralIdentifierStartCodes);
          }
          function isIdentifierChar(code) {
            if (code < 48)
              return code === 36;
            if (code < 58)
              return true;
            if (code < 65)
              return false;
            if (code < 91)
              return true;
            if (code < 97)
              return code === 95;
            if (code < 123)
              return true;
            if (code <= 0xffff)
              return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
            return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
          }
        }, {}],
        642: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.getLineInfo = getLineInfo;
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _whitespace = require("./whitespace");
          var Position = function Position(line, col) {
            _classCallCheck(this, Position);
            this.line = line;
            this.column = col;
          };
          exports.Position = Position;
          var SourceLocation = function SourceLocation(start, end) {
            _classCallCheck(this, SourceLocation);
            this.start = start;
            this.end = end;
          };
          ;
          exports.SourceLocation = SourceLocation;
          function getLineInfo(input, offset) {
            for (var line = 1,
                cur = 0; ; ) {
              _whitespace.lineBreakG.lastIndex = cur;
              var match = _whitespace.lineBreakG.exec(input);
              if (match && match.index < offset) {
                ++line;
                cur = match.index + match[0].length;
              } else {
                return new Position(line, offset - cur);
              }
            }
          }
        }, {"./whitespace": 643}],
        643: [function(require, module, exports) {
          "use strict";
          exports.__esModule = true;
          exports.isNewLine = isNewLine;
          var lineBreak = /\r\n?|\n|\u2028|\u2029/;
          exports.lineBreak = lineBreak;
          var lineBreakG = new RegExp(lineBreak.source, "g");
          exports.lineBreakG = lineBreakG;
          function isNewLine(code) {
            return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
          }
          var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
          exports.nonASCIIwhitespace = nonASCIIwhitespace;
        }, {}]
      }, {}, [31])(31);
    });
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("cf", ["ce"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("ce");
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d0", ["5"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.10.1';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LARGE_ARRAY_SIZE = 200;
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
      var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reHasHexPrefix = /^0[xX]/;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^\d+$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite', 'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var regexpEscapes = {
        '0': 'x30',
        '1': 'x31',
        '2': 'x32',
        '3': 'x33',
        '4': 'x34',
        '5': 'x35',
        '6': 'x36',
        '7': 'x37',
        '8': 'x38',
        '9': 'x39',
        'A': 'x41',
        'B': 'x42',
        'C': 'x43',
        'D': 'x44',
        'E': 'x45',
        'F': 'x46',
        'a': 'x61',
        'b': 'x62',
        'c': 'x63',
        'd': 'x64',
        'e': 'x65',
        'f': 'x66',
        'n': 'x6e',
        'r': 'x72',
        't': 'x74',
        'u': 'x75',
        'v': 'x76',
        'x': 'x78'
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
          if ((value > other && !othIsNull) || !valIsReflexive || (valIsNull && !othIsUndef && othIsReflexive) || (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive || (othIsNull && !valIsUndef && valIsReflexive) || (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseToString(value) {
        return value == null ? '' : (value + '');
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * ((order === 'asc' || order === true) ? 1 : -1);
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
        if (leadingChar) {
          chr = regexpEscapes[chr];
        } else if (whitespaceChar) {
          chr = stringEscapes[chr];
        }
        return '\\' + chr;
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
        var fnToString = Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');
        var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var metaMap = WeakMap && new WeakMap;
        var realNames = {};
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = [];
        }
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = arrayCopy(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = arrayCopy(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = arrayCopy(this.__views__);
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
          }
          var result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayConcat(array, other) {
          var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);
          while (++index < length) {
            result[index] = array[index];
          }
          while (++othIndex < othLength) {
            result[index++] = other[othIndex];
          }
          return result;
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function arraySum(array, iteratee) {
          var length = array.length,
              result = 0;
          while (length--) {
            result += +iteratee(array[length]) || 0;
          }
          return result;
        }
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? (result !== value) : (value === value)) || (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAssign(object, source) {
          return source == null ? object : baseCopy(source, keys(source), object);
        }
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, props, object) {
          object || (object = {});
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = undefined;
            }
            return result || {};
          };
        }());
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, result) {
          result || (result = []);
          var index = -1,
              length = array.length;
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                baseFlatten(value, isDeep, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          if (pathKey !== undefined && pathKey in toObject(object)) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value && (value !== undefined || (key in toObject(object)));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            } else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) && (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (isArrayLike(value) ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
        function baseRandom(min, max) {
          return min + nativeFloor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
          iteratees = arrayMap(iteratees, function(iteratee) {
            return callback(iteratee);
          });
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return {
              'criteria': criteria,
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var action = actions[index];
            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);
          view.set(new Uint8Array(buffer));
          return result;
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
        function createCache(values) {
          return (nativeCreate && Set) ? new SetCache(values) : null;
        }
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor;
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = undefined;
            }
            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
        function createDefaults(assigner, customizer) {
          return restParam(function(args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(customizer);
            return assigner.apply(undefined, args);
          });
        }
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = isArray(collection) ? collection : toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, undefined, partials, holders);
          });
          return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            precision = precision === undefined ? 0 : (+precision || 0);
            if (precision) {
              precision = pow(10, precision);
              return func(number * precision) / precision;
            }
            return func(number);
          };
        }
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback) ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        var getLength = baseProperty('length');
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
        function isLaziable(func) {
          var funcName = getFuncName(func);
          if (!(funcName in LazyWrapper.prototype)) {
            return false;
          }
          var other = lodash[funcName];
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
          var isCombo = (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) || (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) || (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function mergeDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
          var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(nativeFloor(size) || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        var difference = restParam(function(array, values) {
          return (isObjectLike(array) && isArrayLike(array)) ? baseDifference(array, baseFlatten(values, false, true)) : [];
        });
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value);
            if (index < length && (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var args = arguments,
              array = args[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
        var without = restParam(function(array, values) {
          return isArrayLike(array) ? baseDifference(array, values) : [];
        });
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result ? arrayPush(baseDifference(result, array), baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        var wrapperConcat = restParam(function(values) {
          values = baseFlatten(values);
          return this.thru(function(array) {
            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
          });
        });
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          var interceptor = function(value) {
            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
          };
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(interceptor);
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function(collection, props) {
          return baseAt(collection, baseFlatten(props));
        });
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1) : (!!length && getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, path) {
          return map(collection, property(path));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
          var result = baseMap(collection, function(value, key, collection) {
            return {
              'criteria': iteratee(value, key, collection),
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = undefined;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = undefined;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        var modArgs = restParam(function(func, transforms) {
          transforms = baseFlatten(transforms);
          if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = transforms.length;
          return restParam(function(args) {
            var index = nativeMin(args.length, length);
            while (index--) {
              args[index] = transforms[index](args[index]);
            }
            return func.apply(this, args);
          });
        });
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
        });
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0:
                return func.call(this, rest);
              case 1:
                return func.call(this, args[0], rest);
              case 2:
                return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': +wait,
            'trailing': trailing
          });
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function' ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1)) : baseClone(value, isDeep);
        }
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function' ? baseClone(value, true, bindCallback(customizer, thisArg, 1)) : baseClone(value, true);
        }
        function gt(value, other) {
          return value > other;
        }
        function gte(value, other) {
          return value >= other;
        }
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
        function isFunction(value) {
          return isObject(value) && objToString.call(value) == funcTag;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reIsHostCtor.test(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
        function isPlainObject(value) {
          var Ctor;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
        function isRegExp(value) {
          return isObject(value) && objToString.call(value) == regexpTag;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
          return value === undefined;
        }
        function lt(value, other) {
          return value < other;
        }
        function lte(value, other) {
          return value <= other;
        }
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var merge = createAssigner(baseMerge);
        var assign = createAssigner(function(object, source, customizer) {
          return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
        });
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = undefined;
          }
          return properties ? baseAssign(result, properties) : result;
        }
        var defaults = createDefaults(assign, assignDefaults);
        var defaultsDeep = createDefaults(merge, mergeDefaults);
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
          return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object)));
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = undefined;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? undefined : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        var mapKeys = createObjectMapper(true);
        var mapValues = createObjectMapper();
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
        function pairs(object) {
          object = toObject(object);
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function' ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
        });
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : object[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : object[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = undefined;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = position === undefined ? length : nativeMin(position < 0 ? 0 : (+position || 0), length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, escapeRegExpChar) : (string || '(?:)');
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = undefined;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = undefined;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          root._ = oldDash;
          return this;
        }
        function noop() {}
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), path + '');
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = nativeFloor(n);
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
        var ceil = createRound('ceil');
        var floor = createRound('floor');
        var max = createExtremum(gt, NEGATIVE_INFINITY);
        var min = createExtremum(lt, POSITIVE_INFINITY);
        var round = createRound('round');
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          return iteratee.length == 1 ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.modArgs = modArgs;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.floor = floor;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              result.__views__.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getCallback(iteratee, thisArg, 1),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
          return this.reverse().takeWhile(predicate, thisArg).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(POSITIVE_INFINITY);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var interceptor = function(value) {
              return (retUnwrapped && chainAll) ? lodashFunc(value, 1)[0] : lodashFunc.apply(undefined, arrayPush([value], args));
            };
            var action = {
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            },
                onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              if (onlyLazy) {
                value = value.clone();
                value.__actions__.push(action);
                return func.call(value);
              }
              return lodashFunc.call(undefined, this.value())[0];
            }
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push(action);
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);
            names.push({
              'name': methodName,
              'func': lodashFunc
            });
          }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.concat = wrapperConcat;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })(require("5"));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d1", ["d0"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("d0");
  global.define = __define;
  return module.exports;
});

$__System.register("cc", ["af", "ba", "bd", "be", "c5", "a1", "c8", "ca", "cb"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, _Object$assign, React, Component, PropTypes, cn, cm, CodeMirror;

    return {
        setters: [function (_af) {
            _get = _af["default"];
        }, function (_ba) {
            _inherits = _ba["default"];
        }, function (_bd) {
            _createClass = _bd["default"];
        }, function (_be) {
            _classCallCheck = _be["default"];
        }, function (_c5) {
            _Object$assign = _c5["default"];
        }, function (_a1) {
            React = _a1["default"];
            Component = _a1.Component;
            PropTypes = _a1.PropTypes;
        }, function (_c8) {
            cn = _c8["default"];
        }, function (_ca) {
            cm = _ca["default"];
        }, function (_cb) {}],
        execute: function () {

            // Never used. Just to load it into codemirror
            "use strict";

            CodeMirror = (function (_Component) {
                _inherits(CodeMirror, _Component);

                function CodeMirror() {
                    var _this = this;

                    _classCallCheck(this, CodeMirror);

                    _get(Object.getPrototypeOf(CodeMirror.prototype), "constructor", this).apply(this, arguments);

                    this.ignoreNextUpdate = false;

                    this.onChange = function (cm, changes) {
                        if (_this.ignoreNextUpdate) {
                            _this.ignoreNextUpdate = false;
                            return;
                        }

                        if (_this.props.onChange) {
                            _this.props.onChange(cm.getValue());
                        }
                    };
                }

                _createClass(CodeMirror, [{
                    key: "render",
                    value: function render() {
                        var _props = this.props;
                        var height = _props.height;
                        var width = _props.width;
                        var display = _props.display;

                        return React.createElement("div", { ref: "container", style: { height: height + "px", width: width + "px" } });
                    }
                }, {
                    key: "componentDidMount",
                    value: function componentDidMount() {
                        var options = _Object$assign({}, { value: this.props.value }, this.props.options);
                        var container = this.refs.container.getDOMNode();
                        this.codeMirror = cm(container, options);
                        this.codeMirror.refresh();
                        this.codeMirror.on("changes", this.onChange);
                    }
                }, {
                    key: "shouldComponentUpdate",
                    value: function shouldComponentUpdate(nextProps, nextState, nextContext) {
                        return !!this.codeMirror && (nextProps.value !== this.codeMirror.getValue() || nextProps.height !== this.props.height || nextProps.width !== this.props.width);
                    }
                }, {
                    key: "componentDidUpdate",
                    value: function componentDidUpdate() {
                        var _props2 = this.props;
                        var value = _props2.value;
                        var width = _props2.width;
                        var height = _props2.height;
                        var options = _props2.options;

                        this.ignoreNextUpdate = true;
                        this.codeMirror.setValue(value);
                        this.codeMirror.setSize(width, height);
                        for (var key in options) {
                            if (options.hasOwnProperty(key)) {
                                this.codeMirror.setOption(key, options[key]);
                            }
                        }
                        this.codeMirror.refresh();
                    }
                }], [{
                    key: "propTypes",
                    value: {
                        options: PropTypes.object,
                        value: PropTypes.string,
                        height: PropTypes.number.isRequired,
                        width: PropTypes.number.isRequired
                    },
                    enumerable: true
                }, {
                    key: "defaultProps",
                    value: {
                        display: "inherit"
                    },
                    enumerable: true
                }]);

                return CodeMirror;
            })(Component);

            _export("default", CodeMirror);
        }
    };
});
$__System.register("cd", ["af", "ba", "bd", "be", "a1"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, React, Component, OutputPane;

    return {
        setters: [function (_af) {
            _get = _af["default"];
        }, function (_ba) {
            _inherits = _ba["default"];
        }, function (_bd) {
            _createClass = _bd["default"];
        }, function (_be) {
            _classCallCheck = _be["default"];
        }, function (_a1) {
            React = _a1["default"];
            Component = _a1.Component;
        }],
        execute: function () {
            "use strict";

            OutputPane = (function (_Component) {
                _inherits(OutputPane, _Component);

                function OutputPane() {
                    _classCallCheck(this, OutputPane);

                    _get(Object.getPrototypeOf(OutputPane.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(OutputPane, [{
                    key: "render",
                    value: function render() {
                        return React.createElement("div", { className: "output", ref: "container" });
                    }
                }, {
                    key: "componentDidMount",
                    value: function componentDidMount() {
                        var container = this.refs.container.getDOMNode();
                        window.overlay = window.output = document.output = document.overlay = container;
                    }
                }]);

                return OutputPane;
            })(Component);

            _export("default", OutputPane);
        }
    };
});
$__System.register("d2", ["af", "ba", "bd", "be", "c6", "a1", "cc", "cd", "cf", "d1"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, _extends, React, Component, CodeMirror, OutputPane, Babel, _, PlaygroundApp;

    return {
        setters: [function (_af) {
            _get = _af["default"];
        }, function (_ba) {
            _inherits = _ba["default"];
        }, function (_bd) {
            _createClass = _bd["default"];
        }, function (_be) {
            _classCallCheck = _be["default"];
        }, function (_c6) {
            _extends = _c6["default"];
        }, function (_a1) {
            React = _a1["default"];
            Component = _a1.Component;
        }, function (_cc) {
            CodeMirror = _cc["default"];
        }, function (_cd) {
            OutputPane = _cd["default"];
        }, function (_cf) {
            Babel = _cf["default"];
        }, function (_d1) {
            _ = _d1["default"];
        }],
        execute: function () {
            "use strict";

            PlaygroundApp = (function (_Component) {
                _inherits(PlaygroundApp, _Component);

                function PlaygroundApp() {
                    var _this = this;

                    _classCallCheck(this, PlaygroundApp);

                    _get(Object.getPrototypeOf(PlaygroundApp.prototype), "constructor", this).call(this);
                    this.state = {
                        es6value: "",
                        jsvalue: "",
                        viewportHeight: 0,
                        viewportWidth: 0,
                        jserror: false,
                        es6options: {
                            lineNumbers: true,
                            mode: "javascript",
                            theme: "solarized light"
                        },
                        jsoptions: {
                            lineNumbers: true,
                            readOnly: true,
                            mode: "javascript",
                            theme: "monokai"
                        },
                        jsvisible: true
                    };

                    this.onES6Change = function (newValue) {
                        _this.setState({
                            es6value: newValue
                        });

                        _this.transpile(newValue);
                        _this.saveState(newValue);
                    };

                    this.onJSChange = function (newValue) {
                        _this.setState({
                            jsvalue: newValue
                        });
                    };

                    this.onResizeViewport = function () {
                        _this.setState({
                            viewportHeight: document.documentElement.clientHeight,
                            viewportWidth: document.documentElement.clientWidth
                        });
                    };

                    this.onJSRunClick = function () {
                        var _state = _this.state;
                        var jserror = _state.jserror;
                        var jsvalue = _state.jsvalue;

                        if (jserror) {
                            console.error("Can't execute invalid ES6 code!");
                            return;
                        }

                        eval(jsvalue);
                    };

                    this.onJSHideClick = function () {
                        _this.setState({
                            jsvisible: !_this.state.jsvisible
                        });
                    };

                    this.transpile = _.debounce(function (value) {
                        var jsoptions = _this.state.jsoptions;

                        try {
                            var transformation = Babel.transform(value, { stage: 0 });
                            _this.setState({
                                jsvalue: transformation.code,
                                jsoptions: _extends({}, jsoptions, { lineNumbers: true }),
                                jserror: false
                            });
                        } catch (error) {
                            _this.setState({
                                jsvalue: error.message,
                                jsoptions: _extends({}, jsoptions, { lineNumbers: false }),
                                jserror: true
                            });
                        }
                    }, 250);
                    this.saveState = _.debounce(function (value) {
                        if ("localStorage" in window && window["localStorage"] !== null) {
                            window.localStorage.setItem("savedES6Code", value);
                        }
                    }, 500);
                    if ("localStorage" in window && window["localStorage"] !== null) {
                        var savedState = window.localStorage.getItem("savedES6Code");
                        if (savedState !== null && savedState !== undefined) {
                            this.state.es6value = savedState;
                        }
                    }
                }

                _createClass(PlaygroundApp, [{
                    key: "render",
                    value: function render() {
                        var _state2 = this.state;
                        var es6value = _state2.es6value;
                        var jsvalue = _state2.jsvalue;
                        var viewportHeight = _state2.viewportHeight;
                        var viewportWidth = _state2.viewportWidth;
                        var es6options = _state2.es6options;
                        var jsoptions = _state2.jsoptions;
                        var jsvisible = _state2.jsvisible;

                        return React.createElement(
                            "div",
                            null,
                            React.createElement(
                                "table",
                                { className: "comparisonView" },
                                React.createElement(
                                    "tr",
                                    null,
                                    React.createElement(
                                        "td",
                                        { className: "editor" },
                                        React.createElement(CodeMirror, { value: es6value,
                                            options: es6options,
                                            onChange: this.onES6Change,
                                            height: viewportHeight,
                                            width: jsvisible ? Math.ceil(viewportWidth / 2) : viewportWidth })
                                    ),
                                    React.createElement(
                                        "td",
                                        { className: "editor", style: { display: jsvisible ? "inherit" : "none" } },
                                        React.createElement(CodeMirror, { value: jsvalue,
                                            options: jsoptions,
                                            onChange: this.onJSChange,
                                            height: viewportHeight,
                                            width: Math.floor(viewportWidth / 2) })
                                    )
                                ),
                                React.createElement(
                                    "tr",
                                    null,
                                    React.createElement(
                                        "td",
                                        { colSpan: 2 },
                                        React.createElement(OutputPane, null)
                                    )
                                )
                            ),
                            React.createElement(
                                "div",
                                { className: "controls" },
                                React.createElement(
                                    "div",
                                    { onClick: this.onJSHideClick },
                                    React.createElement("i", { className: "fa fa-code fa-lg" })
                                ),
                                React.createElement(
                                    "div",
                                    { onClick: this.onJSRunClick },
                                    React.createElement("i", { className: "fa fa-play-circle-o fa-lg" })
                                )
                            )
                        );
                    }
                }, {
                    key: "componentDidMount",
                    value: function componentDidMount() {
                        this.onResizeViewport();
                        window.addEventListener('resize', this.onResizeViewport);
                        this.onES6Change(this.state.es6value);
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function componentWillUnmount() {
                        window.removeEventListener('resize', this.onResizeViewport);
                    }
                }]);

                return PlaygroundApp;
            })(Component);

            _export("default", PlaygroundApp);
        }
    };
});
$__System.register("1", ["a1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9"], function (_export) {
  "use strict";

  var React, PlaygroundApp;
  return {
    setters: [function (_a1) {
      React = _a1["default"];
    }, function (_d2) {
      PlaygroundApp = _d2["default"];
    }, function (_d3) {}, function (_d4) {}, function (_d5) {}, function (_d6) {}, function (_d7) {}, function (_d8) {}, function (_d9) {}],
    execute: function () {

      React.render(React.createElement(PlaygroundApp, null), document.getElementById('root'));
    }
  };
});
$__System.register('Styles/reset.css!github:systemjs/plugin-css@0.1.18', [], false, function() {});
$__System.register('Styles/interactive.css!github:systemjs/plugin-css@0.1.18', [], false, function() {});
$__System.register('npm:codemirror@5.7.0/lib/codemirror.css!github:systemjs/plugin-css@0.1.18', [], false, function() {});
$__System.register('npm:codemirror@5.7.0/theme/monokai.css!github:systemjs/plugin-css@0.1.18', [], false, function() {});
$__System.register('npm:codemirror@5.7.0/theme/solarized.css!github:systemjs/plugin-css@0.1.18', [], false, function() {});
$__System.register('npm:font-awesome@4.4.0/css/font-awesome.css!github:systemjs/plugin-css@0.1.18', [], false, function() {});
$__System.register('github:twbs/bootstrap@3.3.5/css/bootstrap.css!github:systemjs/plugin-css@0.1.18', [], false, function() {});
(function(c){if (typeof document == 'undefined') return; var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
("a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}table{border-collapse:collapse;border-spacing:0}*{box-sizing:border-box}#root,body{height:100%;font-size:120%;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif}.comparisonView{width:100%;height:100%}.comparisonView tr{width:100%}.comparisonView tr td.editor{position:relative;width:50%;height:100%;vertical-align:top}.CodeMirror{height:100%}.controls{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;top:0;right:0;z-index:100;display:inline-block;color:#B6B6B6;padding:10px}.controls>div{display:inline-block;transition:all ease-in .3s;opacity:.5}.controls>div:hover{opacity:1;color:#FFC107;cursor:pointer}.controls>div:not(:last-child){margin-right:10px}.controls>i{display:inline-block}.CodeMirror{font-family:monospace;height:300px;color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper{-webkit-user-select:none;-moz-user-select:none;user-select:none}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}.cm-s-monokai.CodeMirror{background:#272822;color:#f8f8f2}.cm-s-monokai div.CodeMirror-selected{background:#49483E}.cm-s-monokai .CodeMirror-line::selection,.cm-s-monokai .CodeMirror-line>span::selection,.cm-s-monokai .CodeMirror-line>span>span::selection{background:rgba(73,72,62,.99)}.cm-s-monokai .CodeMirror-line::-moz-selection,.cm-s-monokai .CodeMirror-line>span::-moz-selection,.cm-s-monokai .CodeMirror-line>span>span::-moz-selection{background:rgba(73,72,62,.99)}.cm-s-monokai .CodeMirror-gutters{background:#272822;border-right:0}.cm-s-monokai .CodeMirror-guttermarker{color:#fff}.cm-s-monokai .CodeMirror-guttermarker-subtle{color:#d0d0d0}.cm-s-monokai .CodeMirror-linenumber{color:#d0d0d0}.cm-s-monokai .CodeMirror-cursor{border-left:1px solid #f8f8f0}.cm-s-monokai span.cm-comment{color:#75715e}.cm-s-monokai span.cm-atom{color:#ae81ff}.cm-s-monokai span.cm-number{color:#ae81ff}.cm-s-monokai span.cm-attribute,.cm-s-monokai span.cm-property{color:#a6e22e}.cm-s-monokai span.cm-keyword{color:#f92672}.cm-s-monokai span.cm-string{color:#e6db74}.cm-s-monokai span.cm-variable{color:#f8f8f2}.cm-s-monokai span.cm-variable-2{color:#9effff}.cm-s-monokai span.cm-variable-3{color:#66d9ef}.cm-s-monokai span.cm-def{color:#fd971f}.cm-s-monokai span.cm-bracket{color:#f8f8f2}.cm-s-monokai span.cm-tag{color:#f92672}.cm-s-monokai span.cm-header{color:#ae81ff}.cm-s-monokai span.cm-link{color:#ae81ff}.cm-s-monokai span.cm-error{background:#f92672;color:#f8f8f0}.cm-s-monokai .CodeMirror-activeline-background{background:#373831}.cm-s-monokai .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.solarized.base03{color:#002b36}.solarized.base02{color:#073642}.solarized.base01{color:#586e75}.solarized.base00{color:#657b83}.solarized.base0{color:#839496}.solarized.base1{color:#93a1a1}.solarized.base2{color:#eee8d5}.solarized.base3{color:#fdf6e3}.solarized.solar-yellow{color:#b58900}.solarized.solar-orange{color:#cb4b16}.solarized.solar-red{color:#dc322f}.solarized.solar-magenta{color:#d33682}.solarized.solar-violet{color:#6c71c4}.solarized.solar-blue{color:#268bd2}.solarized.solar-cyan{color:#2aa198}.solarized.solar-green{color:#859900}.cm-s-solarized{line-height:1.45em;color-profile:sRGB;rendering-intent:auto}.cm-s-solarized.cm-s-dark{color:#839496;background-color:#002b36;text-shadow:#002b36 0 1px}.cm-s-solarized.cm-s-light{background-color:#fdf6e3;color:#657b83;text-shadow:#eee8d5 0 1px}.cm-s-solarized .CodeMirror-widget{text-shadow:none}.cm-s-solarized .cm-header{color:#586e75}.cm-s-solarized .cm-quote{color:#93a1a1}.cm-s-solarized .cm-keyword{color:#cb4b16}.cm-s-solarized .cm-atom{color:#d33682}.cm-s-solarized .cm-number{color:#d33682}.cm-s-solarized .cm-def{color:#2aa198}.cm-s-solarized .cm-variable{color:#839496}.cm-s-solarized .cm-variable-2{color:#b58900}.cm-s-solarized .cm-variable-3{color:#6c71c4}.cm-s-solarized .cm-property{color:#2aa198}.cm-s-solarized .cm-operator{color:#6c71c4}.cm-s-solarized .cm-comment{color:#586e75;font-style:italic}.cm-s-solarized .cm-string{color:#859900}.cm-s-solarized .cm-string-2{color:#b58900}.cm-s-solarized .cm-meta{color:#859900}.cm-s-solarized .cm-qualifier{color:#b58900}.cm-s-solarized .cm-builtin{color:#d33682}.cm-s-solarized .cm-bracket{color:#cb4b16}.cm-s-solarized .CodeMirror-matchingbracket{color:#859900}.cm-s-solarized .CodeMirror-nonmatchingbracket{color:#dc322f}.cm-s-solarized .cm-tag{color:#93a1a1}.cm-s-solarized .cm-attribute{color:#2aa198}.cm-s-solarized .cm-hr{color:transparent;border-top:1px solid #586e75;display:block}.cm-s-solarized .cm-link{color:#93a1a1;cursor:pointer}.cm-s-solarized .cm-special{color:#6c71c4}.cm-s-solarized .cm-em{color:#999;text-decoration:underline;text-decoration-style:dotted}.cm-s-solarized .cm-strong{color:#eee}.cm-s-solarized .cm-error,.cm-s-solarized .cm-invalidchar{color:#586e75;border-bottom:1px dotted #dc322f}.cm-s-solarized.cm-s-dark div.CodeMirror-selected{background:#073642}.cm-s-solarized.cm-s-dark.CodeMirror ::selection{background:rgba(7,54,66,.99)}.cm-s-dark .CodeMirror-line>span::-moz-selection,.cm-s-dark .CodeMirror-line>span>span::-moz-selection,.cm-s-solarized.cm-s-dark .CodeMirror-line::-moz-selection{background:rgba(7,54,66,.99)}.cm-s-solarized.cm-s-light div.CodeMirror-selected{background:#eee8d5}.cm-s-light .CodeMirror-line>span::selection,.cm-s-light .CodeMirror-line>span>span::selection,.cm-s-solarized.cm-s-light .CodeMirror-line::selection{background:#eee8d5}.cm-s-ligh .CodeMirror-line>span::-moz-selection,.cm-s-ligh .CodeMirror-line>span>span::-moz-selection,.cm-s-solarized.cm-s-light .CodeMirror-line::-moz-selection{background:#eee8d5}.cm-s-solarized.CodeMirror{-moz-box-shadow:inset 7px 0 12px -6px #000;-webkit-box-shadow:inset 7px 0 12px -6px #000;box-shadow:inset 7px 0 12px -6px #000}.cm-s-solarized .CodeMirror-gutters{border-right:1px solid}.cm-s-solarized.cm-s-dark .CodeMirror-gutters{background-color:#002b36;border-color:#00232c}.cm-s-solarized.cm-s-dark .CodeMirror-linenumber{text-shadow:#021014 0 -1px}.cm-s-solarized.cm-s-light .CodeMirror-gutters{background-color:#fdf6e3;border-color:#eee8d5}.cm-s-solarized .CodeMirror-linenumber{color:#586e75;padding:0 5px}.cm-s-solarized .CodeMirror-guttermarker-subtle{color:#586e75}.cm-s-solarized.cm-s-dark .CodeMirror-guttermarker{color:#ddd}.cm-s-solarized.cm-s-light .CodeMirror-guttermarker{color:#cb4b16}.cm-s-solarized .CodeMirror-gutter .CodeMirror-gutter-text{color:#586e75}.cm-s-solarized .CodeMirror-cursor{border-left:1px solid #819090}.cm-s-solarized.cm-s-dark .CodeMirror-activeline-background{background:rgba(255,255,255,.1)}.cm-s-solarized.cm-s-light .CodeMirror-activeline-background{background:rgba(0,0,0,.1)}/*!\n *  Font Awesome 4.4.0 by @davegandy - http://fontawesome.io - @fontawesome\n *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)\n */@font-face{font-family:FontAwesome;src:url(jspm_packages/npm/font-awesome@4.4.0/fonts/fontawesome-webfont.eot?v=4.4.0);src:url(jspm_packages/npm/font-awesome@4.4.0/fonts/fontawesome-webfont.eot?#iefix&v=4.4.0) format('embedded-opentype'),url(jspm_packages/npm/font-awesome@4.4.0/fonts/fontawesome-webfont.woff2?v=4.4.0) format('woff2'),url(jspm_packages/npm/font-awesome@4.4.0/fonts/fontawesome-webfont.woff?v=4.4.0) format('woff'),url(jspm_packages/npm/font-awesome@4.4.0/fonts/fontawesome-webfont.ttf?v=4.4.0) format('truetype'),url(jspm_packages/npm/font-awesome@4.4.0/fonts/fontawesome-webfont.svg?v=4.4.0#fontawesomeregular) format('svg');font-weight:400;font-style:normal}.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.28571429em;text-align:center}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center}.fa-li.fa-lg{left:-1.85714286em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fa-rotate-90{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=1);-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=2);-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=3);-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);-webkit-transform:scale(-1,1);-ms-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);-webkit-transform:scale(1,-1);-ms-transform:scale(1,-1);transform:scale(1,-1)}:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-rotate-90{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:\"\\f000\"}.fa-music:before{content:\"\\f001\"}.fa-search:before{content:\"\\f002\"}.fa-envelope-o:before{content:\"\\f003\"}.fa-heart:before{content:\"\\f004\"}.fa-star:before{content:\"\\f005\"}.fa-star-o:before{content:\"\\f006\"}.fa-user:before{content:\"\\f007\"}.fa-film:before{content:\"\\f008\"}.fa-th-large:before{content:\"\\f009\"}.fa-th:before{content:\"\\f00a\"}.fa-th-list:before{content:\"\\f00b\"}.fa-check:before{content:\"\\f00c\"}.fa-close:before,.fa-remove:before,.fa-times:before{content:\"\\f00d\"}.fa-search-plus:before{content:\"\\f00e\"}.fa-search-minus:before{content:\"\\f010\"}.fa-power-off:before{content:\"\\f011\"}.fa-signal:before{content:\"\\f012\"}.fa-cog:before,.fa-gear:before{content:\"\\f013\"}.fa-trash-o:before{content:\"\\f014\"}.fa-home:before{content:\"\\f015\"}.fa-file-o:before{content:\"\\f016\"}.fa-clock-o:before{content:\"\\f017\"}.fa-road:before{content:\"\\f018\"}.fa-download:before{content:\"\\f019\"}.fa-arrow-circle-o-down:before{content:\"\\f01a\"}.fa-arrow-circle-o-up:before{content:\"\\f01b\"}.fa-inbox:before{content:\"\\f01c\"}.fa-play-circle-o:before{content:\"\\f01d\"}.fa-repeat:before,.fa-rotate-right:before{content:\"\\f01e\"}.fa-refresh:before{content:\"\\f021\"}.fa-list-alt:before{content:\"\\f022\"}.fa-lock:before{content:\"\\f023\"}.fa-flag:before{content:\"\\f024\"}.fa-headphones:before{content:\"\\f025\"}.fa-volume-off:before{content:\"\\f026\"}.fa-volume-down:before{content:\"\\f027\"}.fa-volume-up:before{content:\"\\f028\"}.fa-qrcode:before{content:\"\\f029\"}.fa-barcode:before{content:\"\\f02a\"}.fa-tag:before{content:\"\\f02b\"}.fa-tags:before{content:\"\\f02c\"}.fa-book:before{content:\"\\f02d\"}.fa-bookmark:before{content:\"\\f02e\"}.fa-print:before{content:\"\\f02f\"}.fa-camera:before{content:\"\\f030\"}.fa-font:before{content:\"\\f031\"}.fa-bold:before{content:\"\\f032\"}.fa-italic:before{content:\"\\f033\"}.fa-text-height:before{content:\"\\f034\"}.fa-text-width:before{content:\"\\f035\"}.fa-align-left:before{content:\"\\f036\"}.fa-align-center:before{content:\"\\f037\"}.fa-align-right:before{content:\"\\f038\"}.fa-align-justify:before{content:\"\\f039\"}.fa-list:before{content:\"\\f03a\"}.fa-dedent:before,.fa-outdent:before{content:\"\\f03b\"}.fa-indent:before{content:\"\\f03c\"}.fa-video-camera:before{content:\"\\f03d\"}.fa-image:before,.fa-photo:before,.fa-picture-o:before{content:\"\\f03e\"}.fa-pencil:before{content:\"\\f040\"}.fa-map-marker:before{content:\"\\f041\"}.fa-adjust:before{content:\"\\f042\"}.fa-tint:before{content:\"\\f043\"}.fa-edit:before,.fa-pencil-square-o:before{content:\"\\f044\"}.fa-share-square-o:before{content:\"\\f045\"}.fa-check-square-o:before{content:\"\\f046\"}.fa-arrows:before{content:\"\\f047\"}.fa-step-backward:before{content:\"\\f048\"}.fa-fast-backward:before{content:\"\\f049\"}.fa-backward:before{content:\"\\f04a\"}.fa-play:before{content:\"\\f04b\"}.fa-pause:before{content:\"\\f04c\"}.fa-stop:before{content:\"\\f04d\"}.fa-forward:before{content:\"\\f04e\"}.fa-fast-forward:before{content:\"\\f050\"}.fa-step-forward:before{content:\"\\f051\"}.fa-eject:before{content:\"\\f052\"}.fa-chevron-left:before{content:\"\\f053\"}.fa-chevron-right:before{content:\"\\f054\"}.fa-plus-circle:before{content:\"\\f055\"}.fa-minus-circle:before{content:\"\\f056\"}.fa-times-circle:before{content:\"\\f057\"}.fa-check-circle:before{content:\"\\f058\"}.fa-question-circle:before{content:\"\\f059\"}.fa-info-circle:before{content:\"\\f05a\"}.fa-crosshairs:before{content:\"\\f05b\"}.fa-times-circle-o:before{content:\"\\f05c\"}.fa-check-circle-o:before{content:\"\\f05d\"}.fa-ban:before{content:\"\\f05e\"}.fa-arrow-left:before{content:\"\\f060\"}.fa-arrow-right:before{content:\"\\f061\"}.fa-arrow-up:before{content:\"\\f062\"}.fa-arrow-down:before{content:\"\\f063\"}.fa-mail-forward:before,.fa-share:before{content:\"\\f064\"}.fa-expand:before{content:\"\\f065\"}.fa-compress:before{content:\"\\f066\"}.fa-plus:before{content:\"\\f067\"}.fa-minus:before{content:\"\\f068\"}.fa-asterisk:before{content:\"\\f069\"}.fa-exclamation-circle:before{content:\"\\f06a\"}.fa-gift:before{content:\"\\f06b\"}.fa-leaf:before{content:\"\\f06c\"}.fa-fire:before{content:\"\\f06d\"}.fa-eye:before{content:\"\\f06e\"}.fa-eye-slash:before{content:\"\\f070\"}.fa-exclamation-triangle:before,.fa-warning:before{content:\"\\f071\"}.fa-plane:before{content:\"\\f072\"}.fa-calendar:before{content:\"\\f073\"}.fa-random:before{content:\"\\f074\"}.fa-comment:before{content:\"\\f075\"}.fa-magnet:before{content:\"\\f076\"}.fa-chevron-up:before{content:\"\\f077\"}.fa-chevron-down:before{content:\"\\f078\"}.fa-retweet:before{content:\"\\f079\"}.fa-shopping-cart:before{content:\"\\f07a\"}.fa-folder:before{content:\"\\f07b\"}.fa-folder-open:before{content:\"\\f07c\"}.fa-arrows-v:before{content:\"\\f07d\"}.fa-arrows-h:before{content:\"\\f07e\"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:\"\\f080\"}.fa-twitter-square:before{content:\"\\f081\"}.fa-facebook-square:before{content:\"\\f082\"}.fa-camera-retro:before{content:\"\\f083\"}.fa-key:before{content:\"\\f084\"}.fa-cogs:before,.fa-gears:before{content:\"\\f085\"}.fa-comments:before{content:\"\\f086\"}.fa-thumbs-o-up:before{content:\"\\f087\"}.fa-thumbs-o-down:before{content:\"\\f088\"}.fa-star-half:before{content:\"\\f089\"}.fa-heart-o:before{content:\"\\f08a\"}.fa-sign-out:before{content:\"\\f08b\"}.fa-linkedin-square:before{content:\"\\f08c\"}.fa-thumb-tack:before{content:\"\\f08d\"}.fa-external-link:before{content:\"\\f08e\"}.fa-sign-in:before{content:\"\\f090\"}.fa-trophy:before{content:\"\\f091\"}.fa-github-square:before{content:\"\\f092\"}.fa-upload:before{content:\"\\f093\"}.fa-lemon-o:before{content:\"\\f094\"}.fa-phone:before{content:\"\\f095\"}.fa-square-o:before{content:\"\\f096\"}.fa-bookmark-o:before{content:\"\\f097\"}.fa-phone-square:before{content:\"\\f098\"}.fa-twitter:before{content:\"\\f099\"}.fa-facebook-f:before,.fa-facebook:before{content:\"\\f09a\"}.fa-github:before{content:\"\\f09b\"}.fa-unlock:before{content:\"\\f09c\"}.fa-credit-card:before{content:\"\\f09d\"}.fa-feed:before,.fa-rss:before{content:\"\\f09e\"}.fa-hdd-o:before{content:\"\\f0a0\"}.fa-bullhorn:before{content:\"\\f0a1\"}.fa-bell:before{content:\"\\f0f3\"}.fa-certificate:before{content:\"\\f0a3\"}.fa-hand-o-right:before{content:\"\\f0a4\"}.fa-hand-o-left:before{content:\"\\f0a5\"}.fa-hand-o-up:before{content:\"\\f0a6\"}.fa-hand-o-down:before{content:\"\\f0a7\"}.fa-arrow-circle-left:before{content:\"\\f0a8\"}.fa-arrow-circle-right:before{content:\"\\f0a9\"}.fa-arrow-circle-up:before{content:\"\\f0aa\"}.fa-arrow-circle-down:before{content:\"\\f0ab\"}.fa-globe:before{content:\"\\f0ac\"}.fa-wrench:before{content:\"\\f0ad\"}.fa-tasks:before{content:\"\\f0ae\"}.fa-filter:before{content:\"\\f0b0\"}.fa-briefcase:before{content:\"\\f0b1\"}.fa-arrows-alt:before{content:\"\\f0b2\"}.fa-group:before,.fa-users:before{content:\"\\f0c0\"}.fa-chain:before,.fa-link:before{content:\"\\f0c1\"}.fa-cloud:before{content:\"\\f0c2\"}.fa-flask:before{content:\"\\f0c3\"}.fa-cut:before,.fa-scissors:before{content:\"\\f0c4\"}.fa-copy:before,.fa-files-o:before{content:\"\\f0c5\"}.fa-paperclip:before{content:\"\\f0c6\"}.fa-floppy-o:before,.fa-save:before{content:\"\\f0c7\"}.fa-square:before{content:\"\\f0c8\"}.fa-bars:before,.fa-navicon:before,.fa-reorder:before{content:\"\\f0c9\"}.fa-list-ul:before{content:\"\\f0ca\"}.fa-list-ol:before{content:\"\\f0cb\"}.fa-strikethrough:before{content:\"\\f0cc\"}.fa-underline:before{content:\"\\f0cd\"}.fa-table:before{content:\"\\f0ce\"}.fa-magic:before{content:\"\\f0d0\"}.fa-truck:before{content:\"\\f0d1\"}.fa-pinterest:before{content:\"\\f0d2\"}.fa-pinterest-square:before{content:\"\\f0d3\"}.fa-google-plus-square:before{content:\"\\f0d4\"}.fa-google-plus:before{content:\"\\f0d5\"}.fa-money:before{content:\"\\f0d6\"}.fa-caret-down:before{content:\"\\f0d7\"}.fa-caret-up:before{content:\"\\f0d8\"}.fa-caret-left:before{content:\"\\f0d9\"}.fa-caret-right:before{content:\"\\f0da\"}.fa-columns:before{content:\"\\f0db\"}.fa-sort:before,.fa-unsorted:before{content:\"\\f0dc\"}.fa-sort-desc:before,.fa-sort-down:before{content:\"\\f0dd\"}.fa-sort-asc:before,.fa-sort-up:before{content:\"\\f0de\"}.fa-envelope:before{content:\"\\f0e0\"}.fa-linkedin:before{content:\"\\f0e1\"}.fa-rotate-left:before,.fa-undo:before{content:\"\\f0e2\"}.fa-gavel:before,.fa-legal:before{content:\"\\f0e3\"}.fa-dashboard:before,.fa-tachometer:before{content:\"\\f0e4\"}.fa-comment-o:before{content:\"\\f0e5\"}.fa-comments-o:before{content:\"\\f0e6\"}.fa-bolt:before,.fa-flash:before{content:\"\\f0e7\"}.fa-sitemap:before{content:\"\\f0e8\"}.fa-umbrella:before{content:\"\\f0e9\"}.fa-clipboard:before,.fa-paste:before{content:\"\\f0ea\"}.fa-lightbulb-o:before{content:\"\\f0eb\"}.fa-exchange:before{content:\"\\f0ec\"}.fa-cloud-download:before{content:\"\\f0ed\"}.fa-cloud-upload:before{content:\"\\f0ee\"}.fa-user-md:before{content:\"\\f0f0\"}.fa-stethoscope:before{content:\"\\f0f1\"}.fa-suitcase:before{content:\"\\f0f2\"}.fa-bell-o:before{content:\"\\f0a2\"}.fa-coffee:before{content:\"\\f0f4\"}.fa-cutlery:before{content:\"\\f0f5\"}.fa-file-text-o:before{content:\"\\f0f6\"}.fa-building-o:before{content:\"\\f0f7\"}.fa-hospital-o:before{content:\"\\f0f8\"}.fa-ambulance:before{content:\"\\f0f9\"}.fa-medkit:before{content:\"\\f0fa\"}.fa-fighter-jet:before{content:\"\\f0fb\"}.fa-beer:before{content:\"\\f0fc\"}.fa-h-square:before{content:\"\\f0fd\"}.fa-plus-square:before{content:\"\\f0fe\"}.fa-angle-double-left:before{content:\"\\f100\"}.fa-angle-double-right:before{content:\"\\f101\"}.fa-angle-double-up:before{content:\"\\f102\"}.fa-angle-double-down:before{content:\"\\f103\"}.fa-angle-left:before{content:\"\\f104\"}.fa-angle-right:before{content:\"\\f105\"}.fa-angle-up:before{content:\"\\f106\"}.fa-angle-down:before{content:\"\\f107\"}.fa-desktop:before{content:\"\\f108\"}.fa-laptop:before{content:\"\\f109\"}.fa-tablet:before{content:\"\\f10a\"}.fa-mobile-phone:before,.fa-mobile:before{content:\"\\f10b\"}.fa-circle-o:before{content:\"\\f10c\"}.fa-quote-left:before{content:\"\\f10d\"}.fa-quote-right:before{content:\"\\f10e\"}.fa-spinner:before{content:\"\\f110\"}.fa-circle:before{content:\"\\f111\"}.fa-mail-reply:before,.fa-reply:before{content:\"\\f112\"}.fa-github-alt:before{content:\"\\f113\"}.fa-folder-o:before{content:\"\\f114\"}.fa-folder-open-o:before{content:\"\\f115\"}.fa-smile-o:before{content:\"\\f118\"}.fa-frown-o:before{content:\"\\f119\"}.fa-meh-o:before{content:\"\\f11a\"}.fa-gamepad:before{content:\"\\f11b\"}.fa-keyboard-o:before{content:\"\\f11c\"}.fa-flag-o:before{content:\"\\f11d\"}.fa-flag-checkered:before{content:\"\\f11e\"}.fa-terminal:before{content:\"\\f120\"}.fa-code:before{content:\"\\f121\"}.fa-mail-reply-all:before,.fa-reply-all:before{content:\"\\f122\"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:\"\\f123\"}.fa-location-arrow:before{content:\"\\f124\"}.fa-crop:before{content:\"\\f125\"}.fa-code-fork:before{content:\"\\f126\"}.fa-chain-broken:before,.fa-unlink:before{content:\"\\f127\"}.fa-question:before{content:\"\\f128\"}.fa-info:before{content:\"\\f129\"}.fa-exclamation:before{content:\"\\f12a\"}.fa-superscript:before{content:\"\\f12b\"}.fa-subscript:before{content:\"\\f12c\"}.fa-eraser:before{content:\"\\f12d\"}.fa-puzzle-piece:before{content:\"\\f12e\"}.fa-microphone:before{content:\"\\f130\"}.fa-microphone-slash:before{content:\"\\f131\"}.fa-shield:before{content:\"\\f132\"}.fa-calendar-o:before{content:\"\\f133\"}.fa-fire-extinguisher:before{content:\"\\f134\"}.fa-rocket:before{content:\"\\f135\"}.fa-maxcdn:before{content:\"\\f136\"}.fa-chevron-circle-left:before{content:\"\\f137\"}.fa-chevron-circle-right:before{content:\"\\f138\"}.fa-chevron-circle-up:before{content:\"\\f139\"}.fa-chevron-circle-down:before{content:\"\\f13a\"}.fa-html5:before{content:\"\\f13b\"}.fa-css3:before{content:\"\\f13c\"}.fa-anchor:before{content:\"\\f13d\"}.fa-unlock-alt:before{content:\"\\f13e\"}.fa-bullseye:before{content:\"\\f140\"}.fa-ellipsis-h:before{content:\"\\f141\"}.fa-ellipsis-v:before{content:\"\\f142\"}.fa-rss-square:before{content:\"\\f143\"}.fa-play-circle:before{content:\"\\f144\"}.fa-ticket:before{content:\"\\f145\"}.fa-minus-square:before{content:\"\\f146\"}.fa-minus-square-o:before{content:\"\\f147\"}.fa-level-up:before{content:\"\\f148\"}.fa-level-down:before{content:\"\\f149\"}.fa-check-square:before{content:\"\\f14a\"}.fa-pencil-square:before{content:\"\\f14b\"}.fa-external-link-square:before{content:\"\\f14c\"}.fa-share-square:before{content:\"\\f14d\"}.fa-compass:before{content:\"\\f14e\"}.fa-caret-square-o-down:before,.fa-toggle-down:before{content:\"\\f150\"}.fa-caret-square-o-up:before,.fa-toggle-up:before{content:\"\\f151\"}.fa-caret-square-o-right:before,.fa-toggle-right:before{content:\"\\f152\"}.fa-eur:before,.fa-euro:before{content:\"\\f153\"}.fa-gbp:before{content:\"\\f154\"}.fa-dollar:before,.fa-usd:before{content:\"\\f155\"}.fa-inr:before,.fa-rupee:before{content:\"\\f156\"}.fa-cny:before,.fa-jpy:before,.fa-rmb:before,.fa-yen:before{content:\"\\f157\"}.fa-rouble:before,.fa-rub:before,.fa-ruble:before{content:\"\\f158\"}.fa-krw:before,.fa-won:before{content:\"\\f159\"}.fa-bitcoin:before,.fa-btc:before{content:\"\\f15a\"}.fa-file:before{content:\"\\f15b\"}.fa-file-text:before{content:\"\\f15c\"}.fa-sort-alpha-asc:before{content:\"\\f15d\"}.fa-sort-alpha-desc:before{content:\"\\f15e\"}.fa-sort-amount-asc:before{content:\"\\f160\"}.fa-sort-amount-desc:before{content:\"\\f161\"}.fa-sort-numeric-asc:before{content:\"\\f162\"}.fa-sort-numeric-desc:before{content:\"\\f163\"}.fa-thumbs-up:before{content:\"\\f164\"}.fa-thumbs-down:before{content:\"\\f165\"}.fa-youtube-square:before{content:\"\\f166\"}.fa-youtube:before{content:\"\\f167\"}.fa-xing:before{content:\"\\f168\"}.fa-xing-square:before{content:\"\\f169\"}.fa-youtube-play:before{content:\"\\f16a\"}.fa-dropbox:before{content:\"\\f16b\"}.fa-stack-overflow:before{content:\"\\f16c\"}.fa-instagram:before{content:\"\\f16d\"}.fa-flickr:before{content:\"\\f16e\"}.fa-adn:before{content:\"\\f170\"}.fa-bitbucket:before{content:\"\\f171\"}.fa-bitbucket-square:before{content:\"\\f172\"}.fa-tumblr:before{content:\"\\f173\"}.fa-tumblr-square:before{content:\"\\f174\"}.fa-long-arrow-down:before{content:\"\\f175\"}.fa-long-arrow-up:before{content:\"\\f176\"}.fa-long-arrow-left:before{content:\"\\f177\"}.fa-long-arrow-right:before{content:\"\\f178\"}.fa-apple:before{content:\"\\f179\"}.fa-windows:before{content:\"\\f17a\"}.fa-android:before{content:\"\\f17b\"}.fa-linux:before{content:\"\\f17c\"}.fa-dribbble:before{content:\"\\f17d\"}.fa-skype:before{content:\"\\f17e\"}.fa-foursquare:before{content:\"\\f180\"}.fa-trello:before{content:\"\\f181\"}.fa-female:before{content:\"\\f182\"}.fa-male:before{content:\"\\f183\"}.fa-gittip:before,.fa-gratipay:before{content:\"\\f184\"}.fa-sun-o:before{content:\"\\f185\"}.fa-moon-o:before{content:\"\\f186\"}.fa-archive:before{content:\"\\f187\"}.fa-bug:before{content:\"\\f188\"}.fa-vk:before{content:\"\\f189\"}.fa-weibo:before{content:\"\\f18a\"}.fa-renren:before{content:\"\\f18b\"}.fa-pagelines:before{content:\"\\f18c\"}.fa-stack-exchange:before{content:\"\\f18d\"}.fa-arrow-circle-o-right:before{content:\"\\f18e\"}.fa-arrow-circle-o-left:before{content:\"\\f190\"}.fa-caret-square-o-left:before,.fa-toggle-left:before{content:\"\\f191\"}.fa-dot-circle-o:before{content:\"\\f192\"}.fa-wheelchair:before{content:\"\\f193\"}.fa-vimeo-square:before{content:\"\\f194\"}.fa-try:before,.fa-turkish-lira:before{content:\"\\f195\"}.fa-plus-square-o:before{content:\"\\f196\"}.fa-space-shuttle:before{content:\"\\f197\"}.fa-slack:before{content:\"\\f198\"}.fa-envelope-square:before{content:\"\\f199\"}.fa-wordpress:before{content:\"\\f19a\"}.fa-openid:before{content:\"\\f19b\"}.fa-bank:before,.fa-institution:before,.fa-university:before{content:\"\\f19c\"}.fa-graduation-cap:before,.fa-mortar-board:before{content:\"\\f19d\"}.fa-yahoo:before{content:\"\\f19e\"}.fa-google:before{content:\"\\f1a0\"}.fa-reddit:before{content:\"\\f1a1\"}.fa-reddit-square:before{content:\"\\f1a2\"}.fa-stumbleupon-circle:before{content:\"\\f1a3\"}.fa-stumbleupon:before{content:\"\\f1a4\"}.fa-delicious:before{content:\"\\f1a5\"}.fa-digg:before{content:\"\\f1a6\"}.fa-pied-piper:before{content:\"\\f1a7\"}.fa-pied-piper-alt:before{content:\"\\f1a8\"}.fa-drupal:before{content:\"\\f1a9\"}.fa-joomla:before{content:\"\\f1aa\"}.fa-language:before{content:\"\\f1ab\"}.fa-fax:before{content:\"\\f1ac\"}.fa-building:before{content:\"\\f1ad\"}.fa-child:before{content:\"\\f1ae\"}.fa-paw:before{content:\"\\f1b0\"}.fa-spoon:before{content:\"\\f1b1\"}.fa-cube:before{content:\"\\f1b2\"}.fa-cubes:before{content:\"\\f1b3\"}.fa-behance:before{content:\"\\f1b4\"}.fa-behance-square:before{content:\"\\f1b5\"}.fa-steam:before{content:\"\\f1b6\"}.fa-steam-square:before{content:\"\\f1b7\"}.fa-recycle:before{content:\"\\f1b8\"}.fa-automobile:before,.fa-car:before{content:\"\\f1b9\"}.fa-cab:before,.fa-taxi:before{content:\"\\f1ba\"}.fa-tree:before{content:\"\\f1bb\"}.fa-spotify:before{content:\"\\f1bc\"}.fa-deviantart:before{content:\"\\f1bd\"}.fa-soundcloud:before{content:\"\\f1be\"}.fa-database:before{content:\"\\f1c0\"}.fa-file-pdf-o:before{content:\"\\f1c1\"}.fa-file-word-o:before{content:\"\\f1c2\"}.fa-file-excel-o:before{content:\"\\f1c3\"}.fa-file-powerpoint-o:before{content:\"\\f1c4\"}.fa-file-image-o:before,.fa-file-photo-o:before,.fa-file-picture-o:before{content:\"\\f1c5\"}.fa-file-archive-o:before,.fa-file-zip-o:before{content:\"\\f1c6\"}.fa-file-audio-o:before,.fa-file-sound-o:before{content:\"\\f1c7\"}.fa-file-movie-o:before,.fa-file-video-o:before{content:\"\\f1c8\"}.fa-file-code-o:before{content:\"\\f1c9\"}.fa-vine:before{content:\"\\f1ca\"}.fa-codepen:before{content:\"\\f1cb\"}.fa-jsfiddle:before{content:\"\\f1cc\"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-ring:before,.fa-life-saver:before,.fa-support:before{content:\"\\f1cd\"}.fa-circle-o-notch:before{content:\"\\f1ce\"}.fa-ra:before,.fa-rebel:before{content:\"\\f1d0\"}.fa-empire:before,.fa-ge:before{content:\"\\f1d1\"}.fa-git-square:before{content:\"\\f1d2\"}.fa-git:before{content:\"\\f1d3\"}.fa-hacker-news:before,.fa-y-combinator-square:before,.fa-yc-square:before{content:\"\\f1d4\"}.fa-tencent-weibo:before{content:\"\\f1d5\"}.fa-qq:before{content:\"\\f1d6\"}.fa-wechat:before,.fa-weixin:before{content:\"\\f1d7\"}.fa-paper-plane:before,.fa-send:before{content:\"\\f1d8\"}.fa-paper-plane-o:before,.fa-send-o:before{content:\"\\f1d9\"}.fa-history:before{content:\"\\f1da\"}.fa-circle-thin:before{content:\"\\f1db\"}.fa-header:before{content:\"\\f1dc\"}.fa-paragraph:before{content:\"\\f1dd\"}.fa-sliders:before{content:\"\\f1de\"}.fa-share-alt:before{content:\"\\f1e0\"}.fa-share-alt-square:before{content:\"\\f1e1\"}.fa-bomb:before{content:\"\\f1e2\"}.fa-futbol-o:before,.fa-soccer-ball-o:before{content:\"\\f1e3\"}.fa-tty:before{content:\"\\f1e4\"}.fa-binoculars:before{content:\"\\f1e5\"}.fa-plug:before{content:\"\\f1e6\"}.fa-slideshare:before{content:\"\\f1e7\"}.fa-twitch:before{content:\"\\f1e8\"}.fa-yelp:before{content:\"\\f1e9\"}.fa-newspaper-o:before{content:\"\\f1ea\"}.fa-wifi:before{content:\"\\f1eb\"}.fa-calculator:before{content:\"\\f1ec\"}.fa-paypal:before{content:\"\\f1ed\"}.fa-google-wallet:before{content:\"\\f1ee\"}.fa-cc-visa:before{content:\"\\f1f0\"}.fa-cc-mastercard:before{content:\"\\f1f1\"}.fa-cc-discover:before{content:\"\\f1f2\"}.fa-cc-amex:before{content:\"\\f1f3\"}.fa-cc-paypal:before{content:\"\\f1f4\"}.fa-cc-stripe:before{content:\"\\f1f5\"}.fa-bell-slash:before{content:\"\\f1f6\"}.fa-bell-slash-o:before{content:\"\\f1f7\"}.fa-trash:before{content:\"\\f1f8\"}.fa-copyright:before{content:\"\\f1f9\"}.fa-at:before{content:\"\\f1fa\"}.fa-eyedropper:before{content:\"\\f1fb\"}.fa-paint-brush:before{content:\"\\f1fc\"}.fa-birthday-cake:before{content:\"\\f1fd\"}.fa-area-chart:before{content:\"\\f1fe\"}.fa-pie-chart:before{content:\"\\f200\"}.fa-line-chart:before{content:\"\\f201\"}.fa-lastfm:before{content:\"\\f202\"}.fa-lastfm-square:before{content:\"\\f203\"}.fa-toggle-off:before{content:\"\\f204\"}.fa-toggle-on:before{content:\"\\f205\"}.fa-bicycle:before{content:\"\\f206\"}.fa-bus:before{content:\"\\f207\"}.fa-ioxhost:before{content:\"\\f208\"}.fa-angellist:before{content:\"\\f209\"}.fa-cc:before{content:\"\\f20a\"}.fa-ils:before,.fa-shekel:before,.fa-sheqel:before{content:\"\\f20b\"}.fa-meanpath:before{content:\"\\f20c\"}.fa-buysellads:before{content:\"\\f20d\"}.fa-connectdevelop:before{content:\"\\f20e\"}.fa-dashcube:before{content:\"\\f210\"}.fa-forumbee:before{content:\"\\f211\"}.fa-leanpub:before{content:\"\\f212\"}.fa-sellsy:before{content:\"\\f213\"}.fa-shirtsinbulk:before{content:\"\\f214\"}.fa-simplybuilt:before{content:\"\\f215\"}.fa-skyatlas:before{content:\"\\f216\"}.fa-cart-plus:before{content:\"\\f217\"}.fa-cart-arrow-down:before{content:\"\\f218\"}.fa-diamond:before{content:\"\\f219\"}.fa-ship:before{content:\"\\f21a\"}.fa-user-secret:before{content:\"\\f21b\"}.fa-motorcycle:before{content:\"\\f21c\"}.fa-street-view:before{content:\"\\f21d\"}.fa-heartbeat:before{content:\"\\f21e\"}.fa-venus:before{content:\"\\f221\"}.fa-mars:before{content:\"\\f222\"}.fa-mercury:before{content:\"\\f223\"}.fa-intersex:before,.fa-transgender:before{content:\"\\f224\"}.fa-transgender-alt:before{content:\"\\f225\"}.fa-venus-double:before{content:\"\\f226\"}.fa-mars-double:before{content:\"\\f227\"}.fa-venus-mars:before{content:\"\\f228\"}.fa-mars-stroke:before{content:\"\\f229\"}.fa-mars-stroke-v:before{content:\"\\f22a\"}.fa-mars-stroke-h:before{content:\"\\f22b\"}.fa-neuter:before{content:\"\\f22c\"}.fa-genderless:before{content:\"\\f22d\"}.fa-facebook-official:before{content:\"\\f230\"}.fa-pinterest-p:before{content:\"\\f231\"}.fa-whatsapp:before{content:\"\\f232\"}.fa-server:before{content:\"\\f233\"}.fa-user-plus:before{content:\"\\f234\"}.fa-user-times:before{content:\"\\f235\"}.fa-bed:before,.fa-hotel:before{content:\"\\f236\"}.fa-viacoin:before{content:\"\\f237\"}.fa-train:before{content:\"\\f238\"}.fa-subway:before{content:\"\\f239\"}.fa-medium:before{content:\"\\f23a\"}.fa-y-combinator:before,.fa-yc:before{content:\"\\f23b\"}.fa-optin-monster:before{content:\"\\f23c\"}.fa-opencart:before{content:\"\\f23d\"}.fa-expeditedssl:before{content:\"\\f23e\"}.fa-battery-4:before,.fa-battery-full:before{content:\"\\f240\"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:\"\\f241\"}.fa-battery-2:before,.fa-battery-half:before{content:\"\\f242\"}.fa-battery-1:before,.fa-battery-quarter:before{content:\"\\f243\"}.fa-battery-0:before,.fa-battery-empty:before{content:\"\\f244\"}.fa-mouse-pointer:before{content:\"\\f245\"}.fa-i-cursor:before{content:\"\\f246\"}.fa-object-group:before{content:\"\\f247\"}.fa-object-ungroup:before{content:\"\\f248\"}.fa-sticky-note:before{content:\"\\f249\"}.fa-sticky-note-o:before{content:\"\\f24a\"}.fa-cc-jcb:before{content:\"\\f24b\"}.fa-cc-diners-club:before{content:\"\\f24c\"}.fa-clone:before{content:\"\\f24d\"}.fa-balance-scale:before{content:\"\\f24e\"}.fa-hourglass-o:before{content:\"\\f250\"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:\"\\f251\"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:\"\\f252\"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:\"\\f253\"}.fa-hourglass:before{content:\"\\f254\"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:\"\\f255\"}.fa-hand-paper-o:before,.fa-hand-stop-o:before{content:\"\\f256\"}.fa-hand-scissors-o:before{content:\"\\f257\"}.fa-hand-lizard-o:before{content:\"\\f258\"}.fa-hand-spock-o:before{content:\"\\f259\"}.fa-hand-pointer-o:before{content:\"\\f25a\"}.fa-hand-peace-o:before{content:\"\\f25b\"}.fa-trademark:before{content:\"\\f25c\"}.fa-registered:before{content:\"\\f25d\"}.fa-creative-commons:before{content:\"\\f25e\"}.fa-gg:before{content:\"\\f260\"}.fa-gg-circle:before{content:\"\\f261\"}.fa-tripadvisor:before{content:\"\\f262\"}.fa-odnoklassniki:before{content:\"\\f263\"}.fa-odnoklassniki-square:before{content:\"\\f264\"}.fa-get-pocket:before{content:\"\\f265\"}.fa-wikipedia-w:before{content:\"\\f266\"}.fa-safari:before{content:\"\\f267\"}.fa-chrome:before{content:\"\\f268\"}.fa-firefox:before{content:\"\\f269\"}.fa-opera:before{content:\"\\f26a\"}.fa-internet-explorer:before{content:\"\\f26b\"}.fa-television:before,.fa-tv:before{content:\"\\f26c\"}.fa-contao:before{content:\"\\f26d\"}.fa-500px:before{content:\"\\f26e\"}.fa-amazon:before{content:\"\\f270\"}.fa-calendar-plus-o:before{content:\"\\f271\"}.fa-calendar-minus-o:before{content:\"\\f272\"}.fa-calendar-times-o:before{content:\"\\f273\"}.fa-calendar-check-o:before{content:\"\\f274\"}.fa-industry:before{content:\"\\f275\"}.fa-map-pin:before{content:\"\\f276\"}.fa-map-signs:before{content:\"\\f277\"}.fa-map-o:before{content:\"\\f278\"}.fa-map:before{content:\"\\f279\"}.fa-commenting:before{content:\"\\f27a\"}.fa-commenting-o:before{content:\"\\f27b\"}.fa-houzz:before{content:\"\\f27c\"}.fa-vimeo:before{content:\"\\f27d\"}.fa-black-tie:before{content:\"\\f27e\"}.fa-fonticons:before{content:\"\\f280\"}/*!\n * Bootstrap v3.3.5 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n *//*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0;font-size:2em}mark{color:#000;background:#ff0}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{height:0;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;font:inherit;color:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{padding:.35em .625em .75em;margin:0 2px;border:1px solid silver}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;-webkit-box-shadow:none!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}abbr[title]:after{content:\" (\" attr(title) \")\"}a[href^=\"#\"]:after,a[href^=\"javascript:\"]:after{content:\"\"}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000!important}.label{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #ddd!important}}@font-face{font-family:'Glyphicons Halflings';src:url(jspm_packages/github/twbs/bootstrap@3.3.5/fonts/glyphicons-halflings-regular.eot);src:url(jspm_packages/github/twbs/bootstrap@3.3.5/fonts/glyphicons-halflings-regular.eot?#iefix) format('embedded-opentype'),url(jspm_packages/github/twbs/bootstrap@3.3.5/fonts/glyphicons-halflings-regular.woff2) format('woff2'),url(jspm_packages/github/twbs/bootstrap@3.3.5/fonts/glyphicons-halflings-regular.woff) format('woff'),url(jspm_packages/github/twbs/bootstrap@3.3.5/fonts/glyphicons-halflings-regular.ttf) format('truetype'),url(jspm_packages/github/twbs/bootstrap@3.3.5/fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular) format('svg')}.glyphicon{position:relative;top:1px;display:inline-block;font-family:'Glyphicons Halflings';font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-asterisk:before{content:\"\\2a\"}.glyphicon-plus:before{content:\"\\2b\"}.glyphicon-eur:before,.glyphicon-euro:before{content:\"\\20ac\"}.glyphicon-minus:before{content:\"\\2212\"}.glyphicon-cloud:before{content:\"\\2601\"}.glyphicon-envelope:before{content:\"\\2709\"}.glyphicon-pencil:before{content:\"\\270f\"}.glyphicon-glass:before{content:\"\\e001\"}.glyphicon-music:before{content:\"\\e002\"}.glyphicon-search:before{content:\"\\e003\"}.glyphicon-heart:before{content:\"\\e005\"}.glyphicon-star:before{content:\"\\e006\"}.glyphicon-star-empty:before{content:\"\\e007\"}.glyphicon-user:before{content:\"\\e008\"}.glyphicon-film:before{content:\"\\e009\"}.glyphicon-th-large:before{content:\"\\e010\"}.glyphicon-th:before{content:\"\\e011\"}.glyphicon-th-list:before{content:\"\\e012\"}.glyphicon-ok:before{content:\"\\e013\"}.glyphicon-remove:before{content:\"\\e014\"}.glyphicon-zoom-in:before{content:\"\\e015\"}.glyphicon-zoom-out:before{content:\"\\e016\"}.glyphicon-off:before{content:\"\\e017\"}.glyphicon-signal:before{content:\"\\e018\"}.glyphicon-cog:before{content:\"\\e019\"}.glyphicon-trash:before{content:\"\\e020\"}.glyphicon-home:before{content:\"\\e021\"}.glyphicon-file:before{content:\"\\e022\"}.glyphicon-time:before{content:\"\\e023\"}.glyphicon-road:before{content:\"\\e024\"}.glyphicon-download-alt:before{content:\"\\e025\"}.glyphicon-download:before{content:\"\\e026\"}.glyphicon-upload:before{content:\"\\e027\"}.glyphicon-inbox:before{content:\"\\e028\"}.glyphicon-play-circle:before{content:\"\\e029\"}.glyphicon-repeat:before{content:\"\\e030\"}.glyphicon-refresh:before{content:\"\\e031\"}.glyphicon-list-alt:before{content:\"\\e032\"}.glyphicon-lock:before{content:\"\\e033\"}.glyphicon-flag:before{content:\"\\e034\"}.glyphicon-headphones:before{content:\"\\e035\"}.glyphicon-volume-off:before{content:\"\\e036\"}.glyphicon-volume-down:before{content:\"\\e037\"}.glyphicon-volume-up:before{content:\"\\e038\"}.glyphicon-qrcode:before{content:\"\\e039\"}.glyphicon-barcode:before{content:\"\\e040\"}.glyphicon-tag:before{content:\"\\e041\"}.glyphicon-tags:before{content:\"\\e042\"}.glyphicon-book:before{content:\"\\e043\"}.glyphicon-bookmark:before{content:\"\\e044\"}.glyphicon-print:before{content:\"\\e045\"}.glyphicon-camera:before{content:\"\\e046\"}.glyphicon-font:before{content:\"\\e047\"}.glyphicon-bold:before{content:\"\\e048\"}.glyphicon-italic:before{content:\"\\e049\"}.glyphicon-text-height:before{content:\"\\e050\"}.glyphicon-text-width:before{content:\"\\e051\"}.glyphicon-align-left:before{content:\"\\e052\"}.glyphicon-align-center:before{content:\"\\e053\"}.glyphicon-align-right:before{content:\"\\e054\"}.glyphicon-align-justify:before{content:\"\\e055\"}.glyphicon-list:before{content:\"\\e056\"}.glyphicon-indent-left:before{content:\"\\e057\"}.glyphicon-indent-right:before{content:\"\\e058\"}.glyphicon-facetime-video:before{content:\"\\e059\"}.glyphicon-picture:before{content:\"\\e060\"}.glyphicon-map-marker:before{content:\"\\e062\"}.glyphicon-adjust:before{content:\"\\e063\"}.glyphicon-tint:before{content:\"\\e064\"}.glyphicon-edit:before{content:\"\\e065\"}.glyphicon-share:before{content:\"\\e066\"}.glyphicon-check:before{content:\"\\e067\"}.glyphicon-move:before{content:\"\\e068\"}.glyphicon-step-backward:before{content:\"\\e069\"}.glyphicon-fast-backward:before{content:\"\\e070\"}.glyphicon-backward:before{content:\"\\e071\"}.glyphicon-play:before{content:\"\\e072\"}.glyphicon-pause:before{content:\"\\e073\"}.glyphicon-stop:before{content:\"\\e074\"}.glyphicon-forward:before{content:\"\\e075\"}.glyphicon-fast-forward:before{content:\"\\e076\"}.glyphicon-step-forward:before{content:\"\\e077\"}.glyphicon-eject:before{content:\"\\e078\"}.glyphicon-chevron-left:before{content:\"\\e079\"}.glyphicon-chevron-right:before{content:\"\\e080\"}.glyphicon-plus-sign:before{content:\"\\e081\"}.glyphicon-minus-sign:before{content:\"\\e082\"}.glyphicon-remove-sign:before{content:\"\\e083\"}.glyphicon-ok-sign:before{content:\"\\e084\"}.glyphicon-question-sign:before{content:\"\\e085\"}.glyphicon-info-sign:before{content:\"\\e086\"}.glyphicon-screenshot:before{content:\"\\e087\"}.glyphicon-remove-circle:before{content:\"\\e088\"}.glyphicon-ok-circle:before{content:\"\\e089\"}.glyphicon-ban-circle:before{content:\"\\e090\"}.glyphicon-arrow-left:before{content:\"\\e091\"}.glyphicon-arrow-right:before{content:\"\\e092\"}.glyphicon-arrow-up:before{content:\"\\e093\"}.glyphicon-arrow-down:before{content:\"\\e094\"}.glyphicon-share-alt:before{content:\"\\e095\"}.glyphicon-resize-full:before{content:\"\\e096\"}.glyphicon-resize-small:before{content:\"\\e097\"}.glyphicon-exclamation-sign:before{content:\"\\e101\"}.glyphicon-gift:before{content:\"\\e102\"}.glyphicon-leaf:before{content:\"\\e103\"}.glyphicon-fire:before{content:\"\\e104\"}.glyphicon-eye-open:before{content:\"\\e105\"}.glyphicon-eye-close:before{content:\"\\e106\"}.glyphicon-warning-sign:before{content:\"\\e107\"}.glyphicon-plane:before{content:\"\\e108\"}.glyphicon-calendar:before{content:\"\\e109\"}.glyphicon-random:before{content:\"\\e110\"}.glyphicon-comment:before{content:\"\\e111\"}.glyphicon-magnet:before{content:\"\\e112\"}.glyphicon-chevron-up:before{content:\"\\e113\"}.glyphicon-chevron-down:before{content:\"\\e114\"}.glyphicon-retweet:before{content:\"\\e115\"}.glyphicon-shopping-cart:before{content:\"\\e116\"}.glyphicon-folder-close:before{content:\"\\e117\"}.glyphicon-folder-open:before{content:\"\\e118\"}.glyphicon-resize-vertical:before{content:\"\\e119\"}.glyphicon-resize-horizontal:before{content:\"\\e120\"}.glyphicon-hdd:before{content:\"\\e121\"}.glyphicon-bullhorn:before{content:\"\\e122\"}.glyphicon-bell:before{content:\"\\e123\"}.glyphicon-certificate:before{content:\"\\e124\"}.glyphicon-thumbs-up:before{content:\"\\e125\"}.glyphicon-thumbs-down:before{content:\"\\e126\"}.glyphicon-hand-right:before{content:\"\\e127\"}.glyphicon-hand-left:before{content:\"\\e128\"}.glyphicon-hand-up:before{content:\"\\e129\"}.glyphicon-hand-down:before{content:\"\\e130\"}.glyphicon-circle-arrow-right:before{content:\"\\e131\"}.glyphicon-circle-arrow-left:before{content:\"\\e132\"}.glyphicon-circle-arrow-up:before{content:\"\\e133\"}.glyphicon-circle-arrow-down:before{content:\"\\e134\"}.glyphicon-globe:before{content:\"\\e135\"}.glyphicon-wrench:before{content:\"\\e136\"}.glyphicon-tasks:before{content:\"\\e137\"}.glyphicon-filter:before{content:\"\\e138\"}.glyphicon-briefcase:before{content:\"\\e139\"}.glyphicon-fullscreen:before{content:\"\\e140\"}.glyphicon-dashboard:before{content:\"\\e141\"}.glyphicon-paperclip:before{content:\"\\e142\"}.glyphicon-heart-empty:before{content:\"\\e143\"}.glyphicon-link:before{content:\"\\e144\"}.glyphicon-phone:before{content:\"\\e145\"}.glyphicon-pushpin:before{content:\"\\e146\"}.glyphicon-usd:before{content:\"\\e148\"}.glyphicon-gbp:before{content:\"\\e149\"}.glyphicon-sort:before{content:\"\\e150\"}.glyphicon-sort-by-alphabet:before{content:\"\\e151\"}.glyphicon-sort-by-alphabet-alt:before{content:\"\\e152\"}.glyphicon-sort-by-order:before{content:\"\\e153\"}.glyphicon-sort-by-order-alt:before{content:\"\\e154\"}.glyphicon-sort-by-attributes:before{content:\"\\e155\"}.glyphicon-sort-by-attributes-alt:before{content:\"\\e156\"}.glyphicon-unchecked:before{content:\"\\e157\"}.glyphicon-expand:before{content:\"\\e158\"}.glyphicon-collapse-down:before{content:\"\\e159\"}.glyphicon-collapse-up:before{content:\"\\e160\"}.glyphicon-log-in:before{content:\"\\e161\"}.glyphicon-flash:before{content:\"\\e162\"}.glyphicon-log-out:before{content:\"\\e163\"}.glyphicon-new-window:before{content:\"\\e164\"}.glyphicon-record:before{content:\"\\e165\"}.glyphicon-save:before{content:\"\\e166\"}.glyphicon-open:before{content:\"\\e167\"}.glyphicon-saved:before{content:\"\\e168\"}.glyphicon-import:before{content:\"\\e169\"}.glyphicon-export:before{content:\"\\e170\"}.glyphicon-send:before{content:\"\\e171\"}.glyphicon-floppy-disk:before{content:\"\\e172\"}.glyphicon-floppy-saved:before{content:\"\\e173\"}.glyphicon-floppy-remove:before{content:\"\\e174\"}.glyphicon-floppy-save:before{content:\"\\e175\"}.glyphicon-floppy-open:before{content:\"\\e176\"}.glyphicon-credit-card:before{content:\"\\e177\"}.glyphicon-transfer:before{content:\"\\e178\"}.glyphicon-cutlery:before{content:\"\\e179\"}.glyphicon-header:before{content:\"\\e180\"}.glyphicon-compressed:before{content:\"\\e181\"}.glyphicon-earphone:before{content:\"\\e182\"}.glyphicon-phone-alt:before{content:\"\\e183\"}.glyphicon-tower:before{content:\"\\e184\"}.glyphicon-stats:before{content:\"\\e185\"}.glyphicon-sd-video:before{content:\"\\e186\"}.glyphicon-hd-video:before{content:\"\\e187\"}.glyphicon-subtitles:before{content:\"\\e188\"}.glyphicon-sound-stereo:before{content:\"\\e189\"}.glyphicon-sound-dolby:before{content:\"\\e190\"}.glyphicon-sound-5-1:before{content:\"\\e191\"}.glyphicon-sound-6-1:before{content:\"\\e192\"}.glyphicon-sound-7-1:before{content:\"\\e193\"}.glyphicon-copyright-mark:before{content:\"\\e194\"}.glyphicon-registration-mark:before{content:\"\\e195\"}.glyphicon-cloud-download:before{content:\"\\e197\"}.glyphicon-cloud-upload:before{content:\"\\e198\"}.glyphicon-tree-conifer:before{content:\"\\e199\"}.glyphicon-tree-deciduous:before{content:\"\\e200\"}.glyphicon-cd:before{content:\"\\e201\"}.glyphicon-save-file:before{content:\"\\e202\"}.glyphicon-open-file:before{content:\"\\e203\"}.glyphicon-level-up:before{content:\"\\e204\"}.glyphicon-copy:before{content:\"\\e205\"}.glyphicon-paste:before{content:\"\\e206\"}.glyphicon-alert:before{content:\"\\e209\"}.glyphicon-equalizer:before{content:\"\\e210\"}.glyphicon-king:before{content:\"\\e211\"}.glyphicon-queen:before{content:\"\\e212\"}.glyphicon-pawn:before{content:\"\\e213\"}.glyphicon-bishop:before{content:\"\\e214\"}.glyphicon-knight:before{content:\"\\e215\"}.glyphicon-baby-formula:before{content:\"\\e216\"}.glyphicon-tent:before{content:\"\\26fa\"}.glyphicon-blackboard:before{content:\"\\e218\"}.glyphicon-bed:before{content:\"\\e219\"}.glyphicon-apple:before{content:\"\\f8ff\"}.glyphicon-erase:before{content:\"\\e221\"}.glyphicon-hourglass:before{content:\"\\231b\"}.glyphicon-lamp:before{content:\"\\e223\"}.glyphicon-duplicate:before{content:\"\\e224\"}.glyphicon-piggy-bank:before{content:\"\\e225\"}.glyphicon-scissors:before{content:\"\\e226\"}.glyphicon-bitcoin:before{content:\"\\e227\"}.glyphicon-btc:before{content:\"\\e227\"}.glyphicon-xbt:before{content:\"\\e227\"}.glyphicon-yen:before{content:\"\\00a5\"}.glyphicon-jpy:before{content:\"\\00a5\"}.glyphicon-ruble:before{content:\"\\20bd\"}.glyphicon-rub:before{content:\"\\20bd\"}.glyphicon-scale:before{content:\"\\e230\"}.glyphicon-ice-lolly:before{content:\"\\e231\"}.glyphicon-ice-lolly-tasted:before{content:\"\\e232\"}.glyphicon-education:before{content:\"\\e233\"}.glyphicon-option-horizontal:before{content:\"\\e234\"}.glyphicon-option-vertical:before{content:\"\\e235\"}.glyphicon-menu-hamburger:before{content:\"\\e236\"}.glyphicon-modal-window:before{content:\"\\e237\"}.glyphicon-oil:before{content:\"\\e238\"}.glyphicon-grain:before{content:\"\\e239\"}.glyphicon-sunglasses:before{content:\"\\e240\"}.glyphicon-text-size:before{content:\"\\e241\"}.glyphicon-text-color:before{content:\"\\e242\"}.glyphicon-text-background:before{content:\"\\e243\"}.glyphicon-object-align-top:before{content:\"\\e244\"}.glyphicon-object-align-bottom:before{content:\"\\e245\"}.glyphicon-object-align-horizontal:before{content:\"\\e246\"}.glyphicon-object-align-left:before{content:\"\\e247\"}.glyphicon-object-align-vertical:before{content:\"\\e248\"}.glyphicon-object-align-right:before{content:\"\\e249\"}.glyphicon-triangle-right:before{content:\"\\e250\"}.glyphicon-triangle-left:before{content:\"\\e251\"}.glyphicon-triangle-bottom:before{content:\"\\e252\"}.glyphicon-triangle-top:before{content:\"\\e253\"}.glyphicon-console:before{content:\"\\e254\"}.glyphicon-superscript:before{content:\"\\e255\"}.glyphicon-subscript:before{content:\"\\e256\"}.glyphicon-menu-left:before{content:\"\\e257\"}.glyphicon-menu-right:before{content:\"\\e258\"}.glyphicon-menu-down:before{content:\"\\e259\"}.glyphicon-menu-up:before{content:\"\\e260\"}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:transparent}body{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.carousel-inner>.item>a>img,.carousel-inner>.item>img,.img-responsive,.thumbnail a>img,.thumbnail>img{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{display:inline-block;max-width:100%;height:auto;padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=button]{cursor:pointer}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-weight:400;line-height:1;color:#777}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small{font-size:65%}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-size:75%}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:16px;font-weight:300;line-height:1.4}@media (min-width:768px){.lead{font-size:21px}}.small,small{font-size:85%}.mark,mark{padding:.2em;background-color:#fcf8e3}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777}.text-primary{color:#337ab7}a.text-primary:focus,a.text-primary:hover{color:#286090}.text-success{color:#3c763d}a.text-success:focus,a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:focus,a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:focus,a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:focus,a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#337ab7}a.bg-primary:focus,a.bg-primary:hover{background-color:#286090}.bg-success{background-color:#dff0d8}a.bg-success:focus,a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:focus,a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:focus,a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:focus,a.bg-danger:hover{background-color:#e4b9b9}.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eee}ol,ul{margin-top:0;margin-bottom:10px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;margin-left:-5px;list-style:none}.list-inline>li{display:inline-block;padding-right:5px;padding-left:5px}dl{margin-top:0;margin-bottom:20px}dd,dt{line-height:1.42857143}dt{font-weight:700}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10px 20px;margin:0 0 20px;font-size:17.5px;border-left:5px solid #eee}blockquote ol:last-child,blockquote p:last-child,blockquote ul:last-child{margin-bottom:0}blockquote .small,blockquote footer,blockquote small{display:block;font-size:80%;line-height:1.42857143;color:#777}blockquote .small:before,blockquote footer:before,blockquote small:before{content:'\\2014 \\00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;text-align:right;border-right:5px solid #eee;border-left:0}.blockquote-reverse .small:before,.blockquote-reverse footer:before,.blockquote-reverse small:before,blockquote.pull-right .small:before,blockquote.pull-right footer:before,blockquote.pull-right small:before{content:''}.blockquote-reverse .small:after,.blockquote-reverse footer:after,.blockquote-reverse small:after,blockquote.pull-right .small:after,blockquote.pull-right footer:after,blockquote.pull-right small:after{content:'\\00A0 \\2014'}address{margin-bottom:20px;font-style:normal;line-height:1.42857143}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,\"Courier New\",monospace}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}kbd{padding:2px 4px;font-size:90%;color:#fff;background-color:#333;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.25);box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;font-weight:700;-webkit-box-shadow:none;box-shadow:none}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:1.42857143;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{margin-right:-15px;margin-left:-15px}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{position:relative;min-height:1px;padding-right:15px;padding-left:15px}.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0}@media (min-width:768px){.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0}}@media (min-width:992px){.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0}}@media (min-width:1200px){.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0}}table{background-color:transparent}caption{padding-top:8px;padding-bottom:8px;color:#777;text-align:left}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>tbody>tr>td,.table>tbody>tr>th,.table>tfoot>tr>td,.table>tfoot>tr>th,.table>thead>tr>td,.table>thead>tr>th{padding:8px;line-height:1.42857143;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>td,.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>td,.table>thead:first-child>tr:first-child>th{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>tbody>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>thead>tr>th{padding:5px}.table-bordered{border:1px solid #ddd}.table-bordered>tbody>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border:1px solid #ddd}.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border-bottom-width:2px}.table-striped>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}.table-hover>tbody>tr:hover{background-color:#f5f5f5}table col[class*=col-]{position:static;display:table-column;float:none}table td[class*=col-],table th[class*=col-]{position:static;display:table-cell;float:none}.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>thead>tr>td.active,.table>thead>tr>th.active{background-color:#f5f5f5}.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr.active:hover>th,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover{background-color:#e8e8e8}.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>thead>tr>td.success,.table>thead>tr>th.success{background-color:#dff0d8}.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr.success:hover>th,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover{background-color:#d0e9c6}.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>thead>tr>td.info,.table>thead>tr>th.info{background-color:#d9edf7}.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr.info:hover>th,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover{background-color:#c4e3f3}.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>thead>tr>td.warning,.table>thead>tr>th.warning{background-color:#fcf8e3}.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr.warning:hover>th,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover{background-color:#faf2cc}.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>thead>tr>td.danger,.table>thead>tr>th.danger{background-color:#f2dede}.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr.danger:hover>th,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover{background-color:#ebcccc}.table-responsive{min-height:.01%;overflow-x:auto}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>thead>tr>th{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border:0;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type=search]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}input[type=checkbox],input[type=radio]{margin:4px 0 0;margin-top:1px\\9;line-height:normal}input[type=file]{display:block}input[type=range]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type=checkbox]:focus,input[type=radio]:focus,input[type=file]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{display:block;padding-top:7px;font-size:14px;line-height:1.42857143;color:#555}.form-control{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#eee;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}input[type=search]{-webkit-appearance:none}@media screen and (-webkit-min-device-pixel-ratio:0){input[type=date].form-control,input[type=time].form-control,input[type=datetime-local].form-control,input[type=month].form-control{line-height:34px}.input-group-sm input[type=date],.input-group-sm input[type=time],.input-group-sm input[type=datetime-local],.input-group-sm input[type=month],input[type=date].input-sm,input[type=time].input-sm,input[type=datetime-local].input-sm,input[type=month].input-sm{line-height:30px}.input-group-lg input[type=date],.input-group-lg input[type=time],.input-group-lg input[type=datetime-local],.input-group-lg input[type=month],input[type=date].input-lg,input[type=time].input-lg,input[type=datetime-local].input-lg,input[type=month].input-lg{line-height:46px}}.form-group{margin-bottom:15px}.checkbox,.radio{position:relative;display:block;margin-top:10px;margin-bottom:10px}.checkbox label,.radio label{min-height:20px;padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.checkbox input[type=checkbox],.checkbox-inline input[type=checkbox],.radio input[type=radio],.radio-inline input[type=radio]{position:absolute;margin-top:4px\\9;margin-left:-20px}.checkbox+.checkbox,.radio+.radio{margin-top:-5px}.checkbox-inline,.radio-inline{position:relative;display:inline-block;padding-left:20px;margin-bottom:0;font-weight:400;vertical-align:middle;cursor:pointer}.checkbox-inline+.checkbox-inline,.radio-inline+.radio-inline{margin-top:0;margin-left:10px}fieldset[disabled] input[type=checkbox],fieldset[disabled] input[type=radio],input[type=checkbox].disabled,input[type=checkbox][disabled],input[type=radio].disabled,input[type=radio][disabled]{cursor:not-allowed}.checkbox-inline.disabled,.radio-inline.disabled,fieldset[disabled] .checkbox-inline,fieldset[disabled] .radio-inline{cursor:not-allowed}.checkbox.disabled label,.radio.disabled label,fieldset[disabled] .checkbox label,fieldset[disabled] .radio label{cursor:not-allowed}.form-control-static{min-height:34px;padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-control-static.input-sm{padding-right:0;padding-left:0}.input-sm{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm{height:30px;line-height:30px}select[multiple].input-sm,textarea.input-sm{height:auto}.form-group-sm .form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.form-group-sm select.form-control{height:30px;line-height:30px}.form-group-sm select[multiple].form-control,.form-group-sm textarea.form-control{height:auto}.form-group-sm .form-control-static{height:30px;min-height:32px;padding:6px 10px;font-size:12px;line-height:1.5}.input-lg{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-lg{height:46px;line-height:46px}select[multiple].input-lg,textarea.input-lg{height:auto}.form-group-lg .form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.form-group-lg select.form-control{height:46px;line-height:46px}.form-group-lg select[multiple].form-control,.form-group-lg textarea.form-control{height:auto}.form-group-lg .form-control-static{height:46px;min-height:38px;padding:11px 16px;font-size:18px;line-height:1.3333333}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:0;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center;pointer-events:none}.form-group-lg .form-control+.form-control-feedback,.input-group-lg+.form-control-feedback,.input-lg+.form-control-feedback{width:46px;height:46px;line-height:46px}.form-group-sm .form-control+.form-control-feedback,.input-group-sm+.form-control-feedback,.input-sm+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .checkbox,.has-success .checkbox-inline,.has-success .control-label,.has-success .help-block,.has-success .radio,.has-success .radio-inline,.has-success.checkbox label,.has-success.checkbox-inline label,.has-success.radio label,.has-success.radio-inline label{color:#3c763d}.has-success .form-control{border-color:#3c763d;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;background-color:#dff0d8;border-color:#3c763d}.has-success .form-control-feedback{color:#3c763d}.has-warning .checkbox,.has-warning .checkbox-inline,.has-warning .control-label,.has-warning .help-block,.has-warning .radio,.has-warning .radio-inline,.has-warning.checkbox label,.has-warning.checkbox-inline label,.has-warning.radio label,.has-warning.radio-inline label{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;background-color:#fcf8e3;border-color:#8a6d3b}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .checkbox,.has-error .checkbox-inline,.has-error .control-label,.has-error .help-block,.has-error .radio,.has-error .radio-inline,.has-error.checkbox label,.has-error.checkbox-inline label,.has-error.radio label,.has-error.radio-inline label{color:#a94442}.has-error .form-control{border-color:#a94442;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;background-color:#f2dede;border-color:#a94442}.has-error .form-control-feedback{color:#a94442}.has-feedback label~.form-control-feedback{top:25px}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-static{display:inline-block}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .form-control,.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .checkbox,.form-inline .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .checkbox label,.form-inline .radio label{padding-left:0}.form-inline .checkbox input[type=checkbox],.form-inline .radio input[type=radio]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}}.form-horizontal .checkbox,.form-horizontal .checkbox-inline,.form-horizontal .radio,.form-horizontal .radio-inline{padding-top:7px;margin-top:0;margin-bottom:0}.form-horizontal .checkbox,.form-horizontal .radio{min-height:27px}.form-horizontal .form-group{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.form-horizontal .control-label{padding-top:7px;margin-bottom:0;text-align:right}}.form-horizontal .has-feedback .form-control-feedback{right:15px}@media (min-width:768px){.form-horizontal .form-group-lg .control-label{padding-top:14.33px;font-size:18px}}@media (min-width:768px){.form-horizontal .form-group-sm .control-label{padding-top:6px;font-size:12px}}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;white-space:nowrap;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:1px solid transparent;border-radius:4px}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none;opacity:.65}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.focus,.btn-default:focus{color:#333;background-color:#e6e6e6;border-color:#8c8c8c}.btn-default:hover{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active.focus,.btn-default.active:focus,.btn-default.active:hover,.btn-default:active.focus,.btn-default:active:focus,.btn-default:active:hover,.open>.dropdown-toggle.btn-default.focus,.open>.dropdown-toggle.btn-default:focus,.open>.dropdown-toggle.btn-default:hover{color:#333;background-color:#d4d4d4;border-color:#8c8c8c}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled,.btn-default.disabled.active,.btn-default.disabled.focus,.btn-default.disabled:active,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled],.btn-default[disabled].active,.btn-default[disabled].focus,.btn-default[disabled]:active,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default.active,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#286090;border-color:#122b40}.btn-primary:hover{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active.focus,.btn-primary.active:focus,.btn-primary.active:hover,.btn-primary:active.focus,.btn-primary:active:focus,.btn-primary:active:hover,.open>.dropdown-toggle.btn-primary.focus,.open>.dropdown-toggle.btn-primary:focus,.open>.dropdown-toggle.btn-primary:hover{color:#fff;background-color:#204d74;border-color:#122b40}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled,.btn-primary.disabled.active,.btn-primary.disabled.focus,.btn-primary.disabled:active,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled],.btn-primary[disabled].active,.btn-primary[disabled].focus,.btn-primary[disabled]:active,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary.active,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#449d44;border-color:#255625}.btn-success:hover{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active.focus,.btn-success.active:focus,.btn-success.active:hover,.btn-success:active.focus,.btn-success:active:focus,.btn-success:active:hover,.open>.dropdown-toggle.btn-success.focus,.open>.dropdown-toggle.btn-success:focus,.open>.dropdown-toggle.btn-success:hover{color:#fff;background-color:#398439;border-color:#255625}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled,.btn-success.disabled.active,.btn-success.disabled.focus,.btn-success.disabled:active,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled],.btn-success[disabled].active,.btn-success[disabled].focus,.btn-success[disabled]:active,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success.active,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#31b0d5;border-color:#1b6d85}.btn-info:hover{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active.focus,.btn-info.active:focus,.btn-info.active:hover,.btn-info:active.focus,.btn-info:active:focus,.btn-info:active:hover,.open>.dropdown-toggle.btn-info.focus,.open>.dropdown-toggle.btn-info:focus,.open>.dropdown-toggle.btn-info:hover{color:#fff;background-color:#269abc;border-color:#1b6d85}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled,.btn-info.disabled.active,.btn-info.disabled.focus,.btn-info.disabled:active,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled],.btn-info[disabled].active,.btn-info[disabled].focus,.btn-info[disabled]:active,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info.active,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.focus,.btn-warning:focus{color:#fff;background-color:#ec971f;border-color:#985f0d}.btn-warning:hover{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active.focus,.btn-warning.active:focus,.btn-warning.active:hover,.btn-warning:active.focus,.btn-warning:active:focus,.btn-warning:active:hover,.open>.dropdown-toggle.btn-warning.focus,.open>.dropdown-toggle.btn-warning:focus,.open>.dropdown-toggle.btn-warning:hover{color:#fff;background-color:#d58512;border-color:#985f0d}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled,.btn-warning.disabled.active,.btn-warning.disabled.focus,.btn-warning.disabled:active,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled],.btn-warning[disabled].active,.btn-warning[disabled].focus,.btn-warning[disabled]:active,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning.active,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#c9302c;border-color:#761c19}.btn-danger:hover{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active.focus,.btn-danger.active:focus,.btn-danger.active:hover,.btn-danger:active.focus,.btn-danger:active:focus,.btn-danger:active:hover,.open>.dropdown-toggle.btn-danger.focus,.open>.dropdown-toggle.btn-danger:focus,.open>.dropdown-toggle.btn-danger:hover{color:#fff;background-color:#ac2925;border-color:#761c19}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled,.btn-danger.disabled.active,.btn-danger.disabled.focus,.btn-danger.disabled:active,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled],.btn-danger[disabled].active,.btn-danger[disabled].focus,.btn-danger[disabled]:active,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger.active,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{font-weight:400;color:#337ab7;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition-timing-function:ease;-o-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-duration:.35s;-o-transition-duration:.35s;transition-duration:.35s;-webkit-transition-property:height,visibility;-o-transition-property:height,visibility;transition-property:height,visibility}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid\\9;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;font-size:14px;text-align:left;list-style:none;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175)}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;background-color:#337ab7;outline:0}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;cursor:not-allowed;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{right:0;left:auto}.dropdown-menu-left{right:auto;left:0}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{content:\"\";border-top:0;border-bottom:4px dashed;border-bottom:4px solid\\9}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{right:0;left:auto}.navbar-right .dropdown-menu-left{right:auto;left:0}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn,.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-right:8px;padding-left:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-top-right-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{display:table-cell;float:none;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn input[type=radio],[data-toggle=buttons]>.btn-group>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*=col-]{float:none;padding-right:0;padding-left:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group-lg>.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-group-lg>.form-control,select.input-group-lg>.input-group-addon,select.input-group-lg>.input-group-btn>.btn{height:46px;line-height:46px}select[multiple].input-group-lg>.form-control,select[multiple].input-group-lg>.input-group-addon,select[multiple].input-group-lg>.input-group-btn>.btn,textarea.input-group-lg>.form-control,textarea.input-group-lg>.input-group-addon,textarea.input-group-lg>.input-group-btn>.btn{height:auto}.input-group-sm>.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-group-sm>.form-control,select.input-group-sm>.input-group-addon,select.input-group-sm>.input-group-btn>.btn{height:30px;line-height:30px}select[multiple].input-group-sm>.form-control,select[multiple].input-group-sm>.input-group-addon,select[multiple].input-group-sm>.input-group-btn>.btn,textarea.input-group-sm>.form-control,textarea.input-group-sm>.input-group-addon,textarea.input-group-sm>.input-group-btn>.btn{height:auto}.input-group .form-control,.input-group-addon,.input-group-btn{display:table-cell}.input-group .form-control:not(:first-child):not(:last-child),.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type=checkbox],.input-group-addon input[type=radio]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn-group:not(:last-child)>.btn,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:first-child>.btn-group:not(:first-child)>.btn,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{position:relative;font-size:0;white-space:nowrap}.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:active,.input-group-btn>.btn:focus,.input-group-btn>.btn:hover{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{z-index:2;margin-left:-1px}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li.disabled>a{color:#777}.nav>li.disabled>a:focus,.nav>li.disabled>a:hover{color:#777;text-decoration:none;cursor:not-allowed;background-color:transparent}.nav .open>a,.nav .open>a:focus,.nav .open>a:hover{background-color:#eee;border-color:#337ab7}.nav .nav-divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.42857143;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>li.active>a,.nav-tabs>li.active>a:focus,.nav-tabs>li.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-tabs.nav-justified{width:100%;border-bottom:0}.nav-tabs.nav-justified>li{float:none}.nav-tabs.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-tabs.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-tabs.nav-justified>li>a{margin-bottom:0}}.nav-tabs.nav-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs.nav-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border-bottom-color:#fff}}.nav-pills>li{float:left}.nav-pills>li>a{border-radius:4px}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover{color:#fff;background-color:#337ab7}.nav-stacked>li{float:none}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified{width:100%}.nav-justified>li{float:none}.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a{margin-bottom:0}}.nav-tabs-justified{border-bottom:0}.nav-tabs-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border-bottom-color:#fff}}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}.navbar-collapse.in{overflow-y:auto}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:340px}@media (max-device-width:480px) and (orientation:landscape){.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:200px}}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}@media (min-width:768px){.navbar-fixed-bottom,.navbar-fixed-top{border-radius:0}}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-brand>img{display:block}@media (min-width:768px){.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;padding:9px 10px;margin-top:8px;margin-right:15px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:4px}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:4px}@media (min-width:768px){.navbar-toggle{display:none}}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu .dropdown-header,.navbar-nav .open .dropdown-menu>li>a{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:20px}.navbar-nav .open .dropdown-menu>li>a:focus,.navbar-nav .open .dropdown-menu>li>a:hover{background-image:none}}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}}.navbar-form{padding:10px 15px;margin-top:8px;margin-right:-15px;margin-bottom:8px;margin-left:-15px;border-top:1px solid transparent;border-bottom:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .form-control,.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .checkbox,.navbar-form .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .checkbox label,.navbar-form .radio label{padding-left:0}.navbar-form .checkbox input[type=checkbox],.navbar-form .radio input[type=radio]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}}@media (max-width:767px){.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}}@media (min-width:768px){.navbar-form{width:auto;padding-top:0;padding-bottom:0;margin-right:0;margin-left:0;border:0;-webkit-box-shadow:none;box-shadow:none}}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-left-radius:0;border-top-right-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.navbar-btn{margin-top:8px;margin-bottom:8px}.navbar-btn.btn-sm{margin-top:10px;margin-bottom:10px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:15px;margin-bottom:15px}@media (min-width:768px){.navbar-text{float:left;margin-right:15px;margin-left:15px}}@media (min-width:768px){.navbar-left{float:left!important}.navbar-right{float:right!important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-text{color:#777}.navbar-default .navbar-nav>li>a{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:focus,.navbar-default .navbar-nav>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-toggle:focus,.navbar-default .navbar-toggle:hover{background-color:#ddd}.navbar-default .navbar-toggle .icon-bar{background-color:#888}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#e7e7e7}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:focus,.navbar-default .navbar-nav>.open>a:hover{color:#555;background-color:#e7e7e7}@media (max-width:767px){.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#777}.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#ccc;background-color:transparent}}.navbar-default .navbar-link{color:#777}.navbar-default .navbar-link:hover{color:#333}.navbar-default .btn-link{color:#777}.navbar-default .btn-link:focus,.navbar-default .btn-link:hover{color:#333}.navbar-default .btn-link[disabled]:focus,.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:focus,fieldset[disabled] .navbar-default .btn-link:hover{color:#ccc}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#9d9d9d}.navbar-inverse .navbar-brand:focus,.navbar-inverse .navbar-brand:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-text{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a:focus,.navbar-inverse .navbar-nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:focus,.navbar-inverse .navbar-nav>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:focus,.navbar-inverse .navbar-nav>.disabled>a:hover{color:#444;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:#333}.navbar-inverse .navbar-toggle:focus,.navbar-inverse .navbar-toggle:hover{background-color:#333}.navbar-inverse .navbar-toggle .icon-bar{background-color:#fff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#101010}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:focus,.navbar-inverse .navbar-nav>.open>a:hover{color:#fff;background-color:#080808}@media (max-width:767px){.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#444;background-color:transparent}}.navbar-inverse .navbar-link{color:#9d9d9d}.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .btn-link{color:#9d9d9d}.navbar-inverse .btn-link:focus,.navbar-inverse .btn-link:hover{color:#fff}.navbar-inverse .btn-link[disabled]:focus,.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:focus,fieldset[disabled] .navbar-inverse .btn-link:hover{color:#444}.breadcrumb{padding:8px 15px;margin-bottom:20px;list-style:none;background-color:#f5f5f5;border-radius:4px}.breadcrumb>li{display:inline-block}.breadcrumb>li+li:before{padding:0 5px;color:#ccc;content:\"/\\00a0\"}.breadcrumb>.active{color:#777}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination>li>a:focus,.pagination>li>a:hover,.pagination>li>span:focus,.pagination>li>span:hover{z-index:3;color:#23527c;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:focus,.pagination>.active>a:hover,.pagination>.active>span,.pagination>.active>span:focus,.pagination>.active>span:hover{z-index:2;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.pagination>.disabled>a,.pagination>.disabled>a:focus,.pagination>.disabled>a:hover,.pagination>.disabled>span,.pagination>.disabled>span:focus,.pagination>.disabled>span:hover{color:#777;cursor:not-allowed;background-color:#fff;border-color:#ddd}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px;line-height:1.3333333}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px;line-height:1.5}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}.pager{padding-left:0;margin:20px 0;text-align:center;list-style:none}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#eee}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#777;cursor:not-allowed;background-color:#fff}.label{display:inline;padding:.2em .6em .3em;font-size:75%;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.label:empty{display:none}.btn .label{position:relative;top:-1px}.label-default{background-color:#777}.label-default[href]:focus,.label-default[href]:hover{background-color:#5e5e5e}.label-primary{background-color:#337ab7}.label-primary[href]:focus,.label-primary[href]:hover{background-color:#286090}.label-success{background-color:#5cb85c}.label-success[href]:focus,.label-success[href]:hover{background-color:#449d44}.label-info{background-color:#5bc0de}.label-info[href]:focus,.label-info[href]:hover{background-color:#31b0d5}.label-warning{background-color:#f0ad4e}.label-warning[href]:focus,.label-warning[href]:hover{background-color:#ec971f}.label-danger{background-color:#d9534f}.label-danger[href]:focus,.label-danger[href]:hover{background-color:#c9302c}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:12px;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:middle;background-color:#777;border-radius:10px}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.btn-group-xs>.btn .badge,.btn-xs .badge{top:0;padding:1px 5px}a.badge:focus,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#337ab7;background-color:#fff}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}.jumbotron{padding-top:30px;padding-bottom:30px;margin-bottom:30px;color:inherit;background-color:#eee}.jumbotron .h1,.jumbotron h1{color:inherit}.jumbotron p{margin-bottom:15px;font-size:21px;font-weight:200}.jumbotron>hr{border-top-color:#d5d5d5}.container .jumbotron,.container-fluid .jumbotron{border-radius:6px}.jumbotron .container{max-width:100%}@media screen and (min-width:768px){.jumbotron{padding-top:48px;padding-bottom:48px}.container .jumbotron,.container-fluid .jumbotron{padding-right:60px;padding-left:60px}.jumbotron .h1,.jumbotron h1{font-size:63px}}.thumbnail{display:block;padding:4px;margin-bottom:20px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:border .2s ease-in-out;-o-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail a>img,.thumbnail>img{margin-right:auto;margin-left:auto}a.thumbnail.active,a.thumbnail:focus,a.thumbnail:hover{border-color:#337ab7}.thumbnail .caption{padding:9px;color:#333}.alert{padding:15px;margin-bottom:20px;border:1px solid transparent;border-radius:4px}.alert h4{margin-top:0;color:inherit}.alert .alert-link{font-weight:700}.alert>p,.alert>ul{margin-bottom:0}.alert>p+p{margin-top:5px}.alert-dismissable,.alert-dismissible{padding-right:35px}.alert-dismissable .close,.alert-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.alert-success{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.alert-success hr{border-top-color:#c9e2b3}.alert-success .alert-link{color:#2b542c}.alert-info{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.alert-info hr{border-top-color:#a6e1ec}.alert-info .alert-link{color:#245269}.alert-warning{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.alert-warning hr{border-top-color:#f7e1b5}.alert-warning .alert-link{color:#66512c}.alert-danger{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.alert-danger hr{border-top-color:#e4b9c0}.alert-danger .alert-link{color:#843534}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f5f5f5;border-radius:4px;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,.1);box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.progress-bar{float:left;width:0;height:100%;font-size:12px;line-height:20px;color:#fff;text-align:center;background-color:#337ab7;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);-webkit-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-bar-striped,.progress-striped .progress-bar{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;background-size:40px 40px}.progress-bar.active,.progress.active .progress-bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-bar-success{background-color:#5cb85c}.progress-striped .progress-bar-success{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-info{background-color:#5bc0de}.progress-striped .progress-bar-info{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-warning{background-color:#f0ad4e}.progress-striped .progress-bar-warning{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-danger{background-color:#d9534f}.progress-striped .progress-bar-danger{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{overflow:hidden;zoom:1}.media-body{width:10000px}.media-object{display:block}.media-object.img-thumbnail{max-width:none}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-body,.media-left,.media-right{display:table-cell;vertical-align:top}.media-middle{vertical-align:middle}.media-bottom{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0;list-style:none}.list-group{padding-left:0;margin-bottom:20px}.list-group-item{position:relative;display:block;padding:10px 15px;margin-bottom:-1px;background-color:#fff;border:1px solid #ddd}.list-group-item:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}a.list-group-item,button.list-group-item{color:#555}a.list-group-item .list-group-item-heading,button.list-group-item .list-group-item-heading{color:#333}a.list-group-item:focus,a.list-group-item:hover,button.list-group-item:focus,button.list-group-item:hover{color:#555;text-decoration:none;background-color:#f5f5f5}button.list-group-item{width:100%;text-align:left}.list-group-item.disabled,.list-group-item.disabled:focus,.list-group-item.disabled:hover{color:#777;cursor:not-allowed;background-color:#eee}.list-group-item.disabled .list-group-item-heading,.list-group-item.disabled:focus .list-group-item-heading,.list-group-item.disabled:hover .list-group-item-heading{color:inherit}.list-group-item.disabled .list-group-item-text,.list-group-item.disabled:focus .list-group-item-text,.list-group-item.disabled:hover .list-group-item-text{color:#777}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{z-index:2;color:#fff;background-color:#337ab7;border-color:#337ab7}.list-group-item.active .list-group-item-heading,.list-group-item.active .list-group-item-heading>.small,.list-group-item.active .list-group-item-heading>small,.list-group-item.active:focus .list-group-item-heading,.list-group-item.active:focus .list-group-item-heading>.small,.list-group-item.active:focus .list-group-item-heading>small,.list-group-item.active:hover .list-group-item-heading,.list-group-item.active:hover .list-group-item-heading>.small,.list-group-item.active:hover .list-group-item-heading>small{color:inherit}.list-group-item.active .list-group-item-text,.list-group-item.active:focus .list-group-item-text,.list-group-item.active:hover .list-group-item-text{color:#c7ddef}.list-group-item-success{color:#3c763d;background-color:#dff0d8}a.list-group-item-success,button.list-group-item-success{color:#3c763d}a.list-group-item-success .list-group-item-heading,button.list-group-item-success .list-group-item-heading{color:inherit}a.list-group-item-success:focus,a.list-group-item-success:hover,button.list-group-item-success:focus,button.list-group-item-success:hover{color:#3c763d;background-color:#d0e9c6}a.list-group-item-success.active,a.list-group-item-success.active:focus,a.list-group-item-success.active:hover,button.list-group-item-success.active,button.list-group-item-success.active:focus,button.list-group-item-success.active:hover{color:#fff;background-color:#3c763d;border-color:#3c763d}.list-group-item-info{color:#31708f;background-color:#d9edf7}a.list-group-item-info,button.list-group-item-info{color:#31708f}a.list-group-item-info .list-group-item-heading,button.list-group-item-info .list-group-item-heading{color:inherit}a.list-group-item-info:focus,a.list-group-item-info:hover,button.list-group-item-info:focus,button.list-group-item-info:hover{color:#31708f;background-color:#c4e3f3}a.list-group-item-info.active,a.list-group-item-info.active:focus,a.list-group-item-info.active:hover,button.list-group-item-info.active,button.list-group-item-info.active:focus,button.list-group-item-info.active:hover{color:#fff;background-color:#31708f;border-color:#31708f}.list-group-item-warning{color:#8a6d3b;background-color:#fcf8e3}a.list-group-item-warning,button.list-group-item-warning{color:#8a6d3b}a.list-group-item-warning .list-group-item-heading,button.list-group-item-warning .list-group-item-heading{color:inherit}a.list-group-item-warning:focus,a.list-group-item-warning:hover,button.list-group-item-warning:focus,button.list-group-item-warning:hover{color:#8a6d3b;background-color:#faf2cc}a.list-group-item-warning.active,a.list-group-item-warning.active:focus,a.list-group-item-warning.active:hover,button.list-group-item-warning.active,button.list-group-item-warning.active:focus,button.list-group-item-warning.active:hover{color:#fff;background-color:#8a6d3b;border-color:#8a6d3b}.list-group-item-danger{color:#a94442;background-color:#f2dede}a.list-group-item-danger,button.list-group-item-danger{color:#a94442}a.list-group-item-danger .list-group-item-heading,button.list-group-item-danger .list-group-item-heading{color:inherit}a.list-group-item-danger:focus,a.list-group-item-danger:hover,button.list-group-item-danger:focus,button.list-group-item-danger:hover{color:#a94442;background-color:#ebcccc}a.list-group-item-danger.active,a.list-group-item-danger.active:focus,a.list-group-item-danger.active:hover,button.list-group-item-danger.active,button.list-group-item-danger.active:focus,button.list-group-item-danger.active:hover{color:#fff;background-color:#a94442;border-color:#a94442}.list-group-item-heading{margin-top:0;margin-bottom:5px}.list-group-item-text{margin-bottom:0;line-height:1.3}.panel{margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:4px;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.panel-body{padding:15px}.panel-heading{padding:10px 15px;border-bottom:1px solid transparent;border-top-left-radius:3px;border-top-right-radius:3px}.panel-heading>.dropdown .dropdown-toggle{color:inherit}.panel-title{margin-top:0;margin-bottom:0;font-size:16px;color:inherit}.panel-title>.small,.panel-title>.small>a,.panel-title>a,.panel-title>small,.panel-title>small>a{color:inherit}.panel-footer{padding:10px 15px;background-color:#f5f5f5;border-top:1px solid #ddd;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.list-group,.panel>.panel-collapse>.list-group{margin-bottom:0}.panel>.list-group .list-group-item,.panel>.panel-collapse>.list-group .list-group-item{border-width:1px 0;border-radius:0}.panel>.list-group:first-child .list-group-item:first-child,.panel>.panel-collapse>.list-group:first-child .list-group-item:first-child{border-top:0;border-top-left-radius:3px;border-top-right-radius:3px}.panel>.list-group:last-child .list-group-item:last-child,.panel>.panel-collapse>.list-group:last-child .list-group-item:last-child{border-bottom:0;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.panel-heading+.panel-collapse>.list-group .list-group-item:first-child{border-top-left-radius:0;border-top-right-radius:0}.panel-heading+.list-group .list-group-item:first-child{border-top-width:0}.list-group+.panel-footer{border-top-width:0}.panel>.panel-collapse>.table,.panel>.table,.panel>.table-responsive>.table{margin-bottom:0}.panel>.panel-collapse>.table caption,.panel>.table caption,.panel>.table-responsive>.table caption{padding-right:15px;padding-left:15px}.panel>.table-responsive:first-child>.table:first-child,.panel>.table:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child,.panel>.table:first-child>thead:first-child>tr:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table:first-child>thead:first-child>tr:first-child th:first-child{border-top-left-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table:first-child>thead:first-child>tr:first-child th:last-child{border-top-right-radius:3px}.panel>.table-responsive:last-child>.table:last-child,.panel>.table:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:first-child{border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:last-child{border-bottom-right-radius:3px}.panel>.panel-body+.table,.panel>.panel-body+.table-responsive,.panel>.table+.panel-body,.panel>.table-responsive+.panel-body{border-top:1px solid #ddd}.panel>.table>tbody:first-child>tr:first-child td,.panel>.table>tbody:first-child>tr:first-child th{border-top:0}.panel>.table-bordered,.panel>.table-responsive>.table-bordered{border:0}.panel>.table-bordered>tbody>tr>td:first-child,.panel>.table-bordered>tbody>tr>th:first-child,.panel>.table-bordered>tfoot>tr>td:first-child,.panel>.table-bordered>tfoot>tr>th:first-child,.panel>.table-bordered>thead>tr>td:first-child,.panel>.table-bordered>thead>tr>th:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:first-child,.panel>.table-responsive>.table-bordered>thead>tr>td:first-child,.panel>.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.panel>.table-bordered>tbody>tr>td:last-child,.panel>.table-bordered>tbody>tr>th:last-child,.panel>.table-bordered>tfoot>tr>td:last-child,.panel>.table-bordered>tfoot>tr>th:last-child,.panel>.table-bordered>thead>tr>td:last-child,.panel>.table-bordered>thead>tr>th:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:last-child,.panel>.table-responsive>.table-bordered>thead>tr>td:last-child,.panel>.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.panel>.table-bordered>tbody>tr:first-child>td,.panel>.table-bordered>tbody>tr:first-child>th,.panel>.table-bordered>thead>tr:first-child>td,.panel>.table-bordered>thead>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>th,.panel>.table-responsive>.table-bordered>thead>tr:first-child>td,.panel>.table-responsive>.table-bordered>thead>tr:first-child>th{border-bottom:0}.panel>.table-bordered>tbody>tr:last-child>td,.panel>.table-bordered>tbody>tr:last-child>th,.panel>.table-bordered>tfoot>tr:last-child>td,.panel>.table-bordered>tfoot>tr:last-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>th,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>td,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}.panel>.table-responsive{margin-bottom:0;border:0}.panel-group{margin-bottom:20px}.panel-group .panel{margin-bottom:0;border-radius:4px}.panel-group .panel+.panel{margin-top:5px}.panel-group .panel-heading{border-bottom:0}.panel-group .panel-heading+.panel-collapse>.list-group,.panel-group .panel-heading+.panel-collapse>.panel-body{border-top:1px solid #ddd}.panel-group .panel-footer{border-top:0}.panel-group .panel-footer+.panel-collapse .panel-body{border-bottom:1px solid #ddd}.panel-default{border-color:#ddd}.panel-default>.panel-heading{color:#333;background-color:#f5f5f5;border-color:#ddd}.panel-default>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ddd}.panel-default>.panel-heading .badge{color:#f5f5f5;background-color:#333}.panel-default>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ddd}.panel-primary{border-color:#337ab7}.panel-primary>.panel-heading{color:#fff;background-color:#337ab7;border-color:#337ab7}.panel-primary>.panel-heading+.panel-collapse>.panel-body{border-top-color:#337ab7}.panel-primary>.panel-heading .badge{color:#337ab7;background-color:#fff}.panel-primary>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#337ab7}.panel-success{border-color:#d6e9c6}.panel-success>.panel-heading{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.panel-success>.panel-heading+.panel-collapse>.panel-body{border-top-color:#d6e9c6}.panel-success>.panel-heading .badge{color:#dff0d8;background-color:#3c763d}.panel-success>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#d6e9c6}.panel-info{border-color:#bce8f1}.panel-info>.panel-heading{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.panel-info>.panel-heading+.panel-collapse>.panel-body{border-top-color:#bce8f1}.panel-info>.panel-heading .badge{color:#d9edf7;background-color:#31708f}.panel-info>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#bce8f1}.panel-warning{border-color:#faebcc}.panel-warning>.panel-heading{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.panel-warning>.panel-heading+.panel-collapse>.panel-body{border-top-color:#faebcc}.panel-warning>.panel-heading .badge{color:#fcf8e3;background-color:#8a6d3b}.panel-warning>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#faebcc}.panel-danger{border-color:#ebccd1}.panel-danger>.panel-heading{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.panel-danger>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ebccd1}.panel-danger>.panel-heading .badge{color:#f2dede;background-color:#a94442}.panel-danger>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ebccd1}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.05);box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.2}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.5}button.close{-webkit-appearance:none;padding:0;cursor:pointer;background:0 0;border:0}.modal-open{overflow:hidden}.modal{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;display:none;overflow:hidden;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transition:-webkit-transform .3s ease-out;-o-transition:-o-transform .3s ease-out;transition:transform .3s ease-out;-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);-o-transform:translate(0,-25%);transform:translate(0,-25%)}.modal.in .modal-dialog{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;outline:0;-webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);box-shadow:0 3px 9px rgba(0,0,0,.5)}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{filter:alpha(opacity=0);opacity:0}.modal-backdrop.in{filter:alpha(opacity=50);opacity:.5}.modal-header{min-height:16.43px;padding:15px;border-bottom:1px solid #e5e5e5}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.42857143}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,.5);box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}.tooltip{position:absolute;z-index:1070;display:block;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:12px;font-style:normal;font-weight:400;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;word-wrap:normal;white-space:normal;filter:alpha(opacity=0);opacity:0;line-break:auto}.tooltip.in{filter:alpha(opacity=90);opacity:.9}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px;bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.popover{position:absolute;top:0;left:0;z-index:1060;display:none;max-width:276px;padding:1px;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;font-style:normal;font-weight:400;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;word-wrap:normal;white-space:normal;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,.2);box-shadow:0 5px 10px rgba(0,0,0,.2);line-break:auto}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.popover-content{padding:9px 14px}.popover>.arrow,.popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover>.arrow{border-width:11px}.popover>.arrow:after{content:\"\";border-width:10px}.popover.top>.arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,.25);border-bottom-width:0}.popover.top>.arrow:after{bottom:1px;margin-left:-10px;content:\" \";border-top-color:#fff;border-bottom-width:0}.popover.right>.arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,.25);border-left-width:0}.popover.right>.arrow:after{bottom:-10px;left:1px;content:\" \";border-right-color:#fff;border-left-width:0}.popover.bottom>.arrow{top:-11px;left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,.25)}.popover.bottom>.arrow:after{top:1px;margin-left:-10px;content:\" \";border-top-width:0;border-bottom-color:#fff}.popover.left>.arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999;border-left-color:rgba(0,0,0,.25)}.popover.left>.arrow:after{right:1px;bottom:-10px;content:\" \";border-right-width:0;border-left-color:#fff}.carousel{position:relative}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>a>img,.carousel-inner>.item>img{line-height:1}@media all and (transform-3d),(-webkit-transform-3d){.carousel-inner>.item{-webkit-transition:-webkit-transform .6s ease-in-out;-o-transition:-o-transform .6s ease-in-out;transition:transform .6s ease-in-out;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000px;perspective:1000px}.carousel-inner>.item.active.right,.carousel-inner>.item.next{left:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}.carousel-inner>.item.active.left,.carousel-inner>.item.prev{left:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.carousel-inner>.item.active,.carousel-inner>.item.next.left,.carousel-inner>.item.prev.right{left:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:0;bottom:0;left:0;width:15%;font-size:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6);filter:alpha(opacity=50);opacity:.5}.carousel-control.left{background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,.0001)));background-image:linear-gradient(to right,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);background-repeat:repeat-x}.carousel-control.right{right:0;left:auto;background-image:-webkit-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.0001)),to(rgba(0,0,0,.5)));background-image:linear-gradient(to right,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);background-repeat:repeat-x}.carousel-control:focus,.carousel-control:hover{color:#fff;text-decoration:none;filter:alpha(opacity=90);outline:0;opacity:.9}.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{position:absolute;top:50%;z-index:5;display:inline-block;margin-top:-10px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{left:50%;margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{right:50%;margin-right:-10px}.carousel-control .icon-next,.carousel-control .icon-prev{width:20px;height:20px;font-family:serif;line-height:1}.carousel-control .icon-prev:before{content:'\\2039'}.carousel-control .icon-next:before{content:'\\203a'}.carousel-indicators{position:absolute;bottom:10px;left:50%;z-index:15;width:60%;padding-left:0;margin-left:-30%;text-align:center;list-style:none}.carousel-indicators li{display:inline-block;width:10px;height:10px;margin:1px;text-indent:-999px;cursor:pointer;background-color:#000\\9;background-color:transparent;border:1px solid #fff;border-radius:10px}.carousel-indicators .active{width:12px;height:12px;margin:0;background-color:#fff}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6)}.carousel-caption .btn{text-shadow:none}@media screen and (min-width:768px){.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{width:30px;height:30px;margin-top:-15px;font-size:30px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{margin-left:-15px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{margin-right:-15px}.carousel-caption{right:20%;left:20%;padding-bottom:30px}.carousel-indicators{bottom:20px}}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before,.container-fluid:after,.container-fluid:before,.container:after,.container:before,.dl-horizontal dd:after,.dl-horizontal dd:before,.form-horizontal .form-group:after,.form-horizontal .form-group:before,.modal-footer:after,.modal-footer:before,.nav:after,.nav:before,.navbar-collapse:after,.navbar-collapse:before,.navbar-header:after,.navbar-header:before,.navbar:after,.navbar:before,.pager:after,.pager:before,.panel-body:after,.panel-body:before,.row:after,.row:before{display:table;content:\" \"}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after,.container-fluid:after,.container:after,.dl-horizontal dd:after,.form-horizontal .form-group:after,.modal-footer:after,.nav:after,.navbar-collapse:after,.navbar-header:after,.navbar:after,.pager:after,.panel-body:after,.row:after{clear:both}.center-block{display:block;margin-right:auto;margin-left:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}@-ms-viewport{width:device-width}.visible-lg,.visible-md,.visible-sm,.visible-xs{display:none!important}.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block{display:none!important}@media (max-width:767px){.visible-xs{display:block!important}table.visible-xs{display:table!important}tr.visible-xs{display:table-row!important}td.visible-xs,th.visible-xs{display:table-cell!important}}@media (max-width:767px){.visible-xs-block{display:block!important}}@media (max-width:767px){.visible-xs-inline{display:inline!important}}@media (max-width:767px){.visible-xs-inline-block{display:inline-block!important}}@media (min-width:768px) and (max-width:991px){.visible-sm{display:block!important}table.visible-sm{display:table!important}tr.visible-sm{display:table-row!important}td.visible-sm,th.visible-sm{display:table-cell!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-block{display:block!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline{display:inline!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline-block{display:inline-block!important}}@media (min-width:992px) and (max-width:1199px){.visible-md{display:block!important}table.visible-md{display:table!important}tr.visible-md{display:table-row!important}td.visible-md,th.visible-md{display:table-cell!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-block{display:block!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline{display:inline!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline-block{display:inline-block!important}}@media (min-width:1200px){.visible-lg{display:block!important}table.visible-lg{display:table!important}tr.visible-lg{display:table-row!important}td.visible-lg,th.visible-lg{display:table-cell!important}}@media (min-width:1200px){.visible-lg-block{display:block!important}}@media (min-width:1200px){.visible-lg-inline{display:inline!important}}@media (min-width:1200px){.visible-lg-inline-block{display:inline-block!important}}@media (max-width:767px){.hidden-xs{display:none!important}}@media (min-width:768px) and (max-width:991px){.hidden-sm{display:none!important}}@media (min-width:992px) and (max-width:1199px){.hidden-md{display:none!important}}@media (min-width:1200px){.hidden-lg{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:block!important}table.visible-print{display:table!important}tr.visible-print{display:table-row!important}td.visible-print,th.visible-print{display:table-cell!important}}.visible-print-block{display:none!important}@media print{.visible-print-block{display:block!important}}.visible-print-inline{display:none!important}@media print{.visible-print-inline{display:inline!important}}.visible-print-inline-block{display:none!important}@media print{.visible-print-inline-block{display:inline-block!important}}@media print{.hidden-print{display:none!important}}");
})
(function(factory) {
  factory();
});
//# sourceMappingURL=bundle.js.map